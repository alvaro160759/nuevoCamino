var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb2, mod2) => function __require() {
  return mod2 || (0, cb2[__getOwnPropNames(cb2)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var require_index_81daafcd = __commonJS({
  "assets/index.81daafcd.js"(exports, module) {
    function _mergeNamespaces(n2, m2) {
      for (var i = 0; i < m2.length; i++) {
        const e2 = m2[i];
        if (typeof e2 !== "string" && !Array.isArray(e2)) {
          for (const k2 in e2) {
            if (k2 !== "default" && !(k2 in n2)) {
              const d2 = Object.getOwnPropertyDescriptor(e2, k2);
              if (d2) {
                Object.defineProperty(n2, k2, d2.get ? d2 : {
                  enumerable: true,
                  get: () => e2[k2]
                });
              }
            }
          }
        }
      }
      return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
    }
    (function polyfill() {
      const relList = document.createElement("link").relList;
      if (relList && relList.supports && relList.supports("modulepreload")) {
        return;
      }
      for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
        processPreload(link);
      }
      new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type !== "childList") {
            continue;
          }
          for (const node2 of mutation.addedNodes) {
            if (node2.tagName === "LINK" && node2.rel === "modulepreload")
              processPreload(node2);
          }
        }
      }).observe(document, { childList: true, subtree: true });
      function getFetchOpts(script) {
        const fetchOpts = {};
        if (script.integrity)
          fetchOpts.integrity = script.integrity;
        if (script.referrerpolicy)
          fetchOpts.referrerPolicy = script.referrerpolicy;
        if (script.crossorigin === "use-credentials")
          fetchOpts.credentials = "include";
        else if (script.crossorigin === "anonymous")
          fetchOpts.credentials = "omit";
        else
          fetchOpts.credentials = "same-origin";
        return fetchOpts;
      }
      function processPreload(link) {
        if (link.ep)
          return;
        link.ep = true;
        const fetchOpts = getFetchOpts(link);
        fetch(link.href, fetchOpts);
      }
    })();
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function getDefaultExportFromCjs(x2) {
      return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
    }
    function getAugmentedNamespace(n2) {
      var f2 = n2.default;
      if (typeof f2 == "function") {
        var a = function() {
          return f2.apply(this, arguments);
        };
        a.prototype = f2.prototype;
      } else
        a = {};
      Object.defineProperty(a, "__esModule", { value: true });
      Object.keys(n2).forEach(function(k2) {
        var d2 = Object.getOwnPropertyDescriptor(n2, k2);
        Object.defineProperty(a, k2, d2.get ? d2 : {
          enumerable: true,
          get: function() {
            return n2[k2];
          }
        });
      });
      return a;
    }
    var react = { exports: {} };
    var react_production_min = {};
    /**
     * @license React
     * react.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var l$3 = Symbol.for("react.element"), n$3 = Symbol.for("react.portal"), p$4 = Symbol.for("react.fragment"), q$3 = Symbol.for("react.strict_mode"), r$2 = Symbol.for("react.profiler"), t$2 = Symbol.for("react.provider"), u$1 = Symbol.for("react.context"), v$3 = Symbol.for("react.forward_ref"), w$1 = Symbol.for("react.suspense"), x$1 = Symbol.for("react.memo"), y$1 = Symbol.for("react.lazy"), z$2 = Symbol.iterator;
    function A$2(a) {
      if (null === a || "object" !== typeof a)
        return null;
      a = z$2 && a[z$2] || a["@@iterator"];
      return "function" === typeof a ? a : null;
    }
    var B$1 = { isMounted: function() {
      return false;
    }, enqueueForceUpdate: function() {
    }, enqueueReplaceState: function() {
    }, enqueueSetState: function() {
    } }, C$1 = Object.assign, D$1 = {};
    function E$1(a, b2, e2) {
      this.props = a;
      this.context = b2;
      this.refs = D$1;
      this.updater = e2 || B$1;
    }
    E$1.prototype.isReactComponent = {};
    E$1.prototype.setState = function(a, b2) {
      if ("object" !== typeof a && "function" !== typeof a && null != a)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, a, b2, "setState");
    };
    E$1.prototype.forceUpdate = function(a) {
      this.updater.enqueueForceUpdate(this, a, "forceUpdate");
    };
    function F() {
    }
    F.prototype = E$1.prototype;
    function G$1(a, b2, e2) {
      this.props = a;
      this.context = b2;
      this.refs = D$1;
      this.updater = e2 || B$1;
    }
    var H$1 = G$1.prototype = new F();
    H$1.constructor = G$1;
    C$1(H$1, E$1.prototype);
    H$1.isPureReactComponent = true;
    var I$1 = Array.isArray, J = Object.prototype.hasOwnProperty, K$1 = { current: null }, L$1 = { key: true, ref: true, __self: true, __source: true };
    function M$1(a, b2, e2) {
      var d2, c2 = {}, k2 = null, h2 = null;
      if (null != b2)
        for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2)
          J.call(b2, d2) && !L$1.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
      var g2 = arguments.length - 2;
      if (1 === g2)
        c2.children = e2;
      else if (1 < g2) {
        for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
          f2[m2] = arguments[m2 + 2];
        c2.children = f2;
      }
      if (a && a.defaultProps)
        for (d2 in g2 = a.defaultProps, g2)
          void 0 === c2[d2] && (c2[d2] = g2[d2]);
      return { $$typeof: l$3, type: a, key: k2, ref: h2, props: c2, _owner: K$1.current };
    }
    function N$1(a, b2) {
      return { $$typeof: l$3, type: a.type, key: b2, ref: a.ref, props: a.props, _owner: a._owner };
    }
    function O$1(a) {
      return "object" === typeof a && null !== a && a.$$typeof === l$3;
    }
    function escape(a) {
      var b2 = { "=": "=0", ":": "=2" };
      return "$" + a.replace(/[=:]/g, function(a2) {
        return b2[a2];
      });
    }
    var P$1 = /\/+/g;
    function Q$1(a, b2) {
      return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b2.toString(36);
    }
    function R$1(a, b2, e2, d2, c2) {
      var k2 = typeof a;
      if ("undefined" === k2 || "boolean" === k2)
        a = null;
      var h2 = false;
      if (null === a)
        h2 = true;
      else
        switch (k2) {
          case "string":
          case "number":
            h2 = true;
            break;
          case "object":
            switch (a.$$typeof) {
              case l$3:
              case n$3:
                h2 = true;
            }
        }
      if (h2)
        return h2 = a, c2 = c2(h2), a = "" === d2 ? "." + Q$1(h2, 0) : d2, I$1(c2) ? (e2 = "", null != a && (e2 = a.replace(P$1, "$&/") + "/"), R$1(c2, b2, e2, "", function(a2) {
          return a2;
        })) : null != c2 && (O$1(c2) && (c2 = N$1(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$1, "$&/") + "/") + a)), b2.push(c2)), 1;
      h2 = 0;
      d2 = "" === d2 ? "." : d2 + ":";
      if (I$1(a))
        for (var g2 = 0; g2 < a.length; g2++) {
          k2 = a[g2];
          var f2 = d2 + Q$1(k2, g2);
          h2 += R$1(k2, b2, e2, f2, c2);
        }
      else if (f2 = A$2(a), "function" === typeof f2)
        for (a = f2.call(a), g2 = 0; !(k2 = a.next()).done; )
          k2 = k2.value, f2 = d2 + Q$1(k2, g2++), h2 += R$1(k2, b2, e2, f2, c2);
      else if ("object" === k2)
        throw b2 = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
      return h2;
    }
    function S$1(a, b2, e2) {
      if (null == a)
        return a;
      var d2 = [], c2 = 0;
      R$1(a, d2, "", "", function(a2) {
        return b2.call(e2, a2, c2++);
      });
      return d2;
    }
    function T$1(a) {
      if (-1 === a._status) {
        var b2 = a._result;
        b2 = b2();
        b2.then(function(b3) {
          if (0 === a._status || -1 === a._status)
            a._status = 1, a._result = b3;
        }, function(b3) {
          if (0 === a._status || -1 === a._status)
            a._status = 2, a._result = b3;
        });
        -1 === a._status && (a._status = 0, a._result = b2);
      }
      if (1 === a._status)
        return a._result.default;
      throw a._result;
    }
    var U$1 = { current: null }, V$1 = { transition: null }, W$1 = { ReactCurrentDispatcher: U$1, ReactCurrentBatchConfig: V$1, ReactCurrentOwner: K$1 };
    react_production_min.Children = { map: S$1, forEach: function(a, b2, e2) {
      S$1(a, function() {
        b2.apply(this, arguments);
      }, e2);
    }, count: function(a) {
      var b2 = 0;
      S$1(a, function() {
        b2++;
      });
      return b2;
    }, toArray: function(a) {
      return S$1(a, function(a2) {
        return a2;
      }) || [];
    }, only: function(a) {
      if (!O$1(a))
        throw Error("React.Children.only expected to receive a single React element child.");
      return a;
    } };
    react_production_min.Component = E$1;
    react_production_min.Fragment = p$4;
    react_production_min.Profiler = r$2;
    react_production_min.PureComponent = G$1;
    react_production_min.StrictMode = q$3;
    react_production_min.Suspense = w$1;
    react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
    react_production_min.cloneElement = function(a, b2, e2) {
      if (null === a || void 0 === a)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
      var d2 = C$1({}, a.props), c2 = a.key, k2 = a.ref, h2 = a._owner;
      if (null != b2) {
        void 0 !== b2.ref && (k2 = b2.ref, h2 = K$1.current);
        void 0 !== b2.key && (c2 = "" + b2.key);
        if (a.type && a.type.defaultProps)
          var g2 = a.type.defaultProps;
        for (f2 in b2)
          J.call(b2, f2) && !L$1.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
      }
      var f2 = arguments.length - 2;
      if (1 === f2)
        d2.children = e2;
      else if (1 < f2) {
        g2 = Array(f2);
        for (var m2 = 0; m2 < f2; m2++)
          g2[m2] = arguments[m2 + 2];
        d2.children = g2;
      }
      return { $$typeof: l$3, type: a.type, key: c2, ref: k2, props: d2, _owner: h2 };
    };
    react_production_min.createContext = function(a) {
      a = { $$typeof: u$1, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
      a.Provider = { $$typeof: t$2, _context: a };
      return a.Consumer = a;
    };
    react_production_min.createElement = M$1;
    react_production_min.createFactory = function(a) {
      var b2 = M$1.bind(null, a);
      b2.type = a;
      return b2;
    };
    react_production_min.createRef = function() {
      return { current: null };
    };
    react_production_min.forwardRef = function(a) {
      return { $$typeof: v$3, render: a };
    };
    react_production_min.isValidElement = O$1;
    react_production_min.lazy = function(a) {
      return { $$typeof: y$1, _payload: { _status: -1, _result: a }, _init: T$1 };
    };
    react_production_min.memo = function(a, b2) {
      return { $$typeof: x$1, type: a, compare: void 0 === b2 ? null : b2 };
    };
    react_production_min.startTransition = function(a) {
      var b2 = V$1.transition;
      V$1.transition = {};
      try {
        a();
      } finally {
        V$1.transition = b2;
      }
    };
    react_production_min.unstable_act = function() {
      throw Error("act(...) is not supported in production builds of React.");
    };
    react_production_min.useCallback = function(a, b2) {
      return U$1.current.useCallback(a, b2);
    };
    react_production_min.useContext = function(a) {
      return U$1.current.useContext(a);
    };
    react_production_min.useDebugValue = function() {
    };
    react_production_min.useDeferredValue = function(a) {
      return U$1.current.useDeferredValue(a);
    };
    react_production_min.useEffect = function(a, b2) {
      return U$1.current.useEffect(a, b2);
    };
    react_production_min.useId = function() {
      return U$1.current.useId();
    };
    react_production_min.useImperativeHandle = function(a, b2, e2) {
      return U$1.current.useImperativeHandle(a, b2, e2);
    };
    react_production_min.useInsertionEffect = function(a, b2) {
      return U$1.current.useInsertionEffect(a, b2);
    };
    react_production_min.useLayoutEffect = function(a, b2) {
      return U$1.current.useLayoutEffect(a, b2);
    };
    react_production_min.useMemo = function(a, b2) {
      return U$1.current.useMemo(a, b2);
    };
    react_production_min.useReducer = function(a, b2, e2) {
      return U$1.current.useReducer(a, b2, e2);
    };
    react_production_min.useRef = function(a) {
      return U$1.current.useRef(a);
    };
    react_production_min.useState = function(a) {
      return U$1.current.useState(a);
    };
    react_production_min.useSyncExternalStore = function(a, b2, e2) {
      return U$1.current.useSyncExternalStore(a, b2, e2);
    };
    react_production_min.useTransition = function() {
      return U$1.current.useTransition();
    };
    react_production_min.version = "18.2.0";
    (function(module2) {
      {
        module2.exports = react_production_min;
      }
    })(react);
    const React = /* @__PURE__ */ getDefaultExportFromCjs(react.exports);
    const React$1 = /* @__PURE__ */ _mergeNamespaces({
      __proto__: null,
      default: React
    }, [react.exports]);
    var client = {};
    var reactDom = { exports: {} };
    var reactDom_production_min = {};
    var scheduler = { exports: {} };
    var scheduler_production_min = {};
    /**
     * @license React
     * scheduler.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    (function(exports2) {
      function f2(a, b2) {
        var c2 = a.length;
        a.push(b2);
        a:
          for (; 0 < c2; ) {
            var d2 = c2 - 1 >>> 1, e2 = a[d2];
            if (0 < g2(e2, b2))
              a[d2] = b2, a[c2] = e2, c2 = d2;
            else
              break a;
          }
      }
      function h2(a) {
        return 0 === a.length ? null : a[0];
      }
      function k2(a) {
        if (0 === a.length)
          return null;
        var b2 = a[0], c2 = a.pop();
        if (c2 !== b2) {
          a[0] = c2;
          a:
            for (var d2 = 0, e2 = a.length, w2 = e2 >>> 1; d2 < w2; ) {
              var m2 = 2 * (d2 + 1) - 1, C2 = a[m2], n2 = m2 + 1, x2 = a[n2];
              if (0 > g2(C2, c2))
                n2 < e2 && 0 > g2(x2, C2) ? (a[d2] = x2, a[n2] = c2, d2 = n2) : (a[d2] = C2, a[m2] = c2, d2 = m2);
              else if (n2 < e2 && 0 > g2(x2, c2))
                a[d2] = x2, a[n2] = c2, d2 = n2;
              else
                break a;
            }
        }
        return b2;
      }
      function g2(a, b2) {
        var c2 = a.sortIndex - b2.sortIndex;
        return 0 !== c2 ? c2 : a.id - b2.id;
      }
      if ("object" === typeof performance && "function" === typeof performance.now) {
        var l2 = performance;
        exports2.unstable_now = function() {
          return l2.now();
        };
      } else {
        var p2 = Date, q2 = p2.now();
        exports2.unstable_now = function() {
          return p2.now() - q2;
        };
      }
      var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
      "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function G2(a) {
        for (var b2 = h2(t2); null !== b2; ) {
          if (null === b2.callback)
            k2(t2);
          else if (b2.startTime <= a)
            k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
          else
            break;
          b2 = h2(t2);
        }
      }
      function H2(a) {
        B2 = false;
        G2(a);
        if (!A2)
          if (null !== h2(r2))
            A2 = true, I2(J2);
          else {
            var b2 = h2(t2);
            null !== b2 && K2(H2, b2.startTime - a);
          }
      }
      function J2(a, b2) {
        A2 = false;
        B2 && (B2 = false, E2(L2), L2 = -1);
        z2 = true;
        var c2 = y2;
        try {
          G2(b2);
          for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a && !M2()); ) {
            var d2 = v2.callback;
            if ("function" === typeof d2) {
              v2.callback = null;
              y2 = v2.priorityLevel;
              var e2 = d2(v2.expirationTime <= b2);
              b2 = exports2.unstable_now();
              "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
              G2(b2);
            } else
              k2(r2);
            v2 = h2(r2);
          }
          if (null !== v2)
            var w2 = true;
          else {
            var m2 = h2(t2);
            null !== m2 && K2(H2, m2.startTime - b2);
            w2 = false;
          }
          return w2;
        } finally {
          v2 = null, y2 = c2, z2 = false;
        }
      }
      var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
      function M2() {
        return exports2.unstable_now() - Q2 < P2 ? false : true;
      }
      function R2() {
        if (null !== O2) {
          var a = exports2.unstable_now();
          Q2 = a;
          var b2 = true;
          try {
            b2 = O2(true, a);
          } finally {
            b2 ? S2() : (N2 = false, O2 = null);
          }
        } else
          N2 = false;
      }
      var S2;
      if ("function" === typeof F2)
        S2 = function() {
          F2(R2);
        };
      else if ("undefined" !== typeof MessageChannel) {
        var T2 = new MessageChannel(), U2 = T2.port2;
        T2.port1.onmessage = R2;
        S2 = function() {
          U2.postMessage(null);
        };
      } else
        S2 = function() {
          D2(R2, 0);
        };
      function I2(a) {
        O2 = a;
        N2 || (N2 = true, S2());
      }
      function K2(a, b2) {
        L2 = D2(function() {
          a(exports2.unstable_now());
        }, b2);
      }
      exports2.unstable_IdlePriority = 5;
      exports2.unstable_ImmediatePriority = 1;
      exports2.unstable_LowPriority = 4;
      exports2.unstable_NormalPriority = 3;
      exports2.unstable_Profiling = null;
      exports2.unstable_UserBlockingPriority = 2;
      exports2.unstable_cancelCallback = function(a) {
        a.callback = null;
      };
      exports2.unstable_continueExecution = function() {
        A2 || z2 || (A2 = true, I2(J2));
      };
      exports2.unstable_forceFrameRate = function(a) {
        0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a ? Math.floor(1e3 / a) : 5;
      };
      exports2.unstable_getCurrentPriorityLevel = function() {
        return y2;
      };
      exports2.unstable_getFirstCallbackNode = function() {
        return h2(r2);
      };
      exports2.unstable_next = function(a) {
        switch (y2) {
          case 1:
          case 2:
          case 3:
            var b2 = 3;
            break;
          default:
            b2 = y2;
        }
        var c2 = y2;
        y2 = b2;
        try {
          return a();
        } finally {
          y2 = c2;
        }
      };
      exports2.unstable_pauseExecution = function() {
      };
      exports2.unstable_requestPaint = function() {
      };
      exports2.unstable_runWithPriority = function(a, b2) {
        switch (a) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            a = 3;
        }
        var c2 = y2;
        y2 = a;
        try {
          return b2();
        } finally {
          y2 = c2;
        }
      };
      exports2.unstable_scheduleCallback = function(a, b2, c2) {
        var d2 = exports2.unstable_now();
        "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
        switch (a) {
          case 1:
            var e2 = -1;
            break;
          case 2:
            e2 = 250;
            break;
          case 5:
            e2 = 1073741823;
            break;
          case 4:
            e2 = 1e4;
            break;
          default:
            e2 = 5e3;
        }
        e2 = c2 + e2;
        a = { id: u2++, callback: b2, priorityLevel: a, startTime: c2, expirationTime: e2, sortIndex: -1 };
        c2 > d2 ? (a.sortIndex = c2, f2(t2, a), null === h2(r2) && a === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d2))) : (a.sortIndex = e2, f2(r2, a), A2 || z2 || (A2 = true, I2(J2)));
        return a;
      };
      exports2.unstable_shouldYield = M2;
      exports2.unstable_wrapCallback = function(a) {
        var b2 = y2;
        return function() {
          var c2 = y2;
          y2 = b2;
          try {
            return a.apply(this, arguments);
          } finally {
            y2 = c2;
          }
        };
      };
    })(scheduler_production_min);
    (function(module2) {
      {
        module2.exports = scheduler_production_min;
      }
    })(scheduler);
    /**
     * @license React
     * react-dom.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var aa = react.exports, ca = scheduler.exports;
    function p$3(a) {
      for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c2 = 1; c2 < arguments.length; c2++)
        b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
      return "Minified React error #" + a + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var da = /* @__PURE__ */ new Set(), ea = {};
    function fa(a, b2) {
      ha(a, b2);
      ha(a + "Capture", b2);
    }
    function ha(a, b2) {
      ea[a] = b2;
      for (a = 0; a < b2.length; a++)
        da.add(b2[a]);
    }
    var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
    function oa(a) {
      if (ja.call(ma, a))
        return true;
      if (ja.call(la, a))
        return false;
      if (ka.test(a))
        return ma[a] = true;
      la[a] = true;
      return false;
    }
    function pa(a, b2, c2, d2) {
      if (null !== c2 && 0 === c2.type)
        return false;
      switch (typeof b2) {
        case "function":
        case "symbol":
          return true;
        case "boolean":
          if (d2)
            return false;
          if (null !== c2)
            return !c2.acceptsBooleans;
          a = a.toLowerCase().slice(0, 5);
          return "data-" !== a && "aria-" !== a;
        default:
          return false;
      }
    }
    function qa(a, b2, c2, d2) {
      if (null === b2 || "undefined" === typeof b2 || pa(a, b2, c2, d2))
        return true;
      if (d2)
        return false;
      if (null !== c2)
        switch (c2.type) {
          case 3:
            return !b2;
          case 4:
            return false === b2;
          case 5:
            return isNaN(b2);
          case 6:
            return isNaN(b2) || 1 > b2;
        }
      return false;
    }
    function v$2(a, b2, c2, d2, e2, f2, g2) {
      this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
      this.attributeName = d2;
      this.attributeNamespace = e2;
      this.mustUseProperty = c2;
      this.propertyName = a;
      this.type = b2;
      this.sanitizeURL = f2;
      this.removeEmptyString = g2;
    }
    var z$1 = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
      z$1[a] = new v$2(a, 0, false, a, null, false, false);
    });
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
      var b2 = a[0];
      z$1[b2] = new v$2(b2, 1, false, a[1], null, false, false);
    });
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
      z$1[a] = new v$2(a, 2, false, a.toLowerCase(), null, false, false);
    });
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
      z$1[a] = new v$2(a, 2, false, a, null, false, false);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
      z$1[a] = new v$2(a, 3, false, a.toLowerCase(), null, false, false);
    });
    ["checked", "multiple", "muted", "selected"].forEach(function(a) {
      z$1[a] = new v$2(a, 3, true, a, null, false, false);
    });
    ["capture", "download"].forEach(function(a) {
      z$1[a] = new v$2(a, 4, false, a, null, false, false);
    });
    ["cols", "rows", "size", "span"].forEach(function(a) {
      z$1[a] = new v$2(a, 6, false, a, null, false, false);
    });
    ["rowSpan", "start"].forEach(function(a) {
      z$1[a] = new v$2(a, 5, false, a.toLowerCase(), null, false, false);
    });
    var ra = /[\-:]([a-z])/g;
    function sa(a) {
      return a[1].toUpperCase();
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
      var b2 = a.replace(
        ra,
        sa
      );
      z$1[b2] = new v$2(b2, 1, false, a, null, false, false);
    });
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
      var b2 = a.replace(ra, sa);
      z$1[b2] = new v$2(b2, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
    });
    ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
      var b2 = a.replace(ra, sa);
      z$1[b2] = new v$2(b2, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
    });
    ["tabIndex", "crossOrigin"].forEach(function(a) {
      z$1[a] = new v$2(a, 1, false, a.toLowerCase(), null, false, false);
    });
    z$1.xlinkHref = new v$2("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
    ["src", "href", "action", "formAction"].forEach(function(a) {
      z$1[a] = new v$2(a, 1, false, a.toLowerCase(), null, true, true);
    });
    function ta(a, b2, c2, d2) {
      var e2 = z$1.hasOwnProperty(b2) ? z$1[b2] : null;
      if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1])
        qa(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa(b2) && (null === c2 ? a.removeAttribute(b2) : a.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a.setAttributeNS(d2, b2, c2) : a.setAttribute(b2, c2)));
    }
    var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
    var Ia = Symbol.for("react.offscreen");
    var Ja = Symbol.iterator;
    function Ka(a) {
      if (null === a || "object" !== typeof a)
        return null;
      a = Ja && a[Ja] || a["@@iterator"];
      return "function" === typeof a ? a : null;
    }
    var A$1 = Object.assign, La;
    function Ma(a) {
      if (void 0 === La)
        try {
          throw Error();
        } catch (c2) {
          var b2 = c2.stack.trim().match(/\n( *(at )?)/);
          La = b2 && b2[1] || "";
        }
      return "\n" + La + a;
    }
    var Na = false;
    function Oa(a, b2) {
      if (!a || Na)
        return "";
      Na = true;
      var c2 = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (b2)
          if (b2 = function() {
            throw Error();
          }, Object.defineProperty(b2.prototype, "props", { set: function() {
            throw Error();
          } }), "object" === typeof Reflect && Reflect.construct) {
            try {
              Reflect.construct(b2, []);
            } catch (l2) {
              var d2 = l2;
            }
            Reflect.construct(a, [], b2);
          } else {
            try {
              b2.call();
            } catch (l2) {
              d2 = l2;
            }
            a.call(b2.prototype);
          }
        else {
          try {
            throw Error();
          } catch (l2) {
            d2 = l2;
          }
          a();
        }
      } catch (l2) {
        if (l2 && d2 && "string" === typeof l2.stack) {
          for (var e2 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; )
            h2--;
          for (; 1 <= g2 && 0 <= h2; g2--, h2--)
            if (e2[g2] !== f2[h2]) {
              if (1 !== g2 || 1 !== h2) {
                do
                  if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
                    var k2 = "\n" + e2[g2].replace(" at new ", " at ");
                    a.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a.displayName));
                    return k2;
                  }
                while (1 <= g2 && 0 <= h2);
              }
              break;
            }
        }
      } finally {
        Na = false, Error.prepareStackTrace = c2;
      }
      return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
    }
    function Pa(a) {
      switch (a.tag) {
        case 5:
          return Ma(a.type);
        case 16:
          return Ma("Lazy");
        case 13:
          return Ma("Suspense");
        case 19:
          return Ma("SuspenseList");
        case 0:
        case 2:
        case 15:
          return a = Oa(a.type, false), a;
        case 11:
          return a = Oa(a.type.render, false), a;
        case 1:
          return a = Oa(a.type, true), a;
        default:
          return "";
      }
    }
    function Qa(a) {
      if (null == a)
        return null;
      if ("function" === typeof a)
        return a.displayName || a.name || null;
      if ("string" === typeof a)
        return a;
      switch (a) {
        case ya:
          return "Fragment";
        case wa:
          return "Portal";
        case Aa:
          return "Profiler";
        case za:
          return "StrictMode";
        case Ea:
          return "Suspense";
        case Fa:
          return "SuspenseList";
      }
      if ("object" === typeof a)
        switch (a.$$typeof) {
          case Ca:
            return (a.displayName || "Context") + ".Consumer";
          case Ba:
            return (a._context.displayName || "Context") + ".Provider";
          case Da:
            var b2 = a.render;
            a = a.displayName;
            a || (a = b2.displayName || b2.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
            return a;
          case Ga:
            return b2 = a.displayName || null, null !== b2 ? b2 : Qa(a.type) || "Memo";
          case Ha:
            b2 = a._payload;
            a = a._init;
            try {
              return Qa(a(b2));
            } catch (c2) {
            }
        }
      return null;
    }
    function Ra(a) {
      var b2 = a.type;
      switch (a.tag) {
        case 24:
          return "Cache";
        case 9:
          return (b2.displayName || "Context") + ".Consumer";
        case 10:
          return (b2._context.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return a = b2.render, a = a.displayName || a.name || "", b2.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 5:
          return b2;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return Qa(b2);
        case 8:
          return b2 === za ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
          if ("function" === typeof b2)
            return b2.displayName || b2.name || null;
          if ("string" === typeof b2)
            return b2;
      }
      return null;
    }
    function Sa(a) {
      switch (typeof a) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return a;
        case "object":
          return a;
        default:
          return "";
      }
    }
    function Ta(a) {
      var b2 = a.type;
      return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
    }
    function Ua(a) {
      var b2 = Ta(a) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a.constructor.prototype, b2), d2 = "" + a[b2];
      if (!a.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
        var e2 = c2.get, f2 = c2.set;
        Object.defineProperty(a, b2, { configurable: true, get: function() {
          return e2.call(this);
        }, set: function(a2) {
          d2 = "" + a2;
          f2.call(this, a2);
        } });
        Object.defineProperty(a, b2, { enumerable: c2.enumerable });
        return { getValue: function() {
          return d2;
        }, setValue: function(a2) {
          d2 = "" + a2;
        }, stopTracking: function() {
          a._valueTracker = null;
          delete a[b2];
        } };
      }
    }
    function Va(a) {
      a._valueTracker || (a._valueTracker = Ua(a));
    }
    function Wa(a) {
      if (!a)
        return false;
      var b2 = a._valueTracker;
      if (!b2)
        return true;
      var c2 = b2.getValue();
      var d2 = "";
      a && (d2 = Ta(a) ? a.checked ? "true" : "false" : a.value);
      a = d2;
      return a !== c2 ? (b2.setValue(a), true) : false;
    }
    function Xa(a) {
      a = a || ("undefined" !== typeof document ? document : void 0);
      if ("undefined" === typeof a)
        return null;
      try {
        return a.activeElement || a.body;
      } catch (b2) {
        return a.body;
      }
    }
    function Ya(a, b2) {
      var c2 = b2.checked;
      return A$1({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a._wrapperState.initialChecked });
    }
    function Za(a, b2) {
      var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
      c2 = Sa(null != b2.value ? b2.value : c2);
      a._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
    }
    function ab(a, b2) {
      b2 = b2.checked;
      null != b2 && ta(a, "checked", b2, false);
    }
    function bb(a, b2) {
      ab(a, b2);
      var c2 = Sa(b2.value), d2 = b2.type;
      if (null != c2)
        if ("number" === d2) {
          if (0 === c2 && "" === a.value || a.value != c2)
            a.value = "" + c2;
        } else
          a.value !== "" + c2 && (a.value = "" + c2);
      else if ("submit" === d2 || "reset" === d2) {
        a.removeAttribute("value");
        return;
      }
      b2.hasOwnProperty("value") ? cb(a, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a, b2.type, Sa(b2.defaultValue));
      null == b2.checked && null != b2.defaultChecked && (a.defaultChecked = !!b2.defaultChecked);
    }
    function db(a, b2, c2) {
      if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
        var d2 = b2.type;
        if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value))
          return;
        b2 = "" + a._wrapperState.initialValue;
        c2 || b2 === a.value || (a.value = b2);
        a.defaultValue = b2;
      }
      c2 = a.name;
      "" !== c2 && (a.name = "");
      a.defaultChecked = !!a._wrapperState.initialChecked;
      "" !== c2 && (a.name = c2);
    }
    function cb(a, b2, c2) {
      if ("number" !== b2 || Xa(a.ownerDocument) !== a)
        null == c2 ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c2 && (a.defaultValue = "" + c2);
    }
    var eb = Array.isArray;
    function fb(a, b2, c2, d2) {
      a = a.options;
      if (b2) {
        b2 = {};
        for (var e2 = 0; e2 < c2.length; e2++)
          b2["$" + c2[e2]] = true;
        for (c2 = 0; c2 < a.length; c2++)
          e2 = b2.hasOwnProperty("$" + a[c2].value), a[c2].selected !== e2 && (a[c2].selected = e2), e2 && d2 && (a[c2].defaultSelected = true);
      } else {
        c2 = "" + Sa(c2);
        b2 = null;
        for (e2 = 0; e2 < a.length; e2++) {
          if (a[e2].value === c2) {
            a[e2].selected = true;
            d2 && (a[e2].defaultSelected = true);
            return;
          }
          null !== b2 || a[e2].disabled || (b2 = a[e2]);
        }
        null !== b2 && (b2.selected = true);
      }
    }
    function gb(a, b2) {
      if (null != b2.dangerouslySetInnerHTML)
        throw Error(p$3(91));
      return A$1({}, b2, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
    }
    function hb(a, b2) {
      var c2 = b2.value;
      if (null == c2) {
        c2 = b2.children;
        b2 = b2.defaultValue;
        if (null != c2) {
          if (null != b2)
            throw Error(p$3(92));
          if (eb(c2)) {
            if (1 < c2.length)
              throw Error(p$3(93));
            c2 = c2[0];
          }
          b2 = c2;
        }
        null == b2 && (b2 = "");
        c2 = b2;
      }
      a._wrapperState = { initialValue: Sa(c2) };
    }
    function ib(a, b2) {
      var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
      null != c2 && (c2 = "" + c2, c2 !== a.value && (a.value = c2), null == b2.defaultValue && a.defaultValue !== c2 && (a.defaultValue = c2));
      null != d2 && (a.defaultValue = "" + d2);
    }
    function jb(a) {
      var b2 = a.textContent;
      b2 === a._wrapperState.initialValue && "" !== b2 && null !== b2 && (a.value = b2);
    }
    function kb(a) {
      switch (a) {
        case "svg":
          return "http://www.w3.org/2000/svg";
        case "math":
          return "http://www.w3.org/1998/Math/MathML";
        default:
          return "http://www.w3.org/1999/xhtml";
      }
    }
    function lb(a, b2) {
      return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b2) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a;
    }
    var mb, nb = function(a) {
      return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
        MSApp.execUnsafeLocalFunction(function() {
          return a(b2, c2, d2, e2);
        });
      } : a;
    }(function(a, b2) {
      if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a)
        a.innerHTML = b2;
      else {
        mb = mb || document.createElement("div");
        mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
        for (b2 = mb.firstChild; a.firstChild; )
          a.removeChild(a.firstChild);
        for (; b2.firstChild; )
          a.appendChild(b2.firstChild);
      }
    });
    function ob(a, b2) {
      if (b2) {
        var c2 = a.firstChild;
        if (c2 && c2 === a.lastChild && 3 === c2.nodeType) {
          c2.nodeValue = b2;
          return;
        }
      }
      a.textContent = b2;
    }
    var pb = {
      animationIterationCount: true,
      aspectRatio: true,
      borderImageOutset: true,
      borderImageSlice: true,
      borderImageWidth: true,
      boxFlex: true,
      boxFlexGroup: true,
      boxOrdinalGroup: true,
      columnCount: true,
      columns: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      flexOrder: true,
      gridArea: true,
      gridRow: true,
      gridRowEnd: true,
      gridRowSpan: true,
      gridRowStart: true,
      gridColumn: true,
      gridColumnEnd: true,
      gridColumnSpan: true,
      gridColumnStart: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      fillOpacity: true,
      floodOpacity: true,
      stopOpacity: true,
      strokeDasharray: true,
      strokeDashoffset: true,
      strokeMiterlimit: true,
      strokeOpacity: true,
      strokeWidth: true
    }, qb = ["Webkit", "ms", "Moz", "O"];
    Object.keys(pb).forEach(function(a) {
      qb.forEach(function(b2) {
        b2 = b2 + a.charAt(0).toUpperCase() + a.substring(1);
        pb[b2] = pb[a];
      });
    });
    function rb(a, b2, c2) {
      return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a) && pb[a] ? ("" + b2).trim() : b2 + "px";
    }
    function sb(a, b2) {
      a = a.style;
      for (var c2 in b2)
        if (b2.hasOwnProperty(c2)) {
          var d2 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d2);
          "float" === c2 && (c2 = "cssFloat");
          d2 ? a.setProperty(c2, e2) : a[c2] = e2;
        }
    }
    var tb = A$1({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
    function ub(a, b2) {
      if (b2) {
        if (tb[a] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
          throw Error(p$3(137, a));
        if (null != b2.dangerouslySetInnerHTML) {
          if (null != b2.children)
            throw Error(p$3(60));
          if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML))
            throw Error(p$3(61));
        }
        if (null != b2.style && "object" !== typeof b2.style)
          throw Error(p$3(62));
      }
    }
    function vb(a, b2) {
      if (-1 === a.indexOf("-"))
        return "string" === typeof b2.is;
      switch (a) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return false;
        default:
          return true;
      }
    }
    var wb = null;
    function xb(a) {
      a = a.target || a.srcElement || window;
      a.correspondingUseElement && (a = a.correspondingUseElement);
      return 3 === a.nodeType ? a.parentNode : a;
    }
    var yb = null, zb = null, Ab = null;
    function Bb(a) {
      if (a = Cb(a)) {
        if ("function" !== typeof yb)
          throw Error(p$3(280));
        var b2 = a.stateNode;
        b2 && (b2 = Db(b2), yb(a.stateNode, a.type, b2));
      }
    }
    function Eb(a) {
      zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
    }
    function Fb() {
      if (zb) {
        var a = zb, b2 = Ab;
        Ab = zb = null;
        Bb(a);
        if (b2)
          for (a = 0; a < b2.length; a++)
            Bb(b2[a]);
      }
    }
    function Gb(a, b2) {
      return a(b2);
    }
    function Hb() {
    }
    var Ib = false;
    function Jb(a, b2, c2) {
      if (Ib)
        return a(b2, c2);
      Ib = true;
      try {
        return Gb(a, b2, c2);
      } finally {
        if (Ib = false, null !== zb || null !== Ab)
          Hb(), Fb();
      }
    }
    function Kb(a, b2) {
      var c2 = a.stateNode;
      if (null === c2)
        return null;
      var d2 = Db(c2);
      if (null === d2)
        return null;
      c2 = d2[b2];
      a:
        switch (b2) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (d2 = !d2.disabled) || (a = a.type, d2 = !("button" === a || "input" === a || "select" === a || "textarea" === a));
            a = !d2;
            break a;
          default:
            a = false;
        }
      if (a)
        return null;
      if (c2 && "function" !== typeof c2)
        throw Error(p$3(231, b2, typeof c2));
      return c2;
    }
    var Lb = false;
    if (ia)
      try {
        var Mb = {};
        Object.defineProperty(Mb, "passive", { get: function() {
          Lb = true;
        } });
        window.addEventListener("test", Mb, Mb);
        window.removeEventListener("test", Mb, Mb);
      } catch (a) {
        Lb = false;
      }
    function Nb(a, b2, c2, d2, e2, f2, g2, h2, k2) {
      var l2 = Array.prototype.slice.call(arguments, 3);
      try {
        b2.apply(c2, l2);
      } catch (m2) {
        this.onError(m2);
      }
    }
    var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a) {
      Ob = true;
      Pb = a;
    } };
    function Tb(a, b2, c2, d2, e2, f2, g2, h2, k2) {
      Ob = false;
      Pb = null;
      Nb.apply(Sb, arguments);
    }
    function Ub(a, b2, c2, d2, e2, f2, g2, h2, k2) {
      Tb.apply(this, arguments);
      if (Ob) {
        if (Ob) {
          var l2 = Pb;
          Ob = false;
          Pb = null;
        } else
          throw Error(p$3(198));
        Qb || (Qb = true, Rb = l2);
      }
    }
    function Vb(a) {
      var b2 = a, c2 = a;
      if (a.alternate)
        for (; b2.return; )
          b2 = b2.return;
      else {
        a = b2;
        do
          b2 = a, 0 !== (b2.flags & 4098) && (c2 = b2.return), a = b2.return;
        while (a);
      }
      return 3 === b2.tag ? c2 : null;
    }
    function Wb(a) {
      if (13 === a.tag) {
        var b2 = a.memoizedState;
        null === b2 && (a = a.alternate, null !== a && (b2 = a.memoizedState));
        if (null !== b2)
          return b2.dehydrated;
      }
      return null;
    }
    function Xb(a) {
      if (Vb(a) !== a)
        throw Error(p$3(188));
    }
    function Yb(a) {
      var b2 = a.alternate;
      if (!b2) {
        b2 = Vb(a);
        if (null === b2)
          throw Error(p$3(188));
        return b2 !== a ? null : a;
      }
      for (var c2 = a, d2 = b2; ; ) {
        var e2 = c2.return;
        if (null === e2)
          break;
        var f2 = e2.alternate;
        if (null === f2) {
          d2 = e2.return;
          if (null !== d2) {
            c2 = d2;
            continue;
          }
          break;
        }
        if (e2.child === f2.child) {
          for (f2 = e2.child; f2; ) {
            if (f2 === c2)
              return Xb(e2), a;
            if (f2 === d2)
              return Xb(e2), b2;
            f2 = f2.sibling;
          }
          throw Error(p$3(188));
        }
        if (c2.return !== d2.return)
          c2 = e2, d2 = f2;
        else {
          for (var g2 = false, h2 = e2.child; h2; ) {
            if (h2 === c2) {
              g2 = true;
              c2 = e2;
              d2 = f2;
              break;
            }
            if (h2 === d2) {
              g2 = true;
              d2 = e2;
              c2 = f2;
              break;
            }
            h2 = h2.sibling;
          }
          if (!g2) {
            for (h2 = f2.child; h2; ) {
              if (h2 === c2) {
                g2 = true;
                c2 = f2;
                d2 = e2;
                break;
              }
              if (h2 === d2) {
                g2 = true;
                d2 = f2;
                c2 = e2;
                break;
              }
              h2 = h2.sibling;
            }
            if (!g2)
              throw Error(p$3(189));
          }
        }
        if (c2.alternate !== d2)
          throw Error(p$3(190));
      }
      if (3 !== c2.tag)
        throw Error(p$3(188));
      return c2.stateNode.current === c2 ? a : b2;
    }
    function Zb(a) {
      a = Yb(a);
      return null !== a ? $b(a) : null;
    }
    function $b(a) {
      if (5 === a.tag || 6 === a.tag)
        return a;
      for (a = a.child; null !== a; ) {
        var b2 = $b(a);
        if (null !== b2)
          return b2;
        a = a.sibling;
      }
      return null;
    }
    var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
    function mc(a) {
      if (lc && "function" === typeof lc.onCommitFiberRoot)
        try {
          lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
        } catch (b2) {
        }
    }
    var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
    function nc(a) {
      a >>>= 0;
      return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
    }
    var rc = 64, sc = 4194304;
    function tc(a) {
      switch (a & -a) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return a & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return a & 130023424;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 1073741824;
        default:
          return a;
      }
    }
    function uc(a, b2) {
      var c2 = a.pendingLanes;
      if (0 === c2)
        return 0;
      var d2 = 0, e2 = a.suspendedLanes, f2 = a.pingedLanes, g2 = c2 & 268435455;
      if (0 !== g2) {
        var h2 = g2 & ~e2;
        0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
      } else
        g2 = c2 & ~e2, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
      if (0 === d2)
        return 0;
      if (0 !== b2 && b2 !== d2 && 0 === (b2 & e2) && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240)))
        return b2;
      0 !== (d2 & 4) && (d2 |= c2 & 16);
      b2 = a.entangledLanes;
      if (0 !== b2)
        for (a = a.entanglements, b2 &= d2; 0 < b2; )
          c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a[c2], b2 &= ~e2;
      return d2;
    }
    function vc(a, b2) {
      switch (a) {
        case 1:
        case 2:
        case 4:
          return b2 + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return b2 + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function wc(a, b2) {
      for (var c2 = a.suspendedLanes, d2 = a.pingedLanes, e2 = a.expirationTimes, f2 = a.pendingLanes; 0 < f2; ) {
        var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
        if (-1 === k2) {
          if (0 === (h2 & c2) || 0 !== (h2 & d2))
            e2[g2] = vc(h2, b2);
        } else
          k2 <= b2 && (a.expiredLanes |= h2);
        f2 &= ~h2;
      }
    }
    function xc(a) {
      a = a.pendingLanes & -1073741825;
      return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
    }
    function yc() {
      var a = rc;
      rc <<= 1;
      0 === (rc & 4194240) && (rc = 64);
      return a;
    }
    function zc(a) {
      for (var b2 = [], c2 = 0; 31 > c2; c2++)
        b2.push(a);
      return b2;
    }
    function Ac(a, b2, c2) {
      a.pendingLanes |= b2;
      536870912 !== b2 && (a.suspendedLanes = 0, a.pingedLanes = 0);
      a = a.eventTimes;
      b2 = 31 - oc(b2);
      a[b2] = c2;
    }
    function Bc(a, b2) {
      var c2 = a.pendingLanes & ~b2;
      a.pendingLanes = b2;
      a.suspendedLanes = 0;
      a.pingedLanes = 0;
      a.expiredLanes &= b2;
      a.mutableReadLanes &= b2;
      a.entangledLanes &= b2;
      b2 = a.entanglements;
      var d2 = a.eventTimes;
      for (a = a.expirationTimes; 0 < c2; ) {
        var e2 = 31 - oc(c2), f2 = 1 << e2;
        b2[e2] = 0;
        d2[e2] = -1;
        a[e2] = -1;
        c2 &= ~f2;
      }
    }
    function Cc(a, b2) {
      var c2 = a.entangledLanes |= b2;
      for (a = a.entanglements; c2; ) {
        var d2 = 31 - oc(c2), e2 = 1 << d2;
        e2 & b2 | a[d2] & b2 && (a[d2] |= b2);
        c2 &= ~e2;
      }
    }
    var C = 0;
    function Dc(a) {
      a &= -a;
      return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
    }
    var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
    function Sc(a, b2) {
      switch (a) {
        case "focusin":
        case "focusout":
          Lc = null;
          break;
        case "dragenter":
        case "dragleave":
          Mc = null;
          break;
        case "mouseover":
        case "mouseout":
          Nc = null;
          break;
        case "pointerover":
        case "pointerout":
          Oc.delete(b2.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          Pc.delete(b2.pointerId);
      }
    }
    function Tc(a, b2, c2, d2, e2, f2) {
      if (null === a || a.nativeEvent !== f2)
        return a = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a;
      a.eventSystemFlags |= d2;
      b2 = a.targetContainers;
      null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
      return a;
    }
    function Uc(a, b2, c2, d2, e2) {
      switch (b2) {
        case "focusin":
          return Lc = Tc(Lc, a, b2, c2, d2, e2), true;
        case "dragenter":
          return Mc = Tc(Mc, a, b2, c2, d2, e2), true;
        case "mouseover":
          return Nc = Tc(Nc, a, b2, c2, d2, e2), true;
        case "pointerover":
          var f2 = e2.pointerId;
          Oc.set(f2, Tc(Oc.get(f2) || null, a, b2, c2, d2, e2));
          return true;
        case "gotpointercapture":
          return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a, b2, c2, d2, e2)), true;
      }
      return false;
    }
    function Vc(a) {
      var b2 = Wc(a.target);
      if (null !== b2) {
        var c2 = Vb(b2);
        if (null !== c2) {
          if (b2 = c2.tag, 13 === b2) {
            if (b2 = Wb(c2), null !== b2) {
              a.blockedOn = b2;
              Ic(a.priority, function() {
                Gc(c2);
              });
              return;
            }
          } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
            a.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
            return;
          }
        }
      }
      a.blockedOn = null;
    }
    function Xc(a) {
      if (null !== a.blockedOn)
        return false;
      for (var b2 = a.targetContainers; 0 < b2.length; ) {
        var c2 = Yc(a.domEventName, a.eventSystemFlags, b2[0], a.nativeEvent);
        if (null === c2) {
          c2 = a.nativeEvent;
          var d2 = new c2.constructor(c2.type, c2);
          wb = d2;
          c2.target.dispatchEvent(d2);
          wb = null;
        } else
          return b2 = Cb(c2), null !== b2 && Fc(b2), a.blockedOn = c2, false;
        b2.shift();
      }
      return true;
    }
    function Zc(a, b2, c2) {
      Xc(a) && c2.delete(b2);
    }
    function $c() {
      Jc = false;
      null !== Lc && Xc(Lc) && (Lc = null);
      null !== Mc && Xc(Mc) && (Mc = null);
      null !== Nc && Xc(Nc) && (Nc = null);
      Oc.forEach(Zc);
      Pc.forEach(Zc);
    }
    function ad(a, b2) {
      a.blockedOn === b2 && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
    }
    function bd(a) {
      function b2(b3) {
        return ad(b3, a);
      }
      if (0 < Kc.length) {
        ad(Kc[0], a);
        for (var c2 = 1; c2 < Kc.length; c2++) {
          var d2 = Kc[c2];
          d2.blockedOn === a && (d2.blockedOn = null);
        }
      }
      null !== Lc && ad(Lc, a);
      null !== Mc && ad(Mc, a);
      null !== Nc && ad(Nc, a);
      Oc.forEach(b2);
      Pc.forEach(b2);
      for (c2 = 0; c2 < Qc.length; c2++)
        d2 = Qc[c2], d2.blockedOn === a && (d2.blockedOn = null);
      for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); )
        Vc(c2), null === c2.blockedOn && Qc.shift();
    }
    var cd = ua.ReactCurrentBatchConfig, dd = true;
    function ed(a, b2, c2, d2) {
      var e2 = C, f2 = cd.transition;
      cd.transition = null;
      try {
        C = 1, fd(a, b2, c2, d2);
      } finally {
        C = e2, cd.transition = f2;
      }
    }
    function gd(a, b2, c2, d2) {
      var e2 = C, f2 = cd.transition;
      cd.transition = null;
      try {
        C = 4, fd(a, b2, c2, d2);
      } finally {
        C = e2, cd.transition = f2;
      }
    }
    function fd(a, b2, c2, d2) {
      if (dd) {
        var e2 = Yc(a, b2, c2, d2);
        if (null === e2)
          hd(a, b2, d2, id, c2), Sc(a, d2);
        else if (Uc(e2, a, b2, c2, d2))
          d2.stopPropagation();
        else if (Sc(a, d2), b2 & 4 && -1 < Rc.indexOf(a)) {
          for (; null !== e2; ) {
            var f2 = Cb(e2);
            null !== f2 && Ec(f2);
            f2 = Yc(a, b2, c2, d2);
            null === f2 && hd(a, b2, d2, id, c2);
            if (f2 === e2)
              break;
            e2 = f2;
          }
          null !== e2 && d2.stopPropagation();
        } else
          hd(a, b2, d2, null, c2);
      }
    }
    var id = null;
    function Yc(a, b2, c2, d2) {
      id = null;
      a = xb(d2);
      a = Wc(a);
      if (null !== a)
        if (b2 = Vb(a), null === b2)
          a = null;
        else if (c2 = b2.tag, 13 === c2) {
          a = Wb(b2);
          if (null !== a)
            return a;
          a = null;
        } else if (3 === c2) {
          if (b2.stateNode.current.memoizedState.isDehydrated)
            return 3 === b2.tag ? b2.stateNode.containerInfo : null;
          a = null;
        } else
          b2 !== a && (a = null);
      id = a;
      return null;
    }
    function jd(a) {
      switch (a) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return 1;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return 4;
        case "message":
          switch (ec()) {
            case fc:
              return 1;
            case gc:
              return 4;
            case hc:
            case ic:
              return 16;
            case jc:
              return 536870912;
            default:
              return 16;
          }
        default:
          return 16;
      }
    }
    var kd = null, ld = null, md = null;
    function nd() {
      if (md)
        return md;
      var a, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
      for (a = 0; a < c2 && b2[a] === e2[a]; a++)
        ;
      var g2 = c2 - a;
      for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++)
        ;
      return md = e2.slice(a, 1 < d2 ? 1 - d2 : void 0);
    }
    function od(a) {
      var b2 = a.keyCode;
      "charCode" in a ? (a = a.charCode, 0 === a && 13 === b2 && (a = 13)) : a = b2;
      10 === a && (a = 13);
      return 32 <= a || 13 === a ? a : 0;
    }
    function pd() {
      return true;
    }
    function qd() {
      return false;
    }
    function rd(a) {
      function b2(b3, d2, e2, f2, g2) {
        this._reactName = b3;
        this._targetInst = e2;
        this.type = d2;
        this.nativeEvent = f2;
        this.target = g2;
        this.currentTarget = null;
        for (var c2 in a)
          a.hasOwnProperty(c2) && (b3 = a[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
        this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
        this.isPropagationStopped = qd;
        return this;
      }
      A$1(b2.prototype, { preventDefault: function() {
        this.defaultPrevented = true;
        var a2 = this.nativeEvent;
        a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
      }, stopPropagation: function() {
        var a2 = this.nativeEvent;
        a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
      }, persist: function() {
      }, isPersistent: pd });
      return b2;
    }
    var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
      return a.timeStamp || Date.now();
    }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$1({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$1({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
      return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
    }, movementX: function(a) {
      if ("movementX" in a)
        return a.movementX;
      a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
      return wd;
    }, movementY: function(a) {
      return "movementY" in a ? a.movementY : xd;
    } }), Bd = rd(Ad), Cd = A$1({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$1({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$1({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$1({}, sd, { clipboardData: function(a) {
      return "clipboardData" in a ? a.clipboardData : window.clipboardData;
    } }), Jd = rd(Id), Kd = A$1({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, Nd = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
    function Pd(a) {
      var b2 = this.nativeEvent;
      return b2.getModifierState ? b2.getModifierState(a) : (a = Od[a]) ? !!b2[a] : false;
    }
    function zd() {
      return Pd;
    }
    var Qd = A$1({}, ud, { key: function(a) {
      if (a.key) {
        var b2 = Md[a.key] || a.key;
        if ("Unidentified" !== b2)
          return b2;
      }
      return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
    }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
      return "keypress" === a.type ? od(a) : 0;
    }, keyCode: function(a) {
      return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
    }, which: function(a) {
      return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
    } }), Rd = rd(Qd), Sd = A$1({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$1({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$1({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$1({}, Ad, {
      deltaX: function(a) {
        return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
      },
      deltaY: function(a) {
        return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
    ia && "documentMode" in document && (be = document.documentMode);
    var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
    function ge(a, b2) {
      switch (a) {
        case "keyup":
          return -1 !== $d.indexOf(b2.keyCode);
        case "keydown":
          return 229 !== b2.keyCode;
        case "keypress":
        case "mousedown":
        case "focusout":
          return true;
        default:
          return false;
      }
    }
    function he(a) {
      a = a.detail;
      return "object" === typeof a && "data" in a ? a.data : null;
    }
    var ie = false;
    function je(a, b2) {
      switch (a) {
        case "compositionend":
          return he(b2);
        case "keypress":
          if (32 !== b2.which)
            return null;
          fe = true;
          return ee;
        case "textInput":
          return a = b2.data, a === ee && fe ? null : a;
        default:
          return null;
      }
    }
    function ke(a, b2) {
      if (ie)
        return "compositionend" === a || !ae && ge(a, b2) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
      switch (a) {
        case "paste":
          return null;
        case "keypress":
          if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
            if (b2.char && 1 < b2.char.length)
              return b2.char;
            if (b2.which)
              return String.fromCharCode(b2.which);
          }
          return null;
        case "compositionend":
          return de && "ko" !== b2.locale ? null : b2.data;
        default:
          return null;
      }
    }
    var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
    function me(a) {
      var b2 = a && a.nodeName && a.nodeName.toLowerCase();
      return "input" === b2 ? !!le[a.type] : "textarea" === b2 ? true : false;
    }
    function ne(a, b2, c2, d2) {
      Eb(d2);
      b2 = oe(b2, "onChange");
      0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a.push({ event: c2, listeners: b2 }));
    }
    var pe = null, qe = null;
    function re(a) {
      se(a, 0);
    }
    function te(a) {
      var b2 = ue(a);
      if (Wa(b2))
        return a;
    }
    function ve(a, b2) {
      if ("change" === a)
        return b2;
    }
    var we = false;
    if (ia) {
      var xe;
      if (ia) {
        var ye = "oninput" in document;
        if (!ye) {
          var ze = document.createElement("div");
          ze.setAttribute("oninput", "return;");
          ye = "function" === typeof ze.oninput;
        }
        xe = ye;
      } else
        xe = false;
      we = xe && (!document.documentMode || 9 < document.documentMode);
    }
    function Ae() {
      pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
    }
    function Be(a) {
      if ("value" === a.propertyName && te(qe)) {
        var b2 = [];
        ne(b2, qe, a, xb(a));
        Jb(re, b2);
      }
    }
    function Ce(a, b2, c2) {
      "focusin" === a ? (Ae(), pe = b2, qe = c2, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
    }
    function De(a) {
      if ("selectionchange" === a || "keyup" === a || "keydown" === a)
        return te(qe);
    }
    function Ee(a, b2) {
      if ("click" === a)
        return te(b2);
    }
    function Fe(a, b2) {
      if ("input" === a || "change" === a)
        return te(b2);
    }
    function Ge(a, b2) {
      return a === b2 && (0 !== a || 1 / a === 1 / b2) || a !== a && b2 !== b2;
    }
    var He = "function" === typeof Object.is ? Object.is : Ge;
    function Ie(a, b2) {
      if (He(a, b2))
        return true;
      if ("object" !== typeof a || null === a || "object" !== typeof b2 || null === b2)
        return false;
      var c2 = Object.keys(a), d2 = Object.keys(b2);
      if (c2.length !== d2.length)
        return false;
      for (d2 = 0; d2 < c2.length; d2++) {
        var e2 = c2[d2];
        if (!ja.call(b2, e2) || !He(a[e2], b2[e2]))
          return false;
      }
      return true;
    }
    function Je(a) {
      for (; a && a.firstChild; )
        a = a.firstChild;
      return a;
    }
    function Ke(a, b2) {
      var c2 = Je(a);
      a = 0;
      for (var d2; c2; ) {
        if (3 === c2.nodeType) {
          d2 = a + c2.textContent.length;
          if (a <= b2 && d2 >= b2)
            return { node: c2, offset: b2 - a };
          a = d2;
        }
        a: {
          for (; c2; ) {
            if (c2.nextSibling) {
              c2 = c2.nextSibling;
              break a;
            }
            c2 = c2.parentNode;
          }
          c2 = void 0;
        }
        c2 = Je(c2);
      }
    }
    function Le(a, b2) {
      return a && b2 ? a === b2 ? true : a && 3 === a.nodeType ? false : b2 && 3 === b2.nodeType ? Le(a, b2.parentNode) : "contains" in a ? a.contains(b2) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b2) & 16) : false : false;
    }
    function Me() {
      for (var a = window, b2 = Xa(); b2 instanceof a.HTMLIFrameElement; ) {
        try {
          var c2 = "string" === typeof b2.contentWindow.location.href;
        } catch (d2) {
          c2 = false;
        }
        if (c2)
          a = b2.contentWindow;
        else
          break;
        b2 = Xa(a.document);
      }
      return b2;
    }
    function Ne(a) {
      var b2 = a && a.nodeName && a.nodeName.toLowerCase();
      return b2 && ("input" === b2 && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b2 || "true" === a.contentEditable);
    }
    function Oe(a) {
      var b2 = Me(), c2 = a.focusedElem, d2 = a.selectionRange;
      if (b2 !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
        if (null !== d2 && Ne(c2)) {
          if (b2 = d2.start, a = d2.end, void 0 === a && (a = b2), "selectionStart" in c2)
            c2.selectionStart = b2, c2.selectionEnd = Math.min(a, c2.value.length);
          else if (a = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a.getSelection) {
            a = a.getSelection();
            var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
            d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e2);
            !a.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
            e2 = Ke(c2, f2);
            var g2 = Ke(
              c2,
              d2
            );
            e2 && g2 && (1 !== a.rangeCount || a.anchorNode !== e2.node || a.anchorOffset !== e2.offset || a.focusNode !== g2.node || a.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a.removeAllRanges(), f2 > d2 ? (a.addRange(b2), a.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a.addRange(b2)));
          }
        }
        b2 = [];
        for (a = c2; a = a.parentNode; )
          1 === a.nodeType && b2.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
        "function" === typeof c2.focus && c2.focus();
        for (c2 = 0; c2 < b2.length; c2++)
          a = b2[c2], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
      }
    }
    var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
    function Ue(a, b2, c2) {
      var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
      Te || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se && Ie(Se, d2) || (Se = d2, d2 = oe(Re, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a.push({ event: b2, listeners: d2 }), b2.target = Qe)));
    }
    function Ve(a, b2) {
      var c2 = {};
      c2[a.toLowerCase()] = b2.toLowerCase();
      c2["Webkit" + a] = "webkit" + b2;
      c2["Moz" + a] = "moz" + b2;
      return c2;
    }
    var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
    ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
    function Ze(a) {
      if (Xe[a])
        return Xe[a];
      if (!We[a])
        return a;
      var b2 = We[a], c2;
      for (c2 in b2)
        if (b2.hasOwnProperty(c2) && c2 in Ye)
          return Xe[a] = b2[c2];
      return a;
    }
    var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    function ff(a, b2) {
      df.set(a, b2);
      fa(b2, [a]);
    }
    for (var gf = 0; gf < ef.length; gf++) {
      var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
      ff(jf, "on" + kf);
    }
    ff($e, "onAnimationEnd");
    ff(af, "onAnimationIteration");
    ff(bf, "onAnimationStart");
    ff("dblclick", "onDoubleClick");
    ff("focusin", "onFocus");
    ff("focusout", "onBlur");
    ff(cf, "onTransitionEnd");
    ha("onMouseEnter", ["mouseout", "mouseover"]);
    ha("onMouseLeave", ["mouseout", "mouseover"]);
    ha("onPointerEnter", ["pointerout", "pointerover"]);
    ha("onPointerLeave", ["pointerout", "pointerover"]);
    fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
    fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
    fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
    fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
    fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
    fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
    function nf(a, b2, c2) {
      var d2 = a.type || "unknown-event";
      a.currentTarget = c2;
      Ub(d2, b2, void 0, a);
      a.currentTarget = null;
    }
    function se(a, b2) {
      b2 = 0 !== (b2 & 4);
      for (var c2 = 0; c2 < a.length; c2++) {
        var d2 = a[c2], e2 = d2.event;
        d2 = d2.listeners;
        a: {
          var f2 = void 0;
          if (b2)
            for (var g2 = d2.length - 1; 0 <= g2; g2--) {
              var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
              h2 = h2.listener;
              if (k2 !== f2 && e2.isPropagationStopped())
                break a;
              nf(e2, h2, l2);
              f2 = k2;
            }
          else
            for (g2 = 0; g2 < d2.length; g2++) {
              h2 = d2[g2];
              k2 = h2.instance;
              l2 = h2.currentTarget;
              h2 = h2.listener;
              if (k2 !== f2 && e2.isPropagationStopped())
                break a;
              nf(e2, h2, l2);
              f2 = k2;
            }
        }
      }
      if (Qb)
        throw a = Rb, Qb = false, Rb = null, a;
    }
    function D(a, b2) {
      var c2 = b2[of];
      void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
      var d2 = a + "__bubble";
      c2.has(d2) || (pf(b2, a, 2, false), c2.add(d2));
    }
    function qf(a, b2, c2) {
      var d2 = 0;
      b2 && (d2 |= 4);
      pf(c2, a, d2, b2);
    }
    var rf = "_reactListening" + Math.random().toString(36).slice(2);
    function sf(a) {
      if (!a[rf]) {
        a[rf] = true;
        da.forEach(function(b3) {
          "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a), qf(b3, true, a));
        });
        var b2 = 9 === a.nodeType ? a : a.ownerDocument;
        null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
      }
    }
    function pf(a, b2, c2, d2) {
      switch (jd(b2)) {
        case 1:
          var e2 = ed;
          break;
        case 4:
          e2 = gd;
          break;
        default:
          e2 = fd;
      }
      c2 = e2.bind(null, b2, c2, a);
      e2 = void 0;
      !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
      d2 ? void 0 !== e2 ? a.addEventListener(b2, c2, { capture: true, passive: e2 }) : a.addEventListener(b2, c2, true) : void 0 !== e2 ? a.addEventListener(b2, c2, { passive: e2 }) : a.addEventListener(b2, c2, false);
    }
    function hd(a, b2, c2, d2, e2) {
      var f2 = d2;
      if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2)
        a:
          for (; ; ) {
            if (null === d2)
              return;
            var g2 = d2.tag;
            if (3 === g2 || 4 === g2) {
              var h2 = d2.stateNode.containerInfo;
              if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2)
                break;
              if (4 === g2)
                for (g2 = d2.return; null !== g2; ) {
                  var k2 = g2.tag;
                  if (3 === k2 || 4 === k2) {
                    if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2)
                      return;
                  }
                  g2 = g2.return;
                }
              for (; null !== h2; ) {
                g2 = Wc(h2);
                if (null === g2)
                  return;
                k2 = g2.tag;
                if (5 === k2 || 6 === k2) {
                  d2 = f2 = g2;
                  continue a;
                }
                h2 = h2.parentNode;
              }
            }
            d2 = d2.return;
          }
      Jb(function() {
        var d3 = f2, e3 = xb(c2), g3 = [];
        a: {
          var h3 = df.get(a);
          if (void 0 !== h3) {
            var k3 = td, n2 = a;
            switch (a) {
              case "keypress":
                if (0 === od(c2))
                  break a;
              case "keydown":
              case "keyup":
                k3 = Rd;
                break;
              case "focusin":
                n2 = "focus";
                k3 = Fd;
                break;
              case "focusout":
                n2 = "blur";
                k3 = Fd;
                break;
              case "beforeblur":
              case "afterblur":
                k3 = Fd;
                break;
              case "click":
                if (2 === c2.button)
                  break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                k3 = Bd;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                k3 = Dd;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                k3 = Vd;
                break;
              case $e:
              case af:
              case bf:
                k3 = Hd;
                break;
              case cf:
                k3 = Xd;
                break;
              case "scroll":
                k3 = vd;
                break;
              case "wheel":
                k3 = Zd;
                break;
              case "copy":
              case "cut":
              case "paste":
                k3 = Jd;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                k3 = Td;
            }
            var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
            t2 = [];
            for (var w2 = d3, u2; null !== w2; ) {
              u2 = w2;
              var F2 = u2.stateNode;
              5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
              if (J2)
                break;
              w2 = w2.return;
            }
            0 < t2.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t2 }));
          }
        }
        if (0 === (b2 & 7)) {
          a: {
            h3 = "mouseover" === a || "pointerover" === a;
            k3 = "mouseout" === a || "pointerout" === a;
            if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf]))
              break a;
            if (k3 || h3) {
              h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
              if (k3) {
                if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
                  n2 = null;
              } else
                k3 = null, n2 = d3;
              if (k3 !== n2) {
                t2 = Bd;
                F2 = "onMouseLeave";
                x2 = "onMouseEnter";
                w2 = "mouse";
                if ("pointerout" === a || "pointerover" === a)
                  t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
                J2 = null == k3 ? h3 : ue(k3);
                u2 = null == n2 ? h3 : ue(n2);
                h3 = new t2(F2, w2 + "leave", k3, c2, e3);
                h3.target = J2;
                h3.relatedTarget = u2;
                F2 = null;
                Wc(e3) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
                J2 = F2;
                if (k3 && n2)
                  b: {
                    t2 = k3;
                    x2 = n2;
                    w2 = 0;
                    for (u2 = t2; u2; u2 = vf(u2))
                      w2++;
                    u2 = 0;
                    for (F2 = x2; F2; F2 = vf(F2))
                      u2++;
                    for (; 0 < w2 - u2; )
                      t2 = vf(t2), w2--;
                    for (; 0 < u2 - w2; )
                      x2 = vf(x2), u2--;
                    for (; w2--; ) {
                      if (t2 === x2 || null !== x2 && t2 === x2.alternate)
                        break b;
                      t2 = vf(t2);
                      x2 = vf(x2);
                    }
                    t2 = null;
                  }
                else
                  t2 = null;
                null !== k3 && wf(g3, h3, k3, t2, false);
                null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
              }
            }
          }
          a: {
            h3 = d3 ? ue(d3) : window;
            k3 = h3.nodeName && h3.nodeName.toLowerCase();
            if ("select" === k3 || "input" === k3 && "file" === h3.type)
              var na = ve;
            else if (me(h3))
              if (we)
                na = Fe;
              else {
                na = De;
                var xa = Ce;
              }
            else
              (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee);
            if (na && (na = na(a, d3))) {
              ne(g3, na, c2, e3);
              break a;
            }
            xa && xa(a, h3, d3);
            "focusout" === a && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
          }
          xa = d3 ? ue(d3) : window;
          switch (a) {
            case "focusin":
              if (me(xa) || "true" === xa.contentEditable)
                Qe = xa, Re = d3, Se = null;
              break;
            case "focusout":
              Se = Re = Qe = null;
              break;
            case "mousedown":
              Te = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              Te = false;
              Ue(g3, c2, e3);
              break;
            case "selectionchange":
              if (Pe)
                break;
            case "keydown":
            case "keyup":
              Ue(g3, c2, e3);
          }
          var $a;
          if (ae)
            b: {
              switch (a) {
                case "compositionstart":
                  var ba = "onCompositionStart";
                  break b;
                case "compositionend":
                  ba = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  ba = "onCompositionUpdate";
                  break b;
              }
              ba = void 0;
            }
          else
            ie ? ge(a, c2) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c2.keyCode && (ba = "onCompositionStart");
          ba && (de && "ko" !== c2.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d3, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c2), null !== $a && (ba.data = $a))));
          if ($a = ce ? je(a, c2) : ke(a, c2))
            d3 = oe(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a);
        }
        se(g3, b2);
      });
    }
    function tf(a, b2, c2) {
      return { instance: a, listener: b2, currentTarget: c2 };
    }
    function oe(a, b2) {
      for (var c2 = b2 + "Capture", d2 = []; null !== a; ) {
        var e2 = a, f2 = e2.stateNode;
        5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a, c2), null != f2 && d2.unshift(tf(a, f2, e2)), f2 = Kb(a, b2), null != f2 && d2.push(tf(a, f2, e2)));
        a = a.return;
      }
      return d2;
    }
    function vf(a) {
      if (null === a)
        return null;
      do
        a = a.return;
      while (a && 5 !== a.tag);
      return a ? a : null;
    }
    function wf(a, b2, c2, d2, e2) {
      for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
        var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
        if (null !== k2 && k2 === d2)
          break;
        5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
        c2 = c2.return;
      }
      0 !== g2.length && a.push({ event: b2, listeners: g2 });
    }
    var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
    function zf(a) {
      return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
    }
    function Af(a, b2, c2) {
      b2 = zf(b2);
      if (zf(a) !== b2 && c2)
        throw Error(p$3(425));
    }
    function Bf() {
    }
    var Cf = null, Df = null;
    function Ef(a, b2) {
      return "textarea" === a || "noscript" === a || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
    }
    var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
      return Hf.resolve(null).then(a).catch(If);
    } : Ff;
    function If(a) {
      setTimeout(function() {
        throw a;
      });
    }
    function Kf(a, b2) {
      var c2 = b2, d2 = 0;
      do {
        var e2 = c2.nextSibling;
        a.removeChild(c2);
        if (e2 && 8 === e2.nodeType)
          if (c2 = e2.data, "/$" === c2) {
            if (0 === d2) {
              a.removeChild(e2);
              bd(b2);
              return;
            }
            d2--;
          } else
            "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
        c2 = e2;
      } while (c2);
      bd(b2);
    }
    function Lf(a) {
      for (; null != a; a = a.nextSibling) {
        var b2 = a.nodeType;
        if (1 === b2 || 3 === b2)
          break;
        if (8 === b2) {
          b2 = a.data;
          if ("$" === b2 || "$!" === b2 || "$?" === b2)
            break;
          if ("/$" === b2)
            return null;
        }
      }
      return a;
    }
    function Mf(a) {
      a = a.previousSibling;
      for (var b2 = 0; a; ) {
        if (8 === a.nodeType) {
          var c2 = a.data;
          if ("$" === c2 || "$!" === c2 || "$?" === c2) {
            if (0 === b2)
              return a;
            b2--;
          } else
            "/$" === c2 && b2++;
        }
        a = a.previousSibling;
      }
      return null;
    }
    var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
    function Wc(a) {
      var b2 = a[Of];
      if (b2)
        return b2;
      for (var c2 = a.parentNode; c2; ) {
        if (b2 = c2[uf] || c2[Of]) {
          c2 = b2.alternate;
          if (null !== b2.child || null !== c2 && null !== c2.child)
            for (a = Mf(a); null !== a; ) {
              if (c2 = a[Of])
                return c2;
              a = Mf(a);
            }
          return b2;
        }
        a = c2;
        c2 = a.parentNode;
      }
      return null;
    }
    function Cb(a) {
      a = a[Of] || a[uf];
      return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
    }
    function ue(a) {
      if (5 === a.tag || 6 === a.tag)
        return a.stateNode;
      throw Error(p$3(33));
    }
    function Db(a) {
      return a[Pf] || null;
    }
    var Sf = [], Tf = -1;
    function Uf(a) {
      return { current: a };
    }
    function E(a) {
      0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
    }
    function G(a, b2) {
      Tf++;
      Sf[Tf] = a.current;
      a.current = b2;
    }
    var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
    function Yf(a, b2) {
      var c2 = a.type.contextTypes;
      if (!c2)
        return Vf;
      var d2 = a.stateNode;
      if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
        return d2.__reactInternalMemoizedMaskedChildContext;
      var e2 = {}, f2;
      for (f2 in c2)
        e2[f2] = b2[f2];
      d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b2, a.__reactInternalMemoizedMaskedChildContext = e2);
      return e2;
    }
    function Zf(a) {
      a = a.childContextTypes;
      return null !== a && void 0 !== a;
    }
    function $f() {
      E(Wf);
      E(H);
    }
    function ag(a, b2, c2) {
      if (H.current !== Vf)
        throw Error(p$3(168));
      G(H, b2);
      G(Wf, c2);
    }
    function bg(a, b2, c2) {
      var d2 = a.stateNode;
      b2 = b2.childContextTypes;
      if ("function" !== typeof d2.getChildContext)
        return c2;
      d2 = d2.getChildContext();
      for (var e2 in d2)
        if (!(e2 in b2))
          throw Error(p$3(108, Ra(a) || "Unknown", e2));
      return A$1({}, c2, d2);
    }
    function cg(a) {
      a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
      Xf = H.current;
      G(H, a);
      G(Wf, Wf.current);
      return true;
    }
    function dg(a, b2, c2) {
      var d2 = a.stateNode;
      if (!d2)
        throw Error(p$3(169));
      c2 ? (a = bg(a, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
      G(Wf, c2);
    }
    var eg = null, fg = false, gg = false;
    function hg(a) {
      null === eg ? eg = [a] : eg.push(a);
    }
    function ig(a) {
      fg = true;
      hg(a);
    }
    function jg() {
      if (!gg && null !== eg) {
        gg = true;
        var a = 0, b2 = C;
        try {
          var c2 = eg;
          for (C = 1; a < c2.length; a++) {
            var d2 = c2[a];
            do
              d2 = d2(true);
            while (null !== d2);
          }
          eg = null;
          fg = false;
        } catch (e2) {
          throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e2;
        } finally {
          C = b2, gg = false;
        }
      }
      return null;
    }
    var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
    function tg(a, b2) {
      kg[lg++] = ng;
      kg[lg++] = mg;
      mg = a;
      ng = b2;
    }
    function ug(a, b2, c2) {
      og[pg++] = rg;
      og[pg++] = sg;
      og[pg++] = qg;
      qg = a;
      var d2 = rg;
      a = sg;
      var e2 = 32 - oc(d2) - 1;
      d2 &= ~(1 << e2);
      c2 += 1;
      var f2 = 32 - oc(b2) + e2;
      if (30 < f2) {
        var g2 = e2 - e2 % 5;
        f2 = (d2 & (1 << g2) - 1).toString(32);
        d2 >>= g2;
        e2 -= g2;
        rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2;
        sg = f2 + a;
      } else
        rg = 1 << f2 | c2 << e2 | d2, sg = a;
    }
    function vg(a) {
      null !== a.return && (tg(a, 1), ug(a, 1, 0));
    }
    function wg(a) {
      for (; a === mg; )
        mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
      for (; a === qg; )
        qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
    }
    var xg = null, yg = null, I = false, zg = null;
    function Ag(a, b2) {
      var c2 = Bg(5, null, null, 0);
      c2.elementType = "DELETED";
      c2.stateNode = b2;
      c2.return = a;
      b2 = a.deletions;
      null === b2 ? (a.deletions = [c2], a.flags |= 16) : b2.push(c2);
    }
    function Cg(a, b2) {
      switch (a.tag) {
        case 5:
          var c2 = a.type;
          b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
          return null !== b2 ? (a.stateNode = b2, xg = a, yg = Lf(b2.firstChild), true) : false;
        case 6:
          return b2 = "" === a.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a.stateNode = b2, xg = a, yg = null, true) : false;
        case 13:
          return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a, a.child = c2, xg = a, yg = null, true) : false;
        default:
          return false;
      }
    }
    function Dg(a) {
      return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
    }
    function Eg(a) {
      if (I) {
        var b2 = yg;
        if (b2) {
          var c2 = b2;
          if (!Cg(a, b2)) {
            if (Dg(a))
              throw Error(p$3(418));
            b2 = Lf(c2.nextSibling);
            var d2 = xg;
            b2 && Cg(a, b2) ? Ag(d2, c2) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
          }
        } else {
          if (Dg(a))
            throw Error(p$3(418));
          a.flags = a.flags & -4097 | 2;
          I = false;
          xg = a;
        }
      }
    }
    function Fg(a) {
      for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; )
        a = a.return;
      xg = a;
    }
    function Gg(a) {
      if (a !== xg)
        return false;
      if (!I)
        return Fg(a), I = true, false;
      var b2;
      (b2 = 3 !== a.tag) && !(b2 = 5 !== a.tag) && (b2 = a.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a.type, a.memoizedProps));
      if (b2 && (b2 = yg)) {
        if (Dg(a))
          throw Hg(), Error(p$3(418));
        for (; b2; )
          Ag(a, b2), b2 = Lf(b2.nextSibling);
      }
      Fg(a);
      if (13 === a.tag) {
        a = a.memoizedState;
        a = null !== a ? a.dehydrated : null;
        if (!a)
          throw Error(p$3(317));
        a: {
          a = a.nextSibling;
          for (b2 = 0; a; ) {
            if (8 === a.nodeType) {
              var c2 = a.data;
              if ("/$" === c2) {
                if (0 === b2) {
                  yg = Lf(a.nextSibling);
                  break a;
                }
                b2--;
              } else
                "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
            }
            a = a.nextSibling;
          }
          yg = null;
        }
      } else
        yg = xg ? Lf(a.stateNode.nextSibling) : null;
      return true;
    }
    function Hg() {
      for (var a = yg; a; )
        a = Lf(a.nextSibling);
    }
    function Ig() {
      yg = xg = null;
      I = false;
    }
    function Jg(a) {
      null === zg ? zg = [a] : zg.push(a);
    }
    var Kg = ua.ReactCurrentBatchConfig;
    function Lg(a, b2) {
      if (a && a.defaultProps) {
        b2 = A$1({}, b2);
        a = a.defaultProps;
        for (var c2 in a)
          void 0 === b2[c2] && (b2[c2] = a[c2]);
        return b2;
      }
      return b2;
    }
    var Mg = Uf(null), Ng = null, Og = null, Pg = null;
    function Qg() {
      Pg = Og = Ng = null;
    }
    function Rg(a) {
      var b2 = Mg.current;
      E(Mg);
      a._currentValue = b2;
    }
    function Sg(a, b2, c2) {
      for (; null !== a; ) {
        var d2 = a.alternate;
        (a.childLanes & b2) !== b2 ? (a.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
        if (a === c2)
          break;
        a = a.return;
      }
    }
    function Tg(a, b2) {
      Ng = a;
      Pg = Og = null;
      a = a.dependencies;
      null !== a && null !== a.firstContext && (0 !== (a.lanes & b2) && (Ug = true), a.firstContext = null);
    }
    function Vg(a) {
      var b2 = a._currentValue;
      if (Pg !== a)
        if (a = { context: a, memoizedValue: b2, next: null }, null === Og) {
          if (null === Ng)
            throw Error(p$3(308));
          Og = a;
          Ng.dependencies = { lanes: 0, firstContext: a };
        } else
          Og = Og.next = a;
      return b2;
    }
    var Wg = null;
    function Xg(a) {
      null === Wg ? Wg = [a] : Wg.push(a);
    }
    function Yg(a, b2, c2, d2) {
      var e2 = b2.interleaved;
      null === e2 ? (c2.next = c2, Xg(b2)) : (c2.next = e2.next, e2.next = c2);
      b2.interleaved = c2;
      return Zg(a, d2);
    }
    function Zg(a, b2) {
      a.lanes |= b2;
      var c2 = a.alternate;
      null !== c2 && (c2.lanes |= b2);
      c2 = a;
      for (a = a.return; null !== a; )
        a.childLanes |= b2, c2 = a.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a, a = a.return;
      return 3 === c2.tag ? c2.stateNode : null;
    }
    var $g = false;
    function ah(a) {
      a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
    }
    function bh(a, b2) {
      a = a.updateQueue;
      b2.updateQueue === a && (b2.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
    }
    function ch(a, b2) {
      return { eventTime: a, lane: b2, tag: 0, payload: null, callback: null, next: null };
    }
    function dh(a, b2, c2) {
      var d2 = a.updateQueue;
      if (null === d2)
        return null;
      d2 = d2.shared;
      if (0 !== (K & 2)) {
        var e2 = d2.pending;
        null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
        d2.pending = b2;
        return Zg(a, c2);
      }
      e2 = d2.interleaved;
      null === e2 ? (b2.next = b2, Xg(d2)) : (b2.next = e2.next, e2.next = b2);
      d2.interleaved = b2;
      return Zg(a, c2);
    }
    function eh(a, b2, c2) {
      b2 = b2.updateQueue;
      if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
        var d2 = b2.lanes;
        d2 &= a.pendingLanes;
        c2 |= d2;
        b2.lanes = c2;
        Cc(a, c2);
      }
    }
    function fh(a, b2) {
      var c2 = a.updateQueue, d2 = a.alternate;
      if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
        var e2 = null, f2 = null;
        c2 = c2.firstBaseUpdate;
        if (null !== c2) {
          do {
            var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
            null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
            c2 = c2.next;
          } while (null !== c2);
          null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
        } else
          e2 = f2 = b2;
        c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
        a.updateQueue = c2;
        return;
      }
      a = c2.lastBaseUpdate;
      null === a ? c2.firstBaseUpdate = b2 : a.next = b2;
      c2.lastBaseUpdate = b2;
    }
    function gh(a, b2, c2, d2) {
      var e2 = a.updateQueue;
      $g = false;
      var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
      if (null !== h2) {
        e2.shared.pending = null;
        var k2 = h2, l2 = k2.next;
        k2.next = null;
        null === g2 ? f2 = l2 : g2.next = l2;
        g2 = k2;
        var m2 = a.alternate;
        null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
      }
      if (null !== f2) {
        var q2 = e2.baseState;
        g2 = 0;
        m2 = l2 = k2 = null;
        h2 = f2;
        do {
          var r2 = h2.lane, y2 = h2.eventTime;
          if ((d2 & r2) === r2) {
            null !== m2 && (m2 = m2.next = {
              eventTime: y2,
              lane: 0,
              tag: h2.tag,
              payload: h2.payload,
              callback: h2.callback,
              next: null
            });
            a: {
              var n2 = a, t2 = h2;
              r2 = b2;
              y2 = c2;
              switch (t2.tag) {
                case 1:
                  n2 = t2.payload;
                  if ("function" === typeof n2) {
                    q2 = n2.call(y2, q2, r2);
                    break a;
                  }
                  q2 = n2;
                  break a;
                case 3:
                  n2.flags = n2.flags & -65537 | 128;
                case 0:
                  n2 = t2.payload;
                  r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
                  if (null === r2 || void 0 === r2)
                    break a;
                  q2 = A$1({}, q2, r2);
                  break a;
                case 2:
                  $g = true;
              }
            }
            null !== h2.callback && 0 !== h2.lane && (a.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
          } else
            y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
          h2 = h2.next;
          if (null === h2)
            if (h2 = e2.shared.pending, null === h2)
              break;
            else
              r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
        } while (1);
        null === m2 && (k2 = q2);
        e2.baseState = k2;
        e2.firstBaseUpdate = l2;
        e2.lastBaseUpdate = m2;
        b2 = e2.shared.interleaved;
        if (null !== b2) {
          e2 = b2;
          do
            g2 |= e2.lane, e2 = e2.next;
          while (e2 !== b2);
        } else
          null === f2 && (e2.shared.lanes = 0);
        hh |= g2;
        a.lanes = g2;
        a.memoizedState = q2;
      }
    }
    function ih(a, b2, c2) {
      a = b2.effects;
      b2.effects = null;
      if (null !== a)
        for (b2 = 0; b2 < a.length; b2++) {
          var d2 = a[b2], e2 = d2.callback;
          if (null !== e2) {
            d2.callback = null;
            d2 = c2;
            if ("function" !== typeof e2)
              throw Error(p$3(191, e2));
            e2.call(d2);
          }
        }
    }
    var jh = new aa.Component().refs;
    function kh(a, b2, c2, d2) {
      b2 = a.memoizedState;
      c2 = c2(d2, b2);
      c2 = null === c2 || void 0 === c2 ? b2 : A$1({}, b2, c2);
      a.memoizedState = c2;
      0 === a.lanes && (a.updateQueue.baseState = c2);
    }
    var nh = { isMounted: function(a) {
      return (a = a._reactInternals) ? Vb(a) === a : false;
    }, enqueueSetState: function(a, b2, c2) {
      a = a._reactInternals;
      var d2 = L(), e2 = lh(a), f2 = ch(d2, e2);
      f2.payload = b2;
      void 0 !== c2 && null !== c2 && (f2.callback = c2);
      b2 = dh(a, f2, e2);
      null !== b2 && (mh(b2, a, e2, d2), eh(b2, a, e2));
    }, enqueueReplaceState: function(a, b2, c2) {
      a = a._reactInternals;
      var d2 = L(), e2 = lh(a), f2 = ch(d2, e2);
      f2.tag = 1;
      f2.payload = b2;
      void 0 !== c2 && null !== c2 && (f2.callback = c2);
      b2 = dh(a, f2, e2);
      null !== b2 && (mh(b2, a, e2, d2), eh(b2, a, e2));
    }, enqueueForceUpdate: function(a, b2) {
      a = a._reactInternals;
      var c2 = L(), d2 = lh(a), e2 = ch(c2, d2);
      e2.tag = 2;
      void 0 !== b2 && null !== b2 && (e2.callback = b2);
      b2 = dh(a, e2, d2);
      null !== b2 && (mh(b2, a, d2, c2), eh(b2, a, d2));
    } };
    function oh(a, b2, c2, d2, e2, f2, g2) {
      a = a.stateNode;
      return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie(c2, d2) || !Ie(e2, f2) : true;
    }
    function ph(a, b2, c2) {
      var d2 = false, e2 = Vf;
      var f2 = b2.contextType;
      "object" === typeof f2 && null !== f2 ? f2 = Vg(f2) : (e2 = Zf(b2) ? Xf : H.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a, e2) : Vf);
      b2 = new b2(c2, f2);
      a.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
      b2.updater = nh;
      a.stateNode = b2;
      b2._reactInternals = a;
      d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e2, a.__reactInternalMemoizedMaskedChildContext = f2);
      return b2;
    }
    function qh(a, b2, c2, d2) {
      a = b2.state;
      "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
      "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
      b2.state !== a && nh.enqueueReplaceState(b2, b2.state, null);
    }
    function rh(a, b2, c2, d2) {
      var e2 = a.stateNode;
      e2.props = c2;
      e2.state = a.memoizedState;
      e2.refs = jh;
      ah(a);
      var f2 = b2.contextType;
      "object" === typeof f2 && null !== f2 ? e2.context = Vg(f2) : (f2 = Zf(b2) ? Xf : H.current, e2.context = Yf(a, f2));
      e2.state = a.memoizedState;
      f2 = b2.getDerivedStateFromProps;
      "function" === typeof f2 && (kh(a, b2, f2, c2), e2.state = a.memoizedState);
      "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && nh.enqueueReplaceState(e2, e2.state, null), gh(a, c2, e2, d2), e2.state = a.memoizedState);
      "function" === typeof e2.componentDidMount && (a.flags |= 4194308);
    }
    function sh(a, b2, c2) {
      a = c2.ref;
      if (null !== a && "function" !== typeof a && "object" !== typeof a) {
        if (c2._owner) {
          c2 = c2._owner;
          if (c2) {
            if (1 !== c2.tag)
              throw Error(p$3(309));
            var d2 = c2.stateNode;
          }
          if (!d2)
            throw Error(p$3(147, a));
          var e2 = d2, f2 = "" + a;
          if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2)
            return b2.ref;
          b2 = function(a2) {
            var b3 = e2.refs;
            b3 === jh && (b3 = e2.refs = {});
            null === a2 ? delete b3[f2] : b3[f2] = a2;
          };
          b2._stringRef = f2;
          return b2;
        }
        if ("string" !== typeof a)
          throw Error(p$3(284));
        if (!c2._owner)
          throw Error(p$3(290, a));
      }
      return a;
    }
    function th(a, b2) {
      a = Object.prototype.toString.call(b2);
      throw Error(p$3(31, "[object Object]" === a ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a));
    }
    function uh(a) {
      var b2 = a._init;
      return b2(a._payload);
    }
    function vh(a) {
      function b2(b3, c3) {
        if (a) {
          var d3 = b3.deletions;
          null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
        }
      }
      function c2(c3, d3) {
        if (!a)
          return null;
        for (; null !== d3; )
          b2(c3, d3), d3 = d3.sibling;
        return null;
      }
      function d2(a2, b3) {
        for (a2 = /* @__PURE__ */ new Map(); null !== b3; )
          null !== b3.key ? a2.set(b3.key, b3) : a2.set(b3.index, b3), b3 = b3.sibling;
        return a2;
      }
      function e2(a2, b3) {
        a2 = wh(a2, b3);
        a2.index = 0;
        a2.sibling = null;
        return a2;
      }
      function f2(b3, c3, d3) {
        b3.index = d3;
        if (!a)
          return b3.flags |= 1048576, c3;
        d3 = b3.alternate;
        if (null !== d3)
          return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
        b3.flags |= 2;
        return c3;
      }
      function g2(b3) {
        a && null === b3.alternate && (b3.flags |= 2);
        return b3;
      }
      function h2(a2, b3, c3, d3) {
        if (null === b3 || 6 !== b3.tag)
          return b3 = xh(c3, a2.mode, d3), b3.return = a2, b3;
        b3 = e2(b3, c3);
        b3.return = a2;
        return b3;
      }
      function k2(a2, b3, c3, d3) {
        var f3 = c3.type;
        if (f3 === ya)
          return m2(a2, b3, c3.props.children, d3, c3.key);
        if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && uh(f3) === b3.type))
          return d3 = e2(b3, c3.props), d3.ref = sh(a2, b3, c3), d3.return = a2, d3;
        d3 = yh(c3.type, c3.key, c3.props, null, a2.mode, d3);
        d3.ref = sh(a2, b3, c3);
        d3.return = a2;
        return d3;
      }
      function l2(a2, b3, c3, d3) {
        if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
          return b3 = zh(c3, a2.mode, d3), b3.return = a2, b3;
        b3 = e2(b3, c3.children || []);
        b3.return = a2;
        return b3;
      }
      function m2(a2, b3, c3, d3, f3) {
        if (null === b3 || 7 !== b3.tag)
          return b3 = Ah(c3, a2.mode, d3, f3), b3.return = a2, b3;
        b3 = e2(b3, c3);
        b3.return = a2;
        return b3;
      }
      function q2(a2, b3, c3) {
        if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3)
          return b3 = xh("" + b3, a2.mode, c3), b3.return = a2, b3;
        if ("object" === typeof b3 && null !== b3) {
          switch (b3.$$typeof) {
            case va:
              return c3 = yh(b3.type, b3.key, b3.props, null, a2.mode, c3), c3.ref = sh(a2, null, b3), c3.return = a2, c3;
            case wa:
              return b3 = zh(b3, a2.mode, c3), b3.return = a2, b3;
            case Ha:
              var d3 = b3._init;
              return q2(a2, d3(b3._payload), c3);
          }
          if (eb(b3) || Ka(b3))
            return b3 = Ah(b3, a2.mode, c3, null), b3.return = a2, b3;
          th(a2, b3);
        }
        return null;
      }
      function r2(a2, b3, c3, d3) {
        var e3 = null !== b3 ? b3.key : null;
        if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3)
          return null !== e3 ? null : h2(a2, b3, "" + c3, d3);
        if ("object" === typeof c3 && null !== c3) {
          switch (c3.$$typeof) {
            case va:
              return c3.key === e3 ? k2(a2, b3, c3, d3) : null;
            case wa:
              return c3.key === e3 ? l2(a2, b3, c3, d3) : null;
            case Ha:
              return e3 = c3._init, r2(
                a2,
                b3,
                e3(c3._payload),
                d3
              );
          }
          if (eb(c3) || Ka(c3))
            return null !== e3 ? null : m2(a2, b3, c3, d3, null);
          th(a2, c3);
        }
        return null;
      }
      function y2(a2, b3, c3, d3, e3) {
        if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3)
          return a2 = a2.get(c3) || null, h2(b3, a2, "" + d3, e3);
        if ("object" === typeof d3 && null !== d3) {
          switch (d3.$$typeof) {
            case va:
              return a2 = a2.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a2, d3, e3);
            case wa:
              return a2 = a2.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a2, d3, e3);
            case Ha:
              var f3 = d3._init;
              return y2(a2, b3, c3, f3(d3._payload), e3);
          }
          if (eb(d3) || Ka(d3))
            return a2 = a2.get(c3) || null, m2(b3, a2, d3, e3, null);
          th(b3, d3);
        }
        return null;
      }
      function n2(e3, g3, h3, k3) {
        for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
          u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
          var n3 = r2(e3, u2, h3[w2], k3);
          if (null === n3) {
            null === u2 && (u2 = x2);
            break;
          }
          a && u2 && null === n3.alternate && b2(e3, u2);
          g3 = f2(n3, g3, w2);
          null === m3 ? l3 = n3 : m3.sibling = n3;
          m3 = n3;
          u2 = x2;
        }
        if (w2 === h3.length)
          return c2(e3, u2), I && tg(e3, w2), l3;
        if (null === u2) {
          for (; w2 < h3.length; w2++)
            u2 = q2(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
          I && tg(e3, w2);
          return l3;
        }
        for (u2 = d2(e3, u2); w2 < h3.length; w2++)
          x2 = y2(u2, e3, w2, h3[w2], k3), null !== x2 && (a && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
        a && u2.forEach(function(a2) {
          return b2(e3, a2);
        });
        I && tg(e3, w2);
        return l3;
      }
      function t2(e3, g3, h3, k3) {
        var l3 = Ka(h3);
        if ("function" !== typeof l3)
          throw Error(p$3(150));
        h3 = l3.call(h3);
        if (null == h3)
          throw Error(p$3(151));
        for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
          m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
          var t3 = r2(e3, m3, n3.value, k3);
          if (null === t3) {
            null === m3 && (m3 = x2);
            break;
          }
          a && m3 && null === t3.alternate && b2(e3, m3);
          g3 = f2(t3, g3, w2);
          null === u2 ? l3 = t3 : u2.sibling = t3;
          u2 = t3;
          m3 = x2;
        }
        if (n3.done)
          return c2(
            e3,
            m3
          ), I && tg(e3, w2), l3;
        if (null === m3) {
          for (; !n3.done; w2++, n3 = h3.next())
            n3 = q2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
          I && tg(e3, w2);
          return l3;
        }
        for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next())
          n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
        a && m3.forEach(function(a2) {
          return b2(e3, a2);
        });
        I && tg(e3, w2);
        return l3;
      }
      function J2(a2, d3, f3, h3) {
        "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
        if ("object" === typeof f3 && null !== f3) {
          switch (f3.$$typeof) {
            case va:
              a: {
                for (var k3 = f3.key, l3 = d3; null !== l3; ) {
                  if (l3.key === k3) {
                    k3 = f3.type;
                    if (k3 === ya) {
                      if (7 === l3.tag) {
                        c2(a2, l3.sibling);
                        d3 = e2(l3, f3.props.children);
                        d3.return = a2;
                        a2 = d3;
                        break a;
                      }
                    } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && uh(k3) === l3.type) {
                      c2(a2, l3.sibling);
                      d3 = e2(l3, f3.props);
                      d3.ref = sh(a2, l3, f3);
                      d3.return = a2;
                      a2 = d3;
                      break a;
                    }
                    c2(a2, l3);
                    break;
                  } else
                    b2(a2, l3);
                  l3 = l3.sibling;
                }
                f3.type === ya ? (d3 = Ah(f3.props.children, a2.mode, h3, f3.key), d3.return = a2, a2 = d3) : (h3 = yh(f3.type, f3.key, f3.props, null, a2.mode, h3), h3.ref = sh(a2, d3, f3), h3.return = a2, a2 = h3);
              }
              return g2(a2);
            case wa:
              a: {
                for (l3 = f3.key; null !== d3; ) {
                  if (d3.key === l3)
                    if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                      c2(a2, d3.sibling);
                      d3 = e2(d3, f3.children || []);
                      d3.return = a2;
                      a2 = d3;
                      break a;
                    } else {
                      c2(a2, d3);
                      break;
                    }
                  else
                    b2(a2, d3);
                  d3 = d3.sibling;
                }
                d3 = zh(f3, a2.mode, h3);
                d3.return = a2;
                a2 = d3;
              }
              return g2(a2);
            case Ha:
              return l3 = f3._init, J2(a2, d3, l3(f3._payload), h3);
          }
          if (eb(f3))
            return n2(a2, d3, f3, h3);
          if (Ka(f3))
            return t2(a2, d3, f3, h3);
          th(a2, f3);
        }
        return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a2, d3.sibling), d3 = e2(d3, f3), d3.return = a2, a2 = d3) : (c2(a2, d3), d3 = xh(f3, a2.mode, h3), d3.return = a2, a2 = d3), g2(a2)) : c2(a2, d3);
      }
      return J2;
    }
    var Bh = vh(true), Ch = vh(false), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
    function Hh(a) {
      if (a === Dh)
        throw Error(p$3(174));
      return a;
    }
    function Ih(a, b2) {
      G(Gh, b2);
      G(Fh, a);
      G(Eh, Dh);
      a = b2.nodeType;
      switch (a) {
        case 9:
        case 11:
          b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
          break;
        default:
          a = 8 === a ? b2.parentNode : b2, b2 = a.namespaceURI || null, a = a.tagName, b2 = lb(b2, a);
      }
      E(Eh);
      G(Eh, b2);
    }
    function Jh() {
      E(Eh);
      E(Fh);
      E(Gh);
    }
    function Kh(a) {
      Hh(Gh.current);
      var b2 = Hh(Eh.current);
      var c2 = lb(b2, a.type);
      b2 !== c2 && (G(Fh, a), G(Eh, c2));
    }
    function Lh(a) {
      Fh.current === a && (E(Eh), E(Fh));
    }
    var M = Uf(0);
    function Mh(a) {
      for (var b2 = a; null !== b2; ) {
        if (13 === b2.tag) {
          var c2 = b2.memoizedState;
          if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
            return b2;
        } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
          if (0 !== (b2.flags & 128))
            return b2;
        } else if (null !== b2.child) {
          b2.child.return = b2;
          b2 = b2.child;
          continue;
        }
        if (b2 === a)
          break;
        for (; null === b2.sibling; ) {
          if (null === b2.return || b2.return === a)
            return null;
          b2 = b2.return;
        }
        b2.sibling.return = b2.return;
        b2 = b2.sibling;
      }
      return null;
    }
    var Nh = [];
    function Oh() {
      for (var a = 0; a < Nh.length; a++)
        Nh[a]._workInProgressVersionPrimary = null;
      Nh.length = 0;
    }
    var Ph = ua.ReactCurrentDispatcher, Qh = ua.ReactCurrentBatchConfig, Rh = 0, N = null, O = null, P = null, Sh = false, Th = false, Uh = 0, Vh = 0;
    function Q() {
      throw Error(p$3(321));
    }
    function Wh(a, b2) {
      if (null === b2)
        return false;
      for (var c2 = 0; c2 < b2.length && c2 < a.length; c2++)
        if (!He(a[c2], b2[c2]))
          return false;
      return true;
    }
    function Xh(a, b2, c2, d2, e2, f2) {
      Rh = f2;
      N = b2;
      b2.memoizedState = null;
      b2.updateQueue = null;
      b2.lanes = 0;
      Ph.current = null === a || null === a.memoizedState ? Yh : Zh;
      a = c2(d2, e2);
      if (Th) {
        f2 = 0;
        do {
          Th = false;
          Uh = 0;
          if (25 <= f2)
            throw Error(p$3(301));
          f2 += 1;
          P = O = null;
          b2.updateQueue = null;
          Ph.current = $h;
          a = c2(d2, e2);
        } while (Th);
      }
      Ph.current = ai;
      b2 = null !== O && null !== O.next;
      Rh = 0;
      P = O = N = null;
      Sh = false;
      if (b2)
        throw Error(p$3(300));
      return a;
    }
    function bi() {
      var a = 0 !== Uh;
      Uh = 0;
      return a;
    }
    function ci() {
      var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      null === P ? N.memoizedState = P = a : P = P.next = a;
      return P;
    }
    function di() {
      if (null === O) {
        var a = N.alternate;
        a = null !== a ? a.memoizedState : null;
      } else
        a = O.next;
      var b2 = null === P ? N.memoizedState : P.next;
      if (null !== b2)
        P = b2, O = a;
      else {
        if (null === a)
          throw Error(p$3(310));
        O = a;
        a = { memoizedState: O.memoizedState, baseState: O.baseState, baseQueue: O.baseQueue, queue: O.queue, next: null };
        null === P ? N.memoizedState = P = a : P = P.next = a;
      }
      return P;
    }
    function ei(a, b2) {
      return "function" === typeof b2 ? b2(a) : b2;
    }
    function fi(a) {
      var b2 = di(), c2 = b2.queue;
      if (null === c2)
        throw Error(p$3(311));
      c2.lastRenderedReducer = a;
      var d2 = O, e2 = d2.baseQueue, f2 = c2.pending;
      if (null !== f2) {
        if (null !== e2) {
          var g2 = e2.next;
          e2.next = f2.next;
          f2.next = g2;
        }
        d2.baseQueue = e2 = f2;
        c2.pending = null;
      }
      if (null !== e2) {
        f2 = e2.next;
        d2 = d2.baseState;
        var h2 = g2 = null, k2 = null, l2 = f2;
        do {
          var m2 = l2.lane;
          if ((Rh & m2) === m2)
            null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a(d2, l2.action);
          else {
            var q2 = {
              lane: m2,
              action: l2.action,
              hasEagerState: l2.hasEagerState,
              eagerState: l2.eagerState,
              next: null
            };
            null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
            N.lanes |= m2;
            hh |= m2;
          }
          l2 = l2.next;
        } while (null !== l2 && l2 !== f2);
        null === k2 ? g2 = d2 : k2.next = h2;
        He(d2, b2.memoizedState) || (Ug = true);
        b2.memoizedState = d2;
        b2.baseState = g2;
        b2.baseQueue = k2;
        c2.lastRenderedState = d2;
      }
      a = c2.interleaved;
      if (null !== a) {
        e2 = a;
        do
          f2 = e2.lane, N.lanes |= f2, hh |= f2, e2 = e2.next;
        while (e2 !== a);
      } else
        null === e2 && (c2.lanes = 0);
      return [b2.memoizedState, c2.dispatch];
    }
    function gi(a) {
      var b2 = di(), c2 = b2.queue;
      if (null === c2)
        throw Error(p$3(311));
      c2.lastRenderedReducer = a;
      var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
      if (null !== e2) {
        c2.pending = null;
        var g2 = e2 = e2.next;
        do
          f2 = a(f2, g2.action), g2 = g2.next;
        while (g2 !== e2);
        He(f2, b2.memoizedState) || (Ug = true);
        b2.memoizedState = f2;
        null === b2.baseQueue && (b2.baseState = f2);
        c2.lastRenderedState = f2;
      }
      return [f2, d2];
    }
    function hi() {
    }
    function ii(a, b2) {
      var c2 = N, d2 = di(), e2 = b2(), f2 = !He(d2.memoizedState, e2);
      f2 && (d2.memoizedState = e2, Ug = true);
      d2 = d2.queue;
      ji(ki.bind(null, c2, d2, a), [a]);
      if (d2.getSnapshot !== b2 || f2 || null !== P && P.memoizedState.tag & 1) {
        c2.flags |= 2048;
        li(9, mi.bind(null, c2, d2, e2, b2), void 0, null);
        if (null === R)
          throw Error(p$3(349));
        0 !== (Rh & 30) || ni(c2, b2, e2);
      }
      return e2;
    }
    function ni(a, b2, c2) {
      a.flags |= 16384;
      a = { getSnapshot: b2, value: c2 };
      b2 = N.updateQueue;
      null === b2 ? (b2 = { lastEffect: null, stores: null }, N.updateQueue = b2, b2.stores = [a]) : (c2 = b2.stores, null === c2 ? b2.stores = [a] : c2.push(a));
    }
    function mi(a, b2, c2, d2) {
      b2.value = c2;
      b2.getSnapshot = d2;
      oi(b2) && pi(a);
    }
    function ki(a, b2, c2) {
      return c2(function() {
        oi(b2) && pi(a);
      });
    }
    function oi(a) {
      var b2 = a.getSnapshot;
      a = a.value;
      try {
        var c2 = b2();
        return !He(a, c2);
      } catch (d2) {
        return true;
      }
    }
    function pi(a) {
      var b2 = Zg(a, 1);
      null !== b2 && mh(b2, a, 1, -1);
    }
    function qi(a) {
      var b2 = ci();
      "function" === typeof a && (a = a());
      b2.memoizedState = b2.baseState = a;
      a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: a };
      b2.queue = a;
      a = a.dispatch = ri.bind(null, N, a);
      return [b2.memoizedState, a];
    }
    function li(a, b2, c2, d2) {
      a = { tag: a, create: b2, destroy: c2, deps: d2, next: null };
      b2 = N.updateQueue;
      null === b2 ? (b2 = { lastEffect: null, stores: null }, N.updateQueue = b2, b2.lastEffect = a.next = a) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a.next = a : (d2 = c2.next, c2.next = a, a.next = d2, b2.lastEffect = a));
      return a;
    }
    function si() {
      return di().memoizedState;
    }
    function ti(a, b2, c2, d2) {
      var e2 = ci();
      N.flags |= a;
      e2.memoizedState = li(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
    }
    function ui(a, b2, c2, d2) {
      var e2 = di();
      d2 = void 0 === d2 ? null : d2;
      var f2 = void 0;
      if (null !== O) {
        var g2 = O.memoizedState;
        f2 = g2.destroy;
        if (null !== d2 && Wh(d2, g2.deps)) {
          e2.memoizedState = li(b2, c2, f2, d2);
          return;
        }
      }
      N.flags |= a;
      e2.memoizedState = li(1 | b2, c2, f2, d2);
    }
    function vi(a, b2) {
      return ti(8390656, 8, a, b2);
    }
    function ji(a, b2) {
      return ui(2048, 8, a, b2);
    }
    function wi(a, b2) {
      return ui(4, 2, a, b2);
    }
    function xi(a, b2) {
      return ui(4, 4, a, b2);
    }
    function yi(a, b2) {
      if ("function" === typeof b2)
        return a = a(), b2(a), function() {
          b2(null);
        };
      if (null !== b2 && void 0 !== b2)
        return a = a(), b2.current = a, function() {
          b2.current = null;
        };
    }
    function zi(a, b2, c2) {
      c2 = null !== c2 && void 0 !== c2 ? c2.concat([a]) : null;
      return ui(4, 4, yi.bind(null, b2, a), c2);
    }
    function Ai() {
    }
    function Bi(a, b2) {
      var c2 = di();
      b2 = void 0 === b2 ? null : b2;
      var d2 = c2.memoizedState;
      if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
        return d2[0];
      c2.memoizedState = [a, b2];
      return a;
    }
    function Ci(a, b2) {
      var c2 = di();
      b2 = void 0 === b2 ? null : b2;
      var d2 = c2.memoizedState;
      if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
        return d2[0];
      a = a();
      c2.memoizedState = [a, b2];
      return a;
    }
    function Di(a, b2, c2) {
      if (0 === (Rh & 21))
        return a.baseState && (a.baseState = false, Ug = true), a.memoizedState = c2;
      He(c2, b2) || (c2 = yc(), N.lanes |= c2, hh |= c2, a.baseState = true);
      return b2;
    }
    function Ei(a, b2) {
      var c2 = C;
      C = 0 !== c2 && 4 > c2 ? c2 : 4;
      a(true);
      var d2 = Qh.transition;
      Qh.transition = {};
      try {
        a(false), b2();
      } finally {
        C = c2, Qh.transition = d2;
      }
    }
    function Fi() {
      return di().memoizedState;
    }
    function Gi(a, b2, c2) {
      var d2 = lh(a);
      c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
      if (Hi(a))
        Ii(b2, c2);
      else if (c2 = Yg(a, b2, c2, d2), null !== c2) {
        var e2 = L();
        mh(c2, a, d2, e2);
        Ji(c2, b2, d2);
      }
    }
    function ri(a, b2, c2) {
      var d2 = lh(a), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
      if (Hi(a))
        Ii(b2, e2);
      else {
        var f2 = a.alternate;
        if (0 === a.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2))
          try {
            var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
            e2.hasEagerState = true;
            e2.eagerState = h2;
            if (He(h2, g2)) {
              var k2 = b2.interleaved;
              null === k2 ? (e2.next = e2, Xg(b2)) : (e2.next = k2.next, k2.next = e2);
              b2.interleaved = e2;
              return;
            }
          } catch (l2) {
          } finally {
          }
        c2 = Yg(a, b2, e2, d2);
        null !== c2 && (e2 = L(), mh(c2, a, d2, e2), Ji(c2, b2, d2));
      }
    }
    function Hi(a) {
      var b2 = a.alternate;
      return a === N || null !== b2 && b2 === N;
    }
    function Ii(a, b2) {
      Th = Sh = true;
      var c2 = a.pending;
      null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
      a.pending = b2;
    }
    function Ji(a, b2, c2) {
      if (0 !== (c2 & 4194240)) {
        var d2 = b2.lanes;
        d2 &= a.pendingLanes;
        c2 |= d2;
        b2.lanes = c2;
        Cc(a, c2);
      }
    }
    var ai = { readContext: Vg, useCallback: Q, useContext: Q, useEffect: Q, useImperativeHandle: Q, useInsertionEffect: Q, useLayoutEffect: Q, useMemo: Q, useReducer: Q, useRef: Q, useState: Q, useDebugValue: Q, useDeferredValue: Q, useTransition: Q, useMutableSource: Q, useSyncExternalStore: Q, useId: Q, unstable_isNewReconciler: false }, Yh = { readContext: Vg, useCallback: function(a, b2) {
      ci().memoizedState = [a, void 0 === b2 ? null : b2];
      return a;
    }, useContext: Vg, useEffect: vi, useImperativeHandle: function(a, b2, c2) {
      c2 = null !== c2 && void 0 !== c2 ? c2.concat([a]) : null;
      return ti(
        4194308,
        4,
        yi.bind(null, b2, a),
        c2
      );
    }, useLayoutEffect: function(a, b2) {
      return ti(4194308, 4, a, b2);
    }, useInsertionEffect: function(a, b2) {
      return ti(4, 2, a, b2);
    }, useMemo: function(a, b2) {
      var c2 = ci();
      b2 = void 0 === b2 ? null : b2;
      a = a();
      c2.memoizedState = [a, b2];
      return a;
    }, useReducer: function(a, b2, c2) {
      var d2 = ci();
      b2 = void 0 !== c2 ? c2(b2) : b2;
      d2.memoizedState = d2.baseState = b2;
      a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b2 };
      d2.queue = a;
      a = a.dispatch = Gi.bind(null, N, a);
      return [d2.memoizedState, a];
    }, useRef: function(a) {
      var b2 = ci();
      a = { current: a };
      return b2.memoizedState = a;
    }, useState: qi, useDebugValue: Ai, useDeferredValue: function(a) {
      return ci().memoizedState = a;
    }, useTransition: function() {
      var a = qi(false), b2 = a[0];
      a = Ei.bind(null, a[1]);
      ci().memoizedState = a;
      return [b2, a];
    }, useMutableSource: function() {
    }, useSyncExternalStore: function(a, b2, c2) {
      var d2 = N, e2 = ci();
      if (I) {
        if (void 0 === c2)
          throw Error(p$3(407));
        c2 = c2();
      } else {
        c2 = b2();
        if (null === R)
          throw Error(p$3(349));
        0 !== (Rh & 30) || ni(d2, b2, c2);
      }
      e2.memoizedState = c2;
      var f2 = { value: c2, getSnapshot: b2 };
      e2.queue = f2;
      vi(ki.bind(
        null,
        d2,
        f2,
        a
      ), [a]);
      d2.flags |= 2048;
      li(9, mi.bind(null, d2, f2, c2, b2), void 0, null);
      return c2;
    }, useId: function() {
      var a = ci(), b2 = R.identifierPrefix;
      if (I) {
        var c2 = sg;
        var d2 = rg;
        c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
        b2 = ":" + b2 + "R" + c2;
        c2 = Uh++;
        0 < c2 && (b2 += "H" + c2.toString(32));
        b2 += ":";
      } else
        c2 = Vh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
      return a.memoizedState = b2;
    }, unstable_isNewReconciler: false }, Zh = {
      readContext: Vg,
      useCallback: Bi,
      useContext: Vg,
      useEffect: ji,
      useImperativeHandle: zi,
      useInsertionEffect: wi,
      useLayoutEffect: xi,
      useMemo: Ci,
      useReducer: fi,
      useRef: si,
      useState: function() {
        return fi(ei);
      },
      useDebugValue: Ai,
      useDeferredValue: function(a) {
        var b2 = di();
        return Di(b2, O.memoizedState, a);
      },
      useTransition: function() {
        var a = fi(ei)[0], b2 = di().memoizedState;
        return [a, b2];
      },
      useMutableSource: hi,
      useSyncExternalStore: ii,
      useId: Fi,
      unstable_isNewReconciler: false
    }, $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: function() {
      return gi(ei);
    }, useDebugValue: Ai, useDeferredValue: function(a) {
      var b2 = di();
      return null === O ? b2.memoizedState = a : Di(b2, O.memoizedState, a);
    }, useTransition: function() {
      var a = gi(ei)[0], b2 = di().memoizedState;
      return [a, b2];
    }, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: false };
    function Ki(a, b2) {
      try {
        var c2 = "", d2 = b2;
        do
          c2 += Pa(d2), d2 = d2.return;
        while (d2);
        var e2 = c2;
      } catch (f2) {
        e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
      }
      return { value: a, source: b2, stack: e2, digest: null };
    }
    function Li(a, b2, c2) {
      return { value: a, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
    }
    function Mi(a, b2) {
      try {
        console.error(b2.value);
      } catch (c2) {
        setTimeout(function() {
          throw c2;
        });
      }
    }
    var Ni = "function" === typeof WeakMap ? WeakMap : Map;
    function Oi(a, b2, c2) {
      c2 = ch(-1, c2);
      c2.tag = 3;
      c2.payload = { element: null };
      var d2 = b2.value;
      c2.callback = function() {
        Pi || (Pi = true, Qi = d2);
        Mi(a, b2);
      };
      return c2;
    }
    function Ri(a, b2, c2) {
      c2 = ch(-1, c2);
      c2.tag = 3;
      var d2 = a.type.getDerivedStateFromError;
      if ("function" === typeof d2) {
        var e2 = b2.value;
        c2.payload = function() {
          return d2(e2);
        };
        c2.callback = function() {
          Mi(a, b2);
        };
      }
      var f2 = a.stateNode;
      null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
        Mi(a, b2);
        "function" !== typeof d2 && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
        var c3 = b2.stack;
        this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
      });
      return c2;
    }
    function Ti(a, b2, c2) {
      var d2 = a.pingCache;
      if (null === d2) {
        d2 = a.pingCache = new Ni();
        var e2 = /* @__PURE__ */ new Set();
        d2.set(b2, e2);
      } else
        e2 = d2.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
      e2.has(c2) || (e2.add(c2), a = Ui.bind(null, a, b2, c2), b2.then(a, a));
    }
    function Vi(a) {
      do {
        var b2;
        if (b2 = 13 === a.tag)
          b2 = a.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
        if (b2)
          return a;
        a = a.return;
      } while (null !== a);
      return null;
    }
    function Wi(a, b2, c2, d2, e2) {
      if (0 === (a.mode & 1))
        return a === b2 ? a.flags |= 65536 : (a.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = ch(-1, 1), b2.tag = 2, dh(c2, b2, 1))), c2.lanes |= 1), a;
      a.flags |= 65536;
      a.lanes = e2;
      return a;
    }
    var Xi = ua.ReactCurrentOwner, Ug = false;
    function Yi(a, b2, c2, d2) {
      b2.child = null === a ? Ch(b2, null, c2, d2) : Bh(b2, a.child, c2, d2);
    }
    function Zi(a, b2, c2, d2, e2) {
      c2 = c2.render;
      var f2 = b2.ref;
      Tg(b2, e2);
      d2 = Xh(a, b2, c2, d2, f2, e2);
      c2 = bi();
      if (null !== a && !Ug)
        return b2.updateQueue = a.updateQueue, b2.flags &= -2053, a.lanes &= ~e2, $i(a, b2, e2);
      I && c2 && vg(b2);
      b2.flags |= 1;
      Yi(a, b2, d2, e2);
      return b2.child;
    }
    function aj(a, b2, c2, d2, e2) {
      if (null === a) {
        var f2 = c2.type;
        if ("function" === typeof f2 && !bj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
          return b2.tag = 15, b2.type = f2, cj(a, b2, f2, d2, e2);
        a = yh(c2.type, null, d2, b2, b2.mode, e2);
        a.ref = b2.ref;
        a.return = b2;
        return b2.child = a;
      }
      f2 = a.child;
      if (0 === (a.lanes & e2)) {
        var g2 = f2.memoizedProps;
        c2 = c2.compare;
        c2 = null !== c2 ? c2 : Ie;
        if (c2(g2, d2) && a.ref === b2.ref)
          return $i(a, b2, e2);
      }
      b2.flags |= 1;
      a = wh(f2, d2);
      a.ref = b2.ref;
      a.return = b2;
      return b2.child = a;
    }
    function cj(a, b2, c2, d2, e2) {
      if (null !== a) {
        var f2 = a.memoizedProps;
        if (Ie(f2, d2) && a.ref === b2.ref)
          if (Ug = false, b2.pendingProps = d2 = f2, 0 !== (a.lanes & e2))
            0 !== (a.flags & 131072) && (Ug = true);
          else
            return b2.lanes = a.lanes, $i(a, b2, e2);
      }
      return dj(a, b2, c2, d2, e2);
    }
    function ej(a, b2, c2) {
      var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a ? a.memoizedState : null;
      if ("hidden" === d2.mode)
        if (0 === (b2.mode & 1))
          b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(fj, gj), gj |= c2;
        else {
          if (0 === (c2 & 1073741824))
            return a = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b2.updateQueue = null, G(fj, gj), gj |= a, null;
          b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
          d2 = null !== f2 ? f2.baseLanes : c2;
          G(fj, gj);
          gj |= d2;
        }
      else
        null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G(fj, gj), gj |= d2;
      Yi(a, b2, e2, c2);
      return b2.child;
    }
    function hj(a, b2) {
      var c2 = b2.ref;
      if (null === a && null !== c2 || null !== a && a.ref !== c2)
        b2.flags |= 512, b2.flags |= 2097152;
    }
    function dj(a, b2, c2, d2, e2) {
      var f2 = Zf(c2) ? Xf : H.current;
      f2 = Yf(b2, f2);
      Tg(b2, e2);
      c2 = Xh(a, b2, c2, d2, f2, e2);
      d2 = bi();
      if (null !== a && !Ug)
        return b2.updateQueue = a.updateQueue, b2.flags &= -2053, a.lanes &= ~e2, $i(a, b2, e2);
      I && d2 && vg(b2);
      b2.flags |= 1;
      Yi(a, b2, c2, e2);
      return b2.child;
    }
    function ij(a, b2, c2, d2, e2) {
      if (Zf(c2)) {
        var f2 = true;
        cg(b2);
      } else
        f2 = false;
      Tg(b2, e2);
      if (null === b2.stateNode)
        jj(a, b2), ph(b2, c2, d2), rh(b2, c2, d2, e2), d2 = true;
      else if (null === a) {
        var g2 = b2.stateNode, h2 = b2.memoizedProps;
        g2.props = h2;
        var k2 = g2.context, l2 = c2.contextType;
        "object" === typeof l2 && null !== l2 ? l2 = Vg(l2) : (l2 = Zf(c2) ? Xf : H.current, l2 = Yf(b2, l2));
        var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
        q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && qh(b2, g2, d2, l2);
        $g = false;
        var r2 = b2.memoizedState;
        g2.state = r2;
        gh(b2, d2, g2, e2);
        k2 = b2.memoizedState;
        h2 !== d2 || r2 !== k2 || Wf.current || $g ? ("function" === typeof m2 && (kh(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = $g || oh(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
      } else {
        g2 = b2.stateNode;
        bh(a, b2);
        h2 = b2.memoizedProps;
        l2 = b2.type === b2.elementType ? h2 : Lg(b2.type, h2);
        g2.props = l2;
        q2 = b2.pendingProps;
        r2 = g2.context;
        k2 = c2.contextType;
        "object" === typeof k2 && null !== k2 ? k2 = Vg(k2) : (k2 = Zf(c2) ? Xf : H.current, k2 = Yf(b2, k2));
        var y2 = c2.getDerivedStateFromProps;
        (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && qh(b2, g2, d2, k2);
        $g = false;
        r2 = b2.memoizedState;
        g2.state = r2;
        gh(b2, d2, g2, e2);
        var n2 = b2.memoizedState;
        h2 !== q2 || r2 !== n2 || Wf.current || $g ? ("function" === typeof y2 && (kh(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = $g || oh(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 1024), d2 = false);
      }
      return kj(a, b2, c2, d2, f2, e2);
    }
    function kj(a, b2, c2, d2, e2, f2) {
      hj(a, b2);
      var g2 = 0 !== (b2.flags & 128);
      if (!d2 && !g2)
        return e2 && dg(b2, c2, false), $i(a, b2, f2);
      d2 = b2.stateNode;
      Xi.current = b2;
      var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
      b2.flags |= 1;
      null !== a && g2 ? (b2.child = Bh(b2, a.child, null, f2), b2.child = Bh(b2, null, h2, f2)) : Yi(a, b2, h2, f2);
      b2.memoizedState = d2.state;
      e2 && dg(b2, c2, true);
      return b2.child;
    }
    function lj(a) {
      var b2 = a.stateNode;
      b2.pendingContext ? ag(a, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a, b2.context, false);
      Ih(a, b2.containerInfo);
    }
    function mj(a, b2, c2, d2, e2) {
      Ig();
      Jg(e2);
      b2.flags |= 256;
      Yi(a, b2, c2, d2);
      return b2.child;
    }
    var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
    function oj(a) {
      return { baseLanes: a, cachePool: null, transitions: null };
    }
    function pj(a, b2, c2) {
      var d2 = b2.pendingProps, e2 = M.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
      (h2 = g2) || (h2 = null !== a && null === a.memoizedState ? false : 0 !== (e2 & 2));
      if (h2)
        f2 = true, b2.flags &= -129;
      else if (null === a || null !== a.memoizedState)
        e2 |= 1;
      G(M, e2 & 1);
      if (null === a) {
        Eg(b2);
        a = b2.memoizedState;
        if (null !== a && (a = a.dehydrated, null !== a))
          return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
        g2 = d2.children;
        a = d2.fallback;
        return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = qj(g2, d2, 0, null), a = Ah(a, d2, c2, null), f2.return = b2, a.return = b2, f2.sibling = a, b2.child = f2, b2.child.memoizedState = oj(c2), b2.memoizedState = nj, a) : rj(b2, g2);
      }
      e2 = a.memoizedState;
      if (null !== e2 && (h2 = e2.dehydrated, null !== h2))
        return sj(a, b2, g2, d2, h2, e2, c2);
      if (f2) {
        f2 = d2.fallback;
        g2 = b2.mode;
        e2 = a.child;
        h2 = e2.sibling;
        var k2 = { mode: "hidden", children: d2.children };
        0 === (g2 & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = wh(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064);
        null !== h2 ? f2 = wh(h2, f2) : (f2 = Ah(f2, g2, c2, null), f2.flags |= 2);
        f2.return = b2;
        d2.return = b2;
        d2.sibling = f2;
        b2.child = d2;
        d2 = f2;
        f2 = b2.child;
        g2 = a.child.memoizedState;
        g2 = null === g2 ? oj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
        f2.memoizedState = g2;
        f2.childLanes = a.childLanes & ~c2;
        b2.memoizedState = nj;
        return d2;
      }
      f2 = a.child;
      a = f2.sibling;
      d2 = wh(f2, { mode: "visible", children: d2.children });
      0 === (b2.mode & 1) && (d2.lanes = c2);
      d2.return = b2;
      d2.sibling = null;
      null !== a && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a], b2.flags |= 16) : c2.push(a));
      b2.child = d2;
      b2.memoizedState = null;
      return d2;
    }
    function rj(a, b2) {
      b2 = qj({ mode: "visible", children: b2 }, a.mode, 0, null);
      b2.return = a;
      return a.child = b2;
    }
    function tj(a, b2, c2, d2) {
      null !== d2 && Jg(d2);
      Bh(b2, a.child, null, c2);
      a = rj(b2, b2.pendingProps.children);
      a.flags |= 2;
      b2.memoizedState = null;
      return a;
    }
    function sj(a, b2, c2, d2, e2, f2, g2) {
      if (c2) {
        if (b2.flags & 256)
          return b2.flags &= -257, d2 = Li(Error(p$3(422))), tj(a, b2, g2, d2);
        if (null !== b2.memoizedState)
          return b2.child = a.child, b2.flags |= 128, null;
        f2 = d2.fallback;
        e2 = b2.mode;
        d2 = qj({ mode: "visible", children: d2.children }, e2, 0, null);
        f2 = Ah(f2, e2, g2, null);
        f2.flags |= 2;
        d2.return = b2;
        f2.return = b2;
        d2.sibling = f2;
        b2.child = d2;
        0 !== (b2.mode & 1) && Bh(b2, a.child, null, g2);
        b2.child.memoizedState = oj(g2);
        b2.memoizedState = nj;
        return f2;
      }
      if (0 === (b2.mode & 1))
        return tj(a, b2, g2, null);
      if ("$!" === e2.data) {
        d2 = e2.nextSibling && e2.nextSibling.dataset;
        if (d2)
          var h2 = d2.dgst;
        d2 = h2;
        f2 = Error(p$3(419));
        d2 = Li(f2, d2, void 0);
        return tj(a, b2, g2, d2);
      }
      h2 = 0 !== (g2 & a.childLanes);
      if (Ug || h2) {
        d2 = R;
        if (null !== d2) {
          switch (g2 & -g2) {
            case 4:
              e2 = 2;
              break;
            case 16:
              e2 = 8;
              break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              e2 = 32;
              break;
            case 536870912:
              e2 = 268435456;
              break;
            default:
              e2 = 0;
          }
          e2 = 0 !== (e2 & (d2.suspendedLanes | g2)) ? 0 : e2;
          0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, Zg(a, e2), mh(d2, a, e2, -1));
        }
        uj();
        d2 = Li(Error(p$3(421)));
        return tj(a, b2, g2, d2);
      }
      if ("$?" === e2.data)
        return b2.flags |= 128, b2.child = a.child, b2 = vj.bind(null, a), e2._reactRetry = b2, null;
      a = f2.treeContext;
      yg = Lf(e2.nextSibling);
      xg = b2;
      I = true;
      zg = null;
      null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b2);
      b2 = rj(b2, d2.children);
      b2.flags |= 4096;
      return b2;
    }
    function wj(a, b2, c2) {
      a.lanes |= b2;
      var d2 = a.alternate;
      null !== d2 && (d2.lanes |= b2);
      Sg(a.return, b2, c2);
    }
    function xj(a, b2, c2, d2, e2) {
      var f2 = a.memoizedState;
      null === f2 ? a.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
    }
    function yj(a, b2, c2) {
      var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
      Yi(a, b2, d2.children, c2);
      d2 = M.current;
      if (0 !== (d2 & 2))
        d2 = d2 & 1 | 2, b2.flags |= 128;
      else {
        if (null !== a && 0 !== (a.flags & 128))
          a:
            for (a = b2.child; null !== a; ) {
              if (13 === a.tag)
                null !== a.memoizedState && wj(a, c2, b2);
              else if (19 === a.tag)
                wj(a, c2, b2);
              else if (null !== a.child) {
                a.child.return = a;
                a = a.child;
                continue;
              }
              if (a === b2)
                break a;
              for (; null === a.sibling; ) {
                if (null === a.return || a.return === b2)
                  break a;
                a = a.return;
              }
              a.sibling.return = a.return;
              a = a.sibling;
            }
        d2 &= 1;
      }
      G(M, d2);
      if (0 === (b2.mode & 1))
        b2.memoizedState = null;
      else
        switch (e2) {
          case "forwards":
            c2 = b2.child;
            for (e2 = null; null !== c2; )
              a = c2.alternate, null !== a && null === Mh(a) && (e2 = c2), c2 = c2.sibling;
            c2 = e2;
            null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
            xj(b2, false, e2, c2, f2);
            break;
          case "backwards":
            c2 = null;
            e2 = b2.child;
            for (b2.child = null; null !== e2; ) {
              a = e2.alternate;
              if (null !== a && null === Mh(a)) {
                b2.child = e2;
                break;
              }
              a = e2.sibling;
              e2.sibling = c2;
              c2 = e2;
              e2 = a;
            }
            xj(b2, true, c2, null, f2);
            break;
          case "together":
            xj(b2, false, null, null, void 0);
            break;
          default:
            b2.memoizedState = null;
        }
      return b2.child;
    }
    function jj(a, b2) {
      0 === (b2.mode & 1) && null !== a && (a.alternate = null, b2.alternate = null, b2.flags |= 2);
    }
    function $i(a, b2, c2) {
      null !== a && (b2.dependencies = a.dependencies);
      hh |= b2.lanes;
      if (0 === (c2 & b2.childLanes))
        return null;
      if (null !== a && b2.child !== a.child)
        throw Error(p$3(153));
      if (null !== b2.child) {
        a = b2.child;
        c2 = wh(a, a.pendingProps);
        b2.child = c2;
        for (c2.return = b2; null !== a.sibling; )
          a = a.sibling, c2 = c2.sibling = wh(a, a.pendingProps), c2.return = b2;
        c2.sibling = null;
      }
      return b2.child;
    }
    function zj(a, b2, c2) {
      switch (b2.tag) {
        case 3:
          lj(b2);
          Ig();
          break;
        case 5:
          Kh(b2);
          break;
        case 1:
          Zf(b2.type) && cg(b2);
          break;
        case 4:
          Ih(b2, b2.stateNode.containerInfo);
          break;
        case 10:
          var d2 = b2.type._context, e2 = b2.memoizedProps.value;
          G(Mg, d2._currentValue);
          d2._currentValue = e2;
          break;
        case 13:
          d2 = b2.memoizedState;
          if (null !== d2) {
            if (null !== d2.dehydrated)
              return G(M, M.current & 1), b2.flags |= 128, null;
            if (0 !== (c2 & b2.child.childLanes))
              return pj(a, b2, c2);
            G(M, M.current & 1);
            a = $i(a, b2, c2);
            return null !== a ? a.sibling : null;
          }
          G(M, M.current & 1);
          break;
        case 19:
          d2 = 0 !== (c2 & b2.childLanes);
          if (0 !== (a.flags & 128)) {
            if (d2)
              return yj(a, b2, c2);
            b2.flags |= 128;
          }
          e2 = b2.memoizedState;
          null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
          G(M, M.current);
          if (d2)
            break;
          else
            return null;
        case 22:
        case 23:
          return b2.lanes = 0, ej(a, b2, c2);
      }
      return $i(a, b2, c2);
    }
    var Aj, Bj, Cj, Dj;
    Aj = function(a, b2) {
      for (var c2 = b2.child; null !== c2; ) {
        if (5 === c2.tag || 6 === c2.tag)
          a.appendChild(c2.stateNode);
        else if (4 !== c2.tag && null !== c2.child) {
          c2.child.return = c2;
          c2 = c2.child;
          continue;
        }
        if (c2 === b2)
          break;
        for (; null === c2.sibling; ) {
          if (null === c2.return || c2.return === b2)
            return;
          c2 = c2.return;
        }
        c2.sibling.return = c2.return;
        c2 = c2.sibling;
      }
    };
    Bj = function() {
    };
    Cj = function(a, b2, c2, d2) {
      var e2 = a.memoizedProps;
      if (e2 !== d2) {
        a = b2.stateNode;
        Hh(Eh.current);
        var f2 = null;
        switch (c2) {
          case "input":
            e2 = Ya(a, e2);
            d2 = Ya(a, d2);
            f2 = [];
            break;
          case "select":
            e2 = A$1({}, e2, { value: void 0 });
            d2 = A$1({}, d2, { value: void 0 });
            f2 = [];
            break;
          case "textarea":
            e2 = gb(a, e2);
            d2 = gb(a, d2);
            f2 = [];
            break;
          default:
            "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a.onclick = Bf);
        }
        ub(c2, d2);
        var g2;
        c2 = null;
        for (l2 in e2)
          if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2])
            if ("style" === l2) {
              var h2 = e2[l2];
              for (g2 in h2)
                h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
            } else
              "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
        for (l2 in d2) {
          var k2 = d2[l2];
          h2 = null != e2 ? e2[l2] : void 0;
          if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
            if ("style" === l2)
              if (h2) {
                for (g2 in h2)
                  !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
                for (g2 in k2)
                  k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
              } else
                c2 || (f2 || (f2 = []), f2.push(
                  l2,
                  c2
                )), c2 = k2;
            else
              "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D("scroll", a), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
        }
        c2 && (f2 = f2 || []).push("style", c2);
        var l2 = f2;
        if (b2.updateQueue = l2)
          b2.flags |= 4;
      }
    };
    Dj = function(a, b2, c2, d2) {
      c2 !== d2 && (b2.flags |= 4);
    };
    function Ej(a, b2) {
      if (!I)
        switch (a.tailMode) {
          case "hidden":
            b2 = a.tail;
            for (var c2 = null; null !== b2; )
              null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
            null === c2 ? a.tail = null : c2.sibling = null;
            break;
          case "collapsed":
            c2 = a.tail;
            for (var d2 = null; null !== c2; )
              null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
            null === d2 ? b2 || null === a.tail ? a.tail = null : a.tail.sibling = null : d2.sibling = null;
        }
    }
    function S(a) {
      var b2 = null !== a.alternate && a.alternate.child === a.child, c2 = 0, d2 = 0;
      if (b2)
        for (var e2 = a.child; null !== e2; )
          c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a, e2 = e2.sibling;
      else
        for (e2 = a.child; null !== e2; )
          c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a, e2 = e2.sibling;
      a.subtreeFlags |= d2;
      a.childLanes = c2;
      return b2;
    }
    function Fj(a, b2, c2) {
      var d2 = b2.pendingProps;
      wg(b2);
      switch (b2.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return S(b2), null;
        case 1:
          return Zf(b2.type) && $f(), S(b2), null;
        case 3:
          d2 = b2.stateNode;
          Jh();
          E(Wf);
          E(H);
          Oh();
          d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
          if (null === a || null === a.child)
            Gg(b2) ? b2.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Gj(zg), zg = null));
          Bj(a, b2);
          S(b2);
          return null;
        case 5:
          Lh(b2);
          var e2 = Hh(Gh.current);
          c2 = b2.type;
          if (null !== a && null != b2.stateNode)
            Cj(a, b2, c2, d2, e2), a.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
          else {
            if (!d2) {
              if (null === b2.stateNode)
                throw Error(p$3(166));
              S(b2);
              return null;
            }
            a = Hh(Eh.current);
            if (Gg(b2)) {
              d2 = b2.stateNode;
              c2 = b2.type;
              var f2 = b2.memoizedProps;
              d2[Of] = b2;
              d2[Pf] = f2;
              a = 0 !== (b2.mode & 1);
              switch (c2) {
                case "dialog":
                  D("cancel", d2);
                  D("close", d2);
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D("load", d2);
                  break;
                case "video":
                case "audio":
                  for (e2 = 0; e2 < lf.length; e2++)
                    D(lf[e2], d2);
                  break;
                case "source":
                  D("error", d2);
                  break;
                case "img":
                case "image":
                case "link":
                  D(
                    "error",
                    d2
                  );
                  D("load", d2);
                  break;
                case "details":
                  D("toggle", d2);
                  break;
                case "input":
                  Za(d2, f2);
                  D("invalid", d2);
                  break;
                case "select":
                  d2._wrapperState = { wasMultiple: !!f2.multiple };
                  D("invalid", d2);
                  break;
                case "textarea":
                  hb(d2, f2), D("invalid", d2);
              }
              ub(c2, f2);
              e2 = null;
              for (var g2 in f2)
                if (f2.hasOwnProperty(g2)) {
                  var h2 = f2[g2];
                  "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                    d2.textContent,
                    h2,
                    a
                  ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D("scroll", d2);
                }
              switch (c2) {
                case "input":
                  Va(d2);
                  db(d2, f2, true);
                  break;
                case "textarea":
                  Va(d2);
                  jb(d2);
                  break;
                case "select":
                case "option":
                  break;
                default:
                  "function" === typeof f2.onClick && (d2.onclick = Bf);
              }
              d2 = e2;
              b2.updateQueue = d2;
              null !== d2 && (b2.flags |= 4);
            } else {
              g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
              "http://www.w3.org/1999/xhtml" === a && (a = kb(c2));
              "http://www.w3.org/1999/xhtml" === a ? "script" === c2 ? (a = g2.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d2.is ? a = g2.createElement(c2, { is: d2.is }) : (a = g2.createElement(c2), "select" === c2 && (g2 = a, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a = g2.createElementNS(a, c2);
              a[Of] = b2;
              a[Pf] = d2;
              Aj(a, b2, false, false);
              b2.stateNode = a;
              a: {
                g2 = vb(c2, d2);
                switch (c2) {
                  case "dialog":
                    D("cancel", a);
                    D("close", a);
                    e2 = d2;
                    break;
                  case "iframe":
                  case "object":
                  case "embed":
                    D("load", a);
                    e2 = d2;
                    break;
                  case "video":
                  case "audio":
                    for (e2 = 0; e2 < lf.length; e2++)
                      D(lf[e2], a);
                    e2 = d2;
                    break;
                  case "source":
                    D("error", a);
                    e2 = d2;
                    break;
                  case "img":
                  case "image":
                  case "link":
                    D(
                      "error",
                      a
                    );
                    D("load", a);
                    e2 = d2;
                    break;
                  case "details":
                    D("toggle", a);
                    e2 = d2;
                    break;
                  case "input":
                    Za(a, d2);
                    e2 = Ya(a, d2);
                    D("invalid", a);
                    break;
                  case "option":
                    e2 = d2;
                    break;
                  case "select":
                    a._wrapperState = { wasMultiple: !!d2.multiple };
                    e2 = A$1({}, d2, { value: void 0 });
                    D("invalid", a);
                    break;
                  case "textarea":
                    hb(a, d2);
                    e2 = gb(a, d2);
                    D("invalid", a);
                    break;
                  default:
                    e2 = d2;
                }
                ub(c2, e2);
                h2 = e2;
                for (f2 in h2)
                  if (h2.hasOwnProperty(f2)) {
                    var k2 = h2[f2];
                    "style" === f2 ? sb(a, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a, k2) : "number" === typeof k2 && ob(a, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D("scroll", a) : null != k2 && ta(a, f2, k2, g2));
                  }
                switch (c2) {
                  case "input":
                    Va(a);
                    db(a, d2, false);
                    break;
                  case "textarea":
                    Va(a);
                    jb(a);
                    break;
                  case "option":
                    null != d2.value && a.setAttribute("value", "" + Sa(d2.value));
                    break;
                  case "select":
                    a.multiple = !!d2.multiple;
                    f2 = d2.value;
                    null != f2 ? fb(a, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                      a,
                      !!d2.multiple,
                      d2.defaultValue,
                      true
                    );
                    break;
                  default:
                    "function" === typeof e2.onClick && (a.onclick = Bf);
                }
                switch (c2) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    d2 = !!d2.autoFocus;
                    break a;
                  case "img":
                    d2 = true;
                    break a;
                  default:
                    d2 = false;
                }
              }
              d2 && (b2.flags |= 4);
            }
            null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
          }
          S(b2);
          return null;
        case 6:
          if (a && null != b2.stateNode)
            Dj(a, b2, a.memoizedProps, d2);
          else {
            if ("string" !== typeof d2 && null === b2.stateNode)
              throw Error(p$3(166));
            c2 = Hh(Gh.current);
            Hh(Eh.current);
            if (Gg(b2)) {
              d2 = b2.stateNode;
              c2 = b2.memoizedProps;
              d2[Of] = b2;
              if (f2 = d2.nodeValue !== c2) {
                if (a = xg, null !== a)
                  switch (a.tag) {
                    case 3:
                      Af(d2.nodeValue, c2, 0 !== (a.mode & 1));
                      break;
                    case 5:
                      true !== a.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a.mode & 1));
                  }
              }
              f2 && (b2.flags |= 4);
            } else
              d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
          }
          S(b2);
          return null;
        case 13:
          E(M);
          d2 = b2.memoizedState;
          if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
            if (I && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128))
              Hg(), Ig(), b2.flags |= 98560, f2 = false;
            else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
              if (null === a) {
                if (!f2)
                  throw Error(p$3(318));
                f2 = b2.memoizedState;
                f2 = null !== f2 ? f2.dehydrated : null;
                if (!f2)
                  throw Error(p$3(317));
                f2[Of] = b2;
              } else
                Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
              S(b2);
              f2 = false;
            } else
              null !== zg && (Gj(zg), zg = null), f2 = true;
            if (!f2)
              return b2.flags & 65536 ? b2 : null;
          }
          if (0 !== (b2.flags & 128))
            return b2.lanes = c2, b2;
          d2 = null !== d2;
          d2 !== (null !== a && null !== a.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a || 0 !== (M.current & 1) ? 0 === T && (T = 3) : uj()));
          null !== b2.updateQueue && (b2.flags |= 4);
          S(b2);
          return null;
        case 4:
          return Jh(), Bj(a, b2), null === a && sf(b2.stateNode.containerInfo), S(b2), null;
        case 10:
          return Rg(b2.type._context), S(b2), null;
        case 17:
          return Zf(b2.type) && $f(), S(b2), null;
        case 19:
          E(M);
          f2 = b2.memoizedState;
          if (null === f2)
            return S(b2), null;
          d2 = 0 !== (b2.flags & 128);
          g2 = f2.rendering;
          if (null === g2)
            if (d2)
              Ej(f2, false);
            else {
              if (0 !== T || null !== a && 0 !== (a.flags & 128))
                for (a = b2.child; null !== a; ) {
                  g2 = Mh(a);
                  if (null !== g2) {
                    b2.flags |= 128;
                    Ej(f2, false);
                    d2 = g2.updateQueue;
                    null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
                    b2.subtreeFlags = 0;
                    d2 = c2;
                    for (c2 = b2.child; null !== c2; )
                      f2 = c2, a = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a = g2.dependencies, f2.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c2 = c2.sibling;
                    G(M, M.current & 1 | 2);
                    return b2.child;
                  }
                  a = a.sibling;
                }
              null !== f2.tail && B() > Hj && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
            }
          else {
            if (!d2)
              if (a = Mh(g2), null !== a) {
                if (b2.flags |= 128, d2 = true, c2 = a.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Ej(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I)
                  return S(b2), null;
              } else
                2 * B() - f2.renderingStartTime > Hj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
            f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
          }
          if (null !== f2.tail)
            return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B(), b2.sibling = null, c2 = M.current, G(M, d2 ? c2 & 1 | 2 : c2 & 1), b2;
          S(b2);
          return null;
        case 22:
        case 23:
          return Ij(), d2 = null !== b2.memoizedState, null !== a && null !== a.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (gj & 1073741824) && (S(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S(b2), null;
        case 24:
          return null;
        case 25:
          return null;
      }
      throw Error(p$3(156, b2.tag));
    }
    function Jj(a, b2) {
      wg(b2);
      switch (b2.tag) {
        case 1:
          return Zf(b2.type) && $f(), a = b2.flags, a & 65536 ? (b2.flags = a & -65537 | 128, b2) : null;
        case 3:
          return Jh(), E(Wf), E(H), Oh(), a = b2.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b2.flags = a & -65537 | 128, b2) : null;
        case 5:
          return Lh(b2), null;
        case 13:
          E(M);
          a = b2.memoizedState;
          if (null !== a && null !== a.dehydrated) {
            if (null === b2.alternate)
              throw Error(p$3(340));
            Ig();
          }
          a = b2.flags;
          return a & 65536 ? (b2.flags = a & -65537 | 128, b2) : null;
        case 19:
          return E(M), null;
        case 4:
          return Jh(), null;
        case 10:
          return Rg(b2.type._context), null;
        case 22:
        case 23:
          return Ij(), null;
        case 24:
          return null;
        default:
          return null;
      }
    }
    var Kj = false, U = false, Lj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
    function Mj(a, b2) {
      var c2 = a.ref;
      if (null !== c2)
        if ("function" === typeof c2)
          try {
            c2(null);
          } catch (d2) {
            W(a, b2, d2);
          }
        else
          c2.current = null;
    }
    function Nj(a, b2, c2) {
      try {
        c2();
      } catch (d2) {
        W(a, b2, d2);
      }
    }
    var Oj = false;
    function Pj(a, b2) {
      Cf = dd;
      a = Me();
      if (Ne(a)) {
        if ("selectionStart" in a)
          var c2 = { start: a.selectionStart, end: a.selectionEnd };
        else
          a: {
            c2 = (c2 = a.ownerDocument) && c2.defaultView || window;
            var d2 = c2.getSelection && c2.getSelection();
            if (d2 && 0 !== d2.rangeCount) {
              c2 = d2.anchorNode;
              var e2 = d2.anchorOffset, f2 = d2.focusNode;
              d2 = d2.focusOffset;
              try {
                c2.nodeType, f2.nodeType;
              } catch (F2) {
                c2 = null;
                break a;
              }
              var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a, r2 = null;
              b:
                for (; ; ) {
                  for (var y2; ; ) {
                    q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h2 = g2 + e2);
                    q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
                    3 === q2.nodeType && (g2 += q2.nodeValue.length);
                    if (null === (y2 = q2.firstChild))
                      break;
                    r2 = q2;
                    q2 = y2;
                  }
                  for (; ; ) {
                    if (q2 === a)
                      break b;
                    r2 === c2 && ++l2 === e2 && (h2 = g2);
                    r2 === f2 && ++m2 === d2 && (k2 = g2);
                    if (null !== (y2 = q2.nextSibling))
                      break;
                    q2 = r2;
                    r2 = q2.parentNode;
                  }
                  q2 = y2;
                }
              c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
            } else
              c2 = null;
          }
        c2 = c2 || { start: 0, end: 0 };
      } else
        c2 = null;
      Df = { focusedElem: a, selectionRange: c2 };
      dd = false;
      for (V = b2; null !== V; )
        if (b2 = V, a = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a)
          a.return = b2, V = a;
        else
          for (; null !== V; ) {
            b2 = V;
            try {
              var n2 = b2.alternate;
              if (0 !== (b2.flags & 1024))
                switch (b2.tag) {
                  case 0:
                  case 11:
                  case 15:
                    break;
                  case 1:
                    if (null !== n2) {
                      var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Lg(b2.type, t2), J2);
                      x2.__reactInternalSnapshotBeforeUpdate = w2;
                    }
                    break;
                  case 3:
                    var u2 = b2.stateNode.containerInfo;
                    1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                    break;
                  case 5:
                  case 6:
                  case 4:
                  case 17:
                    break;
                  default:
                    throw Error(p$3(163));
                }
            } catch (F2) {
              W(b2, b2.return, F2);
            }
            a = b2.sibling;
            if (null !== a) {
              a.return = b2.return;
              V = a;
              break;
            }
            V = b2.return;
          }
      n2 = Oj;
      Oj = false;
      return n2;
    }
    function Qj(a, b2, c2) {
      var d2 = b2.updateQueue;
      d2 = null !== d2 ? d2.lastEffect : null;
      if (null !== d2) {
        var e2 = d2 = d2.next;
        do {
          if ((e2.tag & a) === a) {
            var f2 = e2.destroy;
            e2.destroy = void 0;
            void 0 !== f2 && Nj(b2, c2, f2);
          }
          e2 = e2.next;
        } while (e2 !== d2);
      }
    }
    function Rj(a, b2) {
      b2 = b2.updateQueue;
      b2 = null !== b2 ? b2.lastEffect : null;
      if (null !== b2) {
        var c2 = b2 = b2.next;
        do {
          if ((c2.tag & a) === a) {
            var d2 = c2.create;
            c2.destroy = d2();
          }
          c2 = c2.next;
        } while (c2 !== b2);
      }
    }
    function Sj(a) {
      var b2 = a.ref;
      if (null !== b2) {
        var c2 = a.stateNode;
        switch (a.tag) {
          case 5:
            a = c2;
            break;
          default:
            a = c2;
        }
        "function" === typeof b2 ? b2(a) : b2.current = a;
      }
    }
    function Tj(a) {
      var b2 = a.alternate;
      null !== b2 && (a.alternate = null, Tj(b2));
      a.child = null;
      a.deletions = null;
      a.sibling = null;
      5 === a.tag && (b2 = a.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
      a.stateNode = null;
      a.return = null;
      a.dependencies = null;
      a.memoizedProps = null;
      a.memoizedState = null;
      a.pendingProps = null;
      a.stateNode = null;
      a.updateQueue = null;
    }
    function Uj(a) {
      return 5 === a.tag || 3 === a.tag || 4 === a.tag;
    }
    function Vj(a) {
      a:
        for (; ; ) {
          for (; null === a.sibling; ) {
            if (null === a.return || Uj(a.return))
              return null;
            a = a.return;
          }
          a.sibling.return = a.return;
          for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
            if (a.flags & 2)
              continue a;
            if (null === a.child || 4 === a.tag)
              continue a;
            else
              a.child.return = a, a = a.child;
          }
          if (!(a.flags & 2))
            return a.stateNode;
        }
    }
    function Wj(a, b2, c2) {
      var d2 = a.tag;
      if (5 === d2 || 6 === d2)
        a = a.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a, b2) : c2.insertBefore(a, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a, c2)) : (b2 = c2, b2.appendChild(a)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
      else if (4 !== d2 && (a = a.child, null !== a))
        for (Wj(a, b2, c2), a = a.sibling; null !== a; )
          Wj(a, b2, c2), a = a.sibling;
    }
    function Xj(a, b2, c2) {
      var d2 = a.tag;
      if (5 === d2 || 6 === d2)
        a = a.stateNode, b2 ? c2.insertBefore(a, b2) : c2.appendChild(a);
      else if (4 !== d2 && (a = a.child, null !== a))
        for (Xj(a, b2, c2), a = a.sibling; null !== a; )
          Xj(a, b2, c2), a = a.sibling;
    }
    var X = null, Yj = false;
    function Zj(a, b2, c2) {
      for (c2 = c2.child; null !== c2; )
        ak(a, b2, c2), c2 = c2.sibling;
    }
    function ak(a, b2, c2) {
      if (lc && "function" === typeof lc.onCommitFiberUnmount)
        try {
          lc.onCommitFiberUnmount(kc, c2);
        } catch (h2) {
        }
      switch (c2.tag) {
        case 5:
          U || Mj(c2, b2);
        case 6:
          var d2 = X, e2 = Yj;
          X = null;
          Zj(a, b2, c2);
          X = d2;
          Yj = e2;
          null !== X && (Yj ? (a = X, c2 = c2.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c2) : a.removeChild(c2)) : X.removeChild(c2.stateNode));
          break;
        case 18:
          null !== X && (Yj ? (a = X, c2 = c2.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c2) : 1 === a.nodeType && Kf(a, c2), bd(a)) : Kf(X, c2.stateNode));
          break;
        case 4:
          d2 = X;
          e2 = Yj;
          X = c2.stateNode.containerInfo;
          Yj = true;
          Zj(a, b2, c2);
          X = d2;
          Yj = e2;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          if (!U && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
            e2 = d2 = d2.next;
            do {
              var f2 = e2, g2 = f2.destroy;
              f2 = f2.tag;
              void 0 !== g2 && (0 !== (f2 & 2) ? Nj(c2, b2, g2) : 0 !== (f2 & 4) && Nj(c2, b2, g2));
              e2 = e2.next;
            } while (e2 !== d2);
          }
          Zj(a, b2, c2);
          break;
        case 1:
          if (!U && (Mj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount))
            try {
              d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
            } catch (h2) {
              W(c2, b2, h2);
            }
          Zj(a, b2, c2);
          break;
        case 21:
          Zj(a, b2, c2);
          break;
        case 22:
          c2.mode & 1 ? (U = (d2 = U) || null !== c2.memoizedState, Zj(a, b2, c2), U = d2) : Zj(a, b2, c2);
          break;
        default:
          Zj(a, b2, c2);
      }
    }
    function bk(a) {
      var b2 = a.updateQueue;
      if (null !== b2) {
        a.updateQueue = null;
        var c2 = a.stateNode;
        null === c2 && (c2 = a.stateNode = new Lj());
        b2.forEach(function(b3) {
          var d2 = ck.bind(null, a, b3);
          c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
        });
      }
    }
    function dk(a, b2) {
      var c2 = b2.deletions;
      if (null !== c2)
        for (var d2 = 0; d2 < c2.length; d2++) {
          var e2 = c2[d2];
          try {
            var f2 = a, g2 = b2, h2 = g2;
            a:
              for (; null !== h2; ) {
                switch (h2.tag) {
                  case 5:
                    X = h2.stateNode;
                    Yj = false;
                    break a;
                  case 3:
                    X = h2.stateNode.containerInfo;
                    Yj = true;
                    break a;
                  case 4:
                    X = h2.stateNode.containerInfo;
                    Yj = true;
                    break a;
                }
                h2 = h2.return;
              }
            if (null === X)
              throw Error(p$3(160));
            ak(f2, g2, e2);
            X = null;
            Yj = false;
            var k2 = e2.alternate;
            null !== k2 && (k2.return = null);
            e2.return = null;
          } catch (l2) {
            W(e2, b2, l2);
          }
        }
      if (b2.subtreeFlags & 12854)
        for (b2 = b2.child; null !== b2; )
          ek(b2, a), b2 = b2.sibling;
    }
    function ek(a, b2) {
      var c2 = a.alternate, d2 = a.flags;
      switch (a.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          dk(b2, a);
          fk(a);
          if (d2 & 4) {
            try {
              Qj(3, a, a.return), Rj(3, a);
            } catch (t2) {
              W(a, a.return, t2);
            }
            try {
              Qj(5, a, a.return);
            } catch (t2) {
              W(a, a.return, t2);
            }
          }
          break;
        case 1:
          dk(b2, a);
          fk(a);
          d2 & 512 && null !== c2 && Mj(c2, c2.return);
          break;
        case 5:
          dk(b2, a);
          fk(a);
          d2 & 512 && null !== c2 && Mj(c2, c2.return);
          if (a.flags & 32) {
            var e2 = a.stateNode;
            try {
              ob(e2, "");
            } catch (t2) {
              W(a, a.return, t2);
            }
          }
          if (d2 & 4 && (e2 = a.stateNode, null != e2)) {
            var f2 = a.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a.type, k2 = a.updateQueue;
            a.updateQueue = null;
            if (null !== k2)
              try {
                "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
                vb(h2, g2);
                var l2 = vb(h2, f2);
                for (g2 = 0; g2 < k2.length; g2 += 2) {
                  var m2 = k2[g2], q2 = k2[g2 + 1];
                  "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
                }
                switch (h2) {
                  case "input":
                    bb(e2, f2);
                    break;
                  case "textarea":
                    ib(e2, f2);
                    break;
                  case "select":
                    var r2 = e2._wrapperState.wasMultiple;
                    e2._wrapperState.wasMultiple = !!f2.multiple;
                    var y2 = f2.value;
                    null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                      e2,
                      !!f2.multiple,
                      f2.defaultValue,
                      true
                    ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
                }
                e2[Pf] = f2;
              } catch (t2) {
                W(a, a.return, t2);
              }
          }
          break;
        case 6:
          dk(b2, a);
          fk(a);
          if (d2 & 4) {
            if (null === a.stateNode)
              throw Error(p$3(162));
            e2 = a.stateNode;
            f2 = a.memoizedProps;
            try {
              e2.nodeValue = f2;
            } catch (t2) {
              W(a, a.return, t2);
            }
          }
          break;
        case 3:
          dk(b2, a);
          fk(a);
          if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated)
            try {
              bd(b2.containerInfo);
            } catch (t2) {
              W(a, a.return, t2);
            }
          break;
        case 4:
          dk(b2, a);
          fk(a);
          break;
        case 13:
          dk(b2, a);
          fk(a);
          e2 = a.child;
          e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (gk = B()));
          d2 & 4 && bk(a);
          break;
        case 22:
          m2 = null !== c2 && null !== c2.memoizedState;
          a.mode & 1 ? (U = (l2 = U) || m2, dk(b2, a), U = l2) : dk(b2, a);
          fk(a);
          if (d2 & 8192) {
            l2 = null !== a.memoizedState;
            if ((a.stateNode.isHidden = l2) && !m2 && 0 !== (a.mode & 1))
              for (V = a, m2 = a.child; null !== m2; ) {
                for (q2 = V = m2; null !== V; ) {
                  r2 = V;
                  y2 = r2.child;
                  switch (r2.tag) {
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                      Qj(4, r2, r2.return);
                      break;
                    case 1:
                      Mj(r2, r2.return);
                      var n2 = r2.stateNode;
                      if ("function" === typeof n2.componentWillUnmount) {
                        d2 = r2;
                        c2 = r2.return;
                        try {
                          b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                        } catch (t2) {
                          W(d2, c2, t2);
                        }
                      }
                      break;
                    case 5:
                      Mj(r2, r2.return);
                      break;
                    case 22:
                      if (null !== r2.memoizedState) {
                        hk(q2);
                        continue;
                      }
                  }
                  null !== y2 ? (y2.return = r2, V = y2) : hk(q2);
                }
                m2 = m2.sibling;
              }
            a:
              for (m2 = null, q2 = a; ; ) {
                if (5 === q2.tag) {
                  if (null === m2) {
                    m2 = q2;
                    try {
                      e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                    } catch (t2) {
                      W(a, a.return, t2);
                    }
                  }
                } else if (6 === q2.tag) {
                  if (null === m2)
                    try {
                      q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                    } catch (t2) {
                      W(a, a.return, t2);
                    }
                } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a) && null !== q2.child) {
                  q2.child.return = q2;
                  q2 = q2.child;
                  continue;
                }
                if (q2 === a)
                  break a;
                for (; null === q2.sibling; ) {
                  if (null === q2.return || q2.return === a)
                    break a;
                  m2 === q2 && (m2 = null);
                  q2 = q2.return;
                }
                m2 === q2 && (m2 = null);
                q2.sibling.return = q2.return;
                q2 = q2.sibling;
              }
          }
          break;
        case 19:
          dk(b2, a);
          fk(a);
          d2 & 4 && bk(a);
          break;
        case 21:
          break;
        default:
          dk(
            b2,
            a
          ), fk(a);
      }
    }
    function fk(a) {
      var b2 = a.flags;
      if (b2 & 2) {
        try {
          a: {
            for (var c2 = a.return; null !== c2; ) {
              if (Uj(c2)) {
                var d2 = c2;
                break a;
              }
              c2 = c2.return;
            }
            throw Error(p$3(160));
          }
          switch (d2.tag) {
            case 5:
              var e2 = d2.stateNode;
              d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
              var f2 = Vj(a);
              Xj(a, f2, e2);
              break;
            case 3:
            case 4:
              var g2 = d2.stateNode.containerInfo, h2 = Vj(a);
              Wj(a, h2, g2);
              break;
            default:
              throw Error(p$3(161));
          }
        } catch (k2) {
          W(a, a.return, k2);
        }
        a.flags &= -3;
      }
      b2 & 4096 && (a.flags &= -4097);
    }
    function ik(a, b2, c2) {
      V = a;
      jk(a);
    }
    function jk(a, b2, c2) {
      for (var d2 = 0 !== (a.mode & 1); null !== V; ) {
        var e2 = V, f2 = e2.child;
        if (22 === e2.tag && d2) {
          var g2 = null !== e2.memoizedState || Kj;
          if (!g2) {
            var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U;
            h2 = Kj;
            var l2 = U;
            Kj = g2;
            if ((U = k2) && !l2)
              for (V = e2; null !== V; )
                g2 = V, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? kk(e2) : null !== k2 ? (k2.return = g2, V = k2) : kk(e2);
            for (; null !== f2; )
              V = f2, jk(f2), f2 = f2.sibling;
            V = e2;
            Kj = h2;
            U = l2;
          }
          lk(a);
        } else
          0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V = f2) : lk(a);
      }
    }
    function lk(a) {
      for (; null !== V; ) {
        var b2 = V;
        if (0 !== (b2.flags & 8772)) {
          var c2 = b2.alternate;
          try {
            if (0 !== (b2.flags & 8772))
              switch (b2.tag) {
                case 0:
                case 11:
                case 15:
                  U || Rj(5, b2);
                  break;
                case 1:
                  var d2 = b2.stateNode;
                  if (b2.flags & 4 && !U)
                    if (null === c2)
                      d2.componentDidMount();
                    else {
                      var e2 = b2.elementType === b2.type ? c2.memoizedProps : Lg(b2.type, c2.memoizedProps);
                      d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                    }
                  var f2 = b2.updateQueue;
                  null !== f2 && ih(b2, f2, d2);
                  break;
                case 3:
                  var g2 = b2.updateQueue;
                  if (null !== g2) {
                    c2 = null;
                    if (null !== b2.child)
                      switch (b2.child.tag) {
                        case 5:
                          c2 = b2.child.stateNode;
                          break;
                        case 1:
                          c2 = b2.child.stateNode;
                      }
                    ih(b2, g2, c2);
                  }
                  break;
                case 5:
                  var h2 = b2.stateNode;
                  if (null === c2 && b2.flags & 4) {
                    c2 = h2;
                    var k2 = b2.memoizedProps;
                    switch (b2.type) {
                      case "button":
                      case "input":
                      case "select":
                      case "textarea":
                        k2.autoFocus && c2.focus();
                        break;
                      case "img":
                        k2.src && (c2.src = k2.src);
                    }
                  }
                  break;
                case 6:
                  break;
                case 4:
                  break;
                case 12:
                  break;
                case 13:
                  if (null === b2.memoizedState) {
                    var l2 = b2.alternate;
                    if (null !== l2) {
                      var m2 = l2.memoizedState;
                      if (null !== m2) {
                        var q2 = m2.dehydrated;
                        null !== q2 && bd(q2);
                      }
                    }
                  }
                  break;
                case 19:
                case 17:
                case 21:
                case 22:
                case 23:
                case 25:
                  break;
                default:
                  throw Error(p$3(163));
              }
            U || b2.flags & 512 && Sj(b2);
          } catch (r2) {
            W(b2, b2.return, r2);
          }
        }
        if (b2 === a) {
          V = null;
          break;
        }
        c2 = b2.sibling;
        if (null !== c2) {
          c2.return = b2.return;
          V = c2;
          break;
        }
        V = b2.return;
      }
    }
    function hk(a) {
      for (; null !== V; ) {
        var b2 = V;
        if (b2 === a) {
          V = null;
          break;
        }
        var c2 = b2.sibling;
        if (null !== c2) {
          c2.return = b2.return;
          V = c2;
          break;
        }
        V = b2.return;
      }
    }
    function kk(a) {
      for (; null !== V; ) {
        var b2 = V;
        try {
          switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              var c2 = b2.return;
              try {
                Rj(4, b2);
              } catch (k2) {
                W(b2, c2, k2);
              }
              break;
            case 1:
              var d2 = b2.stateNode;
              if ("function" === typeof d2.componentDidMount) {
                var e2 = b2.return;
                try {
                  d2.componentDidMount();
                } catch (k2) {
                  W(b2, e2, k2);
                }
              }
              var f2 = b2.return;
              try {
                Sj(b2);
              } catch (k2) {
                W(b2, f2, k2);
              }
              break;
            case 5:
              var g2 = b2.return;
              try {
                Sj(b2);
              } catch (k2) {
                W(b2, g2, k2);
              }
          }
        } catch (k2) {
          W(b2, b2.return, k2);
        }
        if (b2 === a) {
          V = null;
          break;
        }
        var h2 = b2.sibling;
        if (null !== h2) {
          h2.return = b2.return;
          V = h2;
          break;
        }
        V = b2.return;
      }
    }
    var mk = Math.ceil, nk = ua.ReactCurrentDispatcher, ok = ua.ReactCurrentOwner, pk = ua.ReactCurrentBatchConfig, K = 0, R = null, Y = null, Z = 0, gj = 0, fj = Uf(0), T = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = Infinity, vk = null, Pi = false, Qi = null, Si = null, wk = false, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
    function L() {
      return 0 !== (K & 6) ? B() : -1 !== Bk ? Bk : Bk = B();
    }
    function lh(a) {
      if (0 === (a.mode & 1))
        return 1;
      if (0 !== (K & 2) && 0 !== Z)
        return Z & -Z;
      if (null !== Kg.transition)
        return 0 === Ck && (Ck = yc()), Ck;
      a = C;
      if (0 !== a)
        return a;
      a = window.event;
      a = void 0 === a ? 16 : jd(a.type);
      return a;
    }
    function mh(a, b2, c2, d2) {
      if (50 < zk)
        throw zk = 0, Ak = null, Error(p$3(185));
      Ac(a, c2, d2);
      if (0 === (K & 2) || a !== R)
        a === R && (0 === (K & 2) && (rk |= c2), 4 === T && Dk(a, Z)), Ek(a, d2), 1 === c2 && 0 === K && 0 === (b2.mode & 1) && (Hj = B() + 500, fg && jg());
    }
    function Ek(a, b2) {
      var c2 = a.callbackNode;
      wc(a, b2);
      var d2 = uc(a, a === R ? Z : 0);
      if (0 === d2)
        null !== c2 && bc(c2), a.callbackNode = null, a.callbackPriority = 0;
      else if (b2 = d2 & -d2, a.callbackPriority !== b2) {
        null != c2 && bc(c2);
        if (1 === b2)
          0 === a.tag ? ig(Fk.bind(null, a)) : hg(Fk.bind(null, a)), Jf(function() {
            0 === (K & 6) && jg();
          }), c2 = null;
        else {
          switch (Dc(d2)) {
            case 1:
              c2 = fc;
              break;
            case 4:
              c2 = gc;
              break;
            case 16:
              c2 = hc;
              break;
            case 536870912:
              c2 = jc;
              break;
            default:
              c2 = hc;
          }
          c2 = Gk(c2, Hk.bind(null, a));
        }
        a.callbackPriority = b2;
        a.callbackNode = c2;
      }
    }
    function Hk(a, b2) {
      Bk = -1;
      Ck = 0;
      if (0 !== (K & 6))
        throw Error(p$3(327));
      var c2 = a.callbackNode;
      if (Ik() && a.callbackNode !== c2)
        return null;
      var d2 = uc(a, a === R ? Z : 0);
      if (0 === d2)
        return null;
      if (0 !== (d2 & 30) || 0 !== (d2 & a.expiredLanes) || b2)
        b2 = Jk(a, d2);
      else {
        b2 = d2;
        var e2 = K;
        K |= 2;
        var f2 = Kk();
        if (R !== a || Z !== b2)
          vk = null, Hj = B() + 500, Lk(a, b2);
        do
          try {
            Mk();
            break;
          } catch (h2) {
            Nk(a, h2);
          }
        while (1);
        Qg();
        nk.current = f2;
        K = e2;
        null !== Y ? b2 = 0 : (R = null, Z = 0, b2 = T);
      }
      if (0 !== b2) {
        2 === b2 && (e2 = xc(a), 0 !== e2 && (d2 = e2, b2 = Ok(a, e2)));
        if (1 === b2)
          throw c2 = qk, Lk(a, 0), Dk(a, d2), Ek(a, B()), c2;
        if (6 === b2)
          Dk(a, d2);
        else {
          e2 = a.current.alternate;
          if (0 === (d2 & 30) && !Pk(e2) && (b2 = Jk(a, d2), 2 === b2 && (f2 = xc(a), 0 !== f2 && (d2 = f2, b2 = Ok(a, f2))), 1 === b2))
            throw c2 = qk, Lk(a, 0), Dk(a, d2), Ek(a, B()), c2;
          a.finishedWork = e2;
          a.finishedLanes = d2;
          switch (b2) {
            case 0:
            case 1:
              throw Error(p$3(345));
            case 2:
              Qk(a, uk, vk);
              break;
            case 3:
              Dk(a, d2);
              if ((d2 & 130023424) === d2 && (b2 = gk + 500 - B(), 10 < b2)) {
                if (0 !== uc(a, 0))
                  break;
                e2 = a.suspendedLanes;
                if ((e2 & d2) !== d2) {
                  L();
                  a.pingedLanes |= a.suspendedLanes & e2;
                  break;
                }
                a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), b2);
                break;
              }
              Qk(a, uk, vk);
              break;
            case 4:
              Dk(a, d2);
              if ((d2 & 4194240) === d2)
                break;
              b2 = a.eventTimes;
              for (e2 = -1; 0 < d2; ) {
                var g2 = 31 - oc(d2);
                f2 = 1 << g2;
                g2 = b2[g2];
                g2 > e2 && (e2 = g2);
                d2 &= ~f2;
              }
              d2 = e2;
              d2 = B() - d2;
              d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * mk(d2 / 1960)) - d2;
              if (10 < d2) {
                a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), d2);
                break;
              }
              Qk(a, uk, vk);
              break;
            case 5:
              Qk(a, uk, vk);
              break;
            default:
              throw Error(p$3(329));
          }
        }
      }
      Ek(a, B());
      return a.callbackNode === c2 ? Hk.bind(null, a) : null;
    }
    function Ok(a, b2) {
      var c2 = tk;
      a.current.memoizedState.isDehydrated && (Lk(a, b2).flags |= 256);
      a = Jk(a, b2);
      2 !== a && (b2 = uk, uk = c2, null !== b2 && Gj(b2));
      return a;
    }
    function Gj(a) {
      null === uk ? uk = a : uk.push.apply(uk, a);
    }
    function Pk(a) {
      for (var b2 = a; ; ) {
        if (b2.flags & 16384) {
          var c2 = b2.updateQueue;
          if (null !== c2 && (c2 = c2.stores, null !== c2))
            for (var d2 = 0; d2 < c2.length; d2++) {
              var e2 = c2[d2], f2 = e2.getSnapshot;
              e2 = e2.value;
              try {
                if (!He(f2(), e2))
                  return false;
              } catch (g2) {
                return false;
              }
            }
        }
        c2 = b2.child;
        if (b2.subtreeFlags & 16384 && null !== c2)
          c2.return = b2, b2 = c2;
        else {
          if (b2 === a)
            break;
          for (; null === b2.sibling; ) {
            if (null === b2.return || b2.return === a)
              return true;
            b2 = b2.return;
          }
          b2.sibling.return = b2.return;
          b2 = b2.sibling;
        }
      }
      return true;
    }
    function Dk(a, b2) {
      b2 &= ~sk;
      b2 &= ~rk;
      a.suspendedLanes |= b2;
      a.pingedLanes &= ~b2;
      for (a = a.expirationTimes; 0 < b2; ) {
        var c2 = 31 - oc(b2), d2 = 1 << c2;
        a[c2] = -1;
        b2 &= ~d2;
      }
    }
    function Fk(a) {
      if (0 !== (K & 6))
        throw Error(p$3(327));
      Ik();
      var b2 = uc(a, 0);
      if (0 === (b2 & 1))
        return Ek(a, B()), null;
      var c2 = Jk(a, b2);
      if (0 !== a.tag && 2 === c2) {
        var d2 = xc(a);
        0 !== d2 && (b2 = d2, c2 = Ok(a, d2));
      }
      if (1 === c2)
        throw c2 = qk, Lk(a, 0), Dk(a, b2), Ek(a, B()), c2;
      if (6 === c2)
        throw Error(p$3(345));
      a.finishedWork = a.current.alternate;
      a.finishedLanes = b2;
      Qk(a, uk, vk);
      Ek(a, B());
      return null;
    }
    function Rk(a, b2) {
      var c2 = K;
      K |= 1;
      try {
        return a(b2);
      } finally {
        K = c2, 0 === K && (Hj = B() + 500, fg && jg());
      }
    }
    function Sk(a) {
      null !== xk && 0 === xk.tag && 0 === (K & 6) && Ik();
      var b2 = K;
      K |= 1;
      var c2 = pk.transition, d2 = C;
      try {
        if (pk.transition = null, C = 1, a)
          return a();
      } finally {
        C = d2, pk.transition = c2, K = b2, 0 === (K & 6) && jg();
      }
    }
    function Ij() {
      gj = fj.current;
      E(fj);
    }
    function Lk(a, b2) {
      a.finishedWork = null;
      a.finishedLanes = 0;
      var c2 = a.timeoutHandle;
      -1 !== c2 && (a.timeoutHandle = -1, Gf(c2));
      if (null !== Y)
        for (c2 = Y.return; null !== c2; ) {
          var d2 = c2;
          wg(d2);
          switch (d2.tag) {
            case 1:
              d2 = d2.type.childContextTypes;
              null !== d2 && void 0 !== d2 && $f();
              break;
            case 3:
              Jh();
              E(Wf);
              E(H);
              Oh();
              break;
            case 5:
              Lh(d2);
              break;
            case 4:
              Jh();
              break;
            case 13:
              E(M);
              break;
            case 19:
              E(M);
              break;
            case 10:
              Rg(d2.type._context);
              break;
            case 22:
            case 23:
              Ij();
          }
          c2 = c2.return;
        }
      R = a;
      Y = a = wh(a.current, null);
      Z = gj = b2;
      T = 0;
      qk = null;
      sk = rk = hh = 0;
      uk = tk = null;
      if (null !== Wg) {
        for (b2 = 0; b2 < Wg.length; b2++)
          if (c2 = Wg[b2], d2 = c2.interleaved, null !== d2) {
            c2.interleaved = null;
            var e2 = d2.next, f2 = c2.pending;
            if (null !== f2) {
              var g2 = f2.next;
              f2.next = e2;
              d2.next = g2;
            }
            c2.pending = d2;
          }
        Wg = null;
      }
      return a;
    }
    function Nk(a, b2) {
      do {
        var c2 = Y;
        try {
          Qg();
          Ph.current = ai;
          if (Sh) {
            for (var d2 = N.memoizedState; null !== d2; ) {
              var e2 = d2.queue;
              null !== e2 && (e2.pending = null);
              d2 = d2.next;
            }
            Sh = false;
          }
          Rh = 0;
          P = O = N = null;
          Th = false;
          Uh = 0;
          ok.current = null;
          if (null === c2 || null === c2.return) {
            T = 1;
            qk = b2;
            Y = null;
            break;
          }
          a: {
            var f2 = a, g2 = c2.return, h2 = c2, k2 = b2;
            b2 = Z;
            h2.flags |= 32768;
            if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
              var l2 = k2, m2 = h2, q2 = m2.tag;
              if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
                var r2 = m2.alternate;
                r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
              }
              var y2 = Vi(g2);
              if (null !== y2) {
                y2.flags &= -257;
                Wi(y2, g2, h2, f2, b2);
                y2.mode & 1 && Ti(f2, l2, b2);
                b2 = y2;
                k2 = l2;
                var n2 = b2.updateQueue;
                if (null === n2) {
                  var t2 = /* @__PURE__ */ new Set();
                  t2.add(k2);
                  b2.updateQueue = t2;
                } else
                  n2.add(k2);
                break a;
              } else {
                if (0 === (b2 & 1)) {
                  Ti(f2, l2, b2);
                  uj();
                  break a;
                }
                k2 = Error(p$3(426));
              }
            } else if (I && h2.mode & 1) {
              var J2 = Vi(g2);
              if (null !== J2) {
                0 === (J2.flags & 65536) && (J2.flags |= 256);
                Wi(J2, g2, h2, f2, b2);
                Jg(Ki(k2, h2));
                break a;
              }
            }
            f2 = k2 = Ki(k2, h2);
            4 !== T && (T = 2);
            null === tk ? tk = [f2] : tk.push(f2);
            f2 = g2;
            do {
              switch (f2.tag) {
                case 3:
                  f2.flags |= 65536;
                  b2 &= -b2;
                  f2.lanes |= b2;
                  var x2 = Oi(f2, k2, b2);
                  fh(f2, x2);
                  break a;
                case 1:
                  h2 = k2;
                  var w2 = f2.type, u2 = f2.stateNode;
                  if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Si || !Si.has(u2)))) {
                    f2.flags |= 65536;
                    b2 &= -b2;
                    f2.lanes |= b2;
                    var F2 = Ri(f2, h2, b2);
                    fh(f2, F2);
                    break a;
                  }
              }
              f2 = f2.return;
            } while (null !== f2);
          }
          Tk(c2);
        } catch (na) {
          b2 = na;
          Y === c2 && null !== c2 && (Y = c2 = c2.return);
          continue;
        }
        break;
      } while (1);
    }
    function Kk() {
      var a = nk.current;
      nk.current = ai;
      return null === a ? ai : a;
    }
    function uj() {
      if (0 === T || 3 === T || 2 === T)
        T = 4;
      null === R || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R, Z);
    }
    function Jk(a, b2) {
      var c2 = K;
      K |= 2;
      var d2 = Kk();
      if (R !== a || Z !== b2)
        vk = null, Lk(a, b2);
      do
        try {
          Uk();
          break;
        } catch (e2) {
          Nk(a, e2);
        }
      while (1);
      Qg();
      K = c2;
      nk.current = d2;
      if (null !== Y)
        throw Error(p$3(261));
      R = null;
      Z = 0;
      return T;
    }
    function Uk() {
      for (; null !== Y; )
        Vk(Y);
    }
    function Mk() {
      for (; null !== Y && !cc(); )
        Vk(Y);
    }
    function Vk(a) {
      var b2 = Wk(a.alternate, a, gj);
      a.memoizedProps = a.pendingProps;
      null === b2 ? Tk(a) : Y = b2;
      ok.current = null;
    }
    function Tk(a) {
      var b2 = a;
      do {
        var c2 = b2.alternate;
        a = b2.return;
        if (0 === (b2.flags & 32768)) {
          if (c2 = Fj(c2, b2, gj), null !== c2) {
            Y = c2;
            return;
          }
        } else {
          c2 = Jj(c2, b2);
          if (null !== c2) {
            c2.flags &= 32767;
            Y = c2;
            return;
          }
          if (null !== a)
            a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
          else {
            T = 6;
            Y = null;
            return;
          }
        }
        b2 = b2.sibling;
        if (null !== b2) {
          Y = b2;
          return;
        }
        Y = b2 = a;
      } while (null !== b2);
      0 === T && (T = 5);
    }
    function Qk(a, b2, c2) {
      var d2 = C, e2 = pk.transition;
      try {
        pk.transition = null, C = 1, Xk(a, b2, c2, d2);
      } finally {
        pk.transition = e2, C = d2;
      }
      return null;
    }
    function Xk(a, b2, c2, d2) {
      do
        Ik();
      while (null !== xk);
      if (0 !== (K & 6))
        throw Error(p$3(327));
      c2 = a.finishedWork;
      var e2 = a.finishedLanes;
      if (null === c2)
        return null;
      a.finishedWork = null;
      a.finishedLanes = 0;
      if (c2 === a.current)
        throw Error(p$3(177));
      a.callbackNode = null;
      a.callbackPriority = 0;
      var f2 = c2.lanes | c2.childLanes;
      Bc(a, f2);
      a === R && (Y = R = null, Z = 0);
      0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || wk || (wk = true, Gk(hc, function() {
        Ik();
        return null;
      }));
      f2 = 0 !== (c2.flags & 15990);
      if (0 !== (c2.subtreeFlags & 15990) || f2) {
        f2 = pk.transition;
        pk.transition = null;
        var g2 = C;
        C = 1;
        var h2 = K;
        K |= 4;
        ok.current = null;
        Pj(a, c2);
        ek(c2, a);
        Oe(Df);
        dd = !!Cf;
        Df = Cf = null;
        a.current = c2;
        ik(c2);
        dc();
        K = h2;
        C = g2;
        pk.transition = f2;
      } else
        a.current = c2;
      wk && (wk = false, xk = a, yk = e2);
      f2 = a.pendingLanes;
      0 === f2 && (Si = null);
      mc(c2.stateNode);
      Ek(a, B());
      if (null !== b2)
        for (d2 = a.onRecoverableError, c2 = 0; c2 < b2.length; c2++)
          e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
      if (Pi)
        throw Pi = false, a = Qi, Qi = null, a;
      0 !== (yk & 1) && 0 !== a.tag && Ik();
      f2 = a.pendingLanes;
      0 !== (f2 & 1) ? a === Ak ? zk++ : (zk = 0, Ak = a) : zk = 0;
      jg();
      return null;
    }
    function Ik() {
      if (null !== xk) {
        var a = Dc(yk), b2 = pk.transition, c2 = C;
        try {
          pk.transition = null;
          C = 16 > a ? 16 : a;
          if (null === xk)
            var d2 = false;
          else {
            a = xk;
            xk = null;
            yk = 0;
            if (0 !== (K & 6))
              throw Error(p$3(331));
            var e2 = K;
            K |= 4;
            for (V = a.current; null !== V; ) {
              var f2 = V, g2 = f2.child;
              if (0 !== (V.flags & 16)) {
                var h2 = f2.deletions;
                if (null !== h2) {
                  for (var k2 = 0; k2 < h2.length; k2++) {
                    var l2 = h2[k2];
                    for (V = l2; null !== V; ) {
                      var m2 = V;
                      switch (m2.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Qj(8, m2, f2);
                      }
                      var q2 = m2.child;
                      if (null !== q2)
                        q2.return = m2, V = q2;
                      else
                        for (; null !== V; ) {
                          m2 = V;
                          var r2 = m2.sibling, y2 = m2.return;
                          Tj(m2);
                          if (m2 === l2) {
                            V = null;
                            break;
                          }
                          if (null !== r2) {
                            r2.return = y2;
                            V = r2;
                            break;
                          }
                          V = y2;
                        }
                    }
                  }
                  var n2 = f2.alternate;
                  if (null !== n2) {
                    var t2 = n2.child;
                    if (null !== t2) {
                      n2.child = null;
                      do {
                        var J2 = t2.sibling;
                        t2.sibling = null;
                        t2 = J2;
                      } while (null !== t2);
                    }
                  }
                  V = f2;
                }
              }
              if (0 !== (f2.subtreeFlags & 2064) && null !== g2)
                g2.return = f2, V = g2;
              else
                b:
                  for (; null !== V; ) {
                    f2 = V;
                    if (0 !== (f2.flags & 2048))
                      switch (f2.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Qj(9, f2, f2.return);
                      }
                    var x2 = f2.sibling;
                    if (null !== x2) {
                      x2.return = f2.return;
                      V = x2;
                      break b;
                    }
                    V = f2.return;
                  }
            }
            var w2 = a.current;
            for (V = w2; null !== V; ) {
              g2 = V;
              var u2 = g2.child;
              if (0 !== (g2.subtreeFlags & 2064) && null !== u2)
                u2.return = g2, V = u2;
              else
                b:
                  for (g2 = w2; null !== V; ) {
                    h2 = V;
                    if (0 !== (h2.flags & 2048))
                      try {
                        switch (h2.tag) {
                          case 0:
                          case 11:
                          case 15:
                            Rj(9, h2);
                        }
                      } catch (na) {
                        W(h2, h2.return, na);
                      }
                    if (h2 === g2) {
                      V = null;
                      break b;
                    }
                    var F2 = h2.sibling;
                    if (null !== F2) {
                      F2.return = h2.return;
                      V = F2;
                      break b;
                    }
                    V = h2.return;
                  }
            }
            K = e2;
            jg();
            if (lc && "function" === typeof lc.onPostCommitFiberRoot)
              try {
                lc.onPostCommitFiberRoot(kc, a);
              } catch (na) {
              }
            d2 = true;
          }
          return d2;
        } finally {
          C = c2, pk.transition = b2;
        }
      }
      return false;
    }
    function Yk(a, b2, c2) {
      b2 = Ki(c2, b2);
      b2 = Oi(a, b2, 1);
      a = dh(a, b2, 1);
      b2 = L();
      null !== a && (Ac(a, 1, b2), Ek(a, b2));
    }
    function W(a, b2, c2) {
      if (3 === a.tag)
        Yk(a, a, c2);
      else
        for (; null !== b2; ) {
          if (3 === b2.tag) {
            Yk(b2, a, c2);
            break;
          } else if (1 === b2.tag) {
            var d2 = b2.stateNode;
            if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Si || !Si.has(d2))) {
              a = Ki(c2, a);
              a = Ri(b2, a, 1);
              b2 = dh(b2, a, 1);
              a = L();
              null !== b2 && (Ac(b2, 1, a), Ek(b2, a));
              break;
            }
          }
          b2 = b2.return;
        }
    }
    function Ui(a, b2, c2) {
      var d2 = a.pingCache;
      null !== d2 && d2.delete(b2);
      b2 = L();
      a.pingedLanes |= a.suspendedLanes & c2;
      R === a && (Z & c2) === c2 && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - gk ? Lk(a, 0) : sk |= c2);
      Ek(a, b2);
    }
    function Zk(a, b2) {
      0 === b2 && (0 === (a.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
      var c2 = L();
      a = Zg(a, b2);
      null !== a && (Ac(a, b2, c2), Ek(a, c2));
    }
    function vj(a) {
      var b2 = a.memoizedState, c2 = 0;
      null !== b2 && (c2 = b2.retryLane);
      Zk(a, c2);
    }
    function ck(a, b2) {
      var c2 = 0;
      switch (a.tag) {
        case 13:
          var d2 = a.stateNode;
          var e2 = a.memoizedState;
          null !== e2 && (c2 = e2.retryLane);
          break;
        case 19:
          d2 = a.stateNode;
          break;
        default:
          throw Error(p$3(314));
      }
      null !== d2 && d2.delete(b2);
      Zk(a, c2);
    }
    var Wk;
    Wk = function(a, b2, c2) {
      if (null !== a)
        if (a.memoizedProps !== b2.pendingProps || Wf.current)
          Ug = true;
        else {
          if (0 === (a.lanes & c2) && 0 === (b2.flags & 128))
            return Ug = false, zj(a, b2, c2);
          Ug = 0 !== (a.flags & 131072) ? true : false;
        }
      else
        Ug = false, I && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
      b2.lanes = 0;
      switch (b2.tag) {
        case 2:
          var d2 = b2.type;
          jj(a, b2);
          a = b2.pendingProps;
          var e2 = Yf(b2, H.current);
          Tg(b2, c2);
          e2 = Xh(null, b2, d2, a, e2, c2);
          var f2 = bi();
          b2.flags |= 1;
          "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, ah(b2), e2.updater = nh, b2.stateNode = e2, e2._reactInternals = b2, rh(b2, d2, a, c2), b2 = kj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I && f2 && vg(b2), Yi(null, b2, e2, c2), b2 = b2.child);
          return b2;
        case 16:
          d2 = b2.elementType;
          a: {
            jj(a, b2);
            a = b2.pendingProps;
            e2 = d2._init;
            d2 = e2(d2._payload);
            b2.type = d2;
            e2 = b2.tag = $k(d2);
            a = Lg(d2, a);
            switch (e2) {
              case 0:
                b2 = dj(null, b2, d2, a, c2);
                break a;
              case 1:
                b2 = ij(null, b2, d2, a, c2);
                break a;
              case 11:
                b2 = Zi(null, b2, d2, a, c2);
                break a;
              case 14:
                b2 = aj(null, b2, d2, Lg(d2.type, a), c2);
                break a;
            }
            throw Error(p$3(
              306,
              d2,
              ""
            ));
          }
          return b2;
        case 0:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), dj(a, b2, d2, e2, c2);
        case 1:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), ij(a, b2, d2, e2, c2);
        case 3:
          a: {
            lj(b2);
            if (null === a)
              throw Error(p$3(387));
            d2 = b2.pendingProps;
            f2 = b2.memoizedState;
            e2 = f2.element;
            bh(a, b2);
            gh(b2, d2, null, c2);
            var g2 = b2.memoizedState;
            d2 = g2.element;
            if (f2.isDehydrated)
              if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
                e2 = Ki(Error(p$3(423)), b2);
                b2 = mj(a, b2, d2, c2, e2);
                break a;
              } else if (d2 !== e2) {
                e2 = Ki(Error(p$3(424)), b2);
                b2 = mj(a, b2, d2, c2, e2);
                break a;
              } else
                for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I = true, zg = null, c2 = Ch(b2, null, d2, c2), b2.child = c2; c2; )
                  c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
            else {
              Ig();
              if (d2 === e2) {
                b2 = $i(a, b2, c2);
                break a;
              }
              Yi(a, b2, d2, c2);
            }
            b2 = b2.child;
          }
          return b2;
        case 5:
          return Kh(b2), null === a && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a ? a.memoizedProps : null, g2 = e2.children, Ef(d2, e2) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), hj(a, b2), Yi(a, b2, g2, c2), b2.child;
        case 6:
          return null === a && Eg(b2), null;
        case 13:
          return pj(a, b2, c2);
        case 4:
          return Ih(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a ? b2.child = Bh(b2, null, d2, c2) : Yi(a, b2, d2, c2), b2.child;
        case 11:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), Zi(a, b2, d2, e2, c2);
        case 7:
          return Yi(a, b2, b2.pendingProps, c2), b2.child;
        case 8:
          return Yi(a, b2, b2.pendingProps.children, c2), b2.child;
        case 12:
          return Yi(a, b2, b2.pendingProps.children, c2), b2.child;
        case 10:
          a: {
            d2 = b2.type._context;
            e2 = b2.pendingProps;
            f2 = b2.memoizedProps;
            g2 = e2.value;
            G(Mg, d2._currentValue);
            d2._currentValue = g2;
            if (null !== f2)
              if (He(f2.value, g2)) {
                if (f2.children === e2.children && !Wf.current) {
                  b2 = $i(a, b2, c2);
                  break a;
                }
              } else
                for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
                  var h2 = f2.dependencies;
                  if (null !== h2) {
                    g2 = f2.child;
                    for (var k2 = h2.firstContext; null !== k2; ) {
                      if (k2.context === d2) {
                        if (1 === f2.tag) {
                          k2 = ch(-1, c2 & -c2);
                          k2.tag = 2;
                          var l2 = f2.updateQueue;
                          if (null !== l2) {
                            l2 = l2.shared;
                            var m2 = l2.pending;
                            null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                            l2.pending = k2;
                          }
                        }
                        f2.lanes |= c2;
                        k2 = f2.alternate;
                        null !== k2 && (k2.lanes |= c2);
                        Sg(
                          f2.return,
                          c2,
                          b2
                        );
                        h2.lanes |= c2;
                        break;
                      }
                      k2 = k2.next;
                    }
                  } else if (10 === f2.tag)
                    g2 = f2.type === b2.type ? null : f2.child;
                  else if (18 === f2.tag) {
                    g2 = f2.return;
                    if (null === g2)
                      throw Error(p$3(341));
                    g2.lanes |= c2;
                    h2 = g2.alternate;
                    null !== h2 && (h2.lanes |= c2);
                    Sg(g2, c2, b2);
                    g2 = f2.sibling;
                  } else
                    g2 = f2.child;
                  if (null !== g2)
                    g2.return = f2;
                  else
                    for (g2 = f2; null !== g2; ) {
                      if (g2 === b2) {
                        g2 = null;
                        break;
                      }
                      f2 = g2.sibling;
                      if (null !== f2) {
                        f2.return = g2.return;
                        g2 = f2;
                        break;
                      }
                      g2 = g2.return;
                    }
                  f2 = g2;
                }
            Yi(a, b2, e2.children, c2);
            b2 = b2.child;
          }
          return b2;
        case 9:
          return e2 = b2.type, d2 = b2.pendingProps.children, Tg(b2, c2), e2 = Vg(e2), d2 = d2(e2), b2.flags |= 1, Yi(a, b2, d2, c2), b2.child;
        case 14:
          return d2 = b2.type, e2 = Lg(d2, b2.pendingProps), e2 = Lg(d2.type, e2), aj(a, b2, d2, e2, c2);
        case 15:
          return cj(a, b2, b2.type, b2.pendingProps, c2);
        case 17:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), jj(a, b2), b2.tag = 1, Zf(d2) ? (a = true, cg(b2)) : a = false, Tg(b2, c2), ph(b2, d2, e2), rh(b2, d2, e2, c2), kj(null, b2, d2, true, a, c2);
        case 19:
          return yj(a, b2, c2);
        case 22:
          return ej(a, b2, c2);
      }
      throw Error(p$3(156, b2.tag));
    };
    function Gk(a, b2) {
      return ac(a, b2);
    }
    function al(a, b2, c2, d2) {
      this.tag = a;
      this.key = c2;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.ref = null;
      this.pendingProps = b2;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = d2;
      this.subtreeFlags = this.flags = 0;
      this.deletions = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
    }
    function Bg(a, b2, c2, d2) {
      return new al(a, b2, c2, d2);
    }
    function bj(a) {
      a = a.prototype;
      return !(!a || !a.isReactComponent);
    }
    function $k(a) {
      if ("function" === typeof a)
        return bj(a) ? 1 : 0;
      if (void 0 !== a && null !== a) {
        a = a.$$typeof;
        if (a === Da)
          return 11;
        if (a === Ga)
          return 14;
      }
      return 2;
    }
    function wh(a, b2) {
      var c2 = a.alternate;
      null === c2 ? (c2 = Bg(a.tag, b2, a.key, a.mode), c2.elementType = a.elementType, c2.type = a.type, c2.stateNode = a.stateNode, c2.alternate = a, a.alternate = c2) : (c2.pendingProps = b2, c2.type = a.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
      c2.flags = a.flags & 14680064;
      c2.childLanes = a.childLanes;
      c2.lanes = a.lanes;
      c2.child = a.child;
      c2.memoizedProps = a.memoizedProps;
      c2.memoizedState = a.memoizedState;
      c2.updateQueue = a.updateQueue;
      b2 = a.dependencies;
      c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
      c2.sibling = a.sibling;
      c2.index = a.index;
      c2.ref = a.ref;
      return c2;
    }
    function yh(a, b2, c2, d2, e2, f2) {
      var g2 = 2;
      d2 = a;
      if ("function" === typeof a)
        bj(a) && (g2 = 1);
      else if ("string" === typeof a)
        g2 = 5;
      else
        a:
          switch (a) {
            case ya:
              return Ah(c2.children, e2, f2, b2);
            case za:
              g2 = 8;
              e2 |= 8;
              break;
            case Aa:
              return a = Bg(12, c2, b2, e2 | 2), a.elementType = Aa, a.lanes = f2, a;
            case Ea:
              return a = Bg(13, c2, b2, e2), a.elementType = Ea, a.lanes = f2, a;
            case Fa:
              return a = Bg(19, c2, b2, e2), a.elementType = Fa, a.lanes = f2, a;
            case Ia:
              return qj(c2, e2, f2, b2);
            default:
              if ("object" === typeof a && null !== a)
                switch (a.$$typeof) {
                  case Ba:
                    g2 = 10;
                    break a;
                  case Ca:
                    g2 = 9;
                    break a;
                  case Da:
                    g2 = 11;
                    break a;
                  case Ga:
                    g2 = 14;
                    break a;
                  case Ha:
                    g2 = 16;
                    d2 = null;
                    break a;
                }
              throw Error(p$3(130, null == a ? a : typeof a, ""));
          }
      b2 = Bg(g2, c2, b2, e2);
      b2.elementType = a;
      b2.type = d2;
      b2.lanes = f2;
      return b2;
    }
    function Ah(a, b2, c2, d2) {
      a = Bg(7, a, d2, b2);
      a.lanes = c2;
      return a;
    }
    function qj(a, b2, c2, d2) {
      a = Bg(22, a, d2, b2);
      a.elementType = Ia;
      a.lanes = c2;
      a.stateNode = { isHidden: false };
      return a;
    }
    function xh(a, b2, c2) {
      a = Bg(6, a, null, b2);
      a.lanes = c2;
      return a;
    }
    function zh(a, b2, c2) {
      b2 = Bg(4, null !== a.children ? a.children : [], a.key, b2);
      b2.lanes = c2;
      b2.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
      return b2;
    }
    function bl(a, b2, c2, d2, e2) {
      this.tag = b2;
      this.containerInfo = a;
      this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = -1;
      this.callbackNode = this.pendingContext = this.context = null;
      this.callbackPriority = 0;
      this.eventTimes = zc(0);
      this.expirationTimes = zc(-1);
      this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
      this.entanglements = zc(0);
      this.identifierPrefix = d2;
      this.onRecoverableError = e2;
      this.mutableSourceEagerHydrationData = null;
    }
    function cl(a, b2, c2, d2, e2, f2, g2, h2, k2) {
      a = new bl(a, b2, c2, h2, k2);
      1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
      f2 = Bg(3, null, null, b2);
      a.current = f2;
      f2.stateNode = a;
      f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
      ah(f2);
      return a;
    }
    function dl(a, b2, c2) {
      var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a, containerInfo: b2, implementation: c2 };
    }
    function el(a) {
      if (!a)
        return Vf;
      a = a._reactInternals;
      a: {
        if (Vb(a) !== a || 1 !== a.tag)
          throw Error(p$3(170));
        var b2 = a;
        do {
          switch (b2.tag) {
            case 3:
              b2 = b2.stateNode.context;
              break a;
            case 1:
              if (Zf(b2.type)) {
                b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
                break a;
              }
          }
          b2 = b2.return;
        } while (null !== b2);
        throw Error(p$3(171));
      }
      if (1 === a.tag) {
        var c2 = a.type;
        if (Zf(c2))
          return bg(a, c2, b2);
      }
      return b2;
    }
    function fl(a, b2, c2, d2, e2, f2, g2, h2, k2) {
      a = cl(c2, d2, true, a, e2, f2, g2, h2, k2);
      a.context = el(null);
      c2 = a.current;
      d2 = L();
      e2 = lh(c2);
      f2 = ch(d2, e2);
      f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
      dh(c2, f2, e2);
      a.current.lanes = e2;
      Ac(a, e2, d2);
      Ek(a, d2);
      return a;
    }
    function gl(a, b2, c2, d2) {
      var e2 = b2.current, f2 = L(), g2 = lh(e2);
      c2 = el(c2);
      null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
      b2 = ch(f2, g2);
      b2.payload = { element: a };
      d2 = void 0 === d2 ? null : d2;
      null !== d2 && (b2.callback = d2);
      a = dh(e2, b2, g2);
      null !== a && (mh(a, e2, g2, f2), eh(a, e2, g2));
      return g2;
    }
    function hl(a) {
      a = a.current;
      if (!a.child)
        return null;
      switch (a.child.tag) {
        case 5:
          return a.child.stateNode;
        default:
          return a.child.stateNode;
      }
    }
    function il(a, b2) {
      a = a.memoizedState;
      if (null !== a && null !== a.dehydrated) {
        var c2 = a.retryLane;
        a.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
      }
    }
    function jl(a, b2) {
      il(a, b2);
      (a = a.alternate) && il(a, b2);
    }
    function kl() {
      return null;
    }
    var ll = "function" === typeof reportError ? reportError : function(a) {
      console.error(a);
    };
    function ml(a) {
      this._internalRoot = a;
    }
    nl.prototype.render = ml.prototype.render = function(a) {
      var b2 = this._internalRoot;
      if (null === b2)
        throw Error(p$3(409));
      gl(a, b2, null, null);
    };
    nl.prototype.unmount = ml.prototype.unmount = function() {
      var a = this._internalRoot;
      if (null !== a) {
        this._internalRoot = null;
        var b2 = a.containerInfo;
        Sk(function() {
          gl(null, a, null, null);
        });
        b2[uf] = null;
      }
    };
    function nl(a) {
      this._internalRoot = a;
    }
    nl.prototype.unstable_scheduleHydration = function(a) {
      if (a) {
        var b2 = Hc();
        a = { blockedOn: null, target: a, priority: b2 };
        for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++)
          ;
        Qc.splice(c2, 0, a);
        0 === c2 && Vc(a);
      }
    };
    function ol(a) {
      return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
    }
    function pl(a) {
      return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
    }
    function ql() {
    }
    function rl(a, b2, c2, d2, e2) {
      if (e2) {
        if ("function" === typeof d2) {
          var f2 = d2;
          d2 = function() {
            var a2 = hl(g2);
            f2.call(a2);
          };
        }
        var g2 = fl(b2, d2, a, 0, null, false, false, "", ql);
        a._reactRootContainer = g2;
        a[uf] = g2.current;
        sf(8 === a.nodeType ? a.parentNode : a);
        Sk();
        return g2;
      }
      for (; e2 = a.lastChild; )
        a.removeChild(e2);
      if ("function" === typeof d2) {
        var h2 = d2;
        d2 = function() {
          var a2 = hl(k2);
          h2.call(a2);
        };
      }
      var k2 = cl(a, 0, false, null, null, false, false, "", ql);
      a._reactRootContainer = k2;
      a[uf] = k2.current;
      sf(8 === a.nodeType ? a.parentNode : a);
      Sk(function() {
        gl(b2, k2, c2, d2);
      });
      return k2;
    }
    function sl(a, b2, c2, d2, e2) {
      var f2 = c2._reactRootContainer;
      if (f2) {
        var g2 = f2;
        if ("function" === typeof e2) {
          var h2 = e2;
          e2 = function() {
            var a2 = hl(g2);
            h2.call(a2);
          };
        }
        gl(b2, g2, a, e2);
      } else
        g2 = rl(c2, b2, a, e2, d2);
      return hl(g2);
    }
    Ec = function(a) {
      switch (a.tag) {
        case 3:
          var b2 = a.stateNode;
          if (b2.current.memoizedState.isDehydrated) {
            var c2 = tc(b2.pendingLanes);
            0 !== c2 && (Cc(b2, c2 | 1), Ek(b2, B()), 0 === (K & 6) && (Hj = B() + 500, jg()));
          }
          break;
        case 13:
          Sk(function() {
            var b3 = Zg(a, 1);
            if (null !== b3) {
              var c3 = L();
              mh(b3, a, 1, c3);
            }
          }), jl(a, 1);
      }
    };
    Fc = function(a) {
      if (13 === a.tag) {
        var b2 = Zg(a, 134217728);
        if (null !== b2) {
          var c2 = L();
          mh(b2, a, 134217728, c2);
        }
        jl(a, 134217728);
      }
    };
    Gc = function(a) {
      if (13 === a.tag) {
        var b2 = lh(a), c2 = Zg(a, b2);
        if (null !== c2) {
          var d2 = L();
          mh(c2, a, b2, d2);
        }
        jl(a, b2);
      }
    };
    Hc = function() {
      return C;
    };
    Ic = function(a, b2) {
      var c2 = C;
      try {
        return C = a, b2();
      } finally {
        C = c2;
      }
    };
    yb = function(a, b2, c2) {
      switch (b2) {
        case "input":
          bb(a, c2);
          b2 = c2.name;
          if ("radio" === c2.type && null != b2) {
            for (c2 = a; c2.parentNode; )
              c2 = c2.parentNode;
            c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
            for (b2 = 0; b2 < c2.length; b2++) {
              var d2 = c2[b2];
              if (d2 !== a && d2.form === a.form) {
                var e2 = Db(d2);
                if (!e2)
                  throw Error(p$3(90));
                Wa(d2);
                bb(d2, e2);
              }
            }
          }
          break;
        case "textarea":
          ib(a, c2);
          break;
        case "select":
          b2 = c2.value, null != b2 && fb(a, !!c2.multiple, b2, false);
      }
    };
    Gb = Rk;
    Hb = Sk;
    var tl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
    var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
      a = Zb(a);
      return null === a ? null : a.stateNode;
    }, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
    if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
      var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!wl.isDisabled && wl.supportsFiber)
        try {
          kc = wl.inject(vl), lc = wl;
        } catch (a) {
        }
    }
    reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
    reactDom_production_min.createPortal = function(a, b2) {
      var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (!ol(b2))
        throw Error(p$3(200));
      return dl(a, b2, null, c2);
    };
    reactDom_production_min.createRoot = function(a, b2) {
      if (!ol(a))
        throw Error(p$3(299));
      var c2 = false, d2 = "", e2 = ll;
      null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
      b2 = cl(a, 1, false, null, null, c2, false, d2, e2);
      a[uf] = b2.current;
      sf(8 === a.nodeType ? a.parentNode : a);
      return new ml(b2);
    };
    reactDom_production_min.findDOMNode = function(a) {
      if (null == a)
        return null;
      if (1 === a.nodeType)
        return a;
      var b2 = a._reactInternals;
      if (void 0 === b2) {
        if ("function" === typeof a.render)
          throw Error(p$3(188));
        a = Object.keys(a).join(",");
        throw Error(p$3(268, a));
      }
      a = Zb(b2);
      a = null === a ? null : a.stateNode;
      return a;
    };
    reactDom_production_min.flushSync = function(a) {
      return Sk(a);
    };
    reactDom_production_min.hydrate = function(a, b2, c2) {
      if (!pl(b2))
        throw Error(p$3(200));
      return sl(null, a, b2, true, c2);
    };
    reactDom_production_min.hydrateRoot = function(a, b2, c2) {
      if (!ol(a))
        throw Error(p$3(405));
      var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g2 = ll;
      null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
      b2 = fl(b2, null, a, 1, null != c2 ? c2 : null, e2, false, f2, g2);
      a[uf] = b2.current;
      sf(a);
      if (d2)
        for (a = 0; a < d2.length; a++)
          c2 = d2[a], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
            c2,
            e2
          );
      return new nl(b2);
    };
    reactDom_production_min.render = function(a, b2, c2) {
      if (!pl(b2))
        throw Error(p$3(200));
      return sl(null, a, b2, false, c2);
    };
    reactDom_production_min.unmountComponentAtNode = function(a) {
      if (!pl(a))
        throw Error(p$3(40));
      return a._reactRootContainer ? (Sk(function() {
        sl(null, null, a, false, function() {
          a._reactRootContainer = null;
          a[uf] = null;
        });
      }), true) : false;
    };
    reactDom_production_min.unstable_batchedUpdates = Rk;
    reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b2, c2, d2) {
      if (!pl(c2))
        throw Error(p$3(200));
      if (null == a || void 0 === a._reactInternals)
        throw Error(p$3(38));
      return sl(a, b2, c2, false, d2);
    };
    reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
    (function(module2) {
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      {
        checkDCE();
        module2.exports = reactDom_production_min;
      }
    })(reactDom);
    const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDom.exports);
    var m$3 = reactDom.exports;
    {
      client.createRoot = m$3.createRoot;
      client.hydrateRoot = m$3.hydrateRoot;
    }
    /**
     * @remix-run/router v1.0.0
     *
     * Copyright (c) Remix Software Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     */
    function _extends$2() {
      _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends$2.apply(this, arguments);
    }
    var Action;
    (function(Action2) {
      Action2["Pop"] = "POP";
      Action2["Push"] = "PUSH";
      Action2["Replace"] = "REPLACE";
    })(Action || (Action = {}));
    const PopStateEventType = "popstate";
    function createHashHistory(options) {
      if (options === void 0) {
        options = {};
      }
      function createHashLocation(window2, globalHistory) {
        var _globalHistory$state3, _globalHistory$state4;
        let {
          pathname = "/",
          search = "",
          hash: hash2 = ""
        } = parsePath(window2.location.hash.substr(1));
        return createLocation(
          "",
          {
            pathname,
            search,
            hash: hash2
          },
          ((_globalHistory$state3 = globalHistory.state) == null ? void 0 : _globalHistory$state3.usr) || null,
          ((_globalHistory$state4 = globalHistory.state) == null ? void 0 : _globalHistory$state4.key) || "default"
        );
      }
      function createHashHref(window2, to2) {
        let base = window2.document.querySelector("base");
        let href = "";
        if (base && base.getAttribute("href")) {
          let url = window2.location.href;
          let hashIndex = url.indexOf("#");
          href = hashIndex === -1 ? url : url.slice(0, hashIndex);
        }
        return href + "#" + (typeof to2 === "string" ? to2 : createPath(to2));
      }
      function validateHashLocation(location2, to2) {
        warning$1(location2.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(" + JSON.stringify(to2) + ")");
      }
      return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);
    }
    function warning$1(cond, message) {
      if (!cond) {
        if (typeof console !== "undefined")
          console.warn(message);
        try {
          throw new Error(message);
        } catch (e2) {
        }
      }
    }
    function createKey() {
      return Math.random().toString(36).substr(2, 8);
    }
    function getHistoryState(location2) {
      return {
        usr: location2.state,
        key: location2.key
      };
    }
    function createLocation(current, to2, state, key) {
      if (state === void 0) {
        state = null;
      }
      let location2 = _extends$2({
        pathname: typeof current === "string" ? current : current.pathname,
        search: "",
        hash: ""
      }, typeof to2 === "string" ? parsePath(to2) : to2, {
        state,
        key: (to2 == null ? void 0 : to2.key) || key || createKey()
      });
      return location2;
    }
    function createPath(_ref) {
      let {
        pathname = "/",
        search = "",
        hash: hash2 = ""
      } = _ref;
      if (search && search !== "?")
        pathname += search.charAt(0) === "?" ? search : "?" + search;
      if (hash2 && hash2 !== "#")
        pathname += hash2.charAt(0) === "#" ? hash2 : "#" + hash2;
      return pathname;
    }
    function parsePath(path) {
      let parsedPath = {};
      if (path) {
        let hashIndex = path.indexOf("#");
        if (hashIndex >= 0) {
          parsedPath.hash = path.substr(hashIndex);
          path = path.substr(0, hashIndex);
        }
        let searchIndex = path.indexOf("?");
        if (searchIndex >= 0) {
          parsedPath.search = path.substr(searchIndex);
          path = path.substr(0, searchIndex);
        }
        if (path) {
          parsedPath.pathname = path;
        }
      }
      return parsedPath;
    }
    function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
      if (options === void 0) {
        options = {};
      }
      let {
        window: window2 = document.defaultView,
        v5Compat = false
      } = options;
      let globalHistory = window2.history;
      let action = Action.Pop;
      let listener = null;
      function handlePop() {
        action = Action.Pop;
        if (listener) {
          listener({
            action,
            location: history.location
          });
        }
      }
      function push(to2, state) {
        action = Action.Push;
        let location2 = createLocation(history.location, to2, state);
        validateLocation == null ? void 0 : validateLocation(location2, to2);
        let historyState = getHistoryState(location2);
        let url = history.createHref(location2);
        try {
          globalHistory.pushState(historyState, "", url);
        } catch (error) {
          window2.location.assign(url);
        }
        if (v5Compat && listener) {
          listener({
            action,
            location: location2
          });
        }
      }
      function replace2(to2, state) {
        action = Action.Replace;
        let location2 = createLocation(history.location, to2, state);
        validateLocation == null ? void 0 : validateLocation(location2, to2);
        let historyState = getHistoryState(location2);
        let url = history.createHref(location2);
        globalHistory.replaceState(historyState, "", url);
        if (v5Compat && listener) {
          listener({
            action,
            location: location2
          });
        }
      }
      let history = {
        get action() {
          return action;
        },
        get location() {
          return getLocation(window2, globalHistory);
        },
        listen(fn) {
          if (listener) {
            throw new Error("A history only accepts one active listener");
          }
          window2.addEventListener(PopStateEventType, handlePop);
          listener = fn;
          return () => {
            window2.removeEventListener(PopStateEventType, handlePop);
            listener = null;
          };
        },
        createHref(to2) {
          return createHref(window2, to2);
        },
        push,
        replace: replace2,
        go(n2) {
          return globalHistory.go(n2);
        }
      };
      return history;
    }
    var ResultType;
    (function(ResultType2) {
      ResultType2["data"] = "data";
      ResultType2["deferred"] = "deferred";
      ResultType2["redirect"] = "redirect";
      ResultType2["error"] = "error";
    })(ResultType || (ResultType = {}));
    function matchRoutes(routes, locationArg, basename) {
      if (basename === void 0) {
        basename = "/";
      }
      let location2 = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
      let pathname = stripBasename(location2.pathname || "/", basename);
      if (pathname == null) {
        return null;
      }
      let branches = flattenRoutes(routes);
      rankRouteBranches(branches);
      let matches = null;
      for (let i = 0; matches == null && i < branches.length; ++i) {
        matches = matchRouteBranch(branches[i], pathname);
      }
      return matches;
    }
    function flattenRoutes(routes, branches, parentsMeta, parentPath) {
      if (branches === void 0) {
        branches = [];
      }
      if (parentsMeta === void 0) {
        parentsMeta = [];
      }
      if (parentPath === void 0) {
        parentPath = "";
      }
      routes.forEach((route, index2) => {
        let meta = {
          relativePath: route.path || "",
          caseSensitive: route.caseSensitive === true,
          childrenIndex: index2,
          route
        };
        if (meta.relativePath.startsWith("/")) {
          invariant(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
          meta.relativePath = meta.relativePath.slice(parentPath.length);
        }
        let path = joinPaths([parentPath, meta.relativePath]);
        let routesMeta = parentsMeta.concat(meta);
        if (route.children && route.children.length > 0) {
          invariant(route.index !== true, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".'));
          flattenRoutes(route.children, branches, routesMeta, path);
        }
        if (route.path == null && !route.index) {
          return;
        }
        branches.push({
          path,
          score: computeScore(path, route.index),
          routesMeta
        });
      });
      return branches;
    }
    function rankRouteBranches(branches) {
      branches.sort((a, b2) => a.score !== b2.score ? b2.score - a.score : compareIndexes(a.routesMeta.map((meta) => meta.childrenIndex), b2.routesMeta.map((meta) => meta.childrenIndex)));
    }
    const paramRe = /^:\w+$/;
    const dynamicSegmentValue = 3;
    const indexRouteValue = 2;
    const emptySegmentValue = 1;
    const staticSegmentValue = 10;
    const splatPenalty = -2;
    const isSplat = (s) => s === "*";
    function computeScore(path, index2) {
      let segments = path.split("/");
      let initialScore = segments.length;
      if (segments.some(isSplat)) {
        initialScore += splatPenalty;
      }
      if (index2) {
        initialScore += indexRouteValue;
      }
      return segments.filter((s) => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
    }
    function compareIndexes(a, b2) {
      let siblings = a.length === b2.length && a.slice(0, -1).every((n2, i) => n2 === b2[i]);
      return siblings ? a[a.length - 1] - b2[b2.length - 1] : 0;
    }
    function matchRouteBranch(branch, pathname) {
      let {
        routesMeta
      } = branch;
      let matchedParams = {};
      let matchedPathname = "/";
      let matches = [];
      for (let i = 0; i < routesMeta.length; ++i) {
        let meta = routesMeta[i];
        let end2 = i === routesMeta.length - 1;
        let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
        let match5 = matchPath({
          path: meta.relativePath,
          caseSensitive: meta.caseSensitive,
          end: end2
        }, remainingPathname);
        if (!match5)
          return null;
        Object.assign(matchedParams, match5.params);
        let route = meta.route;
        matches.push({
          params: matchedParams,
          pathname: joinPaths([matchedPathname, match5.pathname]),
          pathnameBase: normalizePathname(joinPaths([matchedPathname, match5.pathnameBase])),
          route
        });
        if (match5.pathnameBase !== "/") {
          matchedPathname = joinPaths([matchedPathname, match5.pathnameBase]);
        }
      }
      return matches;
    }
    function matchPath(pattern, pathname) {
      if (typeof pattern === "string") {
        pattern = {
          path: pattern,
          caseSensitive: false,
          end: true
        };
      }
      let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
      let match5 = pathname.match(matcher);
      if (!match5)
        return null;
      let matchedPathname = match5[0];
      let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
      let captureGroups = match5.slice(1);
      let params = paramNames.reduce((memo, paramName, index2) => {
        if (paramName === "*") {
          let splatValue = captureGroups[index2] || "";
          pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
        }
        memo[paramName] = safelyDecodeURIComponent(captureGroups[index2] || "", paramName);
        return memo;
      }, {});
      return {
        params,
        pathname: matchedPathname,
        pathnameBase,
        pattern
      };
    }
    function compilePath(path, caseSensitive, end2) {
      if (caseSensitive === void 0) {
        caseSensitive = false;
      }
      if (end2 === void 0) {
        end2 = true;
      }
      warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
      let paramNames = [];
      let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/:(\w+)/g, (_2, paramName) => {
        paramNames.push(paramName);
        return "([^\\/]+)";
      });
      if (path.endsWith("*")) {
        paramNames.push("*");
        regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
      } else {
        regexpSource += end2 ? "\\/*$" : "(?:(?=[@.~-]|%[0-9A-F]{2})|\\b|\\/|$)";
      }
      let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
      return [matcher, paramNames];
    }
    function safelyDecodeURIComponent(value, paramName) {
      try {
        return decodeURIComponent(value);
      } catch (error) {
        warning(false, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error + ")."));
        return value;
      }
    }
    function stripBasename(pathname, basename) {
      if (basename === "/")
        return pathname;
      if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
        return null;
      }
      let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
      let nextChar = pathname.charAt(startIndex);
      if (nextChar && nextChar !== "/") {
        return null;
      }
      return pathname.slice(startIndex) || "/";
    }
    function invariant(value, message) {
      if (value === false || value === null || typeof value === "undefined") {
        throw new Error(message);
      }
    }
    function warning(cond, message) {
      if (!cond) {
        if (typeof console !== "undefined")
          console.warn(message);
        try {
          throw new Error(message);
        } catch (e2) {
        }
      }
    }
    function resolvePath(to2, fromPathname) {
      if (fromPathname === void 0) {
        fromPathname = "/";
      }
      let {
        pathname: toPathname,
        search = "",
        hash: hash2 = ""
      } = typeof to2 === "string" ? parsePath(to2) : to2;
      let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
      return {
        pathname,
        search: normalizeSearch(search),
        hash: normalizeHash(hash2)
      };
    }
    function resolvePathname(relativePath, fromPathname) {
      let segments = fromPathname.replace(/\/+$/, "").split("/");
      let relativeSegments = relativePath.split("/");
      relativeSegments.forEach((segment) => {
        if (segment === "..") {
          if (segments.length > 1)
            segments.pop();
        } else if (segment !== ".") {
          segments.push(segment);
        }
      });
      return segments.length > 1 ? segments.join("/") : "/";
    }
    function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
      if (isPathRelative === void 0) {
        isPathRelative = false;
      }
      let to2 = typeof toArg === "string" ? parsePath(toArg) : _extends$2({}, toArg);
      let isEmptyPath = toArg === "" || to2.pathname === "";
      let toPathname = isEmptyPath ? "/" : to2.pathname;
      let from2;
      if (isPathRelative || toPathname == null) {
        from2 = locationPathname;
      } else {
        let routePathnameIndex = routePathnames.length - 1;
        if (toPathname.startsWith("..")) {
          let toSegments = toPathname.split("/");
          while (toSegments[0] === "..") {
            toSegments.shift();
            routePathnameIndex -= 1;
          }
          to2.pathname = toSegments.join("/");
        }
        from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
      }
      let path = resolvePath(to2, from2);
      let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
      let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
      if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
        path.pathname += "/";
      }
      return path;
    }
    const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
    const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
    const normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
    const normalizeHash = (hash2) => !hash2 || hash2 === "#" ? "" : hash2.startsWith("#") ? hash2 : "#" + hash2;
    class ErrorResponse {
      constructor(status, statusText, data) {
        this.status = status;
        this.statusText = statusText || "";
        this.data = data;
      }
    }
    function isRouteErrorResponse(e2) {
      return e2 instanceof ErrorResponse;
    }
    var jsxRuntime$1 = { exports: {} };
    var reactJsxRuntime_production_min = {};
    /**
     * @license React
     * react-jsx-runtime.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var f$2 = react.exports, k$2 = Symbol.for("react.element"), l$2 = Symbol.for("react.fragment"), m$2 = Object.prototype.hasOwnProperty, n$2 = f$2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$2 = { key: true, ref: true, __self: true, __source: true };
    function q$2(c2, a, g2) {
      var b2, d2 = {}, e2 = null, h2 = null;
      void 0 !== g2 && (e2 = "" + g2);
      void 0 !== a.key && (e2 = "" + a.key);
      void 0 !== a.ref && (h2 = a.ref);
      for (b2 in a)
        m$2.call(a, b2) && !p$2.hasOwnProperty(b2) && (d2[b2] = a[b2]);
      if (c2 && c2.defaultProps)
        for (b2 in a = c2.defaultProps, a)
          void 0 === d2[b2] && (d2[b2] = a[b2]);
      return { $$typeof: k$2, type: c2, key: e2, ref: h2, props: d2, _owner: n$2.current };
    }
    reactJsxRuntime_production_min.Fragment = l$2;
    reactJsxRuntime_production_min.jsx = q$2;
    reactJsxRuntime_production_min.jsxs = q$2;
    (function(module2) {
      {
        module2.exports = reactJsxRuntime_production_min;
      }
    })(jsxRuntime$1);
    const Fragment = jsxRuntime$1.exports.Fragment;
    const jsx = jsxRuntime$1.exports.jsx;
    const jsxs = jsxRuntime$1.exports.jsxs;
    const jsxRuntime = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      Fragment,
      jsx,
      jsxs
    }, Symbol.toStringTag, { value: "Module" }));
    /**
     * React Router v6.4.0
     *
     * Copyright (c) Remix Software Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     */
    function _extends$1() {
      _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends$1.apply(this, arguments);
    }
    function isPolyfill(x2, y2) {
      return x2 === y2 && (x2 !== 0 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
    }
    const is = typeof Object.is === "function" ? Object.is : isPolyfill;
    const {
      useState,
      useEffect,
      useLayoutEffect,
      useDebugValue
    } = React$1;
    function useSyncExternalStore$2(subscribe, getSnapshot, getServerSnapshot) {
      const value = getSnapshot();
      const [{
        inst
      }, forceUpdate] = useState({
        inst: {
          value,
          getSnapshot
        }
      });
      useLayoutEffect(() => {
        inst.value = value;
        inst.getSnapshot = getSnapshot;
        if (checkIfSnapshotChanged(inst)) {
          forceUpdate({
            inst
          });
        }
      }, [subscribe, value, getSnapshot]);
      useEffect(() => {
        if (checkIfSnapshotChanged(inst)) {
          forceUpdate({
            inst
          });
        }
        const handleStoreChange = () => {
          if (checkIfSnapshotChanged(inst)) {
            forceUpdate({
              inst
            });
          }
        };
        return subscribe(handleStoreChange);
      }, [subscribe]);
      useDebugValue(value);
      return value;
    }
    function checkIfSnapshotChanged(inst) {
      const latestGetSnapshot = inst.getSnapshot;
      const prevValue = inst.value;
      try {
        const nextValue = latestGetSnapshot();
        return !is(prevValue, nextValue);
      } catch (error) {
        return true;
      }
    }
    function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
      return getSnapshot();
    }
    const canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
    const isServerEnvironment = !canUseDOM;
    const shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore$2;
    "useSyncExternalStore" in React$1 ? ((module2) => module2.useSyncExternalStore)(React$1) : shim;
    const DataStaticRouterContext = /* @__PURE__ */ react.exports.createContext(null);
    const DataRouterContext = /* @__PURE__ */ react.exports.createContext(null);
    const DataRouterStateContext = /* @__PURE__ */ react.exports.createContext(null);
    const NavigationContext = /* @__PURE__ */ react.exports.createContext(null);
    const LocationContext = /* @__PURE__ */ react.exports.createContext(null);
    const RouteContext = /* @__PURE__ */ react.exports.createContext({
      outlet: null,
      matches: []
    });
    const RouteErrorContext = /* @__PURE__ */ react.exports.createContext(null);
    function useInRouterContext() {
      return react.exports.useContext(LocationContext) != null;
    }
    function useLocation() {
      !useInRouterContext() ? invariant(false) : void 0;
      return react.exports.useContext(LocationContext).location;
    }
    function getPathContributingMatches(matches) {
      return matches.filter((match5, index2) => index2 === 0 || !match5.route.index && match5.pathnameBase !== matches[index2 - 1].pathnameBase);
    }
    function useNavigate() {
      !useInRouterContext() ? invariant(false) : void 0;
      let {
        basename,
        navigator: navigator2
      } = react.exports.useContext(NavigationContext);
      let {
        matches
      } = react.exports.useContext(RouteContext);
      let {
        pathname: locationPathname
      } = useLocation();
      let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map((match5) => match5.pathnameBase));
      let activeRef = react.exports.useRef(false);
      react.exports.useEffect(() => {
        activeRef.current = true;
      });
      let navigate = react.exports.useCallback(function(to2, options) {
        if (options === void 0) {
          options = {};
        }
        if (!activeRef.current)
          return;
        if (typeof to2 === "number") {
          navigator2.go(to2);
          return;
        }
        let path = resolveTo(to2, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
        if (basename !== "/") {
          path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
        }
        (!!options.replace ? navigator2.replace : navigator2.push)(path, options.state, options);
      }, [basename, navigator2, routePathnamesJson, locationPathname]);
      return navigate;
    }
    function useParams() {
      let {
        matches
      } = react.exports.useContext(RouteContext);
      let routeMatch = matches[matches.length - 1];
      return routeMatch ? routeMatch.params : {};
    }
    function useRoutes(routes, locationArg) {
      !useInRouterContext() ? invariant(false) : void 0;
      let dataRouterStateContext = react.exports.useContext(DataRouterStateContext);
      let {
        matches: parentMatches
      } = react.exports.useContext(RouteContext);
      let routeMatch = parentMatches[parentMatches.length - 1];
      let parentParams = routeMatch ? routeMatch.params : {};
      routeMatch ? routeMatch.pathname : "/";
      let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
      routeMatch && routeMatch.route;
      let locationFromContext = useLocation();
      let location2;
      if (locationArg) {
        var _parsedLocationArg$pa;
        let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
        !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant(false) : void 0;
        location2 = parsedLocationArg;
      } else {
        location2 = locationFromContext;
      }
      let pathname = location2.pathname || "/";
      let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
      let matches = matchRoutes(routes, {
        pathname: remainingPathname
      });
      let renderedMatches = _renderMatches(matches && matches.map((match5) => Object.assign({}, match5, {
        params: Object.assign({}, parentParams, match5.params),
        pathname: joinPaths([parentPathnameBase, match5.pathname]),
        pathnameBase: match5.pathnameBase === "/" ? parentPathnameBase : joinPaths([parentPathnameBase, match5.pathnameBase])
      })), parentMatches, dataRouterStateContext || void 0);
      if (locationArg) {
        return /* @__PURE__ */ jsx(LocationContext.Provider, {
          value: {
            location: _extends$1({
              pathname: "/",
              search: "",
              hash: "",
              state: null,
              key: "default"
            }, location2),
            navigationType: Action.Pop
          },
          children: renderedMatches
        });
      }
      return renderedMatches;
    }
    function DefaultErrorElement() {
      let error = useRouteError();
      let message = isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
      let stack = error instanceof Error ? error.stack : null;
      let lightgrey = "rgba(200,200,200, 0.5)";
      let preStyles = {
        padding: "0.5rem",
        backgroundColor: lightgrey
      };
      let codeStyles = {
        padding: "2px 4px",
        backgroundColor: lightgrey
      };
      return /* @__PURE__ */ jsxs(Fragment, {
        children: [/* @__PURE__ */ jsx("h2", {
          children: "Unhandled Thrown Error!"
        }), /* @__PURE__ */ jsx("h3", {
          style: {
            fontStyle: "italic"
          },
          children: message
        }), stack ? /* @__PURE__ */ jsx("pre", {
          style: preStyles,
          children: stack
        }) : null, /* @__PURE__ */ jsx("p", {
          children: "\u{1F4BF} Hey developer \u{1F44B}"
        }), /* @__PURE__ */ jsxs("p", {
          children: ["You can provide a way better UX than this when your app throws errors by providing your own\xA0", /* @__PURE__ */ jsx("code", {
            style: codeStyles,
            children: "errorElement"
          }), " props on\xA0", /* @__PURE__ */ jsx("code", {
            style: codeStyles,
            children: "<Route>"
          })]
        })]
      });
    }
    class RenderErrorBoundary extends react.exports.Component {
      constructor(props2) {
        super(props2);
        this.state = {
          location: props2.location,
          error: props2.error
        };
      }
      static getDerivedStateFromError(error) {
        return {
          error
        };
      }
      static getDerivedStateFromProps(props2, state) {
        if (state.location !== props2.location) {
          return {
            error: props2.error,
            location: props2.location
          };
        }
        return {
          error: props2.error || state.error,
          location: state.location
        };
      }
      componentDidCatch(error, errorInfo) {
        console.error("React Router caught the following error during render", error, errorInfo);
      }
      render() {
        return this.state.error ? /* @__PURE__ */ jsx(RouteErrorContext.Provider, {
          value: this.state.error,
          children: this.props.component
        }) : this.props.children;
      }
    }
    function RenderedRoute(_ref) {
      let {
        routeContext,
        match: match5,
        children
      } = _ref;
      let dataStaticRouterContext = react.exports.useContext(DataStaticRouterContext);
      if (dataStaticRouterContext && match5.route.errorElement) {
        dataStaticRouterContext._deepestRenderedBoundaryId = match5.route.id;
      }
      return /* @__PURE__ */ jsx(RouteContext.Provider, {
        value: routeContext,
        children
      });
    }
    function _renderMatches(matches, parentMatches, dataRouterState) {
      if (parentMatches === void 0) {
        parentMatches = [];
      }
      if (matches == null) {
        if (dataRouterState != null && dataRouterState.errors) {
          matches = dataRouterState.matches;
        } else {
          return null;
        }
      }
      let renderedMatches = matches;
      let errors = dataRouterState == null ? void 0 : dataRouterState.errors;
      if (errors != null) {
        let errorIndex = renderedMatches.findIndex((m2) => m2.route.id && (errors == null ? void 0 : errors[m2.route.id]));
        !(errorIndex >= 0) ? invariant(false) : void 0;
        renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
      }
      return renderedMatches.reduceRight((outlet, match5, index2) => {
        let error = match5.route.id ? errors == null ? void 0 : errors[match5.route.id] : null;
        let errorElement = dataRouterState ? match5.route.errorElement || /* @__PURE__ */ jsx(DefaultErrorElement, {}) : null;
        let getChildren = () => /* @__PURE__ */ jsx(RenderedRoute, {
          match: match5,
          routeContext: {
            outlet,
            matches: parentMatches.concat(renderedMatches.slice(0, index2 + 1))
          },
          children: error ? errorElement : match5.route.element !== void 0 ? match5.route.element : outlet
        });
        return dataRouterState && (match5.route.errorElement || index2 === 0) ? /* @__PURE__ */ jsx(RenderErrorBoundary, {
          location: dataRouterState.location,
          component: errorElement,
          error,
          children: getChildren()
        }) : getChildren();
      }, null);
    }
    var DataRouterHook;
    (function(DataRouterHook2) {
      DataRouterHook2["UseLoaderData"] = "useLoaderData";
      DataRouterHook2["UseActionData"] = "useActionData";
      DataRouterHook2["UseRouteError"] = "useRouteError";
      DataRouterHook2["UseNavigation"] = "useNavigation";
      DataRouterHook2["UseRouteLoaderData"] = "useRouteLoaderData";
      DataRouterHook2["UseMatches"] = "useMatches";
      DataRouterHook2["UseRevalidator"] = "useRevalidator";
    })(DataRouterHook || (DataRouterHook = {}));
    function useDataRouterState(hookName) {
      let state = react.exports.useContext(DataRouterStateContext);
      !state ? invariant(false) : void 0;
      return state;
    }
    function useRouteError() {
      var _state$errors;
      let error = react.exports.useContext(RouteErrorContext);
      let state = useDataRouterState(DataRouterHook.UseRouteError);
      let route = react.exports.useContext(RouteContext);
      let thisRoute = route.matches[route.matches.length - 1];
      if (error) {
        return error;
      }
      !route ? invariant(false) : void 0;
      !thisRoute.route.id ? invariant(false) : void 0;
      return (_state$errors = state.errors) == null ? void 0 : _state$errors[thisRoute.route.id];
    }
    function Route(_props) {
      invariant(false);
    }
    function Router(_ref4) {
      let {
        basename: basenameProp = "/",
        children = null,
        location: locationProp,
        navigationType = Action.Pop,
        navigator: navigator2,
        static: staticProp = false
      } = _ref4;
      !!useInRouterContext() ? invariant(false) : void 0;
      let basename = basenameProp.replace(/^\/*/, "/");
      let navigationContext = react.exports.useMemo(() => ({
        basename,
        navigator: navigator2,
        static: staticProp
      }), [basename, navigator2, staticProp]);
      if (typeof locationProp === "string") {
        locationProp = parsePath(locationProp);
      }
      let {
        pathname = "/",
        search = "",
        hash: hash2 = "",
        state = null,
        key = "default"
      } = locationProp;
      let location2 = react.exports.useMemo(() => {
        let trailingPathname = stripBasename(pathname, basename);
        if (trailingPathname == null) {
          return null;
        }
        return {
          pathname: trailingPathname,
          search,
          hash: hash2,
          state,
          key
        };
      }, [basename, pathname, search, hash2, state, key]);
      if (location2 == null) {
        return null;
      }
      return /* @__PURE__ */ jsx(NavigationContext.Provider, {
        value: navigationContext,
        children: /* @__PURE__ */ jsx(LocationContext.Provider, {
          children,
          value: {
            location: location2,
            navigationType
          }
        })
      });
    }
    function Routes(_ref5) {
      let {
        children,
        location: location2
      } = _ref5;
      let dataRouterContext = react.exports.useContext(DataRouterContext);
      let routes = dataRouterContext && !children ? dataRouterContext.router.routes : createRoutesFromChildren(children);
      return useRoutes(routes, location2);
    }
    var AwaitRenderStatus;
    (function(AwaitRenderStatus2) {
      AwaitRenderStatus2[AwaitRenderStatus2["pending"] = 0] = "pending";
      AwaitRenderStatus2[AwaitRenderStatus2["success"] = 1] = "success";
      AwaitRenderStatus2[AwaitRenderStatus2["error"] = 2] = "error";
    })(AwaitRenderStatus || (AwaitRenderStatus = {}));
    new Promise(() => {
    });
    function createRoutesFromChildren(children, parentPath) {
      if (parentPath === void 0) {
        parentPath = [];
      }
      let routes = [];
      react.exports.Children.forEach(children, (element, index2) => {
        if (!/* @__PURE__ */ react.exports.isValidElement(element)) {
          return;
        }
        if (element.type === react.exports.Fragment) {
          routes.push.apply(routes, createRoutesFromChildren(element.props.children, parentPath));
          return;
        }
        !(element.type === Route) ? invariant(false) : void 0;
        let treePath = [...parentPath, index2];
        let route = {
          id: element.props.id || treePath.join("-"),
          caseSensitive: element.props.caseSensitive,
          element: element.props.element,
          index: element.props.index,
          path: element.props.path,
          loader: element.props.loader,
          action: element.props.action,
          errorElement: element.props.errorElement,
          hasErrorBoundary: element.props.errorElement != null,
          shouldRevalidate: element.props.shouldRevalidate,
          handle: element.props.handle
        };
        if (element.props.children) {
          route.children = createRoutesFromChildren(element.props.children, treePath);
        }
        routes.push(route);
      });
      return routes;
    }
    /**
     * React Router DOM v6.4.0
     *
     * Copyright (c) Remix Software Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     */
    function HashRouter(_ref2) {
      let {
        basename,
        children,
        window: window2
      } = _ref2;
      let historyRef = react.exports.useRef();
      if (historyRef.current == null) {
        historyRef.current = createHashHistory({
          window: window2,
          v5Compat: true
        });
      }
      let history = historyRef.current;
      let [state, setState] = react.exports.useState({
        action: history.action,
        location: history.location
      });
      react.exports.useLayoutEffect(() => history.listen(setState), [history]);
      return /* @__PURE__ */ jsx(Router, {
        basename,
        children,
        location: state.location,
        navigationType: state.action,
        navigator: history
      });
    }
    const App$1 = "";
    const EMPRESAS = [
      { id: "002", name: "YARABAMBA" },
      { id: "001", name: "CAYALT\xCD" }
    ];
    const common = {
      black: "#000",
      white: "#fff"
    };
    const common$1 = common;
    const red = {
      50: "#ffebee",
      100: "#ffcdd2",
      200: "#ef9a9a",
      300: "#e57373",
      400: "#ef5350",
      500: "#f44336",
      600: "#e53935",
      700: "#d32f2f",
      800: "#c62828",
      900: "#b71c1c",
      A100: "#ff8a80",
      A200: "#ff5252",
      A400: "#ff1744",
      A700: "#d50000"
    };
    const red$1 = red;
    const purple = {
      50: "#f3e5f5",
      100: "#e1bee7",
      200: "#ce93d8",
      300: "#ba68c8",
      400: "#ab47bc",
      500: "#9c27b0",
      600: "#8e24aa",
      700: "#7b1fa2",
      800: "#6a1b9a",
      900: "#4a148c",
      A100: "#ea80fc",
      A200: "#e040fb",
      A400: "#d500f9",
      A700: "#aa00ff"
    };
    const purple$1 = purple;
    const blue = {
      50: "#e3f2fd",
      100: "#bbdefb",
      200: "#90caf9",
      300: "#64b5f6",
      400: "#42a5f5",
      500: "#2196f3",
      600: "#1e88e5",
      700: "#1976d2",
      800: "#1565c0",
      900: "#0d47a1",
      A100: "#82b1ff",
      A200: "#448aff",
      A400: "#2979ff",
      A700: "#2962ff"
    };
    const blue$1 = blue;
    const lightBlue = {
      50: "#e1f5fe",
      100: "#b3e5fc",
      200: "#81d4fa",
      300: "#4fc3f7",
      400: "#29b6f6",
      500: "#03a9f4",
      600: "#039be5",
      700: "#0288d1",
      800: "#0277bd",
      900: "#01579b",
      A100: "#80d8ff",
      A200: "#40c4ff",
      A400: "#00b0ff",
      A700: "#0091ea"
    };
    const lightBlue$1 = lightBlue;
    const green = {
      50: "#e8f5e9",
      100: "#c8e6c9",
      200: "#a5d6a7",
      300: "#81c784",
      400: "#66bb6a",
      500: "#4caf50",
      600: "#43a047",
      700: "#388e3c",
      800: "#2e7d32",
      900: "#1b5e20",
      A100: "#b9f6ca",
      A200: "#69f0ae",
      A400: "#00e676",
      A700: "#00c853"
    };
    const green$1 = green;
    const orange = {
      50: "#fff3e0",
      100: "#ffe0b2",
      200: "#ffcc80",
      300: "#ffb74d",
      400: "#ffa726",
      500: "#ff9800",
      600: "#fb8c00",
      700: "#f57c00",
      800: "#ef6c00",
      900: "#e65100",
      A100: "#ffd180",
      A200: "#ffab40",
      A400: "#ff9100",
      A700: "#ff6d00"
    };
    const orange$1 = orange;
    const grey = {
      50: "#fafafa",
      100: "#f5f5f5",
      200: "#eeeeee",
      300: "#e0e0e0",
      400: "#bdbdbd",
      500: "#9e9e9e",
      600: "#757575",
      700: "#616161",
      800: "#424242",
      900: "#212121",
      A100: "#f5f5f5",
      A200: "#eeeeee",
      A400: "#bdbdbd",
      A700: "#616161"
    };
    const grey$1 = grey;
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function memoize$1(fn) {
      var cache = /* @__PURE__ */ Object.create(null);
      return function(arg) {
        if (cache[arg] === void 0)
          cache[arg] = fn(arg);
        return cache[arg];
      };
    }
    var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
    var isPropValid = /* @__PURE__ */ memoize$1(
      function(prop) {
        return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
      }
    );
    function sheetForTag(tag) {
      if (tag.sheet) {
        return tag.sheet;
      }
      for (var i = 0; i < document.styleSheets.length; i++) {
        if (document.styleSheets[i].ownerNode === tag) {
          return document.styleSheets[i];
        }
      }
    }
    function createStyleElement(options) {
      var tag = document.createElement("style");
      tag.setAttribute("data-emotion", options.key);
      if (options.nonce !== void 0) {
        tag.setAttribute("nonce", options.nonce);
      }
      tag.appendChild(document.createTextNode(""));
      tag.setAttribute("data-s", "");
      return tag;
    }
    var StyleSheet = /* @__PURE__ */ function() {
      function StyleSheet2(options) {
        var _this = this;
        this._insertTag = function(tag) {
          var before;
          if (_this.tags.length === 0) {
            if (_this.insertionPoint) {
              before = _this.insertionPoint.nextSibling;
            } else if (_this.prepend) {
              before = _this.container.firstChild;
            } else {
              before = _this.before;
            }
          } else {
            before = _this.tags[_this.tags.length - 1].nextSibling;
          }
          _this.container.insertBefore(tag, before);
          _this.tags.push(tag);
        };
        this.isSpeedy = options.speedy === void 0 ? true : options.speedy;
        this.tags = [];
        this.ctr = 0;
        this.nonce = options.nonce;
        this.key = options.key;
        this.container = options.container;
        this.prepend = options.prepend;
        this.insertionPoint = options.insertionPoint;
        this.before = null;
      }
      var _proto = StyleSheet2.prototype;
      _proto.hydrate = function hydrate(nodes) {
        nodes.forEach(this._insertTag);
      };
      _proto.insert = function insert(rule) {
        if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
          this._insertTag(createStyleElement(this));
        }
        var tag = this.tags[this.tags.length - 1];
        if (this.isSpeedy) {
          var sheet = sheetForTag(tag);
          try {
            sheet.insertRule(rule, sheet.cssRules.length);
          } catch (e2) {
          }
        } else {
          tag.appendChild(document.createTextNode(rule));
        }
        this.ctr++;
      };
      _proto.flush = function flush() {
        this.tags.forEach(function(tag) {
          return tag.parentNode && tag.parentNode.removeChild(tag);
        });
        this.tags = [];
        this.ctr = 0;
      };
      return StyleSheet2;
    }();
    var MS = "-ms-";
    var MOZ = "-moz-";
    var WEBKIT = "-webkit-";
    var COMMENT = "comm";
    var RULESET = "rule";
    var DECLARATION = "decl";
    var IMPORT = "@import";
    var KEYFRAMES = "@keyframes";
    var abs$2 = Math.abs;
    var from$1 = String.fromCharCode;
    var assign = Object.assign;
    function hash$2(value, length2) {
      return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
    }
    function trim(value) {
      return value.trim();
    }
    function match(value, pattern) {
      return (value = pattern.exec(value)) ? value[0] : value;
    }
    function replace(value, pattern, replacement) {
      return value.replace(pattern, replacement);
    }
    function indexof(value, search) {
      return value.indexOf(search);
    }
    function charat(value, index2) {
      return value.charCodeAt(index2) | 0;
    }
    function substr(value, begin, end2) {
      return value.slice(begin, end2);
    }
    function strlen(value) {
      return value.length;
    }
    function sizeof(value) {
      return value.length;
    }
    function append(value, array) {
      return array.push(value), value;
    }
    function combine$1(array, callback) {
      return array.map(callback).join("");
    }
    var line = 1;
    var column = 1;
    var length = 0;
    var position$1 = 0;
    var character = 0;
    var characters = "";
    function node(value, root2, parent, type2, props2, children, length2) {
      return { value, root: root2, parent, type: type2, props: props2, children, line, column, length: length2, return: "" };
    }
    function copy(root2, props2) {
      return assign(node("", null, null, "", null, null, 0), root2, { length: -root2.length }, props2);
    }
    function char() {
      return character;
    }
    function prev() {
      character = position$1 > 0 ? charat(characters, --position$1) : 0;
      if (column--, character === 10)
        column = 1, line--;
      return character;
    }
    function next() {
      character = position$1 < length ? charat(characters, position$1++) : 0;
      if (column++, character === 10)
        column = 1, line++;
      return character;
    }
    function peek() {
      return charat(characters, position$1);
    }
    function caret() {
      return position$1;
    }
    function slice$1(begin, end2) {
      return substr(characters, begin, end2);
    }
    function token$2(type2) {
      switch (type2) {
        case 0:
        case 9:
        case 10:
        case 13:
        case 32:
          return 5;
        case 33:
        case 43:
        case 44:
        case 47:
        case 62:
        case 64:
        case 126:
        case 59:
        case 123:
        case 125:
          return 4;
        case 58:
          return 3;
        case 34:
        case 39:
        case 40:
        case 91:
          return 2;
        case 41:
        case 93:
          return 1;
      }
      return 0;
    }
    function alloc(value) {
      return line = column = 1, length = strlen(characters = value), position$1 = 0, [];
    }
    function dealloc(value) {
      return characters = "", value;
    }
    function delimit(type2) {
      return trim(slice$1(position$1 - 1, delimiter(type2 === 91 ? type2 + 2 : type2 === 40 ? type2 + 1 : type2)));
    }
    function whitespace(type2) {
      while (character = peek())
        if (character < 33)
          next();
        else
          break;
      return token$2(type2) > 2 || token$2(character) > 3 ? "" : " ";
    }
    function escaping(index2, count) {
      while (--count && next())
        if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
          break;
      return slice$1(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
    }
    function delimiter(type2) {
      while (next())
        switch (character) {
          case type2:
            return position$1;
          case 34:
          case 39:
            if (type2 !== 34 && type2 !== 39)
              delimiter(character);
            break;
          case 40:
            if (type2 === 41)
              delimiter(type2);
            break;
          case 92:
            next();
            break;
        }
      return position$1;
    }
    function commenter(type2, index2) {
      while (next())
        if (type2 + character === 47 + 10)
          break;
        else if (type2 + character === 42 + 42 && peek() === 47)
          break;
      return "/*" + slice$1(index2, position$1 - 1) + "*" + from$1(type2 === 47 ? type2 : next());
    }
    function identifier(index2) {
      while (!token$2(peek()))
        next();
      return slice$1(index2, position$1);
    }
    function compile(value) {
      return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
    }
    function parse(value, root2, parent, rule, rules, rulesets, pseudo, points, declarations) {
      var index2 = 0;
      var offset2 = 0;
      var length2 = pseudo;
      var atrule = 0;
      var property = 0;
      var previous = 0;
      var variable = 1;
      var scanning = 1;
      var ampersand = 1;
      var character2 = 0;
      var type2 = "";
      var props2 = rules;
      var children = rulesets;
      var reference2 = rule;
      var characters2 = type2;
      while (scanning)
        switch (previous = character2, character2 = next()) {
          case 40:
            if (previous != 108 && charat(characters2, length2 - 1) == 58) {
              if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
                ampersand = -1;
              break;
            }
          case 34:
          case 39:
          case 91:
            characters2 += delimit(character2);
            break;
          case 9:
          case 10:
          case 13:
          case 32:
            characters2 += whitespace(previous);
            break;
          case 92:
            characters2 += escaping(caret() - 1, 7);
            continue;
          case 47:
            switch (peek()) {
              case 42:
              case 47:
                append(comment(commenter(next(), caret()), root2, parent), declarations);
                break;
              default:
                characters2 += "/";
            }
            break;
          case 123 * variable:
            points[index2++] = strlen(characters2) * ampersand;
          case 125 * variable:
          case 59:
          case 0:
            switch (character2) {
              case 0:
              case 125:
                scanning = 0;
              case 59 + offset2:
                if (property > 0 && strlen(characters2) - length2)
                  append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
                break;
              case 59:
                characters2 += ";";
              default:
                append(reference2 = ruleset(characters2, root2, parent, index2, offset2, rules, points, type2, props2 = [], children = [], length2), rulesets);
                if (character2 === 123)
                  if (offset2 === 0)
                    parse(characters2, root2, reference2, reference2, props2, rulesets, length2, points, children);
                  else
                    switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                      case 100:
                      case 109:
                      case 115:
                        parse(value, reference2, reference2, rule && append(ruleset(value, reference2, reference2, 0, 0, rules, points, type2, rules, props2 = [], length2), children), rules, children, length2, points, rule ? props2 : children);
                        break;
                      default:
                        parse(characters2, reference2, reference2, reference2, [""], children, 0, points, children);
                    }
            }
            index2 = offset2 = property = 0, variable = ampersand = 1, type2 = characters2 = "", length2 = pseudo;
            break;
          case 58:
            length2 = 1 + strlen(characters2), property = previous;
          default:
            if (variable < 1) {
              if (character2 == 123)
                --variable;
              else if (character2 == 125 && variable++ == 0 && prev() == 125)
                continue;
            }
            switch (characters2 += from$1(character2), character2 * variable) {
              case 38:
                ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
                break;
              case 44:
                points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
                break;
              case 64:
                if (peek() === 45)
                  characters2 += delimit(next());
                atrule = peek(), offset2 = length2 = strlen(type2 = characters2 += identifier(caret())), character2++;
                break;
              case 45:
                if (previous === 45 && strlen(characters2) == 2)
                  variable = 0;
            }
        }
      return rulesets;
    }
    function ruleset(value, root2, parent, index2, offset2, rules, points, type2, props2, children, length2) {
      var post = offset2 - 1;
      var rule = offset2 === 0 ? rules : [""];
      var size = sizeof(rule);
      for (var i = 0, j = 0, k2 = 0; i < index2; ++i)
        for (var x2 = 0, y2 = substr(value, post + 1, post = abs$2(j = points[i])), z2 = value; x2 < size; ++x2)
          if (z2 = trim(j > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
            props2[k2++] = z2;
      return node(value, root2, parent, offset2 === 0 ? RULESET : type2, props2, children, length2);
    }
    function comment(value, root2, parent) {
      return node(value, root2, parent, COMMENT, from$1(char()), substr(value, 2, -2), 0);
    }
    function declaration(value, root2, parent, length2) {
      return node(value, root2, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
    }
    function serialize(children, callback) {
      var output = "";
      var length2 = sizeof(children);
      for (var i = 0; i < length2; i++)
        output += callback(children[i], i, children, callback) || "";
      return output;
    }
    function stringify(element, index2, children, callback) {
      switch (element.type) {
        case IMPORT:
        case DECLARATION:
          return element.return = element.return || element.value;
        case COMMENT:
          return "";
        case KEYFRAMES:
          return element.return = element.value + "{" + serialize(element.children, callback) + "}";
        case RULESET:
          element.value = element.props.join(",");
      }
      return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
    }
    function middleware(collection) {
      var length2 = sizeof(collection);
      return function(element, index2, children, callback) {
        var output = "";
        for (var i = 0; i < length2; i++)
          output += collection[i](element, index2, children, callback) || "";
        return output;
      };
    }
    function rulesheet(callback) {
      return function(element) {
        if (!element.root) {
          if (element = element.return)
            callback(element);
        }
      };
    }
    var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index2) {
      var previous = 0;
      var character2 = 0;
      while (true) {
        previous = character2;
        character2 = peek();
        if (previous === 38 && character2 === 12) {
          points[index2] = 1;
        }
        if (token$2(character2)) {
          break;
        }
        next();
      }
      return slice$1(begin, position$1);
    };
    var toRules = function toRules2(parsed, points) {
      var index2 = -1;
      var character2 = 44;
      do {
        switch (token$2(character2)) {
          case 0:
            if (character2 === 38 && peek() === 12) {
              points[index2] = 1;
            }
            parsed[index2] += identifierWithPointTracking(position$1 - 1, points, index2);
            break;
          case 2:
            parsed[index2] += delimit(character2);
            break;
          case 4:
            if (character2 === 44) {
              parsed[++index2] = peek() === 58 ? "&\f" : "";
              points[index2] = parsed[index2].length;
              break;
            }
          default:
            parsed[index2] += from$1(character2);
        }
      } while (character2 = next());
      return parsed;
    };
    var getRules = function getRules2(value, points) {
      return dealloc(toRules(alloc(value), points));
    };
    var fixedElements = /* @__PURE__ */ new WeakMap();
    var compat = function compat2(element) {
      if (element.type !== "rule" || !element.parent || element.length < 1) {
        return;
      }
      var value = element.value, parent = element.parent;
      var isImplicitRule = element.column === parent.column && element.line === parent.line;
      while (parent.type !== "rule") {
        parent = parent.parent;
        if (!parent)
          return;
      }
      if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
        return;
      }
      if (isImplicitRule) {
        return;
      }
      fixedElements.set(element, true);
      var points = [];
      var rules = getRules(value, points);
      var parentRules = parent.props;
      for (var i = 0, k2 = 0; i < rules.length; i++) {
        for (var j = 0; j < parentRules.length; j++, k2++) {
          element.props[k2] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
        }
      }
    };
    var removeLabel = function removeLabel2(element) {
      if (element.type === "decl") {
        var value = element.value;
        if (value.charCodeAt(0) === 108 && value.charCodeAt(2) === 98) {
          element["return"] = "";
          element.value = "";
        }
      }
    };
    function prefix(value, length2) {
      switch (hash$2(value, length2)) {
        case 5103:
          return WEBKIT + "print-" + value + value;
        case 5737:
        case 4201:
        case 3177:
        case 3433:
        case 1641:
        case 4457:
        case 2921:
        case 5572:
        case 6356:
        case 5844:
        case 3191:
        case 6645:
        case 3005:
        case 6391:
        case 5879:
        case 5623:
        case 6135:
        case 4599:
        case 4855:
        case 4215:
        case 6389:
        case 5109:
        case 5365:
        case 5621:
        case 3829:
          return WEBKIT + value + value;
        case 5349:
        case 4246:
        case 4810:
        case 6968:
        case 2756:
          return WEBKIT + value + MOZ + value + MS + value + value;
        case 6828:
        case 4268:
          return WEBKIT + value + MS + value + value;
        case 6165:
          return WEBKIT + value + MS + "flex-" + value + value;
        case 5187:
          return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
        case 5443:
          return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
        case 4675:
          return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
        case 5548:
          return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
        case 5292:
          return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
        case 6060:
          return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
        case 4554:
          return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
        case 6187:
          return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
        case 5495:
        case 3959:
          return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
        case 4968:
          return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
        case 4095:
        case 3583:
        case 4068:
        case 2532:
          return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
        case 8116:
        case 7059:
        case 5753:
        case 5535:
        case 5445:
        case 5701:
        case 4933:
        case 4677:
        case 5533:
        case 5789:
        case 5021:
        case 4765:
          if (strlen(value) - 1 - length2 > 6)
            switch (charat(value, length2 + 1)) {
              case 109:
                if (charat(value, length2 + 4) !== 45)
                  break;
              case 102:
                return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
              case 115:
                return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length2) + value : value;
            }
          break;
        case 4949:
          if (charat(value, length2 + 1) !== 115)
            break;
        case 6444:
          switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
            case 107:
              return replace(value, ":", ":" + WEBKIT) + value;
            case 101:
              return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
          }
          break;
        case 5936:
          switch (charat(value, length2 + 11)) {
            case 114:
              return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
            case 108:
              return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
            case 45:
              return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
          }
          return WEBKIT + value + MS + value + value;
      }
      return value;
    }
    var prefixer = function prefixer2(element, index2, children, callback) {
      if (element.length > -1) {
        if (!element["return"])
          switch (element.type) {
            case DECLARATION:
              element["return"] = prefix(element.value, element.length);
              break;
            case KEYFRAMES:
              return serialize([copy(element, {
                value: replace(element.value, "@", "@" + WEBKIT)
              })], callback);
            case RULESET:
              if (element.length)
                return combine$1(element.props, function(value) {
                  switch (match(value, /(::plac\w+|:read-\w+)/)) {
                    case ":read-only":
                    case ":read-write":
                      return serialize([copy(element, {
                        props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
                      })], callback);
                    case "::placeholder":
                      return serialize([copy(element, {
                        props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                      }), copy(element, {
                        props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
                      }), copy(element, {
                        props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
                      })], callback);
                  }
                  return "";
                });
          }
      }
    };
    var defaultStylisPlugins = [prefixer];
    var createCache = function createCache2(options) {
      var key = options.key;
      if (key === "css") {
        var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
        Array.prototype.forEach.call(ssrStyles, function(node2) {
          var dataEmotionAttribute = node2.getAttribute("data-emotion");
          if (dataEmotionAttribute.indexOf(" ") === -1) {
            return;
          }
          document.head.appendChild(node2);
          node2.setAttribute("data-s", "");
        });
      }
      var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
      var inserted = {};
      var container;
      var nodesToHydrate = [];
      {
        container = options.container || document.head;
        Array.prototype.forEach.call(
          document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
          function(node2) {
            var attrib = node2.getAttribute("data-emotion").split(" ");
            for (var i = 1; i < attrib.length; i++) {
              inserted[attrib[i]] = true;
            }
            nodesToHydrate.push(node2);
          }
        );
      }
      var _insert;
      var omnipresentPlugins = [compat, removeLabel];
      {
        var currentSheet;
        var finalizingPlugins = [stringify, rulesheet(function(rule) {
          currentSheet.insert(rule);
        })];
        var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
        var stylis = function stylis2(styles2) {
          return serialize(compile(styles2), serializer);
        };
        _insert = function insert(selector, serialized, sheet, shouldCache) {
          currentSheet = sheet;
          stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
          if (shouldCache) {
            cache.inserted[serialized.name] = true;
          }
        };
      }
      var cache = {
        key,
        sheet: new StyleSheet({
          key,
          container,
          nonce: options.nonce,
          speedy: options.speedy,
          prepend: options.prepend,
          insertionPoint: options.insertionPoint
        }),
        nonce: options.nonce,
        inserted,
        registered: {},
        insert: _insert
      };
      cache.sheet.hydrate(nodesToHydrate);
      return cache;
    };
    var reactIs$2 = { exports: {} };
    var reactIs_production_min$1 = {};
    /** @license React v16.13.1
     * react-is.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var b$1 = "function" === typeof Symbol && Symbol.for, c$1 = b$1 ? Symbol.for("react.element") : 60103, d$1 = b$1 ? Symbol.for("react.portal") : 60106, e$1 = b$1 ? Symbol.for("react.fragment") : 60107, f$1 = b$1 ? Symbol.for("react.strict_mode") : 60108, g$1 = b$1 ? Symbol.for("react.profiler") : 60114, h$1 = b$1 ? Symbol.for("react.provider") : 60109, k$1 = b$1 ? Symbol.for("react.context") : 60110, l$1 = b$1 ? Symbol.for("react.async_mode") : 60111, m$1 = b$1 ? Symbol.for("react.concurrent_mode") : 60111, n$1 = b$1 ? Symbol.for("react.forward_ref") : 60112, p$1 = b$1 ? Symbol.for("react.suspense") : 60113, q$1 = b$1 ? Symbol.for("react.suspense_list") : 60120, r$1 = b$1 ? Symbol.for("react.memo") : 60115, t$1 = b$1 ? Symbol.for("react.lazy") : 60116, v$1 = b$1 ? Symbol.for("react.block") : 60121, w = b$1 ? Symbol.for("react.fundamental") : 60117, x = b$1 ? Symbol.for("react.responder") : 60118, y = b$1 ? Symbol.for("react.scope") : 60119;
    function z(a) {
      if ("object" === typeof a && null !== a) {
        var u2 = a.$$typeof;
        switch (u2) {
          case c$1:
            switch (a = a.type, a) {
              case l$1:
              case m$1:
              case e$1:
              case g$1:
              case f$1:
              case p$1:
                return a;
              default:
                switch (a = a && a.$$typeof, a) {
                  case k$1:
                  case n$1:
                  case t$1:
                  case r$1:
                  case h$1:
                    return a;
                  default:
                    return u2;
                }
            }
          case d$1:
            return u2;
        }
      }
    }
    function A(a) {
      return z(a) === m$1;
    }
    reactIs_production_min$1.AsyncMode = l$1;
    reactIs_production_min$1.ConcurrentMode = m$1;
    reactIs_production_min$1.ContextConsumer = k$1;
    reactIs_production_min$1.ContextProvider = h$1;
    reactIs_production_min$1.Element = c$1;
    reactIs_production_min$1.ForwardRef = n$1;
    reactIs_production_min$1.Fragment = e$1;
    reactIs_production_min$1.Lazy = t$1;
    reactIs_production_min$1.Memo = r$1;
    reactIs_production_min$1.Portal = d$1;
    reactIs_production_min$1.Profiler = g$1;
    reactIs_production_min$1.StrictMode = f$1;
    reactIs_production_min$1.Suspense = p$1;
    reactIs_production_min$1.isAsyncMode = function(a) {
      return A(a) || z(a) === l$1;
    };
    reactIs_production_min$1.isConcurrentMode = A;
    reactIs_production_min$1.isContextConsumer = function(a) {
      return z(a) === k$1;
    };
    reactIs_production_min$1.isContextProvider = function(a) {
      return z(a) === h$1;
    };
    reactIs_production_min$1.isElement = function(a) {
      return "object" === typeof a && null !== a && a.$$typeof === c$1;
    };
    reactIs_production_min$1.isForwardRef = function(a) {
      return z(a) === n$1;
    };
    reactIs_production_min$1.isFragment = function(a) {
      return z(a) === e$1;
    };
    reactIs_production_min$1.isLazy = function(a) {
      return z(a) === t$1;
    };
    reactIs_production_min$1.isMemo = function(a) {
      return z(a) === r$1;
    };
    reactIs_production_min$1.isPortal = function(a) {
      return z(a) === d$1;
    };
    reactIs_production_min$1.isProfiler = function(a) {
      return z(a) === g$1;
    };
    reactIs_production_min$1.isStrictMode = function(a) {
      return z(a) === f$1;
    };
    reactIs_production_min$1.isSuspense = function(a) {
      return z(a) === p$1;
    };
    reactIs_production_min$1.isValidElementType = function(a) {
      return "string" === typeof a || "function" === typeof a || a === e$1 || a === m$1 || a === g$1 || a === f$1 || a === p$1 || a === q$1 || "object" === typeof a && null !== a && (a.$$typeof === t$1 || a.$$typeof === r$1 || a.$$typeof === h$1 || a.$$typeof === k$1 || a.$$typeof === n$1 || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v$1);
    };
    reactIs_production_min$1.typeOf = z;
    (function(module2) {
      {
        module2.exports = reactIs_production_min$1;
      }
    })(reactIs$2);
    var reactIs$1 = reactIs$2.exports;
    var FORWARD_REF_STATICS = {
      "$$typeof": true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
    };
    var MEMO_STATICS = {
      "$$typeof": true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs$1.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs$1.Memo] = MEMO_STATICS;
    var isBrowser = true;
    function getRegisteredStyles(registered, registeredStyles, classNames) {
      var rawClassName = "";
      classNames.split(" ").forEach(function(className) {
        if (registered[className] !== void 0) {
          registeredStyles.push(registered[className] + ";");
        } else {
          rawClassName += className + " ";
        }
      });
      return rawClassName;
    }
    var registerStyles = function registerStyles2(cache, serialized, isStringTag2) {
      var className = cache.key + "-" + serialized.name;
      if ((isStringTag2 === false || isBrowser === false) && cache.registered[className] === void 0) {
        cache.registered[className] = serialized.styles;
      }
    };
    var insertStyles = function insertStyles2(cache, serialized, isStringTag2) {
      registerStyles(cache, serialized, isStringTag2);
      var className = cache.key + "-" + serialized.name;
      if (cache.inserted[serialized.name] === void 0) {
        var current = serialized;
        do {
          cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
          current = current.next;
        } while (current !== void 0);
      }
    };
    function murmur2(str) {
      var h2 = 0;
      var k2, i = 0, len = str.length;
      for (; len >= 4; ++i, len -= 4) {
        k2 = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
        k2 = (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
        k2 ^= k2 >>> 24;
        h2 = (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      }
      switch (len) {
        case 3:
          h2 ^= (str.charCodeAt(i + 2) & 255) << 16;
        case 2:
          h2 ^= (str.charCodeAt(i + 1) & 255) << 8;
        case 1:
          h2 ^= str.charCodeAt(i) & 255;
          h2 = (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      }
      h2 ^= h2 >>> 13;
      h2 = (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
    }
    var unitlessKeys = {
      animationIterationCount: 1,
      borderImageOutset: 1,
      borderImageSlice: 1,
      borderImageWidth: 1,
      boxFlex: 1,
      boxFlexGroup: 1,
      boxOrdinalGroup: 1,
      columnCount: 1,
      columns: 1,
      flex: 1,
      flexGrow: 1,
      flexPositive: 1,
      flexShrink: 1,
      flexNegative: 1,
      flexOrder: 1,
      gridRow: 1,
      gridRowEnd: 1,
      gridRowSpan: 1,
      gridRowStart: 1,
      gridColumn: 1,
      gridColumnEnd: 1,
      gridColumnSpan: 1,
      gridColumnStart: 1,
      msGridRow: 1,
      msGridRowSpan: 1,
      msGridColumn: 1,
      msGridColumnSpan: 1,
      fontWeight: 1,
      lineHeight: 1,
      opacity: 1,
      order: 1,
      orphans: 1,
      tabSize: 1,
      widows: 1,
      zIndex: 1,
      zoom: 1,
      WebkitLineClamp: 1,
      fillOpacity: 1,
      floodOpacity: 1,
      stopOpacity: 1,
      strokeDasharray: 1,
      strokeDashoffset: 1,
      strokeMiterlimit: 1,
      strokeOpacity: 1,
      strokeWidth: 1
    };
    var hyphenateRegex = /[A-Z]|^ms/g;
    var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
    var isCustomProperty = function isCustomProperty2(property) {
      return property.charCodeAt(1) === 45;
    };
    var isProcessableValue = function isProcessableValue2(value) {
      return value != null && typeof value !== "boolean";
    };
    var processStyleName = /* @__PURE__ */ memoize$1(function(styleName) {
      return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
    });
    var processStyleValue = function processStyleValue2(key, value) {
      switch (key) {
        case "animation":
        case "animationName": {
          if (typeof value === "string") {
            return value.replace(animationRegex, function(match5, p1, p2) {
              cursor = {
                name: p1,
                styles: p2,
                next: cursor
              };
              return p1;
            });
          }
        }
      }
      if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
        return value + "px";
      }
      return value;
    };
    var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
    function handleInterpolation(mergedProps, registered, interpolation) {
      if (interpolation == null) {
        return "";
      }
      if (interpolation.__emotion_styles !== void 0) {
        return interpolation;
      }
      switch (typeof interpolation) {
        case "boolean": {
          return "";
        }
        case "object": {
          if (interpolation.anim === 1) {
            cursor = {
              name: interpolation.name,
              styles: interpolation.styles,
              next: cursor
            };
            return interpolation.name;
          }
          if (interpolation.styles !== void 0) {
            var next2 = interpolation.next;
            if (next2 !== void 0) {
              while (next2 !== void 0) {
                cursor = {
                  name: next2.name,
                  styles: next2.styles,
                  next: cursor
                };
                next2 = next2.next;
              }
            }
            var styles2 = interpolation.styles + ";";
            return styles2;
          }
          return createStringFromObject(mergedProps, registered, interpolation);
        }
        case "function": {
          if (mergedProps !== void 0) {
            var previousCursor = cursor;
            var result = interpolation(mergedProps);
            cursor = previousCursor;
            return handleInterpolation(mergedProps, registered, result);
          }
          break;
        }
      }
      if (registered == null) {
        return interpolation;
      }
      var cached = registered[interpolation];
      return cached !== void 0 ? cached : interpolation;
    }
    function createStringFromObject(mergedProps, registered, obj) {
      var string = "";
      if (Array.isArray(obj)) {
        for (var i = 0; i < obj.length; i++) {
          string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
        }
      } else {
        for (var _key in obj) {
          var value = obj[_key];
          if (typeof value !== "object") {
            if (registered != null && registered[value] !== void 0) {
              string += _key + "{" + registered[value] + "}";
            } else if (isProcessableValue(value)) {
              string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
            }
          } else {
            if (_key === "NO_COMPONENT_SELECTOR" && false) {
              throw new Error(noComponentSelectorMessage);
            }
            if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
              for (var _i = 0; _i < value.length; _i++) {
                if (isProcessableValue(value[_i])) {
                  string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
                }
              }
            } else {
              var interpolated = handleInterpolation(mergedProps, registered, value);
              switch (_key) {
                case "animation":
                case "animationName": {
                  string += processStyleName(_key) + ":" + interpolated + ";";
                  break;
                }
                default: {
                  string += _key + "{" + interpolated + "}";
                }
              }
            }
          }
        }
      }
      return string;
    }
    var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
    var cursor;
    var serializeStyles = function serializeStyles2(args, registered, mergedProps) {
      if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
        return args[0];
      }
      var stringMode = true;
      var styles2 = "";
      cursor = void 0;
      var strings = args[0];
      if (strings == null || strings.raw === void 0) {
        stringMode = false;
        styles2 += handleInterpolation(mergedProps, registered, strings);
      } else {
        styles2 += strings[0];
      }
      for (var i = 1; i < args.length; i++) {
        styles2 += handleInterpolation(mergedProps, registered, args[i]);
        if (stringMode) {
          styles2 += strings[i];
        }
      }
      labelPattern.lastIndex = 0;
      var identifierName = "";
      var match5;
      while ((match5 = labelPattern.exec(styles2)) !== null) {
        identifierName += "-" + match5[1];
      }
      var name = murmur2(styles2) + identifierName;
      return {
        name,
        styles: styles2,
        next: cursor
      };
    };
    var syncFallback = function syncFallback2(create) {
      return create();
    };
    var useInsertionEffect = React$1["useInsertionEffect"] ? React$1["useInsertionEffect"] : false;
    var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
    var useInsertionEffectWithLayoutFallback = useInsertionEffect || react.exports.useLayoutEffect;
    var EmotionCacheContext = /* @__PURE__ */ react.exports.createContext(
      typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
        key: "css"
      }) : null
    );
    EmotionCacheContext.Provider;
    var withEmotionCache = function withEmotionCache2(func) {
      return /* @__PURE__ */ react.exports.forwardRef(function(props2, ref) {
        var cache = react.exports.useContext(EmotionCacheContext);
        return func(props2, cache, ref);
      });
    };
    var ThemeContext$2 = /* @__PURE__ */ react.exports.createContext({});
    var Global = /* @__PURE__ */ withEmotionCache(function(props2, cache) {
      var styles2 = props2.styles;
      var serialized = serializeStyles([styles2], void 0, react.exports.useContext(ThemeContext$2));
      var sheetRef = react.exports.useRef();
      useInsertionEffectWithLayoutFallback(function() {
        var key = cache.key + "-global";
        var sheet = new cache.sheet.constructor({
          key,
          nonce: cache.sheet.nonce,
          container: cache.sheet.container,
          speedy: cache.sheet.isSpeedy
        });
        var rehydrating = false;
        var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
        if (cache.sheet.tags.length) {
          sheet.before = cache.sheet.tags[0];
        }
        if (node2 !== null) {
          rehydrating = true;
          node2.setAttribute("data-emotion", key);
          sheet.hydrate([node2]);
        }
        sheetRef.current = [sheet, rehydrating];
        return function() {
          sheet.flush();
        };
      }, [cache]);
      useInsertionEffectWithLayoutFallback(function() {
        var sheetRefCurrent = sheetRef.current;
        var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
        if (rehydrating) {
          sheetRefCurrent[1] = false;
          return;
        }
        if (serialized.next !== void 0) {
          insertStyles(cache, serialized.next, true);
        }
        if (sheet.tags.length) {
          var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
          sheet.before = element;
          sheet.flush();
        }
        cache.insert("", serialized, sheet, false);
      }, [cache, serialized.name]);
      return null;
    });
    function css() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return serializeStyles(args);
    }
    var keyframes = function keyframes2() {
      var insertable = css.apply(void 0, arguments);
      var name = "animation-" + insertable.name;
      return {
        name,
        styles: "@keyframes " + name + "{" + insertable.styles + "}",
        anim: 1,
        toString: function toString2() {
          return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
        }
      };
    };
    var testOmitPropsOnStringTag = isPropValid;
    var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key) {
      return key !== "theme";
    };
    var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
      return typeof tag === "string" && tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
    };
    var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal) {
      var shouldForwardProp2;
      if (options) {
        var optionsShouldForwardProp = options.shouldForwardProp;
        shouldForwardProp2 = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
          return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
        } : optionsShouldForwardProp;
      }
      if (typeof shouldForwardProp2 !== "function" && isReal) {
        shouldForwardProp2 = tag.__emotion_forwardProp;
      }
      return shouldForwardProp2;
    };
    var Insertion = function Insertion2(_ref) {
      var cache = _ref.cache, serialized = _ref.serialized, isStringTag2 = _ref.isStringTag;
      registerStyles(cache, serialized, isStringTag2);
      useInsertionEffectAlwaysWithSyncFallback(function() {
        return insertStyles(cache, serialized, isStringTag2);
      });
      return null;
    };
    var createStyled$1 = function createStyled2(tag, options) {
      var isReal = tag.__emotion_real === tag;
      var baseTag = isReal && tag.__emotion_base || tag;
      var identifierName;
      var targetClassName;
      if (options !== void 0) {
        identifierName = options.label;
        targetClassName = options.target;
      }
      var shouldForwardProp2 = composeShouldForwardProps(tag, options, isReal);
      var defaultShouldForwardProp = shouldForwardProp2 || getDefaultShouldForwardProp(baseTag);
      var shouldUseAs = !defaultShouldForwardProp("as");
      return function() {
        var args = arguments;
        var styles2 = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
        if (identifierName !== void 0) {
          styles2.push("label:" + identifierName + ";");
        }
        if (args[0] == null || args[0].raw === void 0) {
          styles2.push.apply(styles2, args);
        } else {
          styles2.push(args[0][0]);
          var len = args.length;
          var i = 1;
          for (; i < len; i++) {
            styles2.push(args[i], args[0][i]);
          }
        }
        var Styled = withEmotionCache(function(props2, cache, ref) {
          var FinalTag = shouldUseAs && props2.as || baseTag;
          var className = "";
          var classInterpolations = [];
          var mergedProps = props2;
          if (props2.theme == null) {
            mergedProps = {};
            for (var key in props2) {
              mergedProps[key] = props2[key];
            }
            mergedProps.theme = react.exports.useContext(ThemeContext$2);
          }
          if (typeof props2.className === "string") {
            className = getRegisteredStyles(cache.registered, classInterpolations, props2.className);
          } else if (props2.className != null) {
            className = props2.className + " ";
          }
          var serialized = serializeStyles(styles2.concat(classInterpolations), cache.registered, mergedProps);
          className += cache.key + "-" + serialized.name;
          if (targetClassName !== void 0) {
            className += " " + targetClassName;
          }
          var finalShouldForwardProp = shouldUseAs && shouldForwardProp2 === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
          var newProps = {};
          for (var _key in props2) {
            if (shouldUseAs && _key === "as")
              continue;
            if (finalShouldForwardProp(_key)) {
              newProps[_key] = props2[_key];
            }
          }
          newProps.className = className;
          newProps.ref = ref;
          return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, /* @__PURE__ */ react.exports.createElement(Insertion, {
            cache,
            serialized,
            isStringTag: typeof FinalTag === "string"
          }), /* @__PURE__ */ react.exports.createElement(FinalTag, newProps));
        });
        Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
        Styled.defaultProps = tag.defaultProps;
        Styled.__emotion_real = Styled;
        Styled.__emotion_base = baseTag;
        Styled.__emotion_styles = styles2;
        Styled.__emotion_forwardProp = shouldForwardProp2;
        Object.defineProperty(Styled, "toString", {
          value: function value() {
            if (targetClassName === void 0 && false) {
              return "NO_COMPONENT_SELECTOR";
            }
            return "." + targetClassName;
          }
        });
        Styled.withComponent = function(nextTag, nextOptions) {
          return createStyled2(nextTag, _extends({}, options, nextOptions, {
            shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
          })).apply(void 0, styles2);
        };
        return Styled;
      };
    };
    var tags = [
      "a",
      "abbr",
      "address",
      "area",
      "article",
      "aside",
      "audio",
      "b",
      "base",
      "bdi",
      "bdo",
      "big",
      "blockquote",
      "body",
      "br",
      "button",
      "canvas",
      "caption",
      "cite",
      "code",
      "col",
      "colgroup",
      "data",
      "datalist",
      "dd",
      "del",
      "details",
      "dfn",
      "dialog",
      "div",
      "dl",
      "dt",
      "em",
      "embed",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hgroup",
      "hr",
      "html",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "keygen",
      "label",
      "legend",
      "li",
      "link",
      "main",
      "map",
      "mark",
      "marquee",
      "menu",
      "menuitem",
      "meta",
      "meter",
      "nav",
      "noscript",
      "object",
      "ol",
      "optgroup",
      "option",
      "output",
      "p",
      "param",
      "picture",
      "pre",
      "progress",
      "q",
      "rp",
      "rt",
      "ruby",
      "s",
      "samp",
      "script",
      "section",
      "select",
      "small",
      "source",
      "span",
      "strong",
      "style",
      "sub",
      "summary",
      "sup",
      "table",
      "tbody",
      "td",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "title",
      "tr",
      "track",
      "u",
      "ul",
      "var",
      "video",
      "wbr",
      "circle",
      "clipPath",
      "defs",
      "ellipse",
      "foreignObject",
      "g",
      "image",
      "line",
      "linearGradient",
      "mask",
      "path",
      "pattern",
      "polygon",
      "polyline",
      "radialGradient",
      "rect",
      "stop",
      "svg",
      "text",
      "tspan"
    ];
    var newStyled = createStyled$1.bind();
    tags.forEach(function(tagName) {
      newStyled[tagName] = newStyled(tagName);
    });
    const emStyled = newStyled;
    function isEmpty$4(obj) {
      return obj === void 0 || obj === null || Object.keys(obj).length === 0;
    }
    function GlobalStyles$1(props2) {
      const {
        styles: styles2,
        defaultTheme: defaultTheme2 = {}
      } = props2;
      const globalStyles = typeof styles2 === "function" ? (themeInput) => styles2(isEmpty$4(themeInput) ? defaultTheme2 : themeInput) : styles2;
      return /* @__PURE__ */ jsx(Global, {
        styles: globalStyles
      });
    }
    /** @license MUI v5.10.16
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    function styled$3(tag, options) {
      const stylesFactory = emStyled(tag, options);
      return stylesFactory;
    }
    const internal_processStyles = (tag, processor) => {
      if (Array.isArray(tag.__emotion_styles)) {
        tag.__emotion_styles = processor(tag.__emotion_styles);
      }
    };
    function isPlainObject(item) {
      return item !== null && typeof item === "object" && item.constructor === Object;
    }
    function deepmerge(target, source, options = {
      clone: true
    }) {
      const output = options.clone ? _extends({}, target) : target;
      if (isPlainObject(target) && isPlainObject(source)) {
        Object.keys(source).forEach((key) => {
          if (key === "__proto__") {
            return;
          }
          if (isPlainObject(source[key]) && key in target && isPlainObject(target[key])) {
            output[key] = deepmerge(target[key], source[key], options);
          } else {
            output[key] = source[key];
          }
        });
      }
      return output;
    }
    function formatMuiErrorMessage(code) {
      let url = "https://mui.com/production-error/?code=" + code;
      for (let i = 1; i < arguments.length; i += 1) {
        url += "&args[]=" + encodeURIComponent(arguments[i]);
      }
      return "Minified MUI error #" + code + "; visit " + url + " for the full message.";
    }
    var reactIs = { exports: {} };
    var reactIs_production_min = {};
    /**
     * @license React
     * react-is.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var b = Symbol.for("react.element"), c = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), e = Symbol.for("react.strict_mode"), f = Symbol.for("react.profiler"), g = Symbol.for("react.provider"), h = Symbol.for("react.context"), k = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), m = Symbol.for("react.suspense"), n = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), q = Symbol.for("react.lazy"), t = Symbol.for("react.offscreen"), u;
    u = Symbol.for("react.module.reference");
    function v(a) {
      if ("object" === typeof a && null !== a) {
        var r2 = a.$$typeof;
        switch (r2) {
          case b:
            switch (a = a.type, a) {
              case d:
              case f:
              case e:
              case m:
              case n:
                return a;
              default:
                switch (a = a && a.$$typeof, a) {
                  case k:
                  case h:
                  case l:
                  case q:
                  case p:
                  case g:
                    return a;
                  default:
                    return r2;
                }
            }
          case c:
            return r2;
        }
      }
    }
    reactIs_production_min.ContextConsumer = h;
    reactIs_production_min.ContextProvider = g;
    reactIs_production_min.Element = b;
    reactIs_production_min.ForwardRef = l;
    reactIs_production_min.Fragment = d;
    reactIs_production_min.Lazy = q;
    reactIs_production_min.Memo = p;
    reactIs_production_min.Portal = c;
    reactIs_production_min.Profiler = f;
    reactIs_production_min.StrictMode = e;
    reactIs_production_min.Suspense = m;
    reactIs_production_min.SuspenseList = n;
    reactIs_production_min.isAsyncMode = function() {
      return false;
    };
    reactIs_production_min.isConcurrentMode = function() {
      return false;
    };
    reactIs_production_min.isContextConsumer = function(a) {
      return v(a) === h;
    };
    reactIs_production_min.isContextProvider = function(a) {
      return v(a) === g;
    };
    reactIs_production_min.isElement = function(a) {
      return "object" === typeof a && null !== a && a.$$typeof === b;
    };
    reactIs_production_min.isForwardRef = function(a) {
      return v(a) === l;
    };
    reactIs_production_min.isFragment = function(a) {
      return v(a) === d;
    };
    reactIs_production_min.isLazy = function(a) {
      return v(a) === q;
    };
    reactIs_production_min.isMemo = function(a) {
      return v(a) === p;
    };
    reactIs_production_min.isPortal = function(a) {
      return v(a) === c;
    };
    reactIs_production_min.isProfiler = function(a) {
      return v(a) === f;
    };
    reactIs_production_min.isStrictMode = function(a) {
      return v(a) === e;
    };
    reactIs_production_min.isSuspense = function(a) {
      return v(a) === m;
    };
    reactIs_production_min.isSuspenseList = function(a) {
      return v(a) === n;
    };
    reactIs_production_min.isValidElementType = function(a) {
      return "string" === typeof a || "function" === typeof a || a === d || a === f || a === e || a === m || a === n || a === t || "object" === typeof a && null !== a && (a.$$typeof === q || a.$$typeof === p || a.$$typeof === g || a.$$typeof === h || a.$$typeof === l || a.$$typeof === u || void 0 !== a.getModuleId) ? true : false;
    };
    reactIs_production_min.typeOf = v;
    (function(module2) {
      {
        module2.exports = reactIs_production_min;
      }
    })(reactIs);
    function capitalize(string) {
      if (typeof string !== "string") {
        throw new Error(formatMuiErrorMessage(7));
      }
      return string.charAt(0).toUpperCase() + string.slice(1);
    }
    function createChainedFunction(...funcs) {
      return funcs.reduce((acc, func) => {
        if (func == null) {
          return acc;
        }
        return function chainedFunction(...args) {
          acc.apply(this, args);
          func.apply(this, args);
        };
      }, () => {
      });
    }
    function debounce$1(func, wait = 166) {
      let timeout;
      function debounced(...args) {
        const later = () => {
          func.apply(this, args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      }
      debounced.clear = () => {
        clearTimeout(timeout);
      };
      return debounced;
    }
    function deprecatedPropType(validator, reason) {
      {
        return () => null;
      }
    }
    function isMuiElement(element, muiNames) {
      return /* @__PURE__ */ react.exports.isValidElement(element) && muiNames.indexOf(element.type.muiName) !== -1;
    }
    function ownerDocument(node2) {
      return node2 && node2.ownerDocument || document;
    }
    function ownerWindow(node2) {
      const doc = ownerDocument(node2);
      return doc.defaultView || window;
    }
    function requirePropFactory(componentNameInError, Component) {
      {
        return () => null;
      }
    }
    function setRef(ref, value) {
      if (typeof ref === "function") {
        ref(value);
      } else if (ref) {
        ref.current = value;
      }
    }
    const useEnhancedEffect = typeof window !== "undefined" ? react.exports.useLayoutEffect : react.exports.useEffect;
    const useEnhancedEffect$1 = useEnhancedEffect;
    let globalId = 0;
    function useGlobalId(idOverride) {
      const [defaultId, setDefaultId] = react.exports.useState(idOverride);
      const id2 = idOverride || defaultId;
      react.exports.useEffect(() => {
        if (defaultId == null) {
          globalId += 1;
          setDefaultId(`mui-${globalId}`);
        }
      }, [defaultId]);
      return id2;
    }
    const maybeReactUseId = React$1["useId"];
    function useId(idOverride) {
      if (maybeReactUseId !== void 0) {
        const reactId = maybeReactUseId();
        return idOverride != null ? idOverride : reactId;
      }
      return useGlobalId(idOverride);
    }
    function unsupportedProp(props2, propName, componentName, location2, propFullName) {
      {
        return null;
      }
    }
    function useControlled({
      controlled,
      default: defaultProp,
      name,
      state = "value"
    }) {
      const {
        current: isControlled
      } = react.exports.useRef(controlled !== void 0);
      const [valueState, setValue] = react.exports.useState(defaultProp);
      const value = isControlled ? controlled : valueState;
      const setValueIfUncontrolled = react.exports.useCallback((newValue) => {
        if (!isControlled) {
          setValue(newValue);
        }
      }, []);
      return [value, setValueIfUncontrolled];
    }
    function useEventCallback(fn) {
      const ref = react.exports.useRef(fn);
      useEnhancedEffect$1(() => {
        ref.current = fn;
      });
      return react.exports.useCallback((...args) => (0, ref.current)(...args), []);
    }
    function useForkRef(...refs) {
      return react.exports.useMemo(() => {
        if (refs.every((ref) => ref == null)) {
          return null;
        }
        return (instance) => {
          refs.forEach((ref) => {
            setRef(ref, instance);
          });
        };
      }, refs);
    }
    let hadKeyboardEvent = true;
    let hadFocusVisibleRecently = false;
    let hadFocusVisibleRecentlyTimeout;
    const inputTypesWhitelist = {
      text: true,
      search: true,
      url: true,
      tel: true,
      email: true,
      password: true,
      number: true,
      date: true,
      month: true,
      week: true,
      time: true,
      datetime: true,
      "datetime-local": true
    };
    function focusTriggersKeyboardModality(node2) {
      const {
        type: type2,
        tagName
      } = node2;
      if (tagName === "INPUT" && inputTypesWhitelist[type2] && !node2.readOnly) {
        return true;
      }
      if (tagName === "TEXTAREA" && !node2.readOnly) {
        return true;
      }
      if (node2.isContentEditable) {
        return true;
      }
      return false;
    }
    function handleKeyDown(event) {
      if (event.metaKey || event.altKey || event.ctrlKey) {
        return;
      }
      hadKeyboardEvent = true;
    }
    function handlePointerDown() {
      hadKeyboardEvent = false;
    }
    function handleVisibilityChange() {
      if (this.visibilityState === "hidden") {
        if (hadFocusVisibleRecently) {
          hadKeyboardEvent = true;
        }
      }
    }
    function prepare(doc) {
      doc.addEventListener("keydown", handleKeyDown, true);
      doc.addEventListener("mousedown", handlePointerDown, true);
      doc.addEventListener("pointerdown", handlePointerDown, true);
      doc.addEventListener("touchstart", handlePointerDown, true);
      doc.addEventListener("visibilitychange", handleVisibilityChange, true);
    }
    function isFocusVisible(event) {
      const {
        target
      } = event;
      try {
        return target.matches(":focus-visible");
      } catch (error) {
      }
      return hadKeyboardEvent || focusTriggersKeyboardModality(target);
    }
    function useIsFocusVisible() {
      const ref = react.exports.useCallback((node2) => {
        if (node2 != null) {
          prepare(node2.ownerDocument);
        }
      }, []);
      const isFocusVisibleRef = react.exports.useRef(false);
      function handleBlurVisible() {
        if (isFocusVisibleRef.current) {
          hadFocusVisibleRecently = true;
          window.clearTimeout(hadFocusVisibleRecentlyTimeout);
          hadFocusVisibleRecentlyTimeout = window.setTimeout(() => {
            hadFocusVisibleRecently = false;
          }, 100);
          isFocusVisibleRef.current = false;
          return true;
        }
        return false;
      }
      function handleFocusVisible(event) {
        if (isFocusVisible(event)) {
          isFocusVisibleRef.current = true;
          return true;
        }
        return false;
      }
      return {
        isFocusVisibleRef,
        onFocus: handleFocusVisible,
        onBlur: handleBlurVisible,
        ref
      };
    }
    function getScrollbarSize(doc) {
      const documentWidth = doc.documentElement.clientWidth;
      return Math.abs(window.innerWidth - documentWidth);
    }
    let cachedType;
    function detectScrollType() {
      if (cachedType) {
        return cachedType;
      }
      const dummy = document.createElement("div");
      const container = document.createElement("div");
      container.style.width = "10px";
      container.style.height = "1px";
      dummy.appendChild(container);
      dummy.dir = "rtl";
      dummy.style.fontSize = "14px";
      dummy.style.width = "4px";
      dummy.style.height = "1px";
      dummy.style.position = "absolute";
      dummy.style.top = "-1000px";
      dummy.style.overflow = "scroll";
      document.body.appendChild(dummy);
      cachedType = "reverse";
      if (dummy.scrollLeft > 0) {
        cachedType = "default";
      } else {
        dummy.scrollLeft = 1;
        if (dummy.scrollLeft === 0) {
          cachedType = "negative";
        }
      }
      document.body.removeChild(dummy);
      return cachedType;
    }
    function getNormalizedScrollLeft(element, direction) {
      const scrollLeft = element.scrollLeft;
      if (direction !== "rtl") {
        return scrollLeft;
      }
      const type2 = detectScrollType();
      switch (type2) {
        case "negative":
          return element.scrollWidth - element.clientWidth + scrollLeft;
        case "reverse":
          return element.scrollWidth - element.clientWidth - scrollLeft;
        default:
          return scrollLeft;
      }
    }
    function resolveProps(defaultProps2, props2) {
      const output = _extends({}, props2);
      Object.keys(defaultProps2).forEach((propName) => {
        if (output[propName] === void 0) {
          output[propName] = defaultProps2[propName];
        }
      });
      return output;
    }
    function composeClasses(slots, getUtilityClass, classes) {
      const output = {};
      Object.keys(slots).forEach(
        (slot) => {
          output[slot] = slots[slot].reduce((acc, key) => {
            if (key) {
              acc.push(getUtilityClass(key));
              if (classes && classes[key]) {
                acc.push(classes[key]);
              }
            }
            return acc;
          }, []).join(" ");
        }
      );
      return output;
    }
    const defaultGenerator = (componentName) => componentName;
    const createClassNameGenerator = () => {
      let generate = defaultGenerator;
      return {
        configure(generator) {
          generate = generator;
        },
        generate(componentName) {
          return generate(componentName);
        },
        reset() {
          generate = defaultGenerator;
        }
      };
    };
    const ClassNameGenerator = createClassNameGenerator();
    const ClassNameGenerator$1 = ClassNameGenerator;
    const globalStateClassesMapping = {
      active: "active",
      checked: "checked",
      completed: "completed",
      disabled: "disabled",
      error: "error",
      expanded: "expanded",
      focused: "focused",
      focusVisible: "focusVisible",
      required: "required",
      selected: "selected"
    };
    function generateUtilityClass(componentName, slot, globalStatePrefix = "Mui") {
      const globalStateClass = globalStateClassesMapping[slot];
      return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator$1.generate(componentName)}-${slot}`;
    }
    function generateUtilityClasses(componentName, slots, globalStatePrefix = "Mui") {
      const result = {};
      slots.forEach((slot) => {
        result[slot] = generateUtilityClass(componentName, slot, globalStatePrefix);
      });
      return result;
    }
    function merge(acc, item) {
      if (!item) {
        return acc;
      }
      return deepmerge(acc, item, {
        clone: false
      });
    }
    const values$1 = {
      xs: 0,
      sm: 600,
      md: 900,
      lg: 1200,
      xl: 1536
    };
    const defaultBreakpoints = {
      keys: ["xs", "sm", "md", "lg", "xl"],
      up: (key) => `@media (min-width:${values$1[key]}px)`
    };
    function handleBreakpoints(props2, propValue, styleFromPropValue) {
      const theme = props2.theme || {};
      if (Array.isArray(propValue)) {
        const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
        return propValue.reduce((acc, item, index2) => {
          acc[themeBreakpoints.up(themeBreakpoints.keys[index2])] = styleFromPropValue(propValue[index2]);
          return acc;
        }, {});
      }
      if (typeof propValue === "object") {
        const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
        return Object.keys(propValue).reduce((acc, breakpoint) => {
          if (Object.keys(themeBreakpoints.values || values$1).indexOf(breakpoint) !== -1) {
            const mediaKey = themeBreakpoints.up(breakpoint);
            acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
          } else {
            const cssKey = breakpoint;
            acc[cssKey] = propValue[cssKey];
          }
          return acc;
        }, {});
      }
      const output = styleFromPropValue(propValue);
      return output;
    }
    function createEmptyBreakpointObject(breakpointsInput = {}) {
      var _breakpointsInput$key;
      const breakpointsInOrder = (_breakpointsInput$key = breakpointsInput.keys) == null ? void 0 : _breakpointsInput$key.reduce((acc, key) => {
        const breakpointStyleKey = breakpointsInput.up(key);
        acc[breakpointStyleKey] = {};
        return acc;
      }, {});
      return breakpointsInOrder || {};
    }
    function removeUnusedBreakpoints(breakpointKeys, style2) {
      return breakpointKeys.reduce((acc, key) => {
        const breakpointOutput = acc[key];
        const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;
        if (isBreakpointUnused) {
          delete acc[key];
        }
        return acc;
      }, style2);
    }
    function mergeBreakpointsInOrder(breakpointsInput, ...styles2) {
      const emptyBreakpoints = createEmptyBreakpointObject(breakpointsInput);
      const mergedOutput = [emptyBreakpoints, ...styles2].reduce((prev2, next2) => deepmerge(prev2, next2), {});
      return removeUnusedBreakpoints(Object.keys(emptyBreakpoints), mergedOutput);
    }
    function computeBreakpointsBase(breakpointValues, themeBreakpoints) {
      if (typeof breakpointValues !== "object") {
        return {};
      }
      const base = {};
      const breakpointsKeys = Object.keys(themeBreakpoints);
      if (Array.isArray(breakpointValues)) {
        breakpointsKeys.forEach((breakpoint, i) => {
          if (i < breakpointValues.length) {
            base[breakpoint] = true;
          }
        });
      } else {
        breakpointsKeys.forEach((breakpoint) => {
          if (breakpointValues[breakpoint] != null) {
            base[breakpoint] = true;
          }
        });
      }
      return base;
    }
    function resolveBreakpointValues({
      values: breakpointValues,
      breakpoints: themeBreakpoints,
      base: customBase
    }) {
      const base = customBase || computeBreakpointsBase(breakpointValues, themeBreakpoints);
      const keys2 = Object.keys(base);
      if (keys2.length === 0) {
        return breakpointValues;
      }
      let previous;
      return keys2.reduce((acc, breakpoint, i) => {
        if (Array.isArray(breakpointValues)) {
          acc[breakpoint] = breakpointValues[i] != null ? breakpointValues[i] : breakpointValues[previous];
          previous = i;
        } else if (typeof breakpointValues === "object") {
          acc[breakpoint] = breakpointValues[breakpoint] != null ? breakpointValues[breakpoint] : breakpointValues[previous];
          previous = breakpoint;
        } else {
          acc[breakpoint] = breakpointValues;
        }
        return acc;
      }, {});
    }
    function getPath(obj, path, checkVars = true) {
      if (!path || typeof path !== "string") {
        return null;
      }
      if (obj && obj.vars && checkVars) {
        const val = `vars.${path}`.split(".").reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
        if (val != null) {
          return val;
        }
      }
      return path.split(".").reduce((acc, item) => {
        if (acc && acc[item] != null) {
          return acc[item];
        }
        return null;
      }, obj);
    }
    function getStyleValue$1(themeMapping, transform2, propValueFinal, userValue = propValueFinal) {
      let value;
      if (typeof themeMapping === "function") {
        value = themeMapping(propValueFinal);
      } else if (Array.isArray(themeMapping)) {
        value = themeMapping[propValueFinal] || userValue;
      } else {
        value = getPath(themeMapping, propValueFinal) || userValue;
      }
      if (transform2) {
        value = transform2(value, userValue);
      }
      return value;
    }
    function style$2(options) {
      const {
        prop,
        cssProperty = options.prop,
        themeKey,
        transform: transform2
      } = options;
      const fn = (props2) => {
        if (props2[prop] == null) {
          return null;
        }
        const propValue = props2[prop];
        const theme = props2.theme;
        const themeMapping = getPath(theme, themeKey) || {};
        const styleFromPropValue = (propValueFinal) => {
          let value = getStyleValue$1(themeMapping, transform2, propValueFinal);
          if (propValueFinal === value && typeof propValueFinal === "string") {
            value = getStyleValue$1(themeMapping, transform2, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
          }
          if (cssProperty === false) {
            return value;
          }
          return {
            [cssProperty]: value
          };
        };
        return handleBreakpoints(props2, propValue, styleFromPropValue);
      };
      fn.propTypes = {};
      fn.filterProps = [prop];
      return fn;
    }
    function compose(...styles2) {
      const handlers = styles2.reduce((acc, style2) => {
        style2.filterProps.forEach((prop) => {
          acc[prop] = style2;
        });
        return acc;
      }, {});
      const fn = (props2) => {
        return Object.keys(props2).reduce((acc, prop) => {
          if (handlers[prop]) {
            return merge(acc, handlers[prop](props2));
          }
          return acc;
        }, {});
      };
      fn.propTypes = {};
      fn.filterProps = styles2.reduce((acc, style2) => acc.concat(style2.filterProps), []);
      return fn;
    }
    function memoize(fn) {
      const cache = {};
      return (arg) => {
        if (cache[arg] === void 0) {
          cache[arg] = fn(arg);
        }
        return cache[arg];
      };
    }
    const properties = {
      m: "margin",
      p: "padding"
    };
    const directions = {
      t: "Top",
      r: "Right",
      b: "Bottom",
      l: "Left",
      x: ["Left", "Right"],
      y: ["Top", "Bottom"]
    };
    const aliases$1 = {
      marginX: "mx",
      marginY: "my",
      paddingX: "px",
      paddingY: "py"
    };
    const getCssProperties = memoize((prop) => {
      if (prop.length > 2) {
        if (aliases$1[prop]) {
          prop = aliases$1[prop];
        } else {
          return [prop];
        }
      }
      const [a, b2] = prop.split("");
      const property = properties[a];
      const direction = directions[b2] || "";
      return Array.isArray(direction) ? direction.map((dir) => property + dir) : [property + direction];
    });
    const marginKeys = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"];
    const paddingKeys = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
    const spacingKeys = [...marginKeys, ...paddingKeys];
    function createUnaryUnit(theme, themeKey, defaultValue, propName) {
      var _getPath;
      const themeSpacing = (_getPath = getPath(theme, themeKey, false)) != null ? _getPath : defaultValue;
      if (typeof themeSpacing === "number") {
        return (abs2) => {
          if (typeof abs2 === "string") {
            return abs2;
          }
          return themeSpacing * abs2;
        };
      }
      if (Array.isArray(themeSpacing)) {
        return (abs2) => {
          if (typeof abs2 === "string") {
            return abs2;
          }
          return themeSpacing[abs2];
        };
      }
      if (typeof themeSpacing === "function") {
        return themeSpacing;
      }
      return () => void 0;
    }
    function createUnarySpacing(theme) {
      return createUnaryUnit(theme, "spacing", 8);
    }
    function getValue(transformer, propValue) {
      if (typeof propValue === "string" || propValue == null) {
        return propValue;
      }
      const abs2 = Math.abs(propValue);
      const transformed = transformer(abs2);
      if (propValue >= 0) {
        return transformed;
      }
      if (typeof transformed === "number") {
        return -transformed;
      }
      return `-${transformed}`;
    }
    function getStyleFromPropValue(cssProperties, transformer) {
      return (propValue) => cssProperties.reduce((acc, cssProperty) => {
        acc[cssProperty] = getValue(transformer, propValue);
        return acc;
      }, {});
    }
    function resolveCssProperty(props2, keys2, prop, transformer) {
      if (keys2.indexOf(prop) === -1) {
        return null;
      }
      const cssProperties = getCssProperties(prop);
      const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);
      const propValue = props2[prop];
      return handleBreakpoints(props2, propValue, styleFromPropValue);
    }
    function style$1(props2, keys2) {
      const transformer = createUnarySpacing(props2.theme);
      return Object.keys(props2).map((prop) => resolveCssProperty(props2, keys2, prop, transformer)).reduce(merge, {});
    }
    function spacing(props2) {
      return style$1(props2, spacingKeys);
    }
    spacing.propTypes = {};
    spacing.filterProps = spacingKeys;
    function getBorder(value) {
      if (typeof value !== "number") {
        return value;
      }
      return `${value}px solid`;
    }
    const border = style$2({
      prop: "border",
      themeKey: "borders",
      transform: getBorder
    });
    const borderTop = style$2({
      prop: "borderTop",
      themeKey: "borders",
      transform: getBorder
    });
    const borderRight = style$2({
      prop: "borderRight",
      themeKey: "borders",
      transform: getBorder
    });
    const borderBottom = style$2({
      prop: "borderBottom",
      themeKey: "borders",
      transform: getBorder
    });
    const borderLeft = style$2({
      prop: "borderLeft",
      themeKey: "borders",
      transform: getBorder
    });
    const borderColor = style$2({
      prop: "borderColor",
      themeKey: "palette"
    });
    const borderTopColor = style$2({
      prop: "borderTopColor",
      themeKey: "palette"
    });
    const borderRightColor = style$2({
      prop: "borderRightColor",
      themeKey: "palette"
    });
    const borderBottomColor = style$2({
      prop: "borderBottomColor",
      themeKey: "palette"
    });
    const borderLeftColor = style$2({
      prop: "borderLeftColor",
      themeKey: "palette"
    });
    const borderRadius = (props2) => {
      if (props2.borderRadius !== void 0 && props2.borderRadius !== null) {
        const transformer = createUnaryUnit(props2.theme, "shape.borderRadius", 4);
        const styleFromPropValue = (propValue) => ({
          borderRadius: getValue(transformer, propValue)
        });
        return handleBreakpoints(props2, props2.borderRadius, styleFromPropValue);
      }
      return null;
    };
    borderRadius.propTypes = {};
    borderRadius.filterProps = ["borderRadius"];
    const borders = compose(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius);
    const borders$1 = borders;
    const displayPrint = style$2({
      prop: "displayPrint",
      cssProperty: false,
      transform: (value) => ({
        "@media print": {
          display: value
        }
      })
    });
    const displayRaw = style$2({
      prop: "display"
    });
    const overflow = style$2({
      prop: "overflow"
    });
    const textOverflow = style$2({
      prop: "textOverflow"
    });
    const visibility = style$2({
      prop: "visibility"
    });
    const whiteSpace = style$2({
      prop: "whiteSpace"
    });
    const display = compose(displayPrint, displayRaw, overflow, textOverflow, visibility, whiteSpace);
    const flexBasis = style$2({
      prop: "flexBasis"
    });
    const flexDirection = style$2({
      prop: "flexDirection"
    });
    const flexWrap = style$2({
      prop: "flexWrap"
    });
    const justifyContent = style$2({
      prop: "justifyContent"
    });
    const alignItems = style$2({
      prop: "alignItems"
    });
    const alignContent = style$2({
      prop: "alignContent"
    });
    const order$1 = style$2({
      prop: "order"
    });
    const flex = style$2({
      prop: "flex"
    });
    const flexGrow = style$2({
      prop: "flexGrow"
    });
    const flexShrink = style$2({
      prop: "flexShrink"
    });
    const alignSelf = style$2({
      prop: "alignSelf"
    });
    const justifyItems = style$2({
      prop: "justifyItems"
    });
    const justifySelf = style$2({
      prop: "justifySelf"
    });
    const flexbox = compose(flexBasis, flexDirection, flexWrap, justifyContent, alignItems, alignContent, order$1, flex, flexGrow, flexShrink, alignSelf, justifyItems, justifySelf);
    const flexbox$1 = flexbox;
    const gap = (props2) => {
      if (props2.gap !== void 0 && props2.gap !== null) {
        const transformer = createUnaryUnit(props2.theme, "spacing", 8);
        const styleFromPropValue = (propValue) => ({
          gap: getValue(transformer, propValue)
        });
        return handleBreakpoints(props2, props2.gap, styleFromPropValue);
      }
      return null;
    };
    gap.propTypes = {};
    gap.filterProps = ["gap"];
    const columnGap = (props2) => {
      if (props2.columnGap !== void 0 && props2.columnGap !== null) {
        const transformer = createUnaryUnit(props2.theme, "spacing", 8);
        const styleFromPropValue = (propValue) => ({
          columnGap: getValue(transformer, propValue)
        });
        return handleBreakpoints(props2, props2.columnGap, styleFromPropValue);
      }
      return null;
    };
    columnGap.propTypes = {};
    columnGap.filterProps = ["columnGap"];
    const rowGap = (props2) => {
      if (props2.rowGap !== void 0 && props2.rowGap !== null) {
        const transformer = createUnaryUnit(props2.theme, "spacing", 8);
        const styleFromPropValue = (propValue) => ({
          rowGap: getValue(transformer, propValue)
        });
        return handleBreakpoints(props2, props2.rowGap, styleFromPropValue);
      }
      return null;
    };
    rowGap.propTypes = {};
    rowGap.filterProps = ["rowGap"];
    const gridColumn = style$2({
      prop: "gridColumn"
    });
    const gridRow = style$2({
      prop: "gridRow"
    });
    const gridAutoFlow = style$2({
      prop: "gridAutoFlow"
    });
    const gridAutoColumns = style$2({
      prop: "gridAutoColumns"
    });
    const gridAutoRows = style$2({
      prop: "gridAutoRows"
    });
    const gridTemplateColumns = style$2({
      prop: "gridTemplateColumns"
    });
    const gridTemplateRows = style$2({
      prop: "gridTemplateRows"
    });
    const gridTemplateAreas = style$2({
      prop: "gridTemplateAreas"
    });
    const gridArea = style$2({
      prop: "gridArea"
    });
    const grid = compose(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);
    const grid$1 = grid;
    function transform$1(value, userValue) {
      if (userValue === "grey") {
        return userValue;
      }
      return value;
    }
    const color = style$2({
      prop: "color",
      themeKey: "palette",
      transform: transform$1
    });
    const bgcolor = style$2({
      prop: "bgcolor",
      cssProperty: "backgroundColor",
      themeKey: "palette",
      transform: transform$1
    });
    const backgroundColor = style$2({
      prop: "backgroundColor",
      themeKey: "palette",
      transform: transform$1
    });
    const palette = compose(color, bgcolor, backgroundColor);
    const palette$1 = palette;
    const position = style$2({
      prop: "position"
    });
    const zIndex$2 = style$2({
      prop: "zIndex",
      themeKey: "zIndex"
    });
    const top$1 = style$2({
      prop: "top"
    });
    const right$1 = style$2({
      prop: "right"
    });
    const bottom$1 = style$2({
      prop: "bottom"
    });
    const left$1 = style$2({
      prop: "left"
    });
    const positions = compose(position, zIndex$2, top$1, right$1, bottom$1, left$1);
    const boxShadow = style$2({
      prop: "boxShadow",
      themeKey: "shadows"
    });
    const shadows$2 = boxShadow;
    function transform(value) {
      return value <= 1 && value !== 0 ? `${value * 100}%` : value;
    }
    const width = style$2({
      prop: "width",
      transform
    });
    const maxWidth = (props2) => {
      if (props2.maxWidth !== void 0 && props2.maxWidth !== null) {
        const styleFromPropValue = (propValue) => {
          var _props$theme, _props$theme$breakpoi, _props$theme$breakpoi2;
          const breakpoint = ((_props$theme = props2.theme) == null ? void 0 : (_props$theme$breakpoi = _props$theme.breakpoints) == null ? void 0 : (_props$theme$breakpoi2 = _props$theme$breakpoi.values) == null ? void 0 : _props$theme$breakpoi2[propValue]) || values$1[propValue];
          return {
            maxWidth: breakpoint || transform(propValue)
          };
        };
        return handleBreakpoints(props2, props2.maxWidth, styleFromPropValue);
      }
      return null;
    };
    maxWidth.filterProps = ["maxWidth"];
    const minWidth = style$2({
      prop: "minWidth",
      transform
    });
    const height = style$2({
      prop: "height",
      transform
    });
    const maxHeight = style$2({
      prop: "maxHeight",
      transform
    });
    const minHeight = style$2({
      prop: "minHeight",
      transform
    });
    style$2({
      prop: "size",
      cssProperty: "width",
      transform
    });
    style$2({
      prop: "size",
      cssProperty: "height",
      transform
    });
    const boxSizing = style$2({
      prop: "boxSizing"
    });
    const sizing = compose(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
    const sizing$1 = sizing;
    const fontFamily = style$2({
      prop: "fontFamily",
      themeKey: "typography"
    });
    const fontSize = style$2({
      prop: "fontSize",
      themeKey: "typography"
    });
    const fontStyle = style$2({
      prop: "fontStyle",
      themeKey: "typography"
    });
    const fontWeight = style$2({
      prop: "fontWeight",
      themeKey: "typography"
    });
    const letterSpacing = style$2({
      prop: "letterSpacing"
    });
    const textTransform = style$2({
      prop: "textTransform"
    });
    const lineHeight = style$2({
      prop: "lineHeight"
    });
    const textAlign = style$2({
      prop: "textAlign"
    });
    const typographyVariant = style$2({
      prop: "typography",
      cssProperty: false,
      themeKey: "typography"
    });
    const typography = compose(typographyVariant, fontFamily, fontSize, fontStyle, fontWeight, letterSpacing, lineHeight, textAlign, textTransform);
    const typography$1 = typography;
    const filterPropsMapping = {
      borders: borders$1.filterProps,
      display: display.filterProps,
      flexbox: flexbox$1.filterProps,
      grid: grid$1.filterProps,
      positions: positions.filterProps,
      palette: palette$1.filterProps,
      shadows: shadows$2.filterProps,
      sizing: sizing$1.filterProps,
      spacing: spacing.filterProps,
      typography: typography$1.filterProps
    };
    const styleFunctionMapping = {
      borders: borders$1,
      display,
      flexbox: flexbox$1,
      grid: grid$1,
      positions,
      palette: palette$1,
      shadows: shadows$2,
      sizing: sizing$1,
      spacing,
      typography: typography$1
    };
    const propToStyleFunction = Object.keys(filterPropsMapping).reduce((acc, styleFnName) => {
      filterPropsMapping[styleFnName].forEach((propName) => {
        acc[propName] = styleFunctionMapping[styleFnName];
      });
      return acc;
    }, {});
    function objectsHaveSameKeys(...objects) {
      const allKeys = objects.reduce((keys2, object) => keys2.concat(Object.keys(object)), []);
      const union = new Set(allKeys);
      return objects.every((object) => union.size === Object.keys(object).length);
    }
    function callIfFn(maybeFn, arg) {
      return typeof maybeFn === "function" ? maybeFn(arg) : maybeFn;
    }
    function unstable_createStyleFunctionSx(styleFunctionMapping$1 = styleFunctionMapping) {
      const propToStyleFunction2 = Object.keys(styleFunctionMapping$1).reduce((acc, styleFnName) => {
        styleFunctionMapping$1[styleFnName].filterProps.forEach((propName) => {
          acc[propName] = styleFunctionMapping$1[styleFnName];
        });
        return acc;
      }, {});
      function getThemeValue(prop, value, theme) {
        const inputProps = {
          [prop]: value,
          theme
        };
        const styleFunction = propToStyleFunction2[prop];
        return styleFunction ? styleFunction(inputProps) : {
          [prop]: value
        };
      }
      function styleFunctionSx2(props2) {
        const {
          sx,
          theme = {}
        } = props2 || {};
        if (!sx) {
          return null;
        }
        function traverse(sxInput) {
          let sxObject = sxInput;
          if (typeof sxInput === "function") {
            sxObject = sxInput(theme);
          } else if (typeof sxInput !== "object") {
            return sxInput;
          }
          if (!sxObject) {
            return null;
          }
          const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);
          const breakpointsKeys = Object.keys(emptyBreakpoints);
          let css2 = emptyBreakpoints;
          Object.keys(sxObject).forEach((styleKey) => {
            const value = callIfFn(sxObject[styleKey], theme);
            if (value !== null && value !== void 0) {
              if (typeof value === "object") {
                if (propToStyleFunction2[styleKey]) {
                  css2 = merge(css2, getThemeValue(styleKey, value, theme));
                } else {
                  const breakpointsValues = handleBreakpoints({
                    theme
                  }, value, (x2) => ({
                    [styleKey]: x2
                  }));
                  if (objectsHaveSameKeys(breakpointsValues, value)) {
                    css2[styleKey] = styleFunctionSx2({
                      sx: value,
                      theme
                    });
                  } else {
                    css2 = merge(css2, breakpointsValues);
                  }
                }
              } else {
                css2 = merge(css2, getThemeValue(styleKey, value, theme));
              }
            }
          });
          return removeUnusedBreakpoints(breakpointsKeys, css2);
        }
        return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
      }
      return styleFunctionSx2;
    }
    const styleFunctionSx = unstable_createStyleFunctionSx();
    styleFunctionSx.filterProps = ["sx"];
    const defaultStyleFunctionSx = styleFunctionSx;
    const _excluded$1x = ["sx"];
    const splitProps = (props2) => {
      const result = {
        systemProps: {},
        otherProps: {}
      };
      Object.keys(props2).forEach((prop) => {
        if (propToStyleFunction[prop]) {
          result.systemProps[prop] = props2[prop];
        } else {
          result.otherProps[prop] = props2[prop];
        }
      });
      return result;
    };
    function extendSxProp(props2) {
      const {
        sx: inSx
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$1x);
      const {
        systemProps,
        otherProps
      } = splitProps(other);
      let finalSx;
      if (Array.isArray(inSx)) {
        finalSx = [systemProps, ...inSx];
      } else if (typeof inSx === "function") {
        finalSx = (...args) => {
          const result = inSx(...args);
          if (!isPlainObject(result)) {
            return systemProps;
          }
          return _extends({}, systemProps, result);
        };
      } else {
        finalSx = _extends({}, systemProps, inSx);
      }
      return _extends({}, otherProps, {
        sx: finalSx
      });
    }
    function r(e2) {
      var t2, f2, n2 = "";
      if ("string" == typeof e2 || "number" == typeof e2)
        n2 += e2;
      else if ("object" == typeof e2)
        if (Array.isArray(e2))
          for (t2 = 0; t2 < e2.length; t2++)
            e2[t2] && (f2 = r(e2[t2])) && (n2 && (n2 += " "), n2 += f2);
        else
          for (t2 in e2)
            e2[t2] && (n2 && (n2 += " "), n2 += t2);
      return n2;
    }
    function clsx() {
      for (var e2, t2, f2 = 0, n2 = ""; f2 < arguments.length; )
        (e2 = arguments[f2++]) && (t2 = r(e2)) && (n2 && (n2 += " "), n2 += t2);
      return n2;
    }
    const _excluded$1w = ["values", "unit", "step"];
    const sortBreakpointsValues = (values2) => {
      const breakpointsAsArray = Object.keys(values2).map((key) => ({
        key,
        val: values2[key]
      })) || [];
      breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
      return breakpointsAsArray.reduce((acc, obj) => {
        return _extends({}, acc, {
          [obj.key]: obj.val
        });
      }, {});
    };
    function createBreakpoints(breakpoints) {
      const {
        values: values2 = {
          xs: 0,
          sm: 600,
          md: 900,
          lg: 1200,
          xl: 1536
        },
        unit = "px",
        step = 5
      } = breakpoints, other = _objectWithoutPropertiesLoose(breakpoints, _excluded$1w);
      const sortedValues = sortBreakpointsValues(values2);
      const keys2 = Object.keys(sortedValues);
      function up(key) {
        const value = typeof values2[key] === "number" ? values2[key] : key;
        return `@media (min-width:${value}${unit})`;
      }
      function down(key) {
        const value = typeof values2[key] === "number" ? values2[key] : key;
        return `@media (max-width:${value - step / 100}${unit})`;
      }
      function between(start2, end2) {
        const endIndex = keys2.indexOf(end2);
        return `@media (min-width:${typeof values2[start2] === "number" ? values2[start2] : start2}${unit}) and (max-width:${(endIndex !== -1 && typeof values2[keys2[endIndex]] === "number" ? values2[keys2[endIndex]] : end2) - step / 100}${unit})`;
      }
      function only(key) {
        if (keys2.indexOf(key) + 1 < keys2.length) {
          return between(key, keys2[keys2.indexOf(key) + 1]);
        }
        return up(key);
      }
      function not(key) {
        const keyIndex = keys2.indexOf(key);
        if (keyIndex === 0) {
          return up(keys2[1]);
        }
        if (keyIndex === keys2.length - 1) {
          return down(keys2[keyIndex]);
        }
        return between(key, keys2[keys2.indexOf(key) + 1]).replace("@media", "@media not all and");
      }
      return _extends({
        keys: keys2,
        values: sortedValues,
        up,
        down,
        between,
        only,
        not,
        unit
      }, other);
    }
    const shape = {
      borderRadius: 4
    };
    const shape$1 = shape;
    function createSpacing(spacingInput = 8) {
      if (spacingInput.mui) {
        return spacingInput;
      }
      const transform2 = createUnarySpacing({
        spacing: spacingInput
      });
      const spacing2 = (...argsInput) => {
        const args = argsInput.length === 0 ? [1] : argsInput;
        return args.map((argument) => {
          const output = transform2(argument);
          return typeof output === "number" ? `${output}px` : output;
        }).join(" ");
      };
      spacing2.mui = true;
      return spacing2;
    }
    const _excluded$1v = ["breakpoints", "palette", "spacing", "shape"];
    function createTheme$1(options = {}, ...args) {
      const {
        breakpoints: breakpointsInput = {},
        palette: paletteInput = {},
        spacing: spacingInput,
        shape: shapeInput = {}
      } = options, other = _objectWithoutPropertiesLoose(options, _excluded$1v);
      const breakpoints = createBreakpoints(breakpointsInput);
      const spacing2 = createSpacing(spacingInput);
      let muiTheme = deepmerge({
        breakpoints,
        direction: "ltr",
        components: {},
        palette: _extends({
          mode: "light"
        }, paletteInput),
        spacing: spacing2,
        shape: _extends({}, shape$1, shapeInput)
      }, other);
      muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
      return muiTheme;
    }
    const ThemeContext = /* @__PURE__ */ react.exports.createContext(null);
    const ThemeContext$1 = ThemeContext;
    function useTheme$3() {
      const theme = react.exports.useContext(ThemeContext$1);
      return theme;
    }
    function isObjectEmpty$1(obj) {
      return Object.keys(obj).length === 0;
    }
    function useTheme$2(defaultTheme2 = null) {
      const contextTheme = useTheme$3();
      return !contextTheme || isObjectEmpty$1(contextTheme) ? defaultTheme2 : contextTheme;
    }
    const systemDefaultTheme$1 = createTheme$1();
    function useTheme$1(defaultTheme2 = systemDefaultTheme$1) {
      return useTheme$2(defaultTheme2);
    }
    const _excluded$1u = ["className", "component"];
    function createBox(options = {}) {
      const {
        defaultTheme: defaultTheme2,
        defaultClassName = "MuiBox-root",
        generateClassName,
        styleFunctionSx: styleFunctionSx2 = defaultStyleFunctionSx
      } = options;
      const BoxRoot = styled$3("div", {
        shouldForwardProp: (prop) => prop !== "theme" && prop !== "sx" && prop !== "as"
      })(styleFunctionSx2);
      const Box2 = /* @__PURE__ */ react.exports.forwardRef(function Box3(inProps, ref) {
        const theme = useTheme$1(defaultTheme2);
        const _extendSxProp = extendSxProp(inProps), {
          className,
          component = "div"
        } = _extendSxProp, other = _objectWithoutPropertiesLoose(_extendSxProp, _excluded$1u);
        return /* @__PURE__ */ jsx(BoxRoot, _extends({
          as: component,
          ref,
          className: clsx(className, generateClassName ? generateClassName(defaultClassName) : defaultClassName),
          theme
        }, other));
      });
      return Box2;
    }
    const Box$2 = createBox();
    const Box$3 = Box$2;
    const _excluded$1t = ["variant"];
    function isEmpty$3(string) {
      return string.length === 0;
    }
    function propsToClassKey(props2) {
      const {
        variant
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$1t);
      let classKey = variant || "";
      Object.keys(other).sort().forEach((key) => {
        if (key === "color") {
          classKey += isEmpty$3(classKey) ? props2[key] : capitalize(props2[key]);
        } else {
          classKey += `${isEmpty$3(classKey) ? key : capitalize(key)}${capitalize(props2[key].toString())}`;
        }
      });
      return classKey;
    }
    const _excluded$1s = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"], _excluded2$5 = ["theme"], _excluded3 = ["theme"];
    function isEmpty$2(obj) {
      return Object.keys(obj).length === 0;
    }
    function isStringTag(tag) {
      return typeof tag === "string" && tag.charCodeAt(0) > 96;
    }
    const getStyleOverrides = (name, theme) => {
      if (theme.components && theme.components[name] && theme.components[name].styleOverrides) {
        return theme.components[name].styleOverrides;
      }
      return null;
    };
    const getVariantStyles = (name, theme) => {
      let variants = [];
      if (theme && theme.components && theme.components[name] && theme.components[name].variants) {
        variants = theme.components[name].variants;
      }
      const variantsStyles = {};
      variants.forEach((definition) => {
        const key = propsToClassKey(definition.props);
        variantsStyles[key] = definition.style;
      });
      return variantsStyles;
    };
    const variantsResolver = (props2, styles2, theme, name) => {
      var _theme$components, _theme$components$nam;
      const {
        ownerState = {}
      } = props2;
      const variantsStyles = [];
      const themeVariants = theme == null ? void 0 : (_theme$components = theme.components) == null ? void 0 : (_theme$components$nam = _theme$components[name]) == null ? void 0 : _theme$components$nam.variants;
      if (themeVariants) {
        themeVariants.forEach((themeVariant) => {
          let isMatch = true;
          Object.keys(themeVariant.props).forEach((key) => {
            if (ownerState[key] !== themeVariant.props[key] && props2[key] !== themeVariant.props[key]) {
              isMatch = false;
            }
          });
          if (isMatch) {
            variantsStyles.push(styles2[propsToClassKey(themeVariant.props)]);
          }
        });
      }
      return variantsStyles;
    };
    function shouldForwardProp(prop) {
      return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
    }
    const systemDefaultTheme = createTheme$1();
    function createStyled(input = {}) {
      const {
        defaultTheme: defaultTheme2 = systemDefaultTheme,
        rootShouldForwardProp: rootShouldForwardProp2 = shouldForwardProp,
        slotShouldForwardProp: slotShouldForwardProp2 = shouldForwardProp,
        styleFunctionSx: styleFunctionSx2 = defaultStyleFunctionSx
      } = input;
      const systemSx = (props2) => {
        const theme = isEmpty$2(props2.theme) ? defaultTheme2 : props2.theme;
        return styleFunctionSx2(_extends({}, props2, {
          theme
        }));
      };
      systemSx.__mui_systemSx = true;
      return (tag, inputOptions = {}) => {
        internal_processStyles(tag, (styles2) => styles2.filter((style2) => !(style2 != null && style2.__mui_systemSx)));
        const {
          name: componentName,
          slot: componentSlot,
          skipVariantsResolver: inputSkipVariantsResolver,
          skipSx: inputSkipSx,
          overridesResolver: overridesResolver2
        } = inputOptions, options = _objectWithoutPropertiesLoose(inputOptions, _excluded$1s);
        const skipVariantsResolver = inputSkipVariantsResolver !== void 0 ? inputSkipVariantsResolver : componentSlot && componentSlot !== "Root" || false;
        const skipSx = inputSkipSx || false;
        let label;
        let shouldForwardPropOption = shouldForwardProp;
        if (componentSlot === "Root") {
          shouldForwardPropOption = rootShouldForwardProp2;
        } else if (componentSlot) {
          shouldForwardPropOption = slotShouldForwardProp2;
        } else if (isStringTag(tag)) {
          shouldForwardPropOption = void 0;
        }
        const defaultStyledResolver = styled$3(tag, _extends({
          shouldForwardProp: shouldForwardPropOption,
          label
        }, options));
        const muiStyledResolver = (styleArg2, ...expressions) => {
          const expressionsWithDefaultTheme = expressions ? expressions.map((stylesArg) => {
            return typeof stylesArg === "function" && stylesArg.__emotion_real !== stylesArg ? (_ref) => {
              let {
                theme: themeInput
              } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded2$5);
              return stylesArg(_extends({
                theme: isEmpty$2(themeInput) ? defaultTheme2 : themeInput
              }, other));
            } : stylesArg;
          }) : [];
          let transformedStyleArg = styleArg2;
          if (componentName && overridesResolver2) {
            expressionsWithDefaultTheme.push((props2) => {
              const theme = isEmpty$2(props2.theme) ? defaultTheme2 : props2.theme;
              const styleOverrides = getStyleOverrides(componentName, theme);
              if (styleOverrides) {
                const resolvedStyleOverrides = {};
                Object.entries(styleOverrides).forEach(([slotKey, slotStyle]) => {
                  resolvedStyleOverrides[slotKey] = typeof slotStyle === "function" ? slotStyle(_extends({}, props2, {
                    theme
                  })) : slotStyle;
                });
                return overridesResolver2(props2, resolvedStyleOverrides);
              }
              return null;
            });
          }
          if (componentName && !skipVariantsResolver) {
            expressionsWithDefaultTheme.push((props2) => {
              const theme = isEmpty$2(props2.theme) ? defaultTheme2 : props2.theme;
              return variantsResolver(props2, getVariantStyles(componentName, theme), theme, componentName);
            });
          }
          if (!skipSx) {
            expressionsWithDefaultTheme.push(systemSx);
          }
          const numOfCustomFnsApplied = expressionsWithDefaultTheme.length - expressions.length;
          if (Array.isArray(styleArg2) && numOfCustomFnsApplied > 0) {
            const placeholders = new Array(numOfCustomFnsApplied).fill("");
            transformedStyleArg = [...styleArg2, ...placeholders];
            transformedStyleArg.raw = [...styleArg2.raw, ...placeholders];
          } else if (typeof styleArg2 === "function" && styleArg2.__emotion_real !== styleArg2) {
            transformedStyleArg = (_ref2) => {
              let {
                theme: themeInput
              } = _ref2, other = _objectWithoutPropertiesLoose(_ref2, _excluded3);
              return styleArg2(_extends({
                theme: isEmpty$2(themeInput) ? defaultTheme2 : themeInput
              }, other));
            };
          }
          const Component = defaultStyledResolver(transformedStyleArg, ...expressionsWithDefaultTheme);
          return Component;
        };
        if (defaultStyledResolver.withConfig) {
          muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
        }
        return muiStyledResolver;
      };
    }
    const styled$2 = createStyled();
    const systemStyled = styled$2;
    function getThemeProps(params) {
      const {
        theme,
        name,
        props: props2
      } = params;
      if (!theme || !theme.components || !theme.components[name] || !theme.components[name].defaultProps) {
        return props2;
      }
      return resolveProps(theme.components[name].defaultProps, props2);
    }
    function useThemeProps$1({
      props: props2,
      name,
      defaultTheme: defaultTheme2
    }) {
      const theme = useTheme$1(defaultTheme2);
      const mergedProps = getThemeProps({
        theme,
        name,
        props: props2
      });
      return mergedProps;
    }
    function clamp(value, min2 = 0, max2 = 1) {
      return Math.min(Math.max(min2, value), max2);
    }
    function hexToRgb(color2) {
      color2 = color2.slice(1);
      const re2 = new RegExp(`.{1,${color2.length >= 6 ? 2 : 1}}`, "g");
      let colors = color2.match(re2);
      if (colors && colors[0].length === 1) {
        colors = colors.map((n2) => n2 + n2);
      }
      return colors ? `rgb${colors.length === 4 ? "a" : ""}(${colors.map((n2, index2) => {
        return index2 < 3 ? parseInt(n2, 16) : Math.round(parseInt(n2, 16) / 255 * 1e3) / 1e3;
      }).join(", ")})` : "";
    }
    function decomposeColor(color2) {
      if (color2.type) {
        return color2;
      }
      if (color2.charAt(0) === "#") {
        return decomposeColor(hexToRgb(color2));
      }
      const marker = color2.indexOf("(");
      const type2 = color2.substring(0, marker);
      if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(type2) === -1) {
        throw new Error(formatMuiErrorMessage(9, color2));
      }
      let values2 = color2.substring(marker + 1, color2.length - 1);
      let colorSpace;
      if (type2 === "color") {
        values2 = values2.split(" ");
        colorSpace = values2.shift();
        if (values2.length === 4 && values2[3].charAt(0) === "/") {
          values2[3] = values2[3].slice(1);
        }
        if (["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(colorSpace) === -1) {
          throw new Error(formatMuiErrorMessage(10, colorSpace));
        }
      } else {
        values2 = values2.split(",");
      }
      values2 = values2.map((value) => parseFloat(value));
      return {
        type: type2,
        values: values2,
        colorSpace
      };
    }
    function recomposeColor(color2) {
      const {
        type: type2,
        colorSpace
      } = color2;
      let {
        values: values2
      } = color2;
      if (type2.indexOf("rgb") !== -1) {
        values2 = values2.map((n2, i) => i < 3 ? parseInt(n2, 10) : n2);
      } else if (type2.indexOf("hsl") !== -1) {
        values2[1] = `${values2[1]}%`;
        values2[2] = `${values2[2]}%`;
      }
      if (type2.indexOf("color") !== -1) {
        values2 = `${colorSpace} ${values2.join(" ")}`;
      } else {
        values2 = `${values2.join(", ")}`;
      }
      return `${type2}(${values2})`;
    }
    function hslToRgb(color2) {
      color2 = decomposeColor(color2);
      const {
        values: values2
      } = color2;
      const h2 = values2[0];
      const s = values2[1] / 100;
      const l2 = values2[2] / 100;
      const a = s * Math.min(l2, 1 - l2);
      const f2 = (n2, k2 = (n2 + h2 / 30) % 12) => l2 - a * Math.max(Math.min(k2 - 3, 9 - k2, 1), -1);
      let type2 = "rgb";
      const rgb = [Math.round(f2(0) * 255), Math.round(f2(8) * 255), Math.round(f2(4) * 255)];
      if (color2.type === "hsla") {
        type2 += "a";
        rgb.push(values2[3]);
      }
      return recomposeColor({
        type: type2,
        values: rgb
      });
    }
    function getLuminance(color2) {
      color2 = decomposeColor(color2);
      let rgb = color2.type === "hsl" || color2.type === "hsla" ? decomposeColor(hslToRgb(color2)).values : color2.values;
      rgb = rgb.map((val) => {
        if (color2.type !== "color") {
          val /= 255;
        }
        return val <= 0.03928 ? val / 12.92 : ((val + 0.055) / 1.055) ** 2.4;
      });
      return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
    }
    function getContrastRatio(foreground, background) {
      const lumA = getLuminance(foreground);
      const lumB = getLuminance(background);
      return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
    }
    function alpha(color2, value) {
      color2 = decomposeColor(color2);
      value = clamp(value);
      if (color2.type === "rgb" || color2.type === "hsl") {
        color2.type += "a";
      }
      if (color2.type === "color") {
        color2.values[3] = `/${value}`;
      } else {
        color2.values[3] = value;
      }
      return recomposeColor(color2);
    }
    function darken(color2, coefficient) {
      color2 = decomposeColor(color2);
      coefficient = clamp(coefficient);
      if (color2.type.indexOf("hsl") !== -1) {
        color2.values[2] *= 1 - coefficient;
      } else if (color2.type.indexOf("rgb") !== -1 || color2.type.indexOf("color") !== -1) {
        for (let i = 0; i < 3; i += 1) {
          color2.values[i] *= 1 - coefficient;
        }
      }
      return recomposeColor(color2);
    }
    function lighten(color2, coefficient) {
      color2 = decomposeColor(color2);
      coefficient = clamp(coefficient);
      if (color2.type.indexOf("hsl") !== -1) {
        color2.values[2] += (100 - color2.values[2]) * coefficient;
      } else if (color2.type.indexOf("rgb") !== -1) {
        for (let i = 0; i < 3; i += 1) {
          color2.values[i] += (255 - color2.values[i]) * coefficient;
        }
      } else if (color2.type.indexOf("color") !== -1) {
        for (let i = 0; i < 3; i += 1) {
          color2.values[i] += (1 - color2.values[i]) * coefficient;
        }
      }
      return recomposeColor(color2);
    }
    const _excluded$1r = ["className", "component", "disableGutters", "fixed", "maxWidth", "classes"];
    const defaultTheme$3 = createTheme$1();
    const defaultCreateStyledComponent = systemStyled("div", {
      name: "MuiContainer",
      slot: "Root",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.root, styles2[`maxWidth${capitalize(String(ownerState.maxWidth))}`], ownerState.fixed && styles2.fixed, ownerState.disableGutters && styles2.disableGutters];
      }
    });
    const useThemePropsDefault = (inProps) => useThemeProps$1({
      props: inProps,
      name: "MuiContainer",
      defaultTheme: defaultTheme$3
    });
    const useUtilityClasses$1c = (ownerState, componentName) => {
      const getContainerUtilityClass = (slot) => {
        return generateUtilityClass(componentName, slot);
      };
      const {
        classes,
        fixed,
        disableGutters,
        maxWidth: maxWidth2
      } = ownerState;
      const slots = {
        root: ["root", maxWidth2 && `maxWidth${capitalize(String(maxWidth2))}`, fixed && "fixed", disableGutters && "disableGutters"]
      };
      return composeClasses(slots, getContainerUtilityClass, classes);
    };
    function createContainer(options = {}) {
      const {
        createStyledComponent = defaultCreateStyledComponent,
        useThemeProps: useThemeProps2 = useThemePropsDefault,
        componentName = "MuiContainer"
      } = options;
      const ContainerRoot = createStyledComponent(({
        theme,
        ownerState
      }) => _extends({
        width: "100%",
        marginLeft: "auto",
        boxSizing: "border-box",
        marginRight: "auto",
        display: "block"
      }, !ownerState.disableGutters && {
        paddingLeft: theme.spacing(2),
        paddingRight: theme.spacing(2),
        [theme.breakpoints.up("sm")]: {
          paddingLeft: theme.spacing(3),
          paddingRight: theme.spacing(3)
        }
      }), ({
        theme,
        ownerState
      }) => ownerState.fixed && Object.keys(theme.breakpoints.values).reduce((acc, breakpointValueKey) => {
        const breakpoint = breakpointValueKey;
        const value = theme.breakpoints.values[breakpoint];
        if (value !== 0) {
          acc[theme.breakpoints.up(breakpoint)] = {
            maxWidth: `${value}${theme.breakpoints.unit}`
          };
        }
        return acc;
      }, {}), ({
        theme,
        ownerState
      }) => _extends({}, ownerState.maxWidth === "xs" && {
        [theme.breakpoints.up("xs")]: {
          maxWidth: Math.max(theme.breakpoints.values.xs, 444)
        }
      }, ownerState.maxWidth && ownerState.maxWidth !== "xs" && {
        [theme.breakpoints.up(ownerState.maxWidth)]: {
          maxWidth: `${theme.breakpoints.values[ownerState.maxWidth]}${theme.breakpoints.unit}`
        }
      }));
      const Container2 = /* @__PURE__ */ react.exports.forwardRef(function Container3(inProps, ref) {
        const props2 = useThemeProps2(inProps);
        const {
          className,
          component = "div",
          disableGutters = false,
          fixed = false,
          maxWidth: maxWidth2 = "lg"
        } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$1r);
        const ownerState = _extends({}, props2, {
          component,
          disableGutters,
          fixed,
          maxWidth: maxWidth2
        });
        const classes = useUtilityClasses$1c(ownerState, componentName);
        return /* @__PURE__ */ jsx(ContainerRoot, _extends({
          as: component,
          ownerState,
          className: clsx(classes.root, className),
          ref
        }, other));
      });
      return Container2;
    }
    function createMixins(breakpoints, mixins) {
      return _extends({
        toolbar: {
          minHeight: 56,
          [breakpoints.up("xs")]: {
            "@media (orientation: landscape)": {
              minHeight: 48
            }
          },
          [breakpoints.up("sm")]: {
            minHeight: 64
          }
        }
      }, mixins);
    }
    const _excluded$1q = ["mode", "contrastThreshold", "tonalOffset"];
    const light = {
      text: {
        primary: "rgba(0, 0, 0, 0.87)",
        secondary: "rgba(0, 0, 0, 0.6)",
        disabled: "rgba(0, 0, 0, 0.38)"
      },
      divider: "rgba(0, 0, 0, 0.12)",
      background: {
        paper: common$1.white,
        default: common$1.white
      },
      action: {
        active: "rgba(0, 0, 0, 0.54)",
        hover: "rgba(0, 0, 0, 0.04)",
        hoverOpacity: 0.04,
        selected: "rgba(0, 0, 0, 0.08)",
        selectedOpacity: 0.08,
        disabled: "rgba(0, 0, 0, 0.26)",
        disabledBackground: "rgba(0, 0, 0, 0.12)",
        disabledOpacity: 0.38,
        focus: "rgba(0, 0, 0, 0.12)",
        focusOpacity: 0.12,
        activatedOpacity: 0.12
      }
    };
    const dark = {
      text: {
        primary: common$1.white,
        secondary: "rgba(255, 255, 255, 0.7)",
        disabled: "rgba(255, 255, 255, 0.5)",
        icon: "rgba(255, 255, 255, 0.5)"
      },
      divider: "rgba(255, 255, 255, 0.12)",
      background: {
        paper: "#121212",
        default: "#121212"
      },
      action: {
        active: common$1.white,
        hover: "rgba(255, 255, 255, 0.08)",
        hoverOpacity: 0.08,
        selected: "rgba(255, 255, 255, 0.16)",
        selectedOpacity: 0.16,
        disabled: "rgba(255, 255, 255, 0.3)",
        disabledBackground: "rgba(255, 255, 255, 0.12)",
        disabledOpacity: 0.38,
        focus: "rgba(255, 255, 255, 0.12)",
        focusOpacity: 0.12,
        activatedOpacity: 0.24
      }
    };
    function addLightOrDark(intent, direction, shade, tonalOffset) {
      const tonalOffsetLight = tonalOffset.light || tonalOffset;
      const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
      if (!intent[direction]) {
        if (intent.hasOwnProperty(shade)) {
          intent[direction] = intent[shade];
        } else if (direction === "light") {
          intent.light = lighten(intent.main, tonalOffsetLight);
        } else if (direction === "dark") {
          intent.dark = darken(intent.main, tonalOffsetDark);
        }
      }
    }
    function getDefaultPrimary(mode = "light") {
      if (mode === "dark") {
        return {
          main: blue$1[200],
          light: blue$1[50],
          dark: blue$1[400]
        };
      }
      return {
        main: blue$1[700],
        light: blue$1[400],
        dark: blue$1[800]
      };
    }
    function getDefaultSecondary(mode = "light") {
      if (mode === "dark") {
        return {
          main: purple$1[200],
          light: purple$1[50],
          dark: purple$1[400]
        };
      }
      return {
        main: purple$1[500],
        light: purple$1[300],
        dark: purple$1[700]
      };
    }
    function getDefaultError(mode = "light") {
      if (mode === "dark") {
        return {
          main: red$1[500],
          light: red$1[300],
          dark: red$1[700]
        };
      }
      return {
        main: red$1[700],
        light: red$1[400],
        dark: red$1[800]
      };
    }
    function getDefaultInfo(mode = "light") {
      if (mode === "dark") {
        return {
          main: lightBlue$1[400],
          light: lightBlue$1[300],
          dark: lightBlue$1[700]
        };
      }
      return {
        main: lightBlue$1[700],
        light: lightBlue$1[500],
        dark: lightBlue$1[900]
      };
    }
    function getDefaultSuccess(mode = "light") {
      if (mode === "dark") {
        return {
          main: green$1[400],
          light: green$1[300],
          dark: green$1[700]
        };
      }
      return {
        main: green$1[800],
        light: green$1[500],
        dark: green$1[900]
      };
    }
    function getDefaultWarning(mode = "light") {
      if (mode === "dark") {
        return {
          main: orange$1[400],
          light: orange$1[300],
          dark: orange$1[700]
        };
      }
      return {
        main: "#ed6c02",
        light: orange$1[500],
        dark: orange$1[900]
      };
    }
    function createPalette(palette2) {
      const {
        mode = "light",
        contrastThreshold = 3,
        tonalOffset = 0.2
      } = palette2, other = _objectWithoutPropertiesLoose(palette2, _excluded$1q);
      const primary = palette2.primary || getDefaultPrimary(mode);
      const secondary = palette2.secondary || getDefaultSecondary(mode);
      const error = palette2.error || getDefaultError(mode);
      const info = palette2.info || getDefaultInfo(mode);
      const success = palette2.success || getDefaultSuccess(mode);
      const warning2 = palette2.warning || getDefaultWarning(mode);
      function getContrastText(background) {
        const contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
        return contrastText;
      }
      const augmentColor = ({
        color: color2,
        name,
        mainShade = 500,
        lightShade = 300,
        darkShade = 700
      }) => {
        color2 = _extends({}, color2);
        if (!color2.main && color2[mainShade]) {
          color2.main = color2[mainShade];
        }
        if (!color2.hasOwnProperty("main")) {
          throw new Error(formatMuiErrorMessage(11, name ? ` (${name})` : "", mainShade));
        }
        if (typeof color2.main !== "string") {
          throw new Error(formatMuiErrorMessage(12, name ? ` (${name})` : "", JSON.stringify(color2.main)));
        }
        addLightOrDark(color2, "light", lightShade, tonalOffset);
        addLightOrDark(color2, "dark", darkShade, tonalOffset);
        if (!color2.contrastText) {
          color2.contrastText = getContrastText(color2.main);
        }
        return color2;
      };
      const modes = {
        dark,
        light
      };
      const paletteOutput = deepmerge(_extends({
        common: _extends({}, common$1),
        mode,
        primary: augmentColor({
          color: primary,
          name: "primary"
        }),
        secondary: augmentColor({
          color: secondary,
          name: "secondary",
          mainShade: "A400",
          lightShade: "A200",
          darkShade: "A700"
        }),
        error: augmentColor({
          color: error,
          name: "error"
        }),
        warning: augmentColor({
          color: warning2,
          name: "warning"
        }),
        info: augmentColor({
          color: info,
          name: "info"
        }),
        success: augmentColor({
          color: success,
          name: "success"
        }),
        grey: grey$1,
        contrastThreshold,
        getContrastText,
        augmentColor,
        tonalOffset
      }, modes[mode]), other);
      return paletteOutput;
    }
    const _excluded$1p = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];
    function round$2(value) {
      return Math.round(value * 1e5) / 1e5;
    }
    const caseAllCaps = {
      textTransform: "uppercase"
    };
    const defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
    function createTypography(palette2, typography2) {
      const _ref = typeof typography2 === "function" ? typography2(palette2) : typography2, {
        fontFamily: fontFamily2 = defaultFontFamily,
        fontSize: fontSize2 = 14,
        fontWeightLight = 300,
        fontWeightRegular = 400,
        fontWeightMedium = 500,
        fontWeightBold = 700,
        htmlFontSize = 16,
        allVariants,
        pxToRem: pxToRem2
      } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded$1p);
      const coef = fontSize2 / 14;
      const pxToRem = pxToRem2 || ((size) => `${size / htmlFontSize * coef}rem`);
      const buildVariant = (fontWeight2, size, lineHeight2, letterSpacing2, casing) => _extends({
        fontFamily: fontFamily2,
        fontWeight: fontWeight2,
        fontSize: pxToRem(size),
        lineHeight: lineHeight2
      }, fontFamily2 === defaultFontFamily ? {
        letterSpacing: `${round$2(letterSpacing2 / size)}em`
      } : {}, casing, allVariants);
      const variants = {
        h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
        h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
        h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
        h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
        h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
        h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
        subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
        subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
        body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
        body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
        button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
        caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
        overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps)
      };
      return deepmerge(_extends({
        htmlFontSize,
        pxToRem,
        fontFamily: fontFamily2,
        fontSize: fontSize2,
        fontWeightLight,
        fontWeightRegular,
        fontWeightMedium,
        fontWeightBold
      }, variants), other, {
        clone: false
      });
    }
    const shadowKeyUmbraOpacity = 0.2;
    const shadowKeyPenumbraOpacity = 0.14;
    const shadowAmbientShadowOpacity = 0.12;
    function createShadow(...px) {
      return [`${px[0]}px ${px[1]}px ${px[2]}px ${px[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${px[4]}px ${px[5]}px ${px[6]}px ${px[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${px[8]}px ${px[9]}px ${px[10]}px ${px[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(",");
    }
    const shadows = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
    const shadows$1 = shadows;
    const _excluded$1o = ["duration", "easing", "delay"];
    const easing = {
      easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
      easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
      easeIn: "cubic-bezier(0.4, 0, 1, 1)",
      sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
    };
    const duration = {
      shortest: 150,
      shorter: 200,
      short: 250,
      standard: 300,
      complex: 375,
      enteringScreen: 225,
      leavingScreen: 195
    };
    function formatMs(milliseconds2) {
      return `${Math.round(milliseconds2)}ms`;
    }
    function getAutoHeightDuration(height2) {
      if (!height2) {
        return 0;
      }
      const constant = height2 / 36;
      return Math.round((4 + 15 * constant ** 0.25 + constant / 5) * 10);
    }
    function createTransitions(inputTransitions) {
      const mergedEasing = _extends({}, easing, inputTransitions.easing);
      const mergedDuration = _extends({}, duration, inputTransitions.duration);
      const create = (props2 = ["all"], options = {}) => {
        const {
          duration: durationOption = mergedDuration.standard,
          easing: easingOption = mergedEasing.easeInOut,
          delay = 0
        } = options;
        _objectWithoutPropertiesLoose(options, _excluded$1o);
        return (Array.isArray(props2) ? props2 : [props2]).map((animatedProp) => `${animatedProp} ${typeof durationOption === "string" ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay === "string" ? delay : formatMs(delay)}`).join(",");
      };
      return _extends({
        getAutoHeightDuration,
        create
      }, inputTransitions, {
        easing: mergedEasing,
        duration: mergedDuration
      });
    }
    const zIndex = {
      mobileStepper: 1e3,
      fab: 1050,
      speedDial: 1050,
      appBar: 1100,
      drawer: 1200,
      modal: 1300,
      snackbar: 1400,
      tooltip: 1500
    };
    const zIndex$1 = zIndex;
    const _excluded$1n = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];
    function createTheme(options = {}, ...args) {
      const {
        mixins: mixinsInput = {},
        palette: paletteInput = {},
        transitions: transitionsInput = {},
        typography: typographyInput = {}
      } = options, other = _objectWithoutPropertiesLoose(options, _excluded$1n);
      if (options.vars) {
        throw new Error(formatMuiErrorMessage(18));
      }
      const palette2 = createPalette(paletteInput);
      const systemTheme = createTheme$1(options);
      let muiTheme = deepmerge(systemTheme, {
        mixins: createMixins(systemTheme.breakpoints, mixinsInput),
        palette: palette2,
        shadows: shadows$1.slice(),
        typography: createTypography(palette2, typographyInput),
        transitions: createTransitions(transitionsInput),
        zIndex: _extends({}, zIndex$1)
      });
      muiTheme = deepmerge(muiTheme, other);
      muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
      return muiTheme;
    }
    const defaultTheme$1 = createTheme();
    const defaultTheme$2 = defaultTheme$1;
    function useTheme() {
      const theme = useTheme$1(defaultTheme$2);
      return theme;
    }
    function useThemeProps({
      props: props2,
      name
    }) {
      return useThemeProps$1({
        props: props2,
        name,
        defaultTheme: defaultTheme$2
      });
    }
    const rootShouldForwardProp$1 = (prop) => shouldForwardProp(prop) && prop !== "classes";
    const slotShouldForwardProp = shouldForwardProp;
    const styled = createStyled({
      defaultTheme: defaultTheme$2,
      rootShouldForwardProp: rootShouldForwardProp$1
    });
    const styled$1 = styled;
    const getOverlayAlpha = (elevation) => {
      let alphaValue;
      if (elevation < 1) {
        alphaValue = 5.11916 * elevation ** 2;
      } else {
        alphaValue = 4.5 * Math.log(elevation + 1) + 2;
      }
      return (alphaValue / 100).toFixed(2);
    };
    const getOverlayAlpha$1 = getOverlayAlpha;
    function isHostComponent(element) {
      return typeof element === "string";
    }
    function appendOwnerState(elementType, otherProps, ownerState) {
      if (elementType === void 0 || isHostComponent(elementType)) {
        return otherProps;
      }
      return _extends({}, otherProps, {
        ownerState: _extends({}, otherProps.ownerState, ownerState)
      });
    }
    function extractEventHandlers(object, excludeKeys = []) {
      if (object === void 0) {
        return {};
      }
      const result = {};
      Object.keys(object).filter((prop) => prop.match(/^on[A-Z]/) && typeof object[prop] === "function" && !excludeKeys.includes(prop)).forEach((prop) => {
        result[prop] = object[prop];
      });
      return result;
    }
    function resolveComponentProps(componentProps, ownerState) {
      if (typeof componentProps === "function") {
        return componentProps(ownerState);
      }
      return componentProps;
    }
    function omitEventHandlers(object) {
      if (object === void 0) {
        return {};
      }
      const result = {};
      Object.keys(object).filter((prop) => !(prop.match(/^on[A-Z]/) && typeof object[prop] === "function")).forEach((prop) => {
        result[prop] = object[prop];
      });
      return result;
    }
    function mergeSlotProps(parameters) {
      const {
        getSlotProps,
        additionalProps,
        externalSlotProps,
        externalForwardedProps,
        className
      } = parameters;
      if (!getSlotProps) {
        const joinedClasses2 = clsx(externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className, className, additionalProps == null ? void 0 : additionalProps.className);
        const mergedStyle2 = _extends({}, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
        const props3 = _extends({}, additionalProps, externalForwardedProps, externalSlotProps);
        if (joinedClasses2.length > 0) {
          props3.className = joinedClasses2;
        }
        if (Object.keys(mergedStyle2).length > 0) {
          props3.style = mergedStyle2;
        }
        return {
          props: props3,
          internalRef: void 0
        };
      }
      const eventHandlers = extractEventHandlers(_extends({}, externalForwardedProps, externalSlotProps));
      const componentsPropsWithoutEventHandlers = omitEventHandlers(externalSlotProps);
      const otherPropsWithoutEventHandlers = omitEventHandlers(externalForwardedProps);
      const internalSlotProps = getSlotProps(eventHandlers);
      const joinedClasses = clsx(internalSlotProps == null ? void 0 : internalSlotProps.className, additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
      const mergedStyle = _extends({}, internalSlotProps == null ? void 0 : internalSlotProps.style, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
      const props2 = _extends({}, internalSlotProps, additionalProps, otherPropsWithoutEventHandlers, componentsPropsWithoutEventHandlers);
      if (joinedClasses.length > 0) {
        props2.className = joinedClasses;
      }
      if (Object.keys(mergedStyle).length > 0) {
        props2.style = mergedStyle;
      }
      return {
        props: props2,
        internalRef: internalSlotProps.ref
      };
    }
    const _excluded$1m = ["elementType", "externalSlotProps", "ownerState"];
    function useSlotProps(parameters) {
      var _parameters$additiona;
      const {
        elementType,
        externalSlotProps,
        ownerState
      } = parameters, rest = _objectWithoutPropertiesLoose(parameters, _excluded$1m);
      const resolvedComponentsProps = resolveComponentProps(externalSlotProps, ownerState);
      const {
        props: mergedProps,
        internalRef
      } = mergeSlotProps(_extends({}, rest, {
        externalSlotProps: resolvedComponentsProps
      }));
      const ref = useForkRef(internalRef, resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, (_parameters$additiona = parameters.additionalProps) == null ? void 0 : _parameters$additiona.ref);
      const props2 = appendOwnerState(elementType, _extends({}, mergedProps, {
        ref
      }), ownerState);
      return props2;
    }
    function stripDiacritics(string) {
      return typeof string.normalize !== "undefined" ? string.normalize("NFD").replace(/[\u0300-\u036f]/g, "") : string;
    }
    function createFilterOptions(config2 = {}) {
      const {
        ignoreAccents = true,
        ignoreCase = true,
        limit,
        matchFrom = "any",
        stringify: stringify2,
        trim: trim2 = false
      } = config2;
      return (options, {
        inputValue,
        getOptionLabel
      }) => {
        let input = trim2 ? inputValue.trim() : inputValue;
        if (ignoreCase) {
          input = input.toLowerCase();
        }
        if (ignoreAccents) {
          input = stripDiacritics(input);
        }
        const filteredOptions = !input ? options : options.filter((option) => {
          let candidate = (stringify2 || getOptionLabel)(option);
          if (ignoreCase) {
            candidate = candidate.toLowerCase();
          }
          if (ignoreAccents) {
            candidate = stripDiacritics(candidate);
          }
          return matchFrom === "start" ? candidate.indexOf(input) === 0 : candidate.indexOf(input) > -1;
        });
        return typeof limit === "number" ? filteredOptions.slice(0, limit) : filteredOptions;
      };
    }
    function findIndex(array, comp) {
      for (let i = 0; i < array.length; i += 1) {
        if (comp(array[i])) {
          return i;
        }
      }
      return -1;
    }
    const defaultFilterOptions = createFilterOptions();
    const pageSize = 5;
    const defaultIsActiveElementInListbox = (listboxRef) => {
      var _listboxRef$current$p;
      return listboxRef.current !== null && ((_listboxRef$current$p = listboxRef.current.parentElement) == null ? void 0 : _listboxRef$current$p.contains(document.activeElement));
    };
    function useAutocomplete(props2) {
      const {
        unstable_isActiveElementInListbox = defaultIsActiveElementInListbox,
        unstable_classNamePrefix = "Mui",
        autoComplete = false,
        autoHighlight = false,
        autoSelect = false,
        blurOnSelect = false,
        clearOnBlur = !props2.freeSolo,
        clearOnEscape = false,
        componentName = "useAutocomplete",
        defaultValue = props2.multiple ? [] : null,
        disableClearable = false,
        disableCloseOnSelect = false,
        disabled: disabledProp,
        disabledItemsFocusable = false,
        disableListWrap = false,
        filterOptions = defaultFilterOptions,
        filterSelectedOptions = false,
        freeSolo = false,
        getOptionDisabled,
        getOptionLabel: getOptionLabelProp = (option) => {
          var _option$label;
          return (_option$label = option.label) != null ? _option$label : option;
        },
        groupBy,
        handleHomeEndKeys = !props2.freeSolo,
        id: idProp,
        includeInputInList = false,
        inputValue: inputValueProp,
        isOptionEqualToValue = (option, value2) => option === value2,
        multiple = false,
        onChange,
        onClose,
        onHighlightChange,
        onInputChange,
        onOpen,
        open: openProp,
        openOnFocus = false,
        options,
        readOnly = false,
        selectOnFocus = !props2.freeSolo,
        value: valueProp
      } = props2;
      const id2 = useId(idProp);
      let getOptionLabel = getOptionLabelProp;
      getOptionLabel = (option) => {
        const optionLabel = getOptionLabelProp(option);
        if (typeof optionLabel !== "string") {
          return String(optionLabel);
        }
        return optionLabel;
      };
      const ignoreFocus = react.exports.useRef(false);
      const firstFocus = react.exports.useRef(true);
      const inputRef = react.exports.useRef(null);
      const listboxRef = react.exports.useRef(null);
      const [anchorEl, setAnchorEl] = react.exports.useState(null);
      const [focusedTag, setFocusedTag] = react.exports.useState(-1);
      const defaultHighlighted = autoHighlight ? 0 : -1;
      const highlightedIndexRef = react.exports.useRef(defaultHighlighted);
      const [value, setValueState] = useControlled({
        controlled: valueProp,
        default: defaultValue,
        name: componentName
      });
      const [inputValue, setInputValueState] = useControlled({
        controlled: inputValueProp,
        default: "",
        name: componentName,
        state: "inputValue"
      });
      const [focused, setFocused] = react.exports.useState(false);
      const resetInputValue = react.exports.useCallback((event, newValue) => {
        const isOptionSelected = multiple ? value.length < newValue.length : newValue !== null;
        if (!isOptionSelected && !clearOnBlur) {
          return;
        }
        let newInputValue;
        if (multiple) {
          newInputValue = "";
        } else if (newValue == null) {
          newInputValue = "";
        } else {
          const optionLabel = getOptionLabel(newValue);
          newInputValue = typeof optionLabel === "string" ? optionLabel : "";
        }
        if (inputValue === newInputValue) {
          return;
        }
        setInputValueState(newInputValue);
        if (onInputChange) {
          onInputChange(event, newInputValue, "reset");
        }
      }, [getOptionLabel, inputValue, multiple, onInputChange, setInputValueState, clearOnBlur, value]);
      const prevValue = react.exports.useRef();
      react.exports.useEffect(() => {
        const valueChange = value !== prevValue.current;
        prevValue.current = value;
        if (focused && !valueChange) {
          return;
        }
        if (freeSolo && !valueChange) {
          return;
        }
        resetInputValue(null, value);
      }, [value, resetInputValue, focused, prevValue, freeSolo]);
      const [open, setOpenState] = useControlled({
        controlled: openProp,
        default: false,
        name: componentName,
        state: "open"
      });
      const [inputPristine, setInputPristine] = react.exports.useState(true);
      const inputValueIsSelectedValue = !multiple && value != null && inputValue === getOptionLabel(value);
      const popupOpen = open && !readOnly;
      const filteredOptions = popupOpen ? filterOptions(
        options.filter((option) => {
          if (filterSelectedOptions && (multiple ? value : [value]).some((value2) => value2 !== null && isOptionEqualToValue(option, value2))) {
            return false;
          }
          return true;
        }),
        {
          inputValue: inputValueIsSelectedValue && inputPristine ? "" : inputValue,
          getOptionLabel
        }
      ) : [];
      const listboxAvailable = open && filteredOptions.length > 0 && !readOnly;
      const focusTag = useEventCallback((tagToFocus) => {
        if (tagToFocus === -1) {
          inputRef.current.focus();
        } else {
          anchorEl.querySelector(`[data-tag-index="${tagToFocus}"]`).focus();
        }
      });
      react.exports.useEffect(() => {
        if (multiple && focusedTag > value.length - 1) {
          setFocusedTag(-1);
          focusTag(-1);
        }
      }, [value, multiple, focusedTag, focusTag]);
      function validOptionIndex(index2, direction) {
        if (!listboxRef.current || index2 === -1) {
          return -1;
        }
        let nextFocus = index2;
        while (true) {
          if (direction === "next" && nextFocus === filteredOptions.length || direction === "previous" && nextFocus === -1) {
            return -1;
          }
          const option = listboxRef.current.querySelector(`[data-option-index="${nextFocus}"]`);
          const nextFocusDisabled = disabledItemsFocusable ? false : !option || option.disabled || option.getAttribute("aria-disabled") === "true";
          if (option && !option.hasAttribute("tabindex") || nextFocusDisabled) {
            nextFocus += direction === "next" ? 1 : -1;
          } else {
            return nextFocus;
          }
        }
      }
      const setHighlightedIndex = useEventCallback(({
        event,
        index: index2,
        reason = "auto"
      }) => {
        highlightedIndexRef.current = index2;
        if (index2 === -1) {
          inputRef.current.removeAttribute("aria-activedescendant");
        } else {
          inputRef.current.setAttribute("aria-activedescendant", `${id2}-option-${index2}`);
        }
        if (onHighlightChange) {
          onHighlightChange(event, index2 === -1 ? null : filteredOptions[index2], reason);
        }
        if (!listboxRef.current) {
          return;
        }
        const prev2 = listboxRef.current.querySelector(`[role="option"].${unstable_classNamePrefix}-focused`);
        if (prev2) {
          prev2.classList.remove(`${unstable_classNamePrefix}-focused`);
          prev2.classList.remove(`${unstable_classNamePrefix}-focusVisible`);
        }
        const listboxNode = listboxRef.current.parentElement.querySelector('[role="listbox"]');
        if (!listboxNode) {
          return;
        }
        if (index2 === -1) {
          listboxNode.scrollTop = 0;
          return;
        }
        const option = listboxRef.current.querySelector(`[data-option-index="${index2}"]`);
        if (!option) {
          return;
        }
        option.classList.add(`${unstable_classNamePrefix}-focused`);
        if (reason === "keyboard") {
          option.classList.add(`${unstable_classNamePrefix}-focusVisible`);
        }
        if (listboxNode.scrollHeight > listboxNode.clientHeight && reason !== "mouse") {
          const element = option;
          const scrollBottom = listboxNode.clientHeight + listboxNode.scrollTop;
          const elementBottom = element.offsetTop + element.offsetHeight;
          if (elementBottom > scrollBottom) {
            listboxNode.scrollTop = elementBottom - listboxNode.clientHeight;
          } else if (element.offsetTop - element.offsetHeight * (groupBy ? 1.3 : 0) < listboxNode.scrollTop) {
            listboxNode.scrollTop = element.offsetTop - element.offsetHeight * (groupBy ? 1.3 : 0);
          }
        }
      });
      const changeHighlightedIndex = useEventCallback(({
        event,
        diff: diff2,
        direction = "next",
        reason = "auto"
      }) => {
        if (!popupOpen) {
          return;
        }
        const getNextIndex = () => {
          const maxIndex = filteredOptions.length - 1;
          if (diff2 === "reset") {
            return defaultHighlighted;
          }
          if (diff2 === "start") {
            return 0;
          }
          if (diff2 === "end") {
            return maxIndex;
          }
          const newIndex = highlightedIndexRef.current + diff2;
          if (newIndex < 0) {
            if (newIndex === -1 && includeInputInList) {
              return -1;
            }
            if (disableListWrap && highlightedIndexRef.current !== -1 || Math.abs(diff2) > 1) {
              return 0;
            }
            return maxIndex;
          }
          if (newIndex > maxIndex) {
            if (newIndex === maxIndex + 1 && includeInputInList) {
              return -1;
            }
            if (disableListWrap || Math.abs(diff2) > 1) {
              return maxIndex;
            }
            return 0;
          }
          return newIndex;
        };
        const nextIndex = validOptionIndex(getNextIndex(), direction);
        setHighlightedIndex({
          index: nextIndex,
          reason,
          event
        });
        if (autoComplete && diff2 !== "reset") {
          if (nextIndex === -1) {
            inputRef.current.value = inputValue;
          } else {
            const option = getOptionLabel(filteredOptions[nextIndex]);
            inputRef.current.value = option;
            const index2 = option.toLowerCase().indexOf(inputValue.toLowerCase());
            if (index2 === 0 && inputValue.length > 0) {
              inputRef.current.setSelectionRange(inputValue.length, option.length);
            }
          }
        }
      });
      const syncHighlightedIndex = react.exports.useCallback(() => {
        if (!popupOpen) {
          return;
        }
        const valueItem = multiple ? value[0] : value;
        if (filteredOptions.length === 0 || valueItem == null) {
          changeHighlightedIndex({
            diff: "reset"
          });
          return;
        }
        if (!listboxRef.current) {
          return;
        }
        if (valueItem != null) {
          const currentOption = filteredOptions[highlightedIndexRef.current];
          if (multiple && currentOption && findIndex(value, (val) => isOptionEqualToValue(currentOption, val)) !== -1) {
            return;
          }
          const itemIndex = findIndex(filteredOptions, (optionItem) => isOptionEqualToValue(optionItem, valueItem));
          if (itemIndex === -1) {
            changeHighlightedIndex({
              diff: "reset"
            });
          } else {
            setHighlightedIndex({
              index: itemIndex
            });
          }
          return;
        }
        if (highlightedIndexRef.current >= filteredOptions.length - 1) {
          setHighlightedIndex({
            index: filteredOptions.length - 1
          });
          return;
        }
        setHighlightedIndex({
          index: highlightedIndexRef.current
        });
      }, [
        filteredOptions.length,
        multiple ? false : value,
        filterSelectedOptions,
        changeHighlightedIndex,
        setHighlightedIndex,
        popupOpen,
        inputValue,
        multiple
      ]);
      const handleListboxRef = useEventCallback((node2) => {
        setRef(listboxRef, node2);
        if (!node2) {
          return;
        }
        syncHighlightedIndex();
      });
      react.exports.useEffect(() => {
        syncHighlightedIndex();
      }, [syncHighlightedIndex]);
      const handleOpen = (event) => {
        if (open) {
          return;
        }
        setOpenState(true);
        setInputPristine(true);
        if (onOpen) {
          onOpen(event);
        }
      };
      const handleClose = (event, reason) => {
        if (!open) {
          return;
        }
        setOpenState(false);
        if (onClose) {
          onClose(event, reason);
        }
      };
      const handleValue = (event, newValue, reason, details) => {
        if (multiple) {
          if (value.length === newValue.length && value.every((val, i) => val === newValue[i])) {
            return;
          }
        } else if (value === newValue) {
          return;
        }
        if (onChange) {
          onChange(event, newValue, reason, details);
        }
        setValueState(newValue);
      };
      const isTouch = react.exports.useRef(false);
      const selectNewValue = (event, option, reasonProp = "selectOption", origin = "options") => {
        let reason = reasonProp;
        let newValue = option;
        if (multiple) {
          newValue = Array.isArray(value) ? value.slice() : [];
          const itemIndex = findIndex(newValue, (valueItem) => isOptionEqualToValue(option, valueItem));
          if (itemIndex === -1) {
            newValue.push(option);
          } else if (origin !== "freeSolo") {
            newValue.splice(itemIndex, 1);
            reason = "removeOption";
          }
        }
        resetInputValue(event, newValue);
        handleValue(event, newValue, reason, {
          option
        });
        if (!disableCloseOnSelect && (!event || !event.ctrlKey && !event.metaKey)) {
          handleClose(event, reason);
        }
        if (blurOnSelect === true || blurOnSelect === "touch" && isTouch.current || blurOnSelect === "mouse" && !isTouch.current) {
          inputRef.current.blur();
        }
      };
      function validTagIndex(index2, direction) {
        if (index2 === -1) {
          return -1;
        }
        let nextFocus = index2;
        while (true) {
          if (direction === "next" && nextFocus === value.length || direction === "previous" && nextFocus === -1) {
            return -1;
          }
          const option = anchorEl.querySelector(`[data-tag-index="${nextFocus}"]`);
          if (!option || !option.hasAttribute("tabindex") || option.disabled || option.getAttribute("aria-disabled") === "true") {
            nextFocus += direction === "next" ? 1 : -1;
          } else {
            return nextFocus;
          }
        }
      }
      const handleFocusTag = (event, direction) => {
        if (!multiple) {
          return;
        }
        if (inputValue === "") {
          handleClose(event, "toggleInput");
        }
        let nextTag = focusedTag;
        if (focusedTag === -1) {
          if (inputValue === "" && direction === "previous") {
            nextTag = value.length - 1;
          }
        } else {
          nextTag += direction === "next" ? 1 : -1;
          if (nextTag < 0) {
            nextTag = 0;
          }
          if (nextTag === value.length) {
            nextTag = -1;
          }
        }
        nextTag = validTagIndex(nextTag, direction);
        setFocusedTag(nextTag);
        focusTag(nextTag);
      };
      const handleClear = (event) => {
        ignoreFocus.current = true;
        setInputValueState("");
        if (onInputChange) {
          onInputChange(event, "", "clear");
        }
        handleValue(event, multiple ? [] : null, "clear");
      };
      const handleKeyDown2 = (other) => (event) => {
        if (other.onKeyDown) {
          other.onKeyDown(event);
        }
        if (event.defaultMuiPrevented) {
          return;
        }
        if (focusedTag !== -1 && ["ArrowLeft", "ArrowRight"].indexOf(event.key) === -1) {
          setFocusedTag(-1);
          focusTag(-1);
        }
        if (event.which !== 229) {
          switch (event.key) {
            case "Home":
              if (popupOpen && handleHomeEndKeys) {
                event.preventDefault();
                changeHighlightedIndex({
                  diff: "start",
                  direction: "next",
                  reason: "keyboard",
                  event
                });
              }
              break;
            case "End":
              if (popupOpen && handleHomeEndKeys) {
                event.preventDefault();
                changeHighlightedIndex({
                  diff: "end",
                  direction: "previous",
                  reason: "keyboard",
                  event
                });
              }
              break;
            case "PageUp":
              event.preventDefault();
              changeHighlightedIndex({
                diff: -pageSize,
                direction: "previous",
                reason: "keyboard",
                event
              });
              handleOpen(event);
              break;
            case "PageDown":
              event.preventDefault();
              changeHighlightedIndex({
                diff: pageSize,
                direction: "next",
                reason: "keyboard",
                event
              });
              handleOpen(event);
              break;
            case "ArrowDown":
              event.preventDefault();
              changeHighlightedIndex({
                diff: 1,
                direction: "next",
                reason: "keyboard",
                event
              });
              handleOpen(event);
              break;
            case "ArrowUp":
              event.preventDefault();
              changeHighlightedIndex({
                diff: -1,
                direction: "previous",
                reason: "keyboard",
                event
              });
              handleOpen(event);
              break;
            case "ArrowLeft":
              handleFocusTag(event, "previous");
              break;
            case "ArrowRight":
              handleFocusTag(event, "next");
              break;
            case "Enter":
              if (highlightedIndexRef.current !== -1 && popupOpen) {
                const option = filteredOptions[highlightedIndexRef.current];
                const disabled = getOptionDisabled ? getOptionDisabled(option) : false;
                event.preventDefault();
                if (disabled) {
                  return;
                }
                selectNewValue(event, option, "selectOption");
                if (autoComplete) {
                  inputRef.current.setSelectionRange(inputRef.current.value.length, inputRef.current.value.length);
                }
              } else if (freeSolo && inputValue !== "" && inputValueIsSelectedValue === false) {
                if (multiple) {
                  event.preventDefault();
                }
                selectNewValue(event, inputValue, "createOption", "freeSolo");
              }
              break;
            case "Escape":
              if (popupOpen) {
                event.preventDefault();
                event.stopPropagation();
                handleClose(event, "escape");
              } else if (clearOnEscape && (inputValue !== "" || multiple && value.length > 0)) {
                event.preventDefault();
                event.stopPropagation();
                handleClear(event);
              }
              break;
            case "Backspace":
              if (multiple && !readOnly && inputValue === "" && value.length > 0) {
                const index2 = focusedTag === -1 ? value.length - 1 : focusedTag;
                const newValue = value.slice();
                newValue.splice(index2, 1);
                handleValue(event, newValue, "removeOption", {
                  option: value[index2]
                });
              }
              break;
            case "Delete":
              if (multiple && !readOnly && inputValue === "" && value.length > 0 && focusedTag !== -1) {
                const index2 = focusedTag;
                const newValue = value.slice();
                newValue.splice(index2, 1);
                handleValue(event, newValue, "removeOption", {
                  option: value[index2]
                });
              }
              break;
          }
        }
      };
      const handleFocus = (event) => {
        setFocused(true);
        if (openOnFocus && !ignoreFocus.current) {
          handleOpen(event);
        }
      };
      const handleBlur = (event) => {
        if (unstable_isActiveElementInListbox(listboxRef)) {
          inputRef.current.focus();
          return;
        }
        setFocused(false);
        firstFocus.current = true;
        ignoreFocus.current = false;
        if (autoSelect && highlightedIndexRef.current !== -1 && popupOpen) {
          selectNewValue(event, filteredOptions[highlightedIndexRef.current], "blur");
        } else if (autoSelect && freeSolo && inputValue !== "") {
          selectNewValue(event, inputValue, "blur", "freeSolo");
        } else if (clearOnBlur) {
          resetInputValue(event, value);
        }
        handleClose(event, "blur");
      };
      const handleInputChange = (event) => {
        const newValue = event.target.value;
        if (inputValue !== newValue) {
          setInputValueState(newValue);
          setInputPristine(false);
          if (onInputChange) {
            onInputChange(event, newValue, "input");
          }
        }
        if (newValue === "") {
          if (!disableClearable && !multiple) {
            handleValue(event, null, "clear");
          }
        } else {
          handleOpen(event);
        }
      };
      const handleOptionMouseOver = (event) => {
        setHighlightedIndex({
          event,
          index: Number(event.currentTarget.getAttribute("data-option-index")),
          reason: "mouse"
        });
      };
      const handleOptionTouchStart = () => {
        isTouch.current = true;
      };
      const handleOptionClick = (event) => {
        const index2 = Number(event.currentTarget.getAttribute("data-option-index"));
        selectNewValue(event, filteredOptions[index2], "selectOption");
        isTouch.current = false;
      };
      const handleTagDelete = (index2) => (event) => {
        const newValue = value.slice();
        newValue.splice(index2, 1);
        handleValue(event, newValue, "removeOption", {
          option: value[index2]
        });
      };
      const handlePopupIndicator = (event) => {
        if (open) {
          handleClose(event, "toggleInput");
        } else {
          handleOpen(event);
        }
      };
      const handleMouseDown = (event) => {
        if (event.target.getAttribute("id") !== id2) {
          event.preventDefault();
        }
      };
      const handleClick = () => {
        inputRef.current.focus();
        if (selectOnFocus && firstFocus.current && inputRef.current.selectionEnd - inputRef.current.selectionStart === 0) {
          inputRef.current.select();
        }
        firstFocus.current = false;
      };
      const handleInputMouseDown = (event) => {
        if (inputValue === "" || !open) {
          handlePopupIndicator(event);
        }
      };
      let dirty = freeSolo && inputValue.length > 0;
      dirty = dirty || (multiple ? value.length > 0 : value !== null);
      let groupedOptions = filteredOptions;
      if (groupBy) {
        groupedOptions = filteredOptions.reduce((acc, option, index2) => {
          const group = groupBy(option);
          if (acc.length > 0 && acc[acc.length - 1].group === group) {
            acc[acc.length - 1].options.push(option);
          } else {
            acc.push({
              key: index2,
              index: index2,
              group,
              options: [option]
            });
          }
          return acc;
        }, []);
      }
      if (disabledProp && focused) {
        handleBlur();
      }
      return {
        getRootProps: (other = {}) => _extends({
          "aria-owns": listboxAvailable ? `${id2}-listbox` : null
        }, other, {
          onKeyDown: handleKeyDown2(other),
          onMouseDown: handleMouseDown,
          onClick: handleClick
        }),
        getInputLabelProps: () => ({
          id: `${id2}-label`,
          htmlFor: id2
        }),
        getInputProps: () => ({
          id: id2,
          value: inputValue,
          onBlur: handleBlur,
          onFocus: handleFocus,
          onChange: handleInputChange,
          onMouseDown: handleInputMouseDown,
          "aria-activedescendant": popupOpen ? "" : null,
          "aria-autocomplete": autoComplete ? "both" : "list",
          "aria-controls": listboxAvailable ? `${id2}-listbox` : void 0,
          "aria-expanded": listboxAvailable,
          autoComplete: "off",
          ref: inputRef,
          autoCapitalize: "none",
          spellCheck: "false",
          role: "combobox"
        }),
        getClearProps: () => ({
          tabIndex: -1,
          onClick: handleClear
        }),
        getPopupIndicatorProps: () => ({
          tabIndex: -1,
          onClick: handlePopupIndicator
        }),
        getTagProps: ({
          index: index2
        }) => _extends({
          key: index2,
          "data-tag-index": index2,
          tabIndex: -1
        }, !readOnly && {
          onDelete: handleTagDelete(index2)
        }),
        getListboxProps: () => ({
          role: "listbox",
          id: `${id2}-listbox`,
          "aria-labelledby": `${id2}-label`,
          ref: handleListboxRef,
          onMouseDown: (event) => {
            event.preventDefault();
          }
        }),
        getOptionProps: ({
          index: index2,
          option
        }) => {
          const selected = (multiple ? value : [value]).some((value2) => value2 != null && isOptionEqualToValue(option, value2));
          const disabled = getOptionDisabled ? getOptionDisabled(option) : false;
          return {
            key: getOptionLabel(option),
            tabIndex: -1,
            role: "option",
            id: `${id2}-option-${index2}`,
            onMouseOver: handleOptionMouseOver,
            onClick: handleOptionClick,
            onTouchStart: handleOptionTouchStart,
            "data-option-index": index2,
            "aria-disabled": disabled,
            "aria-selected": selected
          };
        },
        id: id2,
        inputValue,
        value,
        dirty,
        popupOpen,
        focused: focused || focusedTag !== -1,
        anchorEl,
        setAnchorEl,
        focusedTag,
        groupedOptions
      };
    }
    const candidatesSelector = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
    function getTabIndex(node2) {
      const tabindexAttr = parseInt(node2.getAttribute("tabindex"), 10);
      if (!Number.isNaN(tabindexAttr)) {
        return tabindexAttr;
      }
      if (node2.contentEditable === "true" || (node2.nodeName === "AUDIO" || node2.nodeName === "VIDEO" || node2.nodeName === "DETAILS") && node2.getAttribute("tabindex") === null) {
        return 0;
      }
      return node2.tabIndex;
    }
    function isNonTabbableRadio(node2) {
      if (node2.tagName !== "INPUT" || node2.type !== "radio") {
        return false;
      }
      if (!node2.name) {
        return false;
      }
      const getRadio = (selector) => node2.ownerDocument.querySelector(`input[type="radio"]${selector}`);
      let roving = getRadio(`[name="${node2.name}"]:checked`);
      if (!roving) {
        roving = getRadio(`[name="${node2.name}"]`);
      }
      return roving !== node2;
    }
    function isNodeMatchingSelectorFocusable(node2) {
      if (node2.disabled || node2.tagName === "INPUT" && node2.type === "hidden" || isNonTabbableRadio(node2)) {
        return false;
      }
      return true;
    }
    function defaultGetTabbable(root2) {
      const regularTabNodes = [];
      const orderedTabNodes = [];
      Array.from(root2.querySelectorAll(candidatesSelector)).forEach((node2, i) => {
        const nodeTabIndex = getTabIndex(node2);
        if (nodeTabIndex === -1 || !isNodeMatchingSelectorFocusable(node2)) {
          return;
        }
        if (nodeTabIndex === 0) {
          regularTabNodes.push(node2);
        } else {
          orderedTabNodes.push({
            documentOrder: i,
            tabIndex: nodeTabIndex,
            node: node2
          });
        }
      });
      return orderedTabNodes.sort((a, b2) => a.tabIndex === b2.tabIndex ? a.documentOrder - b2.documentOrder : a.tabIndex - b2.tabIndex).map((a) => a.node).concat(regularTabNodes);
    }
    function defaultIsEnabled() {
      return true;
    }
    function FocusTrap(props2) {
      const {
        children,
        disableAutoFocus = false,
        disableEnforceFocus = false,
        disableRestoreFocus = false,
        getTabbable = defaultGetTabbable,
        isEnabled = defaultIsEnabled,
        open
      } = props2;
      const ignoreNextEnforceFocus = react.exports.useRef();
      const sentinelStart = react.exports.useRef(null);
      const sentinelEnd = react.exports.useRef(null);
      const nodeToRestore = react.exports.useRef(null);
      const reactFocusEventTarget = react.exports.useRef(null);
      const activated = react.exports.useRef(false);
      const rootRef = react.exports.useRef(null);
      const handleRef = useForkRef(children.ref, rootRef);
      const lastKeydown = react.exports.useRef(null);
      react.exports.useEffect(() => {
        if (!open || !rootRef.current) {
          return;
        }
        activated.current = !disableAutoFocus;
      }, [disableAutoFocus, open]);
      react.exports.useEffect(() => {
        if (!open || !rootRef.current) {
          return;
        }
        const doc = ownerDocument(rootRef.current);
        if (!rootRef.current.contains(doc.activeElement)) {
          if (!rootRef.current.hasAttribute("tabIndex")) {
            rootRef.current.setAttribute("tabIndex", -1);
          }
          if (activated.current) {
            rootRef.current.focus();
          }
        }
        return () => {
          if (!disableRestoreFocus) {
            if (nodeToRestore.current && nodeToRestore.current.focus) {
              ignoreNextEnforceFocus.current = true;
              nodeToRestore.current.focus();
            }
            nodeToRestore.current = null;
          }
        };
      }, [open]);
      react.exports.useEffect(() => {
        if (!open || !rootRef.current) {
          return;
        }
        const doc = ownerDocument(rootRef.current);
        const contain = (nativeEvent) => {
          const {
            current: rootElement
          } = rootRef;
          if (rootElement === null) {
            return;
          }
          if (!doc.hasFocus() || disableEnforceFocus || !isEnabled() || ignoreNextEnforceFocus.current) {
            ignoreNextEnforceFocus.current = false;
            return;
          }
          if (!rootElement.contains(doc.activeElement)) {
            if (nativeEvent && reactFocusEventTarget.current !== nativeEvent.target || doc.activeElement !== reactFocusEventTarget.current) {
              reactFocusEventTarget.current = null;
            } else if (reactFocusEventTarget.current !== null) {
              return;
            }
            if (!activated.current) {
              return;
            }
            let tabbable = [];
            if (doc.activeElement === sentinelStart.current || doc.activeElement === sentinelEnd.current) {
              tabbable = getTabbable(rootRef.current);
            }
            if (tabbable.length > 0) {
              var _lastKeydown$current, _lastKeydown$current2;
              const isShiftTab = Boolean(((_lastKeydown$current = lastKeydown.current) == null ? void 0 : _lastKeydown$current.shiftKey) && ((_lastKeydown$current2 = lastKeydown.current) == null ? void 0 : _lastKeydown$current2.key) === "Tab");
              const focusNext = tabbable[0];
              const focusPrevious = tabbable[tabbable.length - 1];
              if (isShiftTab) {
                focusPrevious.focus();
              } else {
                focusNext.focus();
              }
            } else {
              rootElement.focus();
            }
          }
        };
        const loopFocus = (nativeEvent) => {
          lastKeydown.current = nativeEvent;
          if (disableEnforceFocus || !isEnabled() || nativeEvent.key !== "Tab") {
            return;
          }
          if (doc.activeElement === rootRef.current && nativeEvent.shiftKey) {
            ignoreNextEnforceFocus.current = true;
            sentinelEnd.current.focus();
          }
        };
        doc.addEventListener("focusin", contain);
        doc.addEventListener("keydown", loopFocus, true);
        const interval = setInterval(() => {
          if (doc.activeElement.tagName === "BODY") {
            contain();
          }
        }, 50);
        return () => {
          clearInterval(interval);
          doc.removeEventListener("focusin", contain);
          doc.removeEventListener("keydown", loopFocus, true);
        };
      }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled, open, getTabbable]);
      const onFocus = (event) => {
        if (nodeToRestore.current === null) {
          nodeToRestore.current = event.relatedTarget;
        }
        activated.current = true;
        reactFocusEventTarget.current = event.target;
        const childrenPropsHandler = children.props.onFocus;
        if (childrenPropsHandler) {
          childrenPropsHandler(event);
        }
      };
      const handleFocusSentinel = (event) => {
        if (nodeToRestore.current === null) {
          nodeToRestore.current = event.relatedTarget;
        }
        activated.current = true;
      };
      return /* @__PURE__ */ jsxs(react.exports.Fragment, {
        children: [/* @__PURE__ */ jsx("div", {
          tabIndex: open ? 0 : -1,
          onFocus: handleFocusSentinel,
          ref: sentinelStart,
          "data-testid": "sentinelStart"
        }), /* @__PURE__ */ react.exports.cloneElement(children, {
          ref: handleRef,
          onFocus
        }), /* @__PURE__ */ jsx("div", {
          tabIndex: open ? 0 : -1,
          onFocus: handleFocusSentinel,
          ref: sentinelEnd,
          "data-testid": "sentinelEnd"
        })]
      });
    }
    var top = "top";
    var bottom = "bottom";
    var right = "right";
    var left = "left";
    var auto = "auto";
    var basePlacements = [top, bottom, right, left];
    var start = "start";
    var end = "end";
    var clippingParents = "clippingParents";
    var viewport = "viewport";
    var popper = "popper";
    var reference = "reference";
    var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
      return acc.concat([placement + "-" + start, placement + "-" + end]);
    }, []);
    var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
      return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
    }, []);
    var beforeRead = "beforeRead";
    var read = "read";
    var afterRead = "afterRead";
    var beforeMain = "beforeMain";
    var main = "main";
    var afterMain = "afterMain";
    var beforeWrite = "beforeWrite";
    var write = "write";
    var afterWrite = "afterWrite";
    var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
    function getNodeName(element) {
      return element ? (element.nodeName || "").toLowerCase() : null;
    }
    function getWindow(node2) {
      if (node2 == null) {
        return window;
      }
      if (node2.toString() !== "[object Window]") {
        var ownerDocument2 = node2.ownerDocument;
        return ownerDocument2 ? ownerDocument2.defaultView || window : window;
      }
      return node2;
    }
    function isElement(node2) {
      var OwnElement = getWindow(node2).Element;
      return node2 instanceof OwnElement || node2 instanceof Element;
    }
    function isHTMLElement(node2) {
      var OwnElement = getWindow(node2).HTMLElement;
      return node2 instanceof OwnElement || node2 instanceof HTMLElement;
    }
    function isShadowRoot(node2) {
      if (typeof ShadowRoot === "undefined") {
        return false;
      }
      var OwnElement = getWindow(node2).ShadowRoot;
      return node2 instanceof OwnElement || node2 instanceof ShadowRoot;
    }
    function applyStyles(_ref) {
      var state = _ref.state;
      Object.keys(state.elements).forEach(function(name) {
        var style2 = state.styles[name] || {};
        var attributes = state.attributes[name] || {};
        var element = state.elements[name];
        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }
        Object.assign(element.style, style2);
        Object.keys(attributes).forEach(function(name2) {
          var value = attributes[name2];
          if (value === false) {
            element.removeAttribute(name2);
          } else {
            element.setAttribute(name2, value === true ? "" : value);
          }
        });
      });
    }
    function effect$2(_ref2) {
      var state = _ref2.state;
      var initialStyles = {
        popper: {
          position: state.options.strategy,
          left: "0",
          top: "0",
          margin: "0"
        },
        arrow: {
          position: "absolute"
        },
        reference: {}
      };
      Object.assign(state.elements.popper.style, initialStyles.popper);
      state.styles = initialStyles;
      if (state.elements.arrow) {
        Object.assign(state.elements.arrow.style, initialStyles.arrow);
      }
      return function() {
        Object.keys(state.elements).forEach(function(name) {
          var element = state.elements[name];
          var attributes = state.attributes[name] || {};
          var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
          var style2 = styleProperties.reduce(function(style3, property) {
            style3[property] = "";
            return style3;
          }, {});
          if (!isHTMLElement(element) || !getNodeName(element)) {
            return;
          }
          Object.assign(element.style, style2);
          Object.keys(attributes).forEach(function(attribute) {
            element.removeAttribute(attribute);
          });
        });
      };
    }
    const applyStyles$1 = {
      name: "applyStyles",
      enabled: true,
      phase: "write",
      fn: applyStyles,
      effect: effect$2,
      requires: ["computeStyles"]
    };
    function getBasePlacement(placement) {
      return placement.split("-")[0];
    }
    var max$1 = Math.max;
    var min$1 = Math.min;
    var round$1 = Math.round;
    function getUAString() {
      var uaData = navigator.userAgentData;
      if (uaData != null && uaData.brands) {
        return uaData.brands.map(function(item) {
          return item.brand + "/" + item.version;
        }).join(" ");
      }
      return navigator.userAgent;
    }
    function isLayoutViewport() {
      return !/^((?!chrome|android).)*safari/i.test(getUAString());
    }
    function getBoundingClientRect(element, includeScale, isFixedStrategy) {
      if (includeScale === void 0) {
        includeScale = false;
      }
      if (isFixedStrategy === void 0) {
        isFixedStrategy = false;
      }
      var clientRect = element.getBoundingClientRect();
      var scaleX = 1;
      var scaleY = 1;
      if (includeScale && isHTMLElement(element)) {
        scaleX = element.offsetWidth > 0 ? round$1(clientRect.width) / element.offsetWidth || 1 : 1;
        scaleY = element.offsetHeight > 0 ? round$1(clientRect.height) / element.offsetHeight || 1 : 1;
      }
      var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
      var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
      var x2 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
      var y2 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
      var width2 = clientRect.width / scaleX;
      var height2 = clientRect.height / scaleY;
      return {
        width: width2,
        height: height2,
        top: y2,
        right: x2 + width2,
        bottom: y2 + height2,
        left: x2,
        x: x2,
        y: y2
      };
    }
    function getLayoutRect(element) {
      var clientRect = getBoundingClientRect(element);
      var width2 = element.offsetWidth;
      var height2 = element.offsetHeight;
      if (Math.abs(clientRect.width - width2) <= 1) {
        width2 = clientRect.width;
      }
      if (Math.abs(clientRect.height - height2) <= 1) {
        height2 = clientRect.height;
      }
      return {
        x: element.offsetLeft,
        y: element.offsetTop,
        width: width2,
        height: height2
      };
    }
    function contains(parent, child) {
      var rootNode = child.getRootNode && child.getRootNode();
      if (parent.contains(child)) {
        return true;
      } else if (rootNode && isShadowRoot(rootNode)) {
        var next2 = child;
        do {
          if (next2 && parent.isSameNode(next2)) {
            return true;
          }
          next2 = next2.parentNode || next2.host;
        } while (next2);
      }
      return false;
    }
    function getComputedStyle(element) {
      return getWindow(element).getComputedStyle(element);
    }
    function isTableElement(element) {
      return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
    }
    function getDocumentElement(element) {
      return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;
    }
    function getParentNode(element) {
      if (getNodeName(element) === "html") {
        return element;
      }
      return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
    }
    function getTrueOffsetParent(element) {
      if (!isHTMLElement(element) || getComputedStyle(element).position === "fixed") {
        return null;
      }
      return element.offsetParent;
    }
    function getContainingBlock(element) {
      var isFirefox = /firefox/i.test(getUAString());
      var isIE = /Trident/i.test(getUAString());
      if (isIE && isHTMLElement(element)) {
        var elementCss = getComputedStyle(element);
        if (elementCss.position === "fixed") {
          return null;
        }
      }
      var currentNode = getParentNode(element);
      if (isShadowRoot(currentNode)) {
        currentNode = currentNode.host;
      }
      while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
        var css2 = getComputedStyle(currentNode);
        if (css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].indexOf(css2.willChange) !== -1 || isFirefox && css2.willChange === "filter" || isFirefox && css2.filter && css2.filter !== "none") {
          return currentNode;
        } else {
          currentNode = currentNode.parentNode;
        }
      }
      return null;
    }
    function getOffsetParent(element) {
      var window2 = getWindow(element);
      var offsetParent = getTrueOffsetParent(element);
      while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
        offsetParent = getTrueOffsetParent(offsetParent);
      }
      if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
        return window2;
      }
      return offsetParent || getContainingBlock(element) || window2;
    }
    function getMainAxisFromPlacement(placement) {
      return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
    }
    function within(min2, value, max2) {
      return max$1(min2, min$1(value, max2));
    }
    function withinMaxClamp(min2, value, max2) {
      var v2 = within(min2, value, max2);
      return v2 > max2 ? max2 : v2;
    }
    function getFreshSideObject() {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    }
    function mergePaddingObject(paddingObject) {
      return Object.assign({}, getFreshSideObject(), paddingObject);
    }
    function expandToHashMap(value, keys2) {
      return keys2.reduce(function(hashMap, key) {
        hashMap[key] = value;
        return hashMap;
      }, {});
    }
    var toPaddingObject = function toPaddingObject2(padding, state) {
      padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
        placement: state.placement
      })) : padding;
      return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
    };
    function arrow(_ref) {
      var _state$modifiersData$;
      var state = _ref.state, name = _ref.name, options = _ref.options;
      var arrowElement = state.elements.arrow;
      var popperOffsets2 = state.modifiersData.popperOffsets;
      var basePlacement = getBasePlacement(state.placement);
      var axis = getMainAxisFromPlacement(basePlacement);
      var isVertical = [left, right].indexOf(basePlacement) >= 0;
      var len = isVertical ? "height" : "width";
      if (!arrowElement || !popperOffsets2) {
        return;
      }
      var paddingObject = toPaddingObject(options.padding, state);
      var arrowRect = getLayoutRect(arrowElement);
      var minProp = axis === "y" ? top : left;
      var maxProp = axis === "y" ? bottom : right;
      var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
      var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
      var arrowOffsetParent = getOffsetParent(arrowElement);
      var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
      var centerToReference = endDiff / 2 - startDiff / 2;
      var min2 = paddingObject[minProp];
      var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
      var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
      var offset2 = within(min2, center, max2);
      var axisProp = axis;
      state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
    }
    function effect$1(_ref2) {
      var state = _ref2.state, options = _ref2.options;
      var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
      if (arrowElement == null) {
        return;
      }
      if (typeof arrowElement === "string") {
        arrowElement = state.elements.popper.querySelector(arrowElement);
        if (!arrowElement) {
          return;
        }
      }
      if (!contains(state.elements.popper, arrowElement)) {
        return;
      }
      state.elements.arrow = arrowElement;
    }
    const arrow$1 = {
      name: "arrow",
      enabled: true,
      phase: "main",
      fn: arrow,
      effect: effect$1,
      requires: ["popperOffsets"],
      requiresIfExists: ["preventOverflow"]
    };
    function getVariation(placement) {
      return placement.split("-")[1];
    }
    var unsetSides = {
      top: "auto",
      right: "auto",
      bottom: "auto",
      left: "auto"
    };
    function roundOffsetsByDPR(_ref) {
      var x2 = _ref.x, y2 = _ref.y;
      var win = window;
      var dpr = win.devicePixelRatio || 1;
      return {
        x: round$1(x2 * dpr) / dpr || 0,
        y: round$1(y2 * dpr) / dpr || 0
      };
    }
    function mapToStyles(_ref2) {
      var _Object$assign2;
      var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position2 = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
      var _offsets$x = offsets.x, x2 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y2 = _offsets$y === void 0 ? 0 : _offsets$y;
      var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
        x: x2,
        y: y2
      }) : {
        x: x2,
        y: y2
      };
      x2 = _ref3.x;
      y2 = _ref3.y;
      var hasX = offsets.hasOwnProperty("x");
      var hasY = offsets.hasOwnProperty("y");
      var sideX = left;
      var sideY = top;
      var win = window;
      if (adaptive) {
        var offsetParent = getOffsetParent(popper2);
        var heightProp = "clientHeight";
        var widthProp = "clientWidth";
        if (offsetParent === getWindow(popper2)) {
          offsetParent = getDocumentElement(popper2);
          if (getComputedStyle(offsetParent).position !== "static" && position2 === "absolute") {
            heightProp = "scrollHeight";
            widthProp = "scrollWidth";
          }
        }
        offsetParent = offsetParent;
        if (placement === top || (placement === left || placement === right) && variation === end) {
          sideY = bottom;
          var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
          y2 -= offsetY - popperRect.height;
          y2 *= gpuAcceleration ? 1 : -1;
        }
        if (placement === left || (placement === top || placement === bottom) && variation === end) {
          sideX = right;
          var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
          x2 -= offsetX - popperRect.width;
          x2 *= gpuAcceleration ? 1 : -1;
        }
      }
      var commonStyles = Object.assign({
        position: position2
      }, adaptive && unsetSides);
      var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
        x: x2,
        y: y2
      }) : {
        x: x2,
        y: y2
      };
      x2 = _ref4.x;
      y2 = _ref4.y;
      if (gpuAcceleration) {
        var _Object$assign;
        return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y2 + "px)" : "translate3d(" + x2 + "px, " + y2 + "px, 0)", _Object$assign));
      }
      return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
    }
    function computeStyles(_ref5) {
      var state = _ref5.state, options = _ref5.options;
      var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
      var commonStyles = {
        placement: getBasePlacement(state.placement),
        variation: getVariation(state.placement),
        popper: state.elements.popper,
        popperRect: state.rects.popper,
        gpuAcceleration,
        isFixed: state.options.strategy === "fixed"
      };
      if (state.modifiersData.popperOffsets != null) {
        state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.popperOffsets,
          position: state.options.strategy,
          adaptive,
          roundOffsets
        })));
      }
      if (state.modifiersData.arrow != null) {
        state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.arrow,
          position: "absolute",
          adaptive: false,
          roundOffsets
        })));
      }
      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        "data-popper-placement": state.placement
      });
    }
    const computeStyles$1 = {
      name: "computeStyles",
      enabled: true,
      phase: "beforeWrite",
      fn: computeStyles,
      data: {}
    };
    var passive = {
      passive: true
    };
    function effect(_ref) {
      var state = _ref.state, instance = _ref.instance, options = _ref.options;
      var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
      var window2 = getWindow(state.elements.popper);
      var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
      if (scroll) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.addEventListener("scroll", instance.update, passive);
        });
      }
      if (resize) {
        window2.addEventListener("resize", instance.update, passive);
      }
      return function() {
        if (scroll) {
          scrollParents.forEach(function(scrollParent) {
            scrollParent.removeEventListener("scroll", instance.update, passive);
          });
        }
        if (resize) {
          window2.removeEventListener("resize", instance.update, passive);
        }
      };
    }
    const eventListeners = {
      name: "eventListeners",
      enabled: true,
      phase: "write",
      fn: function fn() {
      },
      effect,
      data: {}
    };
    var hash$1 = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
    };
    function getOppositePlacement(placement) {
      return placement.replace(/left|right|bottom|top/g, function(matched) {
        return hash$1[matched];
      });
    }
    var hash = {
      start: "end",
      end: "start"
    };
    function getOppositeVariationPlacement(placement) {
      return placement.replace(/start|end/g, function(matched) {
        return hash[matched];
      });
    }
    function getWindowScroll(node2) {
      var win = getWindow(node2);
      var scrollLeft = win.pageXOffset;
      var scrollTop = win.pageYOffset;
      return {
        scrollLeft,
        scrollTop
      };
    }
    function getWindowScrollBarX(element) {
      return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
    }
    function getViewportRect(element, strategy) {
      var win = getWindow(element);
      var html2 = getDocumentElement(element);
      var visualViewport = win.visualViewport;
      var width2 = html2.clientWidth;
      var height2 = html2.clientHeight;
      var x2 = 0;
      var y2 = 0;
      if (visualViewport) {
        width2 = visualViewport.width;
        height2 = visualViewport.height;
        var layoutViewport = isLayoutViewport();
        if (layoutViewport || !layoutViewport && strategy === "fixed") {
          x2 = visualViewport.offsetLeft;
          y2 = visualViewport.offsetTop;
        }
      }
      return {
        width: width2,
        height: height2,
        x: x2 + getWindowScrollBarX(element),
        y: y2
      };
    }
    function getDocumentRect(element) {
      var _element$ownerDocumen;
      var html2 = getDocumentElement(element);
      var winScroll = getWindowScroll(element);
      var body2 = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
      var width2 = max$1(html2.scrollWidth, html2.clientWidth, body2 ? body2.scrollWidth : 0, body2 ? body2.clientWidth : 0);
      var height2 = max$1(html2.scrollHeight, html2.clientHeight, body2 ? body2.scrollHeight : 0, body2 ? body2.clientHeight : 0);
      var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element);
      var y2 = -winScroll.scrollTop;
      if (getComputedStyle(body2 || html2).direction === "rtl") {
        x2 += max$1(html2.clientWidth, body2 ? body2.clientWidth : 0) - width2;
      }
      return {
        width: width2,
        height: height2,
        x: x2,
        y: y2
      };
    }
    function isScrollParent(element) {
      var _getComputedStyle = getComputedStyle(element), overflow2 = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
      return /auto|scroll|overlay|hidden/.test(overflow2 + overflowY + overflowX);
    }
    function getScrollParent(node2) {
      if (["html", "body", "#document"].indexOf(getNodeName(node2)) >= 0) {
        return node2.ownerDocument.body;
      }
      if (isHTMLElement(node2) && isScrollParent(node2)) {
        return node2;
      }
      return getScrollParent(getParentNode(node2));
    }
    function listScrollParents(element, list) {
      var _element$ownerDocumen;
      if (list === void 0) {
        list = [];
      }
      var scrollParent = getScrollParent(element);
      var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
      var win = getWindow(scrollParent);
      var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
      var updatedList = list.concat(target);
      return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
    }
    function rectToClientRect(rect) {
      return Object.assign({}, rect, {
        left: rect.x,
        top: rect.y,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
      });
    }
    function getInnerBoundingClientRect(element, strategy) {
      var rect = getBoundingClientRect(element, false, strategy === "fixed");
      rect.top = rect.top + element.clientTop;
      rect.left = rect.left + element.clientLeft;
      rect.bottom = rect.top + element.clientHeight;
      rect.right = rect.left + element.clientWidth;
      rect.width = element.clientWidth;
      rect.height = element.clientHeight;
      rect.x = rect.left;
      rect.y = rect.top;
      return rect;
    }
    function getClientRectFromMixedType(element, clippingParent, strategy) {
      return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
    }
    function getClippingParents(element) {
      var clippingParents2 = listScrollParents(getParentNode(element));
      var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle(element).position) >= 0;
      var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
      if (!isElement(clipperElement)) {
        return [];
      }
      return clippingParents2.filter(function(clippingParent) {
        return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
      });
    }
    function getClippingRect(element, boundary, rootBoundary, strategy) {
      var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
      var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
      var firstClippingParent = clippingParents2[0];
      var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
        var rect = getClientRectFromMixedType(element, clippingParent, strategy);
        accRect.top = max$1(rect.top, accRect.top);
        accRect.right = min$1(rect.right, accRect.right);
        accRect.bottom = min$1(rect.bottom, accRect.bottom);
        accRect.left = max$1(rect.left, accRect.left);
        return accRect;
      }, getClientRectFromMixedType(element, firstClippingParent, strategy));
      clippingRect.width = clippingRect.right - clippingRect.left;
      clippingRect.height = clippingRect.bottom - clippingRect.top;
      clippingRect.x = clippingRect.left;
      clippingRect.y = clippingRect.top;
      return clippingRect;
    }
    function computeOffsets(_ref) {
      var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
      var basePlacement = placement ? getBasePlacement(placement) : null;
      var variation = placement ? getVariation(placement) : null;
      var commonX = reference2.x + reference2.width / 2 - element.width / 2;
      var commonY = reference2.y + reference2.height / 2 - element.height / 2;
      var offsets;
      switch (basePlacement) {
        case top:
          offsets = {
            x: commonX,
            y: reference2.y - element.height
          };
          break;
        case bottom:
          offsets = {
            x: commonX,
            y: reference2.y + reference2.height
          };
          break;
        case right:
          offsets = {
            x: reference2.x + reference2.width,
            y: commonY
          };
          break;
        case left:
          offsets = {
            x: reference2.x - element.width,
            y: commonY
          };
          break;
        default:
          offsets = {
            x: reference2.x,
            y: reference2.y
          };
      }
      var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
      if (mainAxis != null) {
        var len = mainAxis === "y" ? "height" : "width";
        switch (variation) {
          case start:
            offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
            break;
          case end:
            offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
            break;
        }
      }
      return offsets;
    }
    function detectOverflow(state, options) {
      if (options === void 0) {
        options = {};
      }
      var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
      var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
      var altContext = elementContext === popper ? reference : popper;
      var popperRect = state.rects.popper;
      var element = state.elements[altBoundary ? altContext : elementContext];
      var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
      var referenceClientRect = getBoundingClientRect(state.elements.reference);
      var popperOffsets2 = computeOffsets({
        reference: referenceClientRect,
        element: popperRect,
        strategy: "absolute",
        placement
      });
      var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
      var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
      var overflowOffsets = {
        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
        right: elementClientRect.right - clippingClientRect.right + paddingObject.right
      };
      var offsetData = state.modifiersData.offset;
      if (elementContext === popper && offsetData) {
        var offset2 = offsetData[placement];
        Object.keys(overflowOffsets).forEach(function(key) {
          var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
          var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
          overflowOffsets[key] += offset2[axis] * multiply;
        });
      }
      return overflowOffsets;
    }
    function computeAutoPlacement(state, options) {
      if (options === void 0) {
        options = {};
      }
      var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
      var variation = getVariation(placement);
      var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
        return getVariation(placement2) === variation;
      }) : basePlacements;
      var allowedPlacements = placements$1.filter(function(placement2) {
        return allowedAutoPlacements.indexOf(placement2) >= 0;
      });
      if (allowedPlacements.length === 0) {
        allowedPlacements = placements$1;
      }
      var overflows = allowedPlacements.reduce(function(acc, placement2) {
        acc[placement2] = detectOverflow(state, {
          placement: placement2,
          boundary,
          rootBoundary,
          padding
        })[getBasePlacement(placement2)];
        return acc;
      }, {});
      return Object.keys(overflows).sort(function(a, b2) {
        return overflows[a] - overflows[b2];
      });
    }
    function getExpandedFallbackPlacements(placement) {
      if (getBasePlacement(placement) === auto) {
        return [];
      }
      var oppositePlacement = getOppositePlacement(placement);
      return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
    }
    function flip(_ref) {
      var state = _ref.state, options = _ref.options, name = _ref.name;
      if (state.modifiersData[name]._skip) {
        return;
      }
      var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
      var preferredPlacement = state.options.placement;
      var basePlacement = getBasePlacement(preferredPlacement);
      var isBasePlacement = basePlacement === preferredPlacement;
      var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
      var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
        return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
          placement: placement2,
          boundary,
          rootBoundary,
          padding,
          flipVariations,
          allowedAutoPlacements
        }) : placement2);
      }, []);
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var checksMap = /* @__PURE__ */ new Map();
      var makeFallbackChecks = true;
      var firstFittingPlacement = placements2[0];
      for (var i = 0; i < placements2.length; i++) {
        var placement = placements2[i];
        var _basePlacement = getBasePlacement(placement);
        var isStartVariation = getVariation(placement) === start;
        var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
        var len = isVertical ? "width" : "height";
        var overflow2 = detectOverflow(state, {
          placement,
          boundary,
          rootBoundary,
          altBoundary,
          padding
        });
        var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
        if (referenceRect[len] > popperRect[len]) {
          mainVariationSide = getOppositePlacement(mainVariationSide);
        }
        var altVariationSide = getOppositePlacement(mainVariationSide);
        var checks = [];
        if (checkMainAxis) {
          checks.push(overflow2[_basePlacement] <= 0);
        }
        if (checkAltAxis) {
          checks.push(overflow2[mainVariationSide] <= 0, overflow2[altVariationSide] <= 0);
        }
        if (checks.every(function(check) {
          return check;
        })) {
          firstFittingPlacement = placement;
          makeFallbackChecks = false;
          break;
        }
        checksMap.set(placement, checks);
      }
      if (makeFallbackChecks) {
        var numberOfChecks = flipVariations ? 3 : 1;
        var _loop = function _loop2(_i2) {
          var fittingPlacement = placements2.find(function(placement2) {
            var checks2 = checksMap.get(placement2);
            if (checks2) {
              return checks2.slice(0, _i2).every(function(check) {
                return check;
              });
            }
          });
          if (fittingPlacement) {
            firstFittingPlacement = fittingPlacement;
            return "break";
          }
        };
        for (var _i = numberOfChecks; _i > 0; _i--) {
          var _ret = _loop(_i);
          if (_ret === "break")
            break;
        }
      }
      if (state.placement !== firstFittingPlacement) {
        state.modifiersData[name]._skip = true;
        state.placement = firstFittingPlacement;
        state.reset = true;
      }
    }
    const flip$1 = {
      name: "flip",
      enabled: true,
      phase: "main",
      fn: flip,
      requiresIfExists: ["offset"],
      data: {
        _skip: false
      }
    };
    function getSideOffsets(overflow2, rect, preventedOffsets) {
      if (preventedOffsets === void 0) {
        preventedOffsets = {
          x: 0,
          y: 0
        };
      }
      return {
        top: overflow2.top - rect.height - preventedOffsets.y,
        right: overflow2.right - rect.width + preventedOffsets.x,
        bottom: overflow2.bottom - rect.height + preventedOffsets.y,
        left: overflow2.left - rect.width - preventedOffsets.x
      };
    }
    function isAnySideFullyClipped(overflow2) {
      return [top, right, bottom, left].some(function(side) {
        return overflow2[side] >= 0;
      });
    }
    function hide(_ref) {
      var state = _ref.state, name = _ref.name;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var preventedOffsets = state.modifiersData.preventOverflow;
      var referenceOverflow = detectOverflow(state, {
        elementContext: "reference"
      });
      var popperAltOverflow = detectOverflow(state, {
        altBoundary: true
      });
      var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
      var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
      var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
      var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
      state.modifiersData[name] = {
        referenceClippingOffsets,
        popperEscapeOffsets,
        isReferenceHidden,
        hasPopperEscaped
      };
      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        "data-popper-reference-hidden": isReferenceHidden,
        "data-popper-escaped": hasPopperEscaped
      });
    }
    const hide$1 = {
      name: "hide",
      enabled: true,
      phase: "main",
      requiresIfExists: ["preventOverflow"],
      fn: hide
    };
    function distanceAndSkiddingToXY(placement, rects, offset2) {
      var basePlacement = getBasePlacement(placement);
      var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
      var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
        placement
      })) : offset2, skidding = _ref[0], distance = _ref[1];
      skidding = skidding || 0;
      distance = (distance || 0) * invertDistance;
      return [left, right].indexOf(basePlacement) >= 0 ? {
        x: distance,
        y: skidding
      } : {
        x: skidding,
        y: distance
      };
    }
    function offset$1(_ref2) {
      var state = _ref2.state, options = _ref2.options, name = _ref2.name;
      var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
      var data = placements.reduce(function(acc, placement) {
        acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
        return acc;
      }, {});
      var _data$state$placement = data[state.placement], x2 = _data$state$placement.x, y2 = _data$state$placement.y;
      if (state.modifiersData.popperOffsets != null) {
        state.modifiersData.popperOffsets.x += x2;
        state.modifiersData.popperOffsets.y += y2;
      }
      state.modifiersData[name] = data;
    }
    const offset$2 = {
      name: "offset",
      enabled: true,
      phase: "main",
      requires: ["popperOffsets"],
      fn: offset$1
    };
    function popperOffsets(_ref) {
      var state = _ref.state, name = _ref.name;
      state.modifiersData[name] = computeOffsets({
        reference: state.rects.reference,
        element: state.rects.popper,
        strategy: "absolute",
        placement: state.placement
      });
    }
    const popperOffsets$1 = {
      name: "popperOffsets",
      enabled: true,
      phase: "read",
      fn: popperOffsets,
      data: {}
    };
    function getAltAxis(axis) {
      return axis === "x" ? "y" : "x";
    }
    function preventOverflow(_ref) {
      var state = _ref.state, options = _ref.options, name = _ref.name;
      var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
      var overflow2 = detectOverflow(state, {
        boundary,
        rootBoundary,
        padding,
        altBoundary
      });
      var basePlacement = getBasePlacement(state.placement);
      var variation = getVariation(state.placement);
      var isBasePlacement = !variation;
      var mainAxis = getMainAxisFromPlacement(basePlacement);
      var altAxis = getAltAxis(mainAxis);
      var popperOffsets2 = state.modifiersData.popperOffsets;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
        placement: state.placement
      })) : tetherOffset;
      var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
        mainAxis: tetherOffsetValue,
        altAxis: tetherOffsetValue
      } : Object.assign({
        mainAxis: 0,
        altAxis: 0
      }, tetherOffsetValue);
      var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
      var data = {
        x: 0,
        y: 0
      };
      if (!popperOffsets2) {
        return;
      }
      if (checkMainAxis) {
        var _offsetModifierState$;
        var mainSide = mainAxis === "y" ? top : left;
        var altSide = mainAxis === "y" ? bottom : right;
        var len = mainAxis === "y" ? "height" : "width";
        var offset2 = popperOffsets2[mainAxis];
        var min2 = offset2 + overflow2[mainSide];
        var max2 = offset2 - overflow2[altSide];
        var additive = tether ? -popperRect[len] / 2 : 0;
        var minLen = variation === start ? referenceRect[len] : popperRect[len];
        var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
        var arrowElement = state.elements.arrow;
        var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
          width: 0,
          height: 0
        };
        var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
        var arrowPaddingMin = arrowPaddingObject[mainSide];
        var arrowPaddingMax = arrowPaddingObject[altSide];
        var arrowLen = within(0, referenceRect[len], arrowRect[len]);
        var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
        var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
        var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
        var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
        var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
        var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
        var tetherMax = offset2 + maxOffset - offsetModifierValue;
        var preventedOffset = within(tether ? min$1(min2, tetherMin) : min2, offset2, tether ? max$1(max2, tetherMax) : max2);
        popperOffsets2[mainAxis] = preventedOffset;
        data[mainAxis] = preventedOffset - offset2;
      }
      if (checkAltAxis) {
        var _offsetModifierState$2;
        var _mainSide = mainAxis === "x" ? top : left;
        var _altSide = mainAxis === "x" ? bottom : right;
        var _offset = popperOffsets2[altAxis];
        var _len = altAxis === "y" ? "height" : "width";
        var _min = _offset + overflow2[_mainSide];
        var _max = _offset - overflow2[_altSide];
        var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
        var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
        var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
        var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
        var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
        popperOffsets2[altAxis] = _preventedOffset;
        data[altAxis] = _preventedOffset - _offset;
      }
      state.modifiersData[name] = data;
    }
    const preventOverflow$1 = {
      name: "preventOverflow",
      enabled: true,
      phase: "main",
      fn: preventOverflow,
      requiresIfExists: ["offset"]
    };
    function getHTMLElementScroll(element) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }
    function getNodeScroll(node2) {
      if (node2 === getWindow(node2) || !isHTMLElement(node2)) {
        return getWindowScroll(node2);
      } else {
        return getHTMLElementScroll(node2);
      }
    }
    function isElementScaled(element) {
      var rect = element.getBoundingClientRect();
      var scaleX = round$1(rect.width) / element.offsetWidth || 1;
      var scaleY = round$1(rect.height) / element.offsetHeight || 1;
      return scaleX !== 1 || scaleY !== 1;
    }
    function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
      if (isFixed === void 0) {
        isFixed = false;
      }
      var isOffsetParentAnElement = isHTMLElement(offsetParent);
      var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
      var documentElement = getDocumentElement(offsetParent);
      var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
      var scroll = {
        scrollLeft: 0,
        scrollTop: 0
      };
      var offsets = {
        x: 0,
        y: 0
      };
      if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
          scroll = getNodeScroll(offsetParent);
        }
        if (isHTMLElement(offsetParent)) {
          offsets = getBoundingClientRect(offsetParent, true);
          offsets.x += offsetParent.clientLeft;
          offsets.y += offsetParent.clientTop;
        } else if (documentElement) {
          offsets.x = getWindowScrollBarX(documentElement);
        }
      }
      return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
      };
    }
    function order(modifiers) {
      var map2 = /* @__PURE__ */ new Map();
      var visited = /* @__PURE__ */ new Set();
      var result = [];
      modifiers.forEach(function(modifier) {
        map2.set(modifier.name, modifier);
      });
      function sort(modifier) {
        visited.add(modifier.name);
        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
        requires.forEach(function(dep) {
          if (!visited.has(dep)) {
            var depModifier = map2.get(dep);
            if (depModifier) {
              sort(depModifier);
            }
          }
        });
        result.push(modifier);
      }
      modifiers.forEach(function(modifier) {
        if (!visited.has(modifier.name)) {
          sort(modifier);
        }
      });
      return result;
    }
    function orderModifiers(modifiers) {
      var orderedModifiers = order(modifiers);
      return modifierPhases.reduce(function(acc, phase) {
        return acc.concat(orderedModifiers.filter(function(modifier) {
          return modifier.phase === phase;
        }));
      }, []);
    }
    function debounce(fn) {
      var pending;
      return function() {
        if (!pending) {
          pending = new Promise(function(resolve) {
            Promise.resolve().then(function() {
              pending = void 0;
              resolve(fn());
            });
          });
        }
        return pending;
      };
    }
    function mergeByName(modifiers) {
      var merged = modifiers.reduce(function(merged2, current) {
        var existing = merged2[current.name];
        merged2[current.name] = existing ? Object.assign({}, existing, current, {
          options: Object.assign({}, existing.options, current.options),
          data: Object.assign({}, existing.data, current.data)
        }) : current;
        return merged2;
      }, {});
      return Object.keys(merged).map(function(key) {
        return merged[key];
      });
    }
    var DEFAULT_OPTIONS = {
      placement: "bottom",
      modifiers: [],
      strategy: "absolute"
    };
    function areValidElements() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return !args.some(function(element) {
        return !(element && typeof element.getBoundingClientRect === "function");
      });
    }
    function popperGenerator(generatorOptions) {
      if (generatorOptions === void 0) {
        generatorOptions = {};
      }
      var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
      return function createPopper2(reference2, popper2, options) {
        if (options === void 0) {
          options = defaultOptions;
        }
        var state = {
          placement: "bottom",
          orderedModifiers: [],
          options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
          modifiersData: {},
          elements: {
            reference: reference2,
            popper: popper2
          },
          attributes: {},
          styles: {}
        };
        var effectCleanupFns = [];
        var isDestroyed = false;
        var instance = {
          state,
          setOptions: function setOptions(setOptionsAction) {
            var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
            cleanupModifierEffects();
            state.options = Object.assign({}, defaultOptions, state.options, options2);
            state.scrollParents = {
              reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
              popper: listScrollParents(popper2)
            };
            var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
            state.orderedModifiers = orderedModifiers.filter(function(m2) {
              return m2.enabled;
            });
            runModifierEffects();
            return instance.update();
          },
          forceUpdate: function forceUpdate() {
            if (isDestroyed) {
              return;
            }
            var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
            if (!areValidElements(reference3, popper3)) {
              return;
            }
            state.rects = {
              reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
              popper: getLayoutRect(popper3)
            };
            state.reset = false;
            state.placement = state.options.placement;
            state.orderedModifiers.forEach(function(modifier) {
              return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
            });
            for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
              if (state.reset === true) {
                state.reset = false;
                index2 = -1;
                continue;
              }
              var _state$orderedModifie = state.orderedModifiers[index2], fn = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
              if (typeof fn === "function") {
                state = fn({
                  state,
                  options: _options,
                  name,
                  instance
                }) || state;
              }
            }
          },
          update: debounce(function() {
            return new Promise(function(resolve) {
              instance.forceUpdate();
              resolve(state);
            });
          }),
          destroy: function destroy() {
            cleanupModifierEffects();
            isDestroyed = true;
          }
        };
        if (!areValidElements(reference2, popper2)) {
          return instance;
        }
        instance.setOptions(options).then(function(state2) {
          if (!isDestroyed && options.onFirstUpdate) {
            options.onFirstUpdate(state2);
          }
        });
        function runModifierEffects() {
          state.orderedModifiers.forEach(function(_ref3) {
            var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect2 = _ref3.effect;
            if (typeof effect2 === "function") {
              var cleanupFn = effect2({
                state,
                name,
                instance,
                options: options2
              });
              var noopFn = function noopFn2() {
              };
              effectCleanupFns.push(cleanupFn || noopFn);
            }
          });
        }
        function cleanupModifierEffects() {
          effectCleanupFns.forEach(function(fn) {
            return fn();
          });
          effectCleanupFns = [];
        }
        return instance;
      };
    }
    var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$2, flip$1, preventOverflow$1, arrow$1, hide$1];
    var createPopper = /* @__PURE__ */ popperGenerator({
      defaultModifiers
    });
    function getContainer$1(container) {
      return typeof container === "function" ? container() : container;
    }
    const Portal = /* @__PURE__ */ react.exports.forwardRef(function Portal2(props2, ref) {
      const {
        children,
        container,
        disablePortal = false
      } = props2;
      const [mountNode, setMountNode] = react.exports.useState(null);
      const handleRef = useForkRef(/* @__PURE__ */ react.exports.isValidElement(children) ? children.ref : null, ref);
      useEnhancedEffect$1(() => {
        if (!disablePortal) {
          setMountNode(getContainer$1(container) || document.body);
        }
      }, [container, disablePortal]);
      useEnhancedEffect$1(() => {
        if (mountNode && !disablePortal) {
          setRef(ref, mountNode);
          return () => {
            setRef(ref, null);
          };
        }
        return void 0;
      }, [ref, mountNode, disablePortal]);
      if (disablePortal) {
        if (/* @__PURE__ */ react.exports.isValidElement(children)) {
          return /* @__PURE__ */ react.exports.cloneElement(children, {
            ref: handleRef
          });
        }
        return children;
      }
      return /* @__PURE__ */ jsx(react.exports.Fragment, {
        children: mountNode ? /* @__PURE__ */ reactDom.exports.createPortal(children, mountNode) : mountNode
      });
    });
    const Portal$1 = Portal;
    function getPopperUnstyledUtilityClass(slot) {
      return generateUtilityClass("MuiPopperUnstyled", slot);
    }
    generateUtilityClasses("MuiPopperUnstyled", ["root"]);
    const _excluded$1l = ["anchorEl", "children", "component", "direction", "disablePortal", "modifiers", "open", "ownerState", "placement", "popperOptions", "popperRef", "slotProps", "slots", "TransitionProps"], _excluded2$4 = ["anchorEl", "children", "container", "direction", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "style", "transition"];
    function flipPlacement(placement, direction) {
      if (direction === "ltr") {
        return placement;
      }
      switch (placement) {
        case "bottom-end":
          return "bottom-start";
        case "bottom-start":
          return "bottom-end";
        case "top-end":
          return "top-start";
        case "top-start":
          return "top-end";
        default:
          return placement;
      }
    }
    function resolveAnchorEl$1(anchorEl) {
      return typeof anchorEl === "function" ? anchorEl() : anchorEl;
    }
    const useUtilityClasses$1b = () => {
      const slots = {
        root: ["root"]
      };
      return composeClasses(slots, getPopperUnstyledUtilityClass, {});
    };
    const defaultPopperOptions = {};
    const PopperTooltip = /* @__PURE__ */ react.exports.forwardRef(function PopperTooltip2(props2, ref) {
      var _ref;
      const {
        anchorEl,
        children,
        component,
        direction,
        disablePortal,
        modifiers,
        open,
        ownerState,
        placement: initialPlacement,
        popperOptions,
        popperRef: popperRefProp,
        slotProps = {},
        slots = {},
        TransitionProps
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$1l);
      const tooltipRef = react.exports.useRef(null);
      const ownRef = useForkRef(tooltipRef, ref);
      const popperRef = react.exports.useRef(null);
      const handlePopperRef = useForkRef(popperRef, popperRefProp);
      const handlePopperRefRef = react.exports.useRef(handlePopperRef);
      useEnhancedEffect$1(() => {
        handlePopperRefRef.current = handlePopperRef;
      }, [handlePopperRef]);
      react.exports.useImperativeHandle(popperRefProp, () => popperRef.current, []);
      const rtlPlacement = flipPlacement(initialPlacement, direction);
      const [placement, setPlacement] = react.exports.useState(rtlPlacement);
      react.exports.useEffect(() => {
        if (popperRef.current) {
          popperRef.current.forceUpdate();
        }
      });
      useEnhancedEffect$1(() => {
        if (!anchorEl || !open) {
          return void 0;
        }
        const handlePopperUpdate = (data) => {
          setPlacement(data.placement);
        };
        resolveAnchorEl$1(anchorEl);
        let popperModifiers = [{
          name: "preventOverflow",
          options: {
            altBoundary: disablePortal
          }
        }, {
          name: "flip",
          options: {
            altBoundary: disablePortal
          }
        }, {
          name: "onUpdate",
          enabled: true,
          phase: "afterWrite",
          fn: ({
            state
          }) => {
            handlePopperUpdate(state);
          }
        }];
        if (modifiers != null) {
          popperModifiers = popperModifiers.concat(modifiers);
        }
        if (popperOptions && popperOptions.modifiers != null) {
          popperModifiers = popperModifiers.concat(popperOptions.modifiers);
        }
        const popper2 = createPopper(resolveAnchorEl$1(anchorEl), tooltipRef.current, _extends({
          placement: rtlPlacement
        }, popperOptions, {
          modifiers: popperModifiers
        }));
        handlePopperRefRef.current(popper2);
        return () => {
          popper2.destroy();
          handlePopperRefRef.current(null);
        };
      }, [anchorEl, disablePortal, modifiers, open, popperOptions, rtlPlacement]);
      const childProps = {
        placement
      };
      if (TransitionProps !== null) {
        childProps.TransitionProps = TransitionProps;
      }
      const classes = useUtilityClasses$1b();
      const Root = (_ref = component != null ? component : slots.root) != null ? _ref : "div";
      const rootProps = useSlotProps({
        elementType: Root,
        externalSlotProps: slotProps.root,
        externalForwardedProps: other,
        additionalProps: {
          role: "tooltip",
          ref: ownRef
        },
        ownerState: _extends({}, props2, ownerState),
        className: classes.root
      });
      return /* @__PURE__ */ jsx(Root, _extends({}, rootProps, {
        children: typeof children === "function" ? children(childProps) : children
      }));
    });
    const PopperUnstyled = /* @__PURE__ */ react.exports.forwardRef(function PopperUnstyled2(props2, ref) {
      const {
        anchorEl,
        children,
        container: containerProp,
        direction = "ltr",
        disablePortal = false,
        keepMounted = false,
        modifiers,
        open,
        placement = "bottom",
        popperOptions = defaultPopperOptions,
        popperRef,
        style: style2,
        transition = false
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded2$4);
      const [exited, setExited] = react.exports.useState(true);
      const handleEnter = () => {
        setExited(false);
      };
      const handleExited = () => {
        setExited(true);
      };
      if (!keepMounted && !open && (!transition || exited)) {
        return null;
      }
      const container = containerProp || (anchorEl ? ownerDocument(resolveAnchorEl$1(anchorEl)).body : void 0);
      return /* @__PURE__ */ jsx(Portal$1, {
        disablePortal,
        container,
        children: /* @__PURE__ */ jsx(PopperTooltip, _extends({
          anchorEl,
          direction,
          disablePortal,
          modifiers,
          ref,
          open: transition ? !exited : open,
          placement,
          popperOptions,
          popperRef
        }, other, {
          style: _extends({
            position: "fixed",
            top: 0,
            left: 0,
            display: !open && keepMounted && (!transition || exited) ? "none" : null
          }, style2),
          TransitionProps: transition ? {
            in: open,
            onEnter: handleEnter,
            onExited: handleExited
          } : null,
          children
        }))
      });
    });
    const PopperUnstyled$1 = PopperUnstyled;
    function isOverflowing(container) {
      const doc = ownerDocument(container);
      if (doc.body === container) {
        return ownerWindow(container).innerWidth > doc.documentElement.clientWidth;
      }
      return container.scrollHeight > container.clientHeight;
    }
    function ariaHidden(element, show) {
      if (show) {
        element.setAttribute("aria-hidden", "true");
      } else {
        element.removeAttribute("aria-hidden");
      }
    }
    function getPaddingRight(element) {
      return parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) || 0;
    }
    function isAriaHiddenForbiddenOnElement(element) {
      const forbiddenTagNames = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"];
      const isForbiddenTagName = forbiddenTagNames.indexOf(element.tagName) !== -1;
      const isInputHidden = element.tagName === "INPUT" && element.getAttribute("type") === "hidden";
      return isForbiddenTagName || isInputHidden;
    }
    function ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude, show) {
      const blacklist = [mountElement, currentElement, ...elementsToExclude];
      [].forEach.call(container.children, (element) => {
        const isNotExcludedElement = blacklist.indexOf(element) === -1;
        const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);
        if (isNotExcludedElement && isNotForbiddenElement) {
          ariaHidden(element, show);
        }
      });
    }
    function findIndexOf(items, callback) {
      let idx = -1;
      items.some((item, index2) => {
        if (callback(item)) {
          idx = index2;
          return true;
        }
        return false;
      });
      return idx;
    }
    function handleContainer(containerInfo, props2) {
      const restoreStyle = [];
      const container = containerInfo.container;
      if (!props2.disableScrollLock) {
        if (isOverflowing(container)) {
          const scrollbarSize = getScrollbarSize(ownerDocument(container));
          restoreStyle.push({
            value: container.style.paddingRight,
            property: "padding-right",
            el: container
          });
          container.style.paddingRight = `${getPaddingRight(container) + scrollbarSize}px`;
          const fixedElements2 = ownerDocument(container).querySelectorAll(".mui-fixed");
          [].forEach.call(fixedElements2, (element) => {
            restoreStyle.push({
              value: element.style.paddingRight,
              property: "padding-right",
              el: element
            });
            element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;
          });
        }
        let scrollContainer;
        if (container.parentNode instanceof DocumentFragment) {
          scrollContainer = ownerDocument(container).body;
        } else {
          const parent = container.parentElement;
          const containerWindow = ownerWindow(container);
          scrollContainer = (parent == null ? void 0 : parent.nodeName) === "HTML" && containerWindow.getComputedStyle(parent).overflowY === "scroll" ? parent : container;
        }
        restoreStyle.push({
          value: scrollContainer.style.overflow,
          property: "overflow",
          el: scrollContainer
        }, {
          value: scrollContainer.style.overflowX,
          property: "overflow-x",
          el: scrollContainer
        }, {
          value: scrollContainer.style.overflowY,
          property: "overflow-y",
          el: scrollContainer
        });
        scrollContainer.style.overflow = "hidden";
      }
      const restore = () => {
        restoreStyle.forEach(({
          value,
          el: el2,
          property
        }) => {
          if (value) {
            el2.style.setProperty(property, value);
          } else {
            el2.style.removeProperty(property);
          }
        });
      };
      return restore;
    }
    function getHiddenSiblings(container) {
      const hiddenSiblings = [];
      [].forEach.call(container.children, (element) => {
        if (element.getAttribute("aria-hidden") === "true") {
          hiddenSiblings.push(element);
        }
      });
      return hiddenSiblings;
    }
    class ModalManager {
      constructor() {
        this.containers = void 0;
        this.modals = void 0;
        this.modals = [];
        this.containers = [];
      }
      add(modal, container) {
        let modalIndex = this.modals.indexOf(modal);
        if (modalIndex !== -1) {
          return modalIndex;
        }
        modalIndex = this.modals.length;
        this.modals.push(modal);
        if (modal.modalRef) {
          ariaHidden(modal.modalRef, false);
        }
        const hiddenSiblings = getHiddenSiblings(container);
        ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, true);
        const containerIndex = findIndexOf(this.containers, (item) => item.container === container);
        if (containerIndex !== -1) {
          this.containers[containerIndex].modals.push(modal);
          return modalIndex;
        }
        this.containers.push({
          modals: [modal],
          container,
          restore: null,
          hiddenSiblings
        });
        return modalIndex;
      }
      mount(modal, props2) {
        const containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal) !== -1);
        const containerInfo = this.containers[containerIndex];
        if (!containerInfo.restore) {
          containerInfo.restore = handleContainer(containerInfo, props2);
        }
      }
      remove(modal, ariaHiddenState = true) {
        const modalIndex = this.modals.indexOf(modal);
        if (modalIndex === -1) {
          return modalIndex;
        }
        const containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal) !== -1);
        const containerInfo = this.containers[containerIndex];
        containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
        this.modals.splice(modalIndex, 1);
        if (containerInfo.modals.length === 0) {
          if (containerInfo.restore) {
            containerInfo.restore();
          }
          if (modal.modalRef) {
            ariaHidden(modal.modalRef, ariaHiddenState);
          }
          ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);
          this.containers.splice(containerIndex, 1);
        } else {
          const nextTop = containerInfo.modals[containerInfo.modals.length - 1];
          if (nextTop.modalRef) {
            ariaHidden(nextTop.modalRef, false);
          }
        }
        return modalIndex;
      }
      isTopModal(modal) {
        return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
      }
    }
    function getModalUtilityClass(slot) {
      return generateUtilityClass("MuiModal", slot);
    }
    generateUtilityClasses("MuiModal", ["root", "hidden"]);
    const _excluded$1k = ["children", "classes", "closeAfterTransition", "component", "container", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "manager", "onBackdropClick", "onClose", "onKeyDown", "open", "onTransitionEnter", "onTransitionExited", "slotProps", "slots"];
    const useUtilityClasses$1a = (ownerState) => {
      const {
        open,
        exited,
        classes
      } = ownerState;
      const slots = {
        root: ["root", !open && exited && "hidden"]
      };
      return composeClasses(slots, getModalUtilityClass, classes);
    };
    function getContainer(container) {
      return typeof container === "function" ? container() : container;
    }
    function getHasTransition(props2) {
      return props2.children ? props2.children.props.hasOwnProperty("in") : false;
    }
    const defaultManager = new ModalManager();
    const ModalUnstyled = /* @__PURE__ */ react.exports.forwardRef(function ModalUnstyled2(props2, ref) {
      var _props$ariaHidden, _ref;
      const {
        children,
        classes: classesProp,
        closeAfterTransition = false,
        component,
        container,
        disableAutoFocus = false,
        disableEnforceFocus = false,
        disableEscapeKeyDown = false,
        disablePortal = false,
        disableRestoreFocus = false,
        disableScrollLock = false,
        hideBackdrop = false,
        keepMounted = false,
        manager = defaultManager,
        onBackdropClick,
        onClose,
        onKeyDown,
        open,
        onTransitionEnter,
        onTransitionExited,
        slotProps = {},
        slots = {}
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$1k);
      const [exited, setExited] = react.exports.useState(true);
      const modal = react.exports.useRef({});
      const mountNodeRef = react.exports.useRef(null);
      const modalRef = react.exports.useRef(null);
      const handleRef = useForkRef(modalRef, ref);
      const hasTransition = getHasTransition(props2);
      const ariaHiddenProp = (_props$ariaHidden = props2["aria-hidden"]) != null ? _props$ariaHidden : true;
      const getDoc = () => ownerDocument(mountNodeRef.current);
      const getModal = () => {
        modal.current.modalRef = modalRef.current;
        modal.current.mountNode = mountNodeRef.current;
        return modal.current;
      };
      const handleMounted = () => {
        manager.mount(getModal(), {
          disableScrollLock
        });
        modalRef.current.scrollTop = 0;
      };
      const handleOpen = useEventCallback(() => {
        const resolvedContainer = getContainer(container) || getDoc().body;
        manager.add(getModal(), resolvedContainer);
        if (modalRef.current) {
          handleMounted();
        }
      });
      const isTopModal = react.exports.useCallback(() => manager.isTopModal(getModal()), [manager]);
      const handlePortalRef = useEventCallback((node2) => {
        mountNodeRef.current = node2;
        if (!node2) {
          return;
        }
        if (open && isTopModal()) {
          handleMounted();
        } else {
          ariaHidden(modalRef.current, ariaHiddenProp);
        }
      });
      const handleClose = react.exports.useCallback(() => {
        manager.remove(getModal(), ariaHiddenProp);
      }, [manager, ariaHiddenProp]);
      react.exports.useEffect(() => {
        return () => {
          handleClose();
        };
      }, [handleClose]);
      react.exports.useEffect(() => {
        if (open) {
          handleOpen();
        } else if (!hasTransition || !closeAfterTransition) {
          handleClose();
        }
      }, [open, handleClose, hasTransition, closeAfterTransition, handleOpen]);
      const ownerState = _extends({}, props2, {
        classes: classesProp,
        closeAfterTransition,
        disableAutoFocus,
        disableEnforceFocus,
        disableEscapeKeyDown,
        disablePortal,
        disableRestoreFocus,
        disableScrollLock,
        exited,
        hideBackdrop,
        keepMounted
      });
      const classes = useUtilityClasses$1a(ownerState);
      const handleEnter = () => {
        setExited(false);
        if (onTransitionEnter) {
          onTransitionEnter();
        }
      };
      const handleExited = () => {
        setExited(true);
        if (onTransitionExited) {
          onTransitionExited();
        }
        if (closeAfterTransition) {
          handleClose();
        }
      };
      const handleBackdropClick = (event) => {
        if (event.target !== event.currentTarget) {
          return;
        }
        if (onBackdropClick) {
          onBackdropClick(event);
        }
        if (onClose) {
          onClose(event, "backdropClick");
        }
      };
      const handleKeyDown2 = (event) => {
        if (onKeyDown) {
          onKeyDown(event);
        }
        if (event.key !== "Escape" || !isTopModal()) {
          return;
        }
        if (!disableEscapeKeyDown) {
          event.stopPropagation();
          if (onClose) {
            onClose(event, "escapeKeyDown");
          }
        }
      };
      const childProps = {};
      if (children.props.tabIndex === void 0) {
        childProps.tabIndex = "-1";
      }
      if (hasTransition) {
        childProps.onEnter = createChainedFunction(handleEnter, children.props.onEnter);
        childProps.onExited = createChainedFunction(handleExited, children.props.onExited);
      }
      const Root = (_ref = component != null ? component : slots.root) != null ? _ref : "div";
      const rootProps = useSlotProps({
        elementType: Root,
        externalSlotProps: slotProps.root,
        externalForwardedProps: other,
        additionalProps: {
          ref: handleRef,
          role: "presentation",
          onKeyDown: handleKeyDown2
        },
        className: classes.root,
        ownerState
      });
      const BackdropComponent = slots.backdrop;
      const backdropProps = useSlotProps({
        elementType: BackdropComponent,
        externalSlotProps: slotProps.backdrop,
        additionalProps: {
          "aria-hidden": true,
          onClick: handleBackdropClick,
          open
        },
        className: classes.backdrop,
        ownerState
      });
      if (!keepMounted && !open && (!hasTransition || exited)) {
        return null;
      }
      return /* @__PURE__ */ jsx(Portal$1, {
        ref: handlePortalRef,
        container,
        disablePortal,
        children: /* @__PURE__ */ jsxs(Root, _extends({}, rootProps, {
          children: [!hideBackdrop && BackdropComponent ? /* @__PURE__ */ jsx(BackdropComponent, _extends({}, backdropProps)) : null, /* @__PURE__ */ jsx(FocusTrap, {
            disableEnforceFocus,
            disableAutoFocus,
            disableRestoreFocus,
            isEnabled: isTopModal,
            open,
            children: /* @__PURE__ */ react.exports.cloneElement(children, childProps)
          })]
        }))
      });
    });
    const ModalUnstyled$1 = ModalUnstyled;
    const _excluded$1j = ["onChange", "maxRows", "minRows", "style", "value"];
    function getStyleValue(computedStyle, property) {
      return parseInt(computedStyle[property], 10) || 0;
    }
    const styles$4 = {
      shadow: {
        visibility: "hidden",
        position: "absolute",
        overflow: "hidden",
        height: 0,
        top: 0,
        left: 0,
        transform: "translateZ(0)"
      }
    };
    function isEmpty$1(obj) {
      return obj === void 0 || obj === null || Object.keys(obj).length === 0;
    }
    const TextareaAutosize = /* @__PURE__ */ react.exports.forwardRef(function TextareaAutosize2(props2, ref) {
      const {
        onChange,
        maxRows,
        minRows = 1,
        style: style2,
        value
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$1j);
      const {
        current: isControlled
      } = react.exports.useRef(value != null);
      const inputRef = react.exports.useRef(null);
      const handleRef = useForkRef(ref, inputRef);
      const shadowRef = react.exports.useRef(null);
      const renders = react.exports.useRef(0);
      const [state, setState] = react.exports.useState({});
      const getUpdatedState = react.exports.useCallback(() => {
        const input = inputRef.current;
        const containerWindow = ownerWindow(input);
        const computedStyle = containerWindow.getComputedStyle(input);
        if (computedStyle.width === "0px") {
          return {};
        }
        const inputShallow = shadowRef.current;
        inputShallow.style.width = computedStyle.width;
        inputShallow.value = input.value || props2.placeholder || "x";
        if (inputShallow.value.slice(-1) === "\n") {
          inputShallow.value += " ";
        }
        const boxSizing2 = computedStyle["box-sizing"];
        const padding = getStyleValue(computedStyle, "padding-bottom") + getStyleValue(computedStyle, "padding-top");
        const border2 = getStyleValue(computedStyle, "border-bottom-width") + getStyleValue(computedStyle, "border-top-width");
        const innerHeight = inputShallow.scrollHeight;
        inputShallow.value = "x";
        const singleRowHeight = inputShallow.scrollHeight;
        let outerHeight = innerHeight;
        if (minRows) {
          outerHeight = Math.max(Number(minRows) * singleRowHeight, outerHeight);
        }
        if (maxRows) {
          outerHeight = Math.min(Number(maxRows) * singleRowHeight, outerHeight);
        }
        outerHeight = Math.max(outerHeight, singleRowHeight);
        const outerHeightStyle = outerHeight + (boxSizing2 === "border-box" ? padding + border2 : 0);
        const overflow2 = Math.abs(outerHeight - innerHeight) <= 1;
        return {
          outerHeightStyle,
          overflow: overflow2
        };
      }, [maxRows, minRows, props2.placeholder]);
      const updateState = (prevState, newState) => {
        const {
          outerHeightStyle,
          overflow: overflow2
        } = newState;
        if (renders.current < 20 && (outerHeightStyle > 0 && Math.abs((prevState.outerHeightStyle || 0) - outerHeightStyle) > 1 || prevState.overflow !== overflow2)) {
          renders.current += 1;
          return {
            overflow: overflow2,
            outerHeightStyle
          };
        }
        return prevState;
      };
      const syncHeight = react.exports.useCallback(() => {
        const newState = getUpdatedState();
        if (isEmpty$1(newState)) {
          return;
        }
        setState((prevState) => {
          return updateState(prevState, newState);
        });
      }, [getUpdatedState]);
      const syncHeightWithFlushSycn = () => {
        const newState = getUpdatedState();
        if (isEmpty$1(newState)) {
          return;
        }
        reactDom.exports.flushSync(() => {
          setState((prevState) => {
            return updateState(prevState, newState);
          });
        });
      };
      react.exports.useEffect(() => {
        const handleResize = debounce$1(() => {
          renders.current = 0;
          if (inputRef.current) {
            syncHeightWithFlushSycn();
          }
        });
        const containerWindow = ownerWindow(inputRef.current);
        containerWindow.addEventListener("resize", handleResize);
        let resizeObserver;
        if (typeof ResizeObserver !== "undefined") {
          resizeObserver = new ResizeObserver(handleResize);
          resizeObserver.observe(inputRef.current);
        }
        return () => {
          handleResize.clear();
          containerWindow.removeEventListener("resize", handleResize);
          if (resizeObserver) {
            resizeObserver.disconnect();
          }
        };
      });
      useEnhancedEffect$1(() => {
        syncHeight();
      });
      react.exports.useEffect(() => {
        renders.current = 0;
      }, [value]);
      const handleChange = (event) => {
        renders.current = 0;
        if (!isControlled) {
          syncHeight();
        }
        if (onChange) {
          onChange(event);
        }
      };
      return /* @__PURE__ */ jsxs(react.exports.Fragment, {
        children: [/* @__PURE__ */ jsx("textarea", _extends({
          value,
          onChange: handleChange,
          ref: handleRef,
          rows: minRows,
          style: _extends({
            height: state.outerHeightStyle,
            overflow: state.overflow ? "hidden" : null
          }, style2)
        }, other)), /* @__PURE__ */ jsx("textarea", {
          "aria-hidden": true,
          className: props2.className,
          readOnly: true,
          ref: shadowRef,
          tabIndex: -1,
          style: _extends({}, styles$4.shadow, style2, {
            padding: 0
          })
        })]
      });
    });
    const TextareaAutosize$1 = TextareaAutosize;
    function getSvgIconUtilityClass(slot) {
      return generateUtilityClass("MuiSvgIcon", slot);
    }
    generateUtilityClasses("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
    const _excluded$1i = ["children", "className", "color", "component", "fontSize", "htmlColor", "inheritViewBox", "titleAccess", "viewBox"];
    const useUtilityClasses$19 = (ownerState) => {
      const {
        color: color2,
        fontSize: fontSize2,
        classes
      } = ownerState;
      const slots = {
        root: ["root", color2 !== "inherit" && `color${capitalize(color2)}`, `fontSize${capitalize(fontSize2)}`]
      };
      return composeClasses(slots, getSvgIconUtilityClass, classes);
    };
    const SvgIconRoot = styled$1("svg", {
      name: "MuiSvgIcon",
      slot: "Root",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.root, ownerState.color !== "inherit" && styles2[`color${capitalize(ownerState.color)}`], styles2[`fontSize${capitalize(ownerState.fontSize)}`]];
      }
    })(({
      theme,
      ownerState
    }) => {
      var _theme$transitions, _theme$transitions$cr, _theme$transitions2, _theme$transitions2$d, _theme$typography, _theme$typography$pxT, _theme$typography2, _theme$typography2$px, _theme$typography3, _theme$typography3$px, _palette$ownerState$c, _palette, _palette$ownerState$c2, _palette2, _palette2$action, _palette3, _palette3$action;
      return {
        userSelect: "none",
        width: "1em",
        height: "1em",
        display: "inline-block",
        fill: "currentColor",
        flexShrink: 0,
        transition: (_theme$transitions = theme.transitions) == null ? void 0 : (_theme$transitions$cr = _theme$transitions.create) == null ? void 0 : _theme$transitions$cr.call(_theme$transitions, "fill", {
          duration: (_theme$transitions2 = theme.transitions) == null ? void 0 : (_theme$transitions2$d = _theme$transitions2.duration) == null ? void 0 : _theme$transitions2$d.shorter
        }),
        fontSize: {
          inherit: "inherit",
          small: ((_theme$typography = theme.typography) == null ? void 0 : (_theme$typography$pxT = _theme$typography.pxToRem) == null ? void 0 : _theme$typography$pxT.call(_theme$typography, 20)) || "1.25rem",
          medium: ((_theme$typography2 = theme.typography) == null ? void 0 : (_theme$typography2$px = _theme$typography2.pxToRem) == null ? void 0 : _theme$typography2$px.call(_theme$typography2, 24)) || "1.5rem",
          large: ((_theme$typography3 = theme.typography) == null ? void 0 : (_theme$typography3$px = _theme$typography3.pxToRem) == null ? void 0 : _theme$typography3$px.call(_theme$typography3, 35)) || "2.1875rem"
        }[ownerState.fontSize],
        color: (_palette$ownerState$c = (_palette = (theme.vars || theme).palette) == null ? void 0 : (_palette$ownerState$c2 = _palette[ownerState.color]) == null ? void 0 : _palette$ownerState$c2.main) != null ? _palette$ownerState$c : {
          action: (_palette2 = (theme.vars || theme).palette) == null ? void 0 : (_palette2$action = _palette2.action) == null ? void 0 : _palette2$action.active,
          disabled: (_palette3 = (theme.vars || theme).palette) == null ? void 0 : (_palette3$action = _palette3.action) == null ? void 0 : _palette3$action.disabled,
          inherit: void 0
        }[ownerState.color]
      };
    });
    const SvgIcon = /* @__PURE__ */ react.exports.forwardRef(function SvgIcon2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiSvgIcon"
      });
      const {
        children,
        className,
        color: color2 = "inherit",
        component = "svg",
        fontSize: fontSize2 = "medium",
        htmlColor,
        inheritViewBox = false,
        titleAccess,
        viewBox = "0 0 24 24"
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$1i);
      const ownerState = _extends({}, props2, {
        color: color2,
        component,
        fontSize: fontSize2,
        instanceFontSize: inProps.fontSize,
        inheritViewBox,
        viewBox
      });
      const more = {};
      if (!inheritViewBox) {
        more.viewBox = viewBox;
      }
      const classes = useUtilityClasses$19(ownerState);
      return /* @__PURE__ */ jsxs(SvgIconRoot, _extends({
        as: component,
        className: clsx(classes.root, className),
        focusable: "false",
        color: htmlColor,
        "aria-hidden": titleAccess ? void 0 : true,
        role: titleAccess ? "img" : void 0,
        ref
      }, more, other, {
        ownerState,
        children: [children, titleAccess ? /* @__PURE__ */ jsx("title", {
          children: titleAccess
        }) : null]
      }));
    });
    SvgIcon.muiName = "SvgIcon";
    const SvgIcon$1 = SvgIcon;
    function createSvgIcon$1(path, displayName) {
      function Component(props2, ref) {
        return /* @__PURE__ */ jsx(SvgIcon$1, _extends({
          "data-testid": `${displayName}Icon`,
          ref
        }, props2, {
          children: path
        }));
      }
      Component.muiName = SvgIcon$1.muiName;
      return /* @__PURE__ */ react.exports.memo(/* @__PURE__ */ react.exports.forwardRef(Component));
    }
    const unstable_ClassNameGenerator = {
      configure: (generator) => {
        console.warn(["MUI: `ClassNameGenerator` import from `@mui/material/utils` is outdated and might cause unexpected issues.", "", "You should use `import { unstable_ClassNameGenerator } from '@mui/material/className'` instead", "", "The detail of the issue: https://github.com/mui/material-ui/issues/30011#issuecomment-1024993401", "", "The updated documentation: https://mui.com/guides/classname-generator/"].join("\n"));
        ClassNameGenerator$1.configure(generator);
      }
    };
    const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      unstable_ClassNameGenerator,
      capitalize,
      createChainedFunction,
      createSvgIcon: createSvgIcon$1,
      debounce: debounce$1,
      deprecatedPropType,
      isMuiElement,
      ownerDocument,
      ownerWindow,
      requirePropFactory,
      setRef,
      unstable_useEnhancedEffect: useEnhancedEffect$1,
      unstable_useId: useId,
      unsupportedProp,
      useControlled,
      useEventCallback,
      useForkRef,
      useIsFocusVisible
    }, Symbol.toStringTag, { value: "Module" }));
    function _setPrototypeOf(o, p2) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
        o2.__proto__ = p3;
        return o2;
      };
      return _setPrototypeOf(o, p2);
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function hasClass(element, className) {
      if (element.classList)
        return !!className && element.classList.contains(className);
      return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
    }
    function addClass(element, className) {
      if (element.classList)
        element.classList.add(className);
      else if (!hasClass(element, className))
        if (typeof element.className === "string")
          element.className = element.className + " " + className;
        else
          element.setAttribute("class", (element.className && element.className.baseVal || "") + " " + className);
    }
    function replaceClassName(origClass, classToRemove) {
      return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
    }
    function removeClass$1(element, className) {
      if (element.classList) {
        element.classList.remove(className);
      } else if (typeof element.className === "string") {
        element.className = replaceClassName(element.className, className);
      } else {
        element.setAttribute("class", replaceClassName(element.className && element.className.baseVal || "", className));
      }
    }
    const config = {
      disabled: false
    };
    const TransitionGroupContext = React.createContext(null);
    var forceReflow = function forceReflow2(node2) {
      return node2.scrollTop;
    };
    var UNMOUNTED = "unmounted";
    var EXITED = "exited";
    var ENTERING = "entering";
    var ENTERED = "entered";
    var EXITING = "exiting";
    var Transition = /* @__PURE__ */ function(_React$Component) {
      _inheritsLoose(Transition2, _React$Component);
      function Transition2(props2, context) {
        var _this;
        _this = _React$Component.call(this, props2, context) || this;
        var parentGroup = context;
        var appear = parentGroup && !parentGroup.isMounting ? props2.enter : props2.appear;
        var initialStatus;
        _this.appearStatus = null;
        if (props2.in) {
          if (appear) {
            initialStatus = EXITED;
            _this.appearStatus = ENTERING;
          } else {
            initialStatus = ENTERED;
          }
        } else {
          if (props2.unmountOnExit || props2.mountOnEnter) {
            initialStatus = UNMOUNTED;
          } else {
            initialStatus = EXITED;
          }
        }
        _this.state = {
          status: initialStatus
        };
        _this.nextCallback = null;
        return _this;
      }
      Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
        var nextIn = _ref.in;
        if (nextIn && prevState.status === UNMOUNTED) {
          return {
            status: EXITED
          };
        }
        return null;
      };
      var _proto = Transition2.prototype;
      _proto.componentDidMount = function componentDidMount() {
        this.updateStatus(true, this.appearStatus);
      };
      _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
        var nextStatus = null;
        if (prevProps !== this.props) {
          var status = this.state.status;
          if (this.props.in) {
            if (status !== ENTERING && status !== ENTERED) {
              nextStatus = ENTERING;
            }
          } else {
            if (status === ENTERING || status === ENTERED) {
              nextStatus = EXITING;
            }
          }
        }
        this.updateStatus(false, nextStatus);
      };
      _proto.componentWillUnmount = function componentWillUnmount() {
        this.cancelNextCallback();
      };
      _proto.getTimeouts = function getTimeouts() {
        var timeout = this.props.timeout;
        var exit, enter, appear;
        exit = enter = appear = timeout;
        if (timeout != null && typeof timeout !== "number") {
          exit = timeout.exit;
          enter = timeout.enter;
          appear = timeout.appear !== void 0 ? timeout.appear : enter;
        }
        return {
          exit,
          enter,
          appear
        };
      };
      _proto.updateStatus = function updateStatus(mounting, nextStatus) {
        if (mounting === void 0) {
          mounting = false;
        }
        if (nextStatus !== null) {
          this.cancelNextCallback();
          if (nextStatus === ENTERING) {
            if (this.props.unmountOnExit || this.props.mountOnEnter) {
              var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
              if (node2)
                forceReflow(node2);
            }
            this.performEnter(mounting);
          } else {
            this.performExit();
          }
        } else if (this.props.unmountOnExit && this.state.status === EXITED) {
          this.setState({
            status: UNMOUNTED
          });
        }
      };
      _proto.performEnter = function performEnter(mounting) {
        var _this2 = this;
        var enter = this.props.enter;
        var appearing = this.context ? this.context.isMounting : mounting;
        var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
        var timeouts = this.getTimeouts();
        var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
        if (!mounting && !enter || config.disabled) {
          this.safeSetState({
            status: ENTERED
          }, function() {
            _this2.props.onEntered(maybeNode);
          });
          return;
        }
        this.props.onEnter(maybeNode, maybeAppearing);
        this.safeSetState({
          status: ENTERING
        }, function() {
          _this2.props.onEntering(maybeNode, maybeAppearing);
          _this2.onTransitionEnd(enterTimeout, function() {
            _this2.safeSetState({
              status: ENTERED
            }, function() {
              _this2.props.onEntered(maybeNode, maybeAppearing);
            });
          });
        });
      };
      _proto.performExit = function performExit() {
        var _this3 = this;
        var exit = this.props.exit;
        var timeouts = this.getTimeouts();
        var maybeNode = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
        if (!exit || config.disabled) {
          this.safeSetState({
            status: EXITED
          }, function() {
            _this3.props.onExited(maybeNode);
          });
          return;
        }
        this.props.onExit(maybeNode);
        this.safeSetState({
          status: EXITING
        }, function() {
          _this3.props.onExiting(maybeNode);
          _this3.onTransitionEnd(timeouts.exit, function() {
            _this3.safeSetState({
              status: EXITED
            }, function() {
              _this3.props.onExited(maybeNode);
            });
          });
        });
      };
      _proto.cancelNextCallback = function cancelNextCallback() {
        if (this.nextCallback !== null) {
          this.nextCallback.cancel();
          this.nextCallback = null;
        }
      };
      _proto.safeSetState = function safeSetState(nextState, callback) {
        callback = this.setNextCallback(callback);
        this.setState(nextState, callback);
      };
      _proto.setNextCallback = function setNextCallback(callback) {
        var _this4 = this;
        var active = true;
        this.nextCallback = function(event) {
          if (active) {
            active = false;
            _this4.nextCallback = null;
            callback(event);
          }
        };
        this.nextCallback.cancel = function() {
          active = false;
        };
        return this.nextCallback;
      };
      _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {
        this.setNextCallback(handler);
        var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
        var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;
        if (!node2 || doesNotHaveTimeoutOrListener) {
          setTimeout(this.nextCallback, 0);
          return;
        }
        if (this.props.addEndListener) {
          var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node2, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
          this.props.addEndListener(maybeNode, maybeNextCallback);
        }
        if (timeout != null) {
          setTimeout(this.nextCallback, timeout);
        }
      };
      _proto.render = function render() {
        var status = this.state.status;
        if (status === UNMOUNTED) {
          return null;
        }
        var _this$props = this.props, children = _this$props.children;
        _this$props.in;
        _this$props.mountOnEnter;
        _this$props.unmountOnExit;
        _this$props.appear;
        _this$props.enter;
        _this$props.exit;
        _this$props.timeout;
        _this$props.addEndListener;
        _this$props.onEnter;
        _this$props.onEntering;
        _this$props.onEntered;
        _this$props.onExit;
        _this$props.onExiting;
        _this$props.onExited;
        _this$props.nodeRef;
        var childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
        return /* @__PURE__ */ jsx(TransitionGroupContext.Provider, {
          value: null,
          children: typeof children === "function" ? children(status, childProps) : React.cloneElement(React.Children.only(children), childProps)
        });
      };
      return Transition2;
    }(React.Component);
    Transition.contextType = TransitionGroupContext;
    Transition.propTypes = {};
    function noop$3() {
    }
    Transition.defaultProps = {
      in: false,
      mountOnEnter: false,
      unmountOnExit: false,
      appear: false,
      enter: true,
      exit: true,
      onEnter: noop$3,
      onEntering: noop$3,
      onEntered: noop$3,
      onExit: noop$3,
      onExiting: noop$3,
      onExited: noop$3
    };
    Transition.UNMOUNTED = UNMOUNTED;
    Transition.EXITED = EXITED;
    Transition.ENTERING = ENTERING;
    Transition.ENTERED = ENTERED;
    Transition.EXITING = EXITING;
    const Transition$1 = Transition;
    var _addClass = function addClass$1(node2, classes) {
      return node2 && classes && classes.split(" ").forEach(function(c2) {
        return addClass(node2, c2);
      });
    };
    var removeClass = function removeClass2(node2, classes) {
      return node2 && classes && classes.split(" ").forEach(function(c2) {
        return removeClass$1(node2, c2);
      });
    };
    var CSSTransition = /* @__PURE__ */ function(_React$Component) {
      _inheritsLoose(CSSTransition2, _React$Component);
      function CSSTransition2() {
        var _this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
        _this.appliedClasses = {
          appear: {},
          enter: {},
          exit: {}
        };
        _this.onEnter = function(maybeNode, maybeAppearing) {
          var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing), node2 = _this$resolveArgument[0], appearing = _this$resolveArgument[1];
          _this.removeClasses(node2, "exit");
          _this.addClass(node2, appearing ? "appear" : "enter", "base");
          if (_this.props.onEnter) {
            _this.props.onEnter(maybeNode, maybeAppearing);
          }
        };
        _this.onEntering = function(maybeNode, maybeAppearing) {
          var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing), node2 = _this$resolveArgument2[0], appearing = _this$resolveArgument2[1];
          var type2 = appearing ? "appear" : "enter";
          _this.addClass(node2, type2, "active");
          if (_this.props.onEntering) {
            _this.props.onEntering(maybeNode, maybeAppearing);
          }
        };
        _this.onEntered = function(maybeNode, maybeAppearing) {
          var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing), node2 = _this$resolveArgument3[0], appearing = _this$resolveArgument3[1];
          var type2 = appearing ? "appear" : "enter";
          _this.removeClasses(node2, type2);
          _this.addClass(node2, type2, "done");
          if (_this.props.onEntered) {
            _this.props.onEntered(maybeNode, maybeAppearing);
          }
        };
        _this.onExit = function(maybeNode) {
          var _this$resolveArgument4 = _this.resolveArguments(maybeNode), node2 = _this$resolveArgument4[0];
          _this.removeClasses(node2, "appear");
          _this.removeClasses(node2, "enter");
          _this.addClass(node2, "exit", "base");
          if (_this.props.onExit) {
            _this.props.onExit(maybeNode);
          }
        };
        _this.onExiting = function(maybeNode) {
          var _this$resolveArgument5 = _this.resolveArguments(maybeNode), node2 = _this$resolveArgument5[0];
          _this.addClass(node2, "exit", "active");
          if (_this.props.onExiting) {
            _this.props.onExiting(maybeNode);
          }
        };
        _this.onExited = function(maybeNode) {
          var _this$resolveArgument6 = _this.resolveArguments(maybeNode), node2 = _this$resolveArgument6[0];
          _this.removeClasses(node2, "exit");
          _this.addClass(node2, "exit", "done");
          if (_this.props.onExited) {
            _this.props.onExited(maybeNode);
          }
        };
        _this.resolveArguments = function(maybeNode, maybeAppearing) {
          return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] : [maybeNode, maybeAppearing];
        };
        _this.getClassNames = function(type2) {
          var classNames = _this.props.classNames;
          var isStringClassNames = typeof classNames === "string";
          var prefix2 = isStringClassNames && classNames ? classNames + "-" : "";
          var baseClassName = isStringClassNames ? "" + prefix2 + type2 : classNames[type2];
          var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type2 + "Active"];
          var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type2 + "Done"];
          return {
            baseClassName,
            activeClassName,
            doneClassName
          };
        };
        return _this;
      }
      var _proto = CSSTransition2.prototype;
      _proto.addClass = function addClass2(node2, type2, phase) {
        var className = this.getClassNames(type2)[phase + "ClassName"];
        var _this$getClassNames = this.getClassNames("enter"), doneClassName = _this$getClassNames.doneClassName;
        if (type2 === "appear" && phase === "done" && doneClassName) {
          className += " " + doneClassName;
        }
        if (phase === "active") {
          if (node2)
            forceReflow(node2);
        }
        if (className) {
          this.appliedClasses[type2][phase] = className;
          _addClass(node2, className);
        }
      };
      _proto.removeClasses = function removeClasses(node2, type2) {
        var _this$appliedClasses$ = this.appliedClasses[type2], baseClassName = _this$appliedClasses$.base, activeClassName = _this$appliedClasses$.active, doneClassName = _this$appliedClasses$.done;
        this.appliedClasses[type2] = {};
        if (baseClassName) {
          removeClass(node2, baseClassName);
        }
        if (activeClassName) {
          removeClass(node2, activeClassName);
        }
        if (doneClassName) {
          removeClass(node2, doneClassName);
        }
      };
      _proto.render = function render() {
        var _this$props = this.props;
        _this$props.classNames;
        var props2 = _objectWithoutPropertiesLoose(_this$props, ["classNames"]);
        return /* @__PURE__ */ jsx(Transition$1, {
          ...props2,
          onEnter: this.onEnter,
          onEntered: this.onEntered,
          onEntering: this.onEntering,
          onExit: this.onExit,
          onExiting: this.onExiting,
          onExited: this.onExited
        });
      };
      return CSSTransition2;
    }(React.Component);
    CSSTransition.defaultProps = {
      classNames: ""
    };
    CSSTransition.propTypes = {};
    const CSSTransition$1 = CSSTransition;
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function getChildMapping(children, mapFn) {
      var mapper = function mapper2(child) {
        return mapFn && react.exports.isValidElement(child) ? mapFn(child) : child;
      };
      var result = /* @__PURE__ */ Object.create(null);
      if (children)
        react.exports.Children.map(children, function(c2) {
          return c2;
        }).forEach(function(child) {
          result[child.key] = mapper(child);
        });
      return result;
    }
    function mergeChildMappings(prev2, next2) {
      prev2 = prev2 || {};
      next2 = next2 || {};
      function getValueForKey(key) {
        return key in next2 ? next2[key] : prev2[key];
      }
      var nextKeysPending = /* @__PURE__ */ Object.create(null);
      var pendingKeys = [];
      for (var prevKey in prev2) {
        if (prevKey in next2) {
          if (pendingKeys.length) {
            nextKeysPending[prevKey] = pendingKeys;
            pendingKeys = [];
          }
        } else {
          pendingKeys.push(prevKey);
        }
      }
      var i;
      var childMapping = {};
      for (var nextKey in next2) {
        if (nextKeysPending[nextKey]) {
          for (i = 0; i < nextKeysPending[nextKey].length; i++) {
            var pendingNextKey = nextKeysPending[nextKey][i];
            childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
          }
        }
        childMapping[nextKey] = getValueForKey(nextKey);
      }
      for (i = 0; i < pendingKeys.length; i++) {
        childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
      }
      return childMapping;
    }
    function getProp(child, prop, props2) {
      return props2[prop] != null ? props2[prop] : child.props[prop];
    }
    function getInitialChildMapping(props2, onExited) {
      return getChildMapping(props2.children, function(child) {
        return react.exports.cloneElement(child, {
          onExited: onExited.bind(null, child),
          in: true,
          appear: getProp(child, "appear", props2),
          enter: getProp(child, "enter", props2),
          exit: getProp(child, "exit", props2)
        });
      });
    }
    function getNextChildMapping(nextProps, prevChildMapping, onExited) {
      var nextChildMapping = getChildMapping(nextProps.children);
      var children = mergeChildMappings(prevChildMapping, nextChildMapping);
      Object.keys(children).forEach(function(key) {
        var child = children[key];
        if (!react.exports.isValidElement(child))
          return;
        var hasPrev = key in prevChildMapping;
        var hasNext = key in nextChildMapping;
        var prevChild = prevChildMapping[key];
        var isLeaving = react.exports.isValidElement(prevChild) && !prevChild.props.in;
        if (hasNext && (!hasPrev || isLeaving)) {
          children[key] = react.exports.cloneElement(child, {
            onExited: onExited.bind(null, child),
            in: true,
            exit: getProp(child, "exit", nextProps),
            enter: getProp(child, "enter", nextProps)
          });
        } else if (!hasNext && hasPrev && !isLeaving) {
          children[key] = react.exports.cloneElement(child, {
            in: false
          });
        } else if (hasNext && hasPrev && react.exports.isValidElement(prevChild)) {
          children[key] = react.exports.cloneElement(child, {
            onExited: onExited.bind(null, child),
            in: prevChild.props.in,
            exit: getProp(child, "exit", nextProps),
            enter: getProp(child, "enter", nextProps)
          });
        }
      });
      return children;
    }
    var values = Object.values || function(obj) {
      return Object.keys(obj).map(function(k2) {
        return obj[k2];
      });
    };
    var defaultProps = {
      component: "div",
      childFactory: function childFactory(child) {
        return child;
      }
    };
    var TransitionGroup = /* @__PURE__ */ function(_React$Component) {
      _inheritsLoose(TransitionGroup2, _React$Component);
      function TransitionGroup2(props2, context) {
        var _this;
        _this = _React$Component.call(this, props2, context) || this;
        var handleExited = _this.handleExited.bind(_assertThisInitialized(_this));
        _this.state = {
          contextValue: {
            isMounting: true
          },
          handleExited,
          firstRender: true
        };
        return _this;
      }
      var _proto = TransitionGroup2.prototype;
      _proto.componentDidMount = function componentDidMount() {
        this.mounted = true;
        this.setState({
          contextValue: {
            isMounting: false
          }
        });
      };
      _proto.componentWillUnmount = function componentWillUnmount() {
        this.mounted = false;
      };
      TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
        var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
        return {
          children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
          firstRender: false
        };
      };
      _proto.handleExited = function handleExited(child, node2) {
        var currentChildMapping = getChildMapping(this.props.children);
        if (child.key in currentChildMapping)
          return;
        if (child.props.onExited) {
          child.props.onExited(node2);
        }
        if (this.mounted) {
          this.setState(function(state) {
            var children = _extends({}, state.children);
            delete children[child.key];
            return {
              children
            };
          });
        }
      };
      _proto.render = function render() {
        var _this$props = this.props, Component = _this$props.component, childFactory = _this$props.childFactory, props2 = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);
        var contextValue = this.state.contextValue;
        var children = values(this.state.children).map(childFactory);
        delete props2.appear;
        delete props2.enter;
        delete props2.exit;
        if (Component === null) {
          return /* @__PURE__ */ jsx(TransitionGroupContext.Provider, {
            value: contextValue,
            children
          });
        }
        return /* @__PURE__ */ jsx(TransitionGroupContext.Provider, {
          value: contextValue,
          children: /* @__PURE__ */ jsx(Component, {
            ...props2,
            children
          })
        });
      };
      return TransitionGroup2;
    }(React.Component);
    TransitionGroup.propTypes = {};
    TransitionGroup.defaultProps = defaultProps;
    const TransitionGroup$1 = TransitionGroup;
    const reflow = (node2) => node2.scrollTop;
    function getTransitionProps(props2, options) {
      var _style$transitionDura, _style$transitionTimi;
      const {
        timeout,
        easing: easing2,
        style: style2 = {}
      } = props2;
      return {
        duration: (_style$transitionDura = style2.transitionDuration) != null ? _style$transitionDura : typeof timeout === "number" ? timeout : timeout[options.mode] || 0,
        easing: (_style$transitionTimi = style2.transitionTimingFunction) != null ? _style$transitionTimi : typeof easing2 === "object" ? easing2[options.mode] : easing2,
        delay: style2.transitionDelay
      };
    }
    function getPaperUtilityClass(slot) {
      return generateUtilityClass("MuiPaper", slot);
    }
    generateUtilityClasses("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
    const _excluded$1h = ["className", "component", "elevation", "square", "variant"];
    const useUtilityClasses$18 = (ownerState) => {
      const {
        square,
        elevation,
        variant,
        classes
      } = ownerState;
      const slots = {
        root: ["root", variant, !square && "rounded", variant === "elevation" && `elevation${elevation}`]
      };
      return composeClasses(slots, getPaperUtilityClass, classes);
    };
    const PaperRoot = styled$1("div", {
      name: "MuiPaper",
      slot: "Root",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.root, styles2[ownerState.variant], !ownerState.square && styles2.rounded, ownerState.variant === "elevation" && styles2[`elevation${ownerState.elevation}`]];
      }
    })(({
      theme,
      ownerState
    }) => {
      var _theme$vars$overlays;
      return _extends({
        backgroundColor: (theme.vars || theme).palette.background.paper,
        color: (theme.vars || theme).palette.text.primary,
        transition: theme.transitions.create("box-shadow")
      }, !ownerState.square && {
        borderRadius: theme.shape.borderRadius
      }, ownerState.variant === "outlined" && {
        border: `1px solid ${(theme.vars || theme).palette.divider}`
      }, ownerState.variant === "elevation" && _extends({
        boxShadow: (theme.vars || theme).shadows[ownerState.elevation]
      }, !theme.vars && theme.palette.mode === "dark" && {
        backgroundImage: `linear-gradient(${alpha("#fff", getOverlayAlpha$1(ownerState.elevation))}, ${alpha("#fff", getOverlayAlpha$1(ownerState.elevation))})`
      }, theme.vars && {
        backgroundImage: (_theme$vars$overlays = theme.vars.overlays) == null ? void 0 : _theme$vars$overlays[ownerState.elevation]
      }));
    });
    const Paper = /* @__PURE__ */ react.exports.forwardRef(function Paper2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiPaper"
      });
      const {
        className,
        component = "div",
        elevation = 1,
        square = false,
        variant = "elevation"
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$1h);
      const ownerState = _extends({}, props2, {
        component,
        elevation,
        square,
        variant
      });
      const classes = useUtilityClasses$18(ownerState);
      return /* @__PURE__ */ jsx(PaperRoot, _extends({
        as: component,
        ownerState,
        className: clsx(classes.root, className),
        ref
      }, other));
    });
    const Paper$1 = Paper;
    function Ripple(props2) {
      const {
        className,
        classes,
        pulsate = false,
        rippleX,
        rippleY,
        rippleSize,
        in: inProp,
        onExited,
        timeout
      } = props2;
      const [leaving, setLeaving] = react.exports.useState(false);
      const rippleClassName = clsx(className, classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate);
      const rippleStyles = {
        width: rippleSize,
        height: rippleSize,
        top: -(rippleSize / 2) + rippleY,
        left: -(rippleSize / 2) + rippleX
      };
      const childClassName = clsx(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);
      if (!inProp && !leaving) {
        setLeaving(true);
      }
      react.exports.useEffect(() => {
        if (!inProp && onExited != null) {
          const timeoutId = setTimeout(onExited, timeout);
          return () => {
            clearTimeout(timeoutId);
          };
        }
        return void 0;
      }, [onExited, inProp, timeout]);
      return /* @__PURE__ */ jsx("span", {
        className: rippleClassName,
        style: rippleStyles,
        children: /* @__PURE__ */ jsx("span", {
          className: childClassName
        })
      });
    }
    const touchRippleClasses = generateUtilityClasses("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]);
    const touchRippleClasses$1 = touchRippleClasses;
    const _excluded$1g = ["center", "classes", "className"];
    let _$2 = (t2) => t2, _t$2, _t2$2, _t3$2, _t4$2;
    const DURATION = 550;
    const DELAY_RIPPLE = 80;
    const enterKeyframe = keyframes(_t$2 || (_t$2 = _$2`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`));
    const exitKeyframe = keyframes(_t2$2 || (_t2$2 = _$2`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`));
    const pulsateKeyframe = keyframes(_t3$2 || (_t3$2 = _$2`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`));
    const TouchRippleRoot = styled$1("span", {
      name: "MuiTouchRipple",
      slot: "Root"
    })({
      overflow: "hidden",
      pointerEvents: "none",
      position: "absolute",
      zIndex: 0,
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      borderRadius: "inherit"
    });
    const TouchRippleRipple = styled$1(Ripple, {
      name: "MuiTouchRipple",
      slot: "Ripple"
    })(_t4$2 || (_t4$2 = _$2`
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`), touchRippleClasses$1.rippleVisible, enterKeyframe, DURATION, ({
      theme
    }) => theme.transitions.easing.easeInOut, touchRippleClasses$1.ripplePulsate, ({
      theme
    }) => theme.transitions.duration.shorter, touchRippleClasses$1.child, touchRippleClasses$1.childLeaving, exitKeyframe, DURATION, ({
      theme
    }) => theme.transitions.easing.easeInOut, touchRippleClasses$1.childPulsate, pulsateKeyframe, ({
      theme
    }) => theme.transitions.easing.easeInOut);
    const TouchRipple = /* @__PURE__ */ react.exports.forwardRef(function TouchRipple2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiTouchRipple"
      });
      const {
        center: centerProp = false,
        classes = {},
        className
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$1g);
      const [ripples, setRipples] = react.exports.useState([]);
      const nextKey = react.exports.useRef(0);
      const rippleCallback = react.exports.useRef(null);
      react.exports.useEffect(() => {
        if (rippleCallback.current) {
          rippleCallback.current();
          rippleCallback.current = null;
        }
      }, [ripples]);
      const ignoringMouseDown = react.exports.useRef(false);
      const startTimer = react.exports.useRef(null);
      const startTimerCommit = react.exports.useRef(null);
      const container = react.exports.useRef(null);
      react.exports.useEffect(() => {
        return () => {
          clearTimeout(startTimer.current);
        };
      }, []);
      const startCommit = react.exports.useCallback((params) => {
        const {
          pulsate: pulsate2,
          rippleX,
          rippleY,
          rippleSize,
          cb: cb2
        } = params;
        setRipples((oldRipples) => [...oldRipples, /* @__PURE__ */ jsx(TouchRippleRipple, {
          classes: {
            ripple: clsx(classes.ripple, touchRippleClasses$1.ripple),
            rippleVisible: clsx(classes.rippleVisible, touchRippleClasses$1.rippleVisible),
            ripplePulsate: clsx(classes.ripplePulsate, touchRippleClasses$1.ripplePulsate),
            child: clsx(classes.child, touchRippleClasses$1.child),
            childLeaving: clsx(classes.childLeaving, touchRippleClasses$1.childLeaving),
            childPulsate: clsx(classes.childPulsate, touchRippleClasses$1.childPulsate)
          },
          timeout: DURATION,
          pulsate: pulsate2,
          rippleX,
          rippleY,
          rippleSize
        }, nextKey.current)]);
        nextKey.current += 1;
        rippleCallback.current = cb2;
      }, [classes]);
      const start2 = react.exports.useCallback((event = {}, options = {}, cb2 = () => {
      }) => {
        const {
          pulsate: pulsate2 = false,
          center = centerProp || options.pulsate,
          fakeElement = false
        } = options;
        if ((event == null ? void 0 : event.type) === "mousedown" && ignoringMouseDown.current) {
          ignoringMouseDown.current = false;
          return;
        }
        if ((event == null ? void 0 : event.type) === "touchstart") {
          ignoringMouseDown.current = true;
        }
        const element = fakeElement ? null : container.current;
        const rect = element ? element.getBoundingClientRect() : {
          width: 0,
          height: 0,
          left: 0,
          top: 0
        };
        let rippleX;
        let rippleY;
        let rippleSize;
        if (center || event === void 0 || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {
          rippleX = Math.round(rect.width / 2);
          rippleY = Math.round(rect.height / 2);
        } else {
          const {
            clientX,
            clientY
          } = event.touches && event.touches.length > 0 ? event.touches[0] : event;
          rippleX = Math.round(clientX - rect.left);
          rippleY = Math.round(clientY - rect.top);
        }
        if (center) {
          rippleSize = Math.sqrt((2 * rect.width ** 2 + rect.height ** 2) / 3);
          if (rippleSize % 2 === 0) {
            rippleSize += 1;
          }
        } else {
          const sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
          const sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
          rippleSize = Math.sqrt(sizeX ** 2 + sizeY ** 2);
        }
        if (event != null && event.touches) {
          if (startTimerCommit.current === null) {
            startTimerCommit.current = () => {
              startCommit({
                pulsate: pulsate2,
                rippleX,
                rippleY,
                rippleSize,
                cb: cb2
              });
            };
            startTimer.current = setTimeout(() => {
              if (startTimerCommit.current) {
                startTimerCommit.current();
                startTimerCommit.current = null;
              }
            }, DELAY_RIPPLE);
          }
        } else {
          startCommit({
            pulsate: pulsate2,
            rippleX,
            rippleY,
            rippleSize,
            cb: cb2
          });
        }
      }, [centerProp, startCommit]);
      const pulsate = react.exports.useCallback(() => {
        start2({}, {
          pulsate: true
        });
      }, [start2]);
      const stop = react.exports.useCallback((event, cb2) => {
        clearTimeout(startTimer.current);
        if ((event == null ? void 0 : event.type) === "touchend" && startTimerCommit.current) {
          startTimerCommit.current();
          startTimerCommit.current = null;
          startTimer.current = setTimeout(() => {
            stop(event, cb2);
          });
          return;
        }
        startTimerCommit.current = null;
        setRipples((oldRipples) => {
          if (oldRipples.length > 0) {
            return oldRipples.slice(1);
          }
          return oldRipples;
        });
        rippleCallback.current = cb2;
      }, []);
      react.exports.useImperativeHandle(ref, () => ({
        pulsate,
        start: start2,
        stop
      }), [pulsate, start2, stop]);
      return /* @__PURE__ */ jsx(TouchRippleRoot, _extends({
        className: clsx(touchRippleClasses$1.root, classes.root, className),
        ref: container
      }, other, {
        children: /* @__PURE__ */ jsx(TransitionGroup$1, {
          component: null,
          exit: true,
          children: ripples
        })
      }));
    });
    const TouchRipple$1 = TouchRipple;
    function getButtonBaseUtilityClass(slot) {
      return generateUtilityClass("MuiButtonBase", slot);
    }
    const buttonBaseClasses = generateUtilityClasses("MuiButtonBase", ["root", "disabled", "focusVisible"]);
    const buttonBaseClasses$1 = buttonBaseClasses;
    const _excluded$1f = ["action", "centerRipple", "children", "className", "component", "disabled", "disableRipple", "disableTouchRipple", "focusRipple", "focusVisibleClassName", "LinkComponent", "onBlur", "onClick", "onContextMenu", "onDragLeave", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseDown", "onMouseLeave", "onMouseUp", "onTouchEnd", "onTouchMove", "onTouchStart", "tabIndex", "TouchRippleProps", "touchRippleRef", "type"];
    const useUtilityClasses$17 = (ownerState) => {
      const {
        disabled,
        focusVisible,
        focusVisibleClassName,
        classes
      } = ownerState;
      const slots = {
        root: ["root", disabled && "disabled", focusVisible && "focusVisible"]
      };
      const composedClasses = composeClasses(slots, getButtonBaseUtilityClass, classes);
      if (focusVisible && focusVisibleClassName) {
        composedClasses.root += ` ${focusVisibleClassName}`;
      }
      return composedClasses;
    };
    const ButtonBaseRoot = styled$1("button", {
      name: "MuiButtonBase",
      slot: "Root",
      overridesResolver: (props2, styles2) => styles2.root
    })({
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      position: "relative",
      boxSizing: "border-box",
      WebkitTapHighlightColor: "transparent",
      backgroundColor: "transparent",
      outline: 0,
      border: 0,
      margin: 0,
      borderRadius: 0,
      padding: 0,
      cursor: "pointer",
      userSelect: "none",
      verticalAlign: "middle",
      MozAppearance: "none",
      WebkitAppearance: "none",
      textDecoration: "none",
      color: "inherit",
      "&::-moz-focus-inner": {
        borderStyle: "none"
      },
      [`&.${buttonBaseClasses$1.disabled}`]: {
        pointerEvents: "none",
        cursor: "default"
      },
      "@media print": {
        colorAdjust: "exact"
      }
    });
    const ButtonBase = /* @__PURE__ */ react.exports.forwardRef(function ButtonBase2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiButtonBase"
      });
      const {
        action,
        centerRipple = false,
        children,
        className,
        component = "button",
        disabled = false,
        disableRipple = false,
        disableTouchRipple = false,
        focusRipple = false,
        LinkComponent = "a",
        onBlur,
        onClick,
        onContextMenu,
        onDragLeave,
        onFocus,
        onFocusVisible,
        onKeyDown,
        onKeyUp,
        onMouseDown,
        onMouseLeave,
        onMouseUp,
        onTouchEnd,
        onTouchMove,
        onTouchStart,
        tabIndex = 0,
        TouchRippleProps,
        touchRippleRef,
        type: type2
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$1f);
      const buttonRef = react.exports.useRef(null);
      const rippleRef = react.exports.useRef(null);
      const handleRippleRef = useForkRef(rippleRef, touchRippleRef);
      const {
        isFocusVisibleRef,
        onFocus: handleFocusVisible,
        onBlur: handleBlurVisible,
        ref: focusVisibleRef
      } = useIsFocusVisible();
      const [focusVisible, setFocusVisible] = react.exports.useState(false);
      if (disabled && focusVisible) {
        setFocusVisible(false);
      }
      react.exports.useImperativeHandle(action, () => ({
        focusVisible: () => {
          setFocusVisible(true);
          buttonRef.current.focus();
        }
      }), []);
      const [mountedState, setMountedState] = react.exports.useState(false);
      react.exports.useEffect(() => {
        setMountedState(true);
      }, []);
      const enableTouchRipple = mountedState && !disableRipple && !disabled;
      react.exports.useEffect(() => {
        if (focusVisible && focusRipple && !disableRipple && mountedState) {
          rippleRef.current.pulsate();
        }
      }, [disableRipple, focusRipple, focusVisible, mountedState]);
      function useRippleHandler(rippleAction, eventCallback, skipRippleAction = disableTouchRipple) {
        return useEventCallback((event) => {
          if (eventCallback) {
            eventCallback(event);
          }
          const ignore = skipRippleAction;
          if (!ignore && rippleRef.current) {
            rippleRef.current[rippleAction](event);
          }
          return true;
        });
      }
      const handleMouseDown = useRippleHandler("start", onMouseDown);
      const handleContextMenu = useRippleHandler("stop", onContextMenu);
      const handleDragLeave = useRippleHandler("stop", onDragLeave);
      const handleMouseUp = useRippleHandler("stop", onMouseUp);
      const handleMouseLeave = useRippleHandler("stop", (event) => {
        if (focusVisible) {
          event.preventDefault();
        }
        if (onMouseLeave) {
          onMouseLeave(event);
        }
      });
      const handleTouchStart = useRippleHandler("start", onTouchStart);
      const handleTouchEnd = useRippleHandler("stop", onTouchEnd);
      const handleTouchMove = useRippleHandler("stop", onTouchMove);
      const handleBlur = useRippleHandler("stop", (event) => {
        handleBlurVisible(event);
        if (isFocusVisibleRef.current === false) {
          setFocusVisible(false);
        }
        if (onBlur) {
          onBlur(event);
        }
      }, false);
      const handleFocus = useEventCallback((event) => {
        if (!buttonRef.current) {
          buttonRef.current = event.currentTarget;
        }
        handleFocusVisible(event);
        if (isFocusVisibleRef.current === true) {
          setFocusVisible(true);
          if (onFocusVisible) {
            onFocusVisible(event);
          }
        }
        if (onFocus) {
          onFocus(event);
        }
      });
      const isNonNativeButton = () => {
        const button = buttonRef.current;
        return component && component !== "button" && !(button.tagName === "A" && button.href);
      };
      const keydownRef = react.exports.useRef(false);
      const handleKeyDown2 = useEventCallback((event) => {
        if (focusRipple && !keydownRef.current && focusVisible && rippleRef.current && event.key === " ") {
          keydownRef.current = true;
          rippleRef.current.stop(event, () => {
            rippleRef.current.start(event);
          });
        }
        if (event.target === event.currentTarget && isNonNativeButton() && event.key === " ") {
          event.preventDefault();
        }
        if (onKeyDown) {
          onKeyDown(event);
        }
        if (event.target === event.currentTarget && isNonNativeButton() && event.key === "Enter" && !disabled) {
          event.preventDefault();
          if (onClick) {
            onClick(event);
          }
        }
      });
      const handleKeyUp = useEventCallback((event) => {
        if (focusRipple && event.key === " " && rippleRef.current && focusVisible && !event.defaultPrevented) {
          keydownRef.current = false;
          rippleRef.current.stop(event, () => {
            rippleRef.current.pulsate(event);
          });
        }
        if (onKeyUp) {
          onKeyUp(event);
        }
        if (onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === " " && !event.defaultPrevented) {
          onClick(event);
        }
      });
      let ComponentProp = component;
      if (ComponentProp === "button" && (other.href || other.to)) {
        ComponentProp = LinkComponent;
      }
      const buttonProps = {};
      if (ComponentProp === "button") {
        buttonProps.type = type2 === void 0 ? "button" : type2;
        buttonProps.disabled = disabled;
      } else {
        if (!other.href && !other.to) {
          buttonProps.role = "button";
        }
        if (disabled) {
          buttonProps["aria-disabled"] = disabled;
        }
      }
      const handleRef = useForkRef(ref, focusVisibleRef, buttonRef);
      const ownerState = _extends({}, props2, {
        centerRipple,
        component,
        disabled,
        disableRipple,
        disableTouchRipple,
        focusRipple,
        tabIndex,
        focusVisible
      });
      const classes = useUtilityClasses$17(ownerState);
      return /* @__PURE__ */ jsxs(ButtonBaseRoot, _extends({
        as: ComponentProp,
        className: clsx(classes.root, className),
        ownerState,
        onBlur: handleBlur,
        onClick,
        onContextMenu: handleContextMenu,
        onFocus: handleFocus,
        onKeyDown: handleKeyDown2,
        onKeyUp: handleKeyUp,
        onMouseDown: handleMouseDown,
        onMouseLeave: handleMouseLeave,
        onMouseUp: handleMouseUp,
        onDragLeave: handleDragLeave,
        onTouchEnd: handleTouchEnd,
        onTouchMove: handleTouchMove,
        onTouchStart: handleTouchStart,
        ref: handleRef,
        tabIndex: disabled ? -1 : tabIndex,
        type: type2
      }, buttonProps, other, {
        children: [children, enableTouchRipple ? /* @__PURE__ */ jsx(TouchRipple$1, _extends({
          ref: handleRippleRef,
          center: centerRipple
        }, TouchRippleProps)) : null]
      }));
    });
    const ButtonBase$1 = ButtonBase;
    function getAlertUtilityClass(slot) {
      return generateUtilityClass("MuiAlert", slot);
    }
    const alertClasses = generateUtilityClasses("MuiAlert", ["root", "action", "icon", "message", "filled", "filledSuccess", "filledInfo", "filledWarning", "filledError", "outlined", "outlinedSuccess", "outlinedInfo", "outlinedWarning", "outlinedError", "standard", "standardSuccess", "standardInfo", "standardWarning", "standardError"]);
    const alertClasses$1 = alertClasses;
    function getIconButtonUtilityClass(slot) {
      return generateUtilityClass("MuiIconButton", slot);
    }
    const iconButtonClasses = generateUtilityClasses("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge"]);
    const iconButtonClasses$1 = iconButtonClasses;
    const _excluded$1e = ["edge", "children", "className", "color", "disabled", "disableFocusRipple", "size"];
    const useUtilityClasses$16 = (ownerState) => {
      const {
        classes,
        disabled,
        color: color2,
        edge,
        size
      } = ownerState;
      const slots = {
        root: ["root", disabled && "disabled", color2 !== "default" && `color${capitalize(color2)}`, edge && `edge${capitalize(edge)}`, `size${capitalize(size)}`]
      };
      return composeClasses(slots, getIconButtonUtilityClass, classes);
    };
    const IconButtonRoot = styled$1(ButtonBase$1, {
      name: "MuiIconButton",
      slot: "Root",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.root, ownerState.color !== "default" && styles2[`color${capitalize(ownerState.color)}`], ownerState.edge && styles2[`edge${capitalize(ownerState.edge)}`], styles2[`size${capitalize(ownerState.size)}`]];
      }
    })(({
      theme,
      ownerState
    }) => _extends({
      textAlign: "center",
      flex: "0 0 auto",
      fontSize: theme.typography.pxToRem(24),
      padding: 8,
      borderRadius: "50%",
      overflow: "visible",
      color: (theme.vars || theme).palette.action.active,
      transition: theme.transitions.create("background-color", {
        duration: theme.transitions.duration.shortest
      })
    }, !ownerState.disableRipple && {
      "&:hover": {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity),
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    }, ownerState.edge === "start" && {
      marginLeft: ownerState.size === "small" ? -3 : -12
    }, ownerState.edge === "end" && {
      marginRight: ownerState.size === "small" ? -3 : -12
    }), ({
      theme,
      ownerState
    }) => {
      var _palette;
      const palette2 = (_palette = (theme.vars || theme).palette) == null ? void 0 : _palette[ownerState.color];
      return _extends({}, ownerState.color === "inherit" && {
        color: "inherit"
      }, ownerState.color !== "inherit" && ownerState.color !== "default" && _extends({
        color: palette2 == null ? void 0 : palette2.main
      }, !ownerState.disableRipple && {
        "&:hover": _extends({}, palette2 && {
          backgroundColor: theme.vars ? `rgba(${palette2.mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(palette2.main, theme.palette.action.hoverOpacity)
        }, {
          "@media (hover: none)": {
            backgroundColor: "transparent"
          }
        })
      }), ownerState.size === "small" && {
        padding: 5,
        fontSize: theme.typography.pxToRem(18)
      }, ownerState.size === "large" && {
        padding: 12,
        fontSize: theme.typography.pxToRem(28)
      }, {
        [`&.${iconButtonClasses$1.disabled}`]: {
          backgroundColor: "transparent",
          color: (theme.vars || theme).palette.action.disabled
        }
      });
    });
    const IconButton = /* @__PURE__ */ react.exports.forwardRef(function IconButton2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiIconButton"
      });
      const {
        edge = false,
        children,
        className,
        color: color2 = "default",
        disabled = false,
        disableFocusRipple = false,
        size = "medium"
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$1e);
      const ownerState = _extends({}, props2, {
        edge,
        color: color2,
        disabled,
        disableFocusRipple,
        size
      });
      const classes = useUtilityClasses$16(ownerState);
      return /* @__PURE__ */ jsx(IconButtonRoot, _extends({
        className: clsx(classes.root, className),
        centerRipple: true,
        focusRipple: !disableFocusRipple,
        disabled,
        ref,
        ownerState
      }, other, {
        children
      }));
    });
    const IconButton$1 = IconButton;
    const SuccessOutlinedIcon = createSvgIcon$1(/* @__PURE__ */ jsx("path", {
      d: "M20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4C12.76,4 13.5,4.11 14.2, 4.31L15.77,2.74C14.61,2.26 13.34,2 12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0, 0 22,12M7.91,10.08L6.5,11.5L11,16L21,6L19.59,4.58L11,13.17L7.91,10.08Z"
    }), "SuccessOutlined");
    const ReportProblemOutlinedIcon = createSvgIcon$1(/* @__PURE__ */ jsx("path", {
      d: "M12 5.99L19.53 19H4.47L12 5.99M12 2L1 21h22L12 2zm1 14h-2v2h2v-2zm0-6h-2v4h2v-4z"
    }), "ReportProblemOutlined");
    const ErrorOutlineIcon = createSvgIcon$1(/* @__PURE__ */ jsx("path", {
      d: "M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
    }), "ErrorOutline");
    const InfoOutlinedIcon = createSvgIcon$1(/* @__PURE__ */ jsx("path", {
      d: "M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20, 12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10, 10 0 0,0 12,2M11,17H13V11H11V17Z"
    }), "InfoOutlined");
    const ClearIcon = createSvgIcon$1(/* @__PURE__ */ jsx("path", {
      d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
    }), "Close");
    const _excluded$1d = ["action", "children", "className", "closeText", "color", "components", "componentsProps", "icon", "iconMapping", "onClose", "role", "severity", "slotProps", "slots", "variant"];
    const useUtilityClasses$15 = (ownerState) => {
      const {
        variant,
        color: color2,
        severity,
        classes
      } = ownerState;
      const slots = {
        root: ["root", `${variant}${capitalize(color2 || severity)}`, `${variant}`],
        icon: ["icon"],
        message: ["message"],
        action: ["action"]
      };
      return composeClasses(slots, getAlertUtilityClass, classes);
    };
    const AlertRoot = styled$1(Paper$1, {
      name: "MuiAlert",
      slot: "Root",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.root, styles2[ownerState.variant], styles2[`${ownerState.variant}${capitalize(ownerState.color || ownerState.severity)}`]];
      }
    })(({
      theme,
      ownerState
    }) => {
      const getColor = theme.palette.mode === "light" ? darken : lighten;
      const getBackgroundColor = theme.palette.mode === "light" ? lighten : darken;
      const color2 = ownerState.color || ownerState.severity;
      return _extends({}, theme.typography.body2, {
        backgroundColor: "transparent",
        display: "flex",
        padding: "6px 16px"
      }, color2 && ownerState.variant === "standard" && {
        color: theme.vars ? theme.vars.palette.Alert[`${color2}Color`] : getColor(theme.palette[color2].light, 0.6),
        backgroundColor: theme.vars ? theme.vars.palette.Alert[`${color2}StandardBg`] : getBackgroundColor(theme.palette[color2].light, 0.9),
        [`& .${alertClasses$1.icon}`]: theme.vars ? {
          color: theme.vars.palette.Alert[`${color2}IconColor`]
        } : {
          color: theme.palette.mode === "dark" ? theme.palette[color2].main : theme.palette[color2].light
        }
      }, color2 && ownerState.variant === "outlined" && {
        color: theme.vars ? theme.vars.palette.Alert[`${color2}Color`] : getColor(theme.palette[color2].light, 0.6),
        border: `1px solid ${(theme.vars || theme).palette[color2].light}`,
        [`& .${alertClasses$1.icon}`]: theme.vars ? {
          color: theme.vars.palette.Alert[`${color2}IconColor`]
        } : {
          color: theme.palette.mode === "dark" ? theme.palette[color2].main : theme.palette[color2].light
        }
      }, color2 && ownerState.variant === "filled" && _extends({
        fontWeight: theme.typography.fontWeightMedium
      }, theme.vars ? {
        color: theme.vars.palette.Alert[`${color2}FilledColor`],
        backgroundColor: theme.vars.palette.Alert[`${color2}FilledBg`]
      } : {
        backgroundColor: theme.palette.mode === "dark" ? theme.palette[color2].dark : theme.palette[color2].main,
        color: theme.palette.getContrastText(theme.palette.mode === "dark" ? theme.palette[color2].dark : theme.palette[color2].main)
      }));
    });
    const AlertIcon = styled$1("div", {
      name: "MuiAlert",
      slot: "Icon",
      overridesResolver: (props2, styles2) => styles2.icon
    })({
      marginRight: 12,
      padding: "7px 0",
      display: "flex",
      fontSize: 22,
      opacity: 0.9
    });
    const AlertMessage = styled$1("div", {
      name: "MuiAlert",
      slot: "Message",
      overridesResolver: (props2, styles2) => styles2.message
    })({
      padding: "8px 0",
      minWidth: 0,
      overflow: "auto"
    });
    const AlertAction = styled$1("div", {
      name: "MuiAlert",
      slot: "Action",
      overridesResolver: (props2, styles2) => styles2.action
    })({
      display: "flex",
      alignItems: "flex-start",
      padding: "4px 0 0 16px",
      marginLeft: "auto",
      marginRight: -8
    });
    const defaultIconMapping = {
      success: /* @__PURE__ */ jsx(SuccessOutlinedIcon, {
        fontSize: "inherit"
      }),
      warning: /* @__PURE__ */ jsx(ReportProblemOutlinedIcon, {
        fontSize: "inherit"
      }),
      error: /* @__PURE__ */ jsx(ErrorOutlineIcon, {
        fontSize: "inherit"
      }),
      info: /* @__PURE__ */ jsx(InfoOutlinedIcon, {
        fontSize: "inherit"
      })
    };
    const Alert = /* @__PURE__ */ react.exports.forwardRef(function Alert2(inProps, ref) {
      var _ref, _slots$closeButton, _ref2, _slots$closeIcon, _slotProps$closeButto, _slotProps$closeIcon;
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiAlert"
      });
      const {
        action,
        children,
        className,
        closeText = "Close",
        color: color2,
        components = {},
        componentsProps = {},
        icon,
        iconMapping = defaultIconMapping,
        onClose,
        role = "alert",
        severity = "success",
        slotProps = {},
        slots = {},
        variant = "standard"
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$1d);
      const ownerState = _extends({}, props2, {
        color: color2,
        severity,
        variant
      });
      const classes = useUtilityClasses$15(ownerState);
      const AlertCloseButton = (_ref = (_slots$closeButton = slots.closeButton) != null ? _slots$closeButton : components.CloseButton) != null ? _ref : IconButton$1;
      const AlertCloseIcon = (_ref2 = (_slots$closeIcon = slots.closeIcon) != null ? _slots$closeIcon : components.CloseIcon) != null ? _ref2 : ClearIcon;
      const closeButtonProps = (_slotProps$closeButto = slotProps.closeButton) != null ? _slotProps$closeButto : componentsProps.closeButton;
      const closeIconProps = (_slotProps$closeIcon = slotProps.closeIcon) != null ? _slotProps$closeIcon : componentsProps.closeIcon;
      return /* @__PURE__ */ jsxs(AlertRoot, _extends({
        role,
        elevation: 0,
        ownerState,
        className: clsx(classes.root, className),
        ref
      }, other, {
        children: [icon !== false ? /* @__PURE__ */ jsx(AlertIcon, {
          ownerState,
          className: classes.icon,
          children: icon || iconMapping[severity] || defaultIconMapping[severity]
        }) : null, /* @__PURE__ */ jsx(AlertMessage, {
          ownerState,
          className: classes.message,
          children
        }), action != null ? /* @__PURE__ */ jsx(AlertAction, {
          ownerState,
          className: classes.action,
          children: action
        }) : null, action == null && onClose ? /* @__PURE__ */ jsx(AlertAction, {
          ownerState,
          className: classes.action,
          children: /* @__PURE__ */ jsx(AlertCloseButton, _extends({
            size: "small",
            "aria-label": closeText,
            title: closeText,
            color: "inherit",
            onClick: onClose
          }, closeButtonProps, {
            children: /* @__PURE__ */ jsx(AlertCloseIcon, _extends({
              fontSize: "small"
            }, closeIconProps))
          }))
        }) : null]
      }));
    });
    const Alert$1 = Alert;
    function getTypographyUtilityClass(slot) {
      return generateUtilityClass("MuiTypography", slot);
    }
    generateUtilityClasses("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]);
    const _excluded$1c = ["align", "className", "component", "gutterBottom", "noWrap", "paragraph", "variant", "variantMapping"];
    const useUtilityClasses$14 = (ownerState) => {
      const {
        align,
        gutterBottom,
        noWrap,
        paragraph,
        variant,
        classes
      } = ownerState;
      const slots = {
        root: ["root", variant, ownerState.align !== "inherit" && `align${capitalize(align)}`, gutterBottom && "gutterBottom", noWrap && "noWrap", paragraph && "paragraph"]
      };
      return composeClasses(slots, getTypographyUtilityClass, classes);
    };
    const TypographyRoot = styled$1("span", {
      name: "MuiTypography",
      slot: "Root",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.root, ownerState.variant && styles2[ownerState.variant], ownerState.align !== "inherit" && styles2[`align${capitalize(ownerState.align)}`], ownerState.noWrap && styles2.noWrap, ownerState.gutterBottom && styles2.gutterBottom, ownerState.paragraph && styles2.paragraph];
      }
    })(({
      theme,
      ownerState
    }) => _extends({
      margin: 0
    }, ownerState.variant && theme.typography[ownerState.variant], ownerState.align !== "inherit" && {
      textAlign: ownerState.align
    }, ownerState.noWrap && {
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap"
    }, ownerState.gutterBottom && {
      marginBottom: "0.35em"
    }, ownerState.paragraph && {
      marginBottom: 16
    }));
    const defaultVariantMapping = {
      h1: "h1",
      h2: "h2",
      h3: "h3",
      h4: "h4",
      h5: "h5",
      h6: "h6",
      subtitle1: "h6",
      subtitle2: "h6",
      body1: "p",
      body2: "p",
      inherit: "p"
    };
    const colorTransformations = {
      primary: "primary.main",
      textPrimary: "text.primary",
      secondary: "secondary.main",
      textSecondary: "text.secondary",
      error: "error.main"
    };
    const transformDeprecatedColors = (color2) => {
      return colorTransformations[color2] || color2;
    };
    const Typography = /* @__PURE__ */ react.exports.forwardRef(function Typography2(inProps, ref) {
      const themeProps = useThemeProps({
        props: inProps,
        name: "MuiTypography"
      });
      const color2 = transformDeprecatedColors(themeProps.color);
      const props2 = extendSxProp(_extends({}, themeProps, {
        color: color2
      }));
      const {
        align = "inherit",
        className,
        component,
        gutterBottom = false,
        noWrap = false,
        paragraph = false,
        variant = "body1",
        variantMapping = defaultVariantMapping
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$1c);
      const ownerState = _extends({}, props2, {
        align,
        color: color2,
        className,
        component,
        gutterBottom,
        noWrap,
        paragraph,
        variant,
        variantMapping
      });
      const Component = component || (paragraph ? "p" : variantMapping[variant] || defaultVariantMapping[variant]) || "span";
      const classes = useUtilityClasses$14(ownerState);
      return /* @__PURE__ */ jsx(TypographyRoot, _extends({
        as: Component,
        ref,
        ownerState,
        className: clsx(classes.root, className)
      }, other));
    });
    const Typography$1 = Typography;
    function getAppBarUtilityClass(slot) {
      return generateUtilityClass("MuiAppBar", slot);
    }
    generateUtilityClasses("MuiAppBar", ["root", "positionFixed", "positionAbsolute", "positionSticky", "positionStatic", "positionRelative", "colorDefault", "colorPrimary", "colorSecondary", "colorInherit", "colorTransparent"]);
    const _excluded$1b = ["className", "color", "enableColorOnDark", "position"];
    const useUtilityClasses$13 = (ownerState) => {
      const {
        color: color2,
        position: position2,
        classes
      } = ownerState;
      const slots = {
        root: ["root", `color${capitalize(color2)}`, `position${capitalize(position2)}`]
      };
      return composeClasses(slots, getAppBarUtilityClass, classes);
    };
    const joinVars = (var1, var2) => `${var1 == null ? void 0 : var1.replace(")", "")}, ${var2})`;
    const AppBarRoot = styled$1(Paper$1, {
      name: "MuiAppBar",
      slot: "Root",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.root, styles2[`position${capitalize(ownerState.position)}`], styles2[`color${capitalize(ownerState.color)}`]];
      }
    })(({
      theme,
      ownerState
    }) => {
      const backgroundColorDefault = theme.palette.mode === "light" ? theme.palette.grey[100] : theme.palette.grey[900];
      return _extends({
        display: "flex",
        flexDirection: "column",
        width: "100%",
        boxSizing: "border-box",
        flexShrink: 0
      }, ownerState.position === "fixed" && {
        position: "fixed",
        zIndex: (theme.vars || theme).zIndex.appBar,
        top: 0,
        left: "auto",
        right: 0,
        "@media print": {
          position: "absolute"
        }
      }, ownerState.position === "absolute" && {
        position: "absolute",
        zIndex: (theme.vars || theme).zIndex.appBar,
        top: 0,
        left: "auto",
        right: 0
      }, ownerState.position === "sticky" && {
        position: "sticky",
        zIndex: (theme.vars || theme).zIndex.appBar,
        top: 0,
        left: "auto",
        right: 0
      }, ownerState.position === "static" && {
        position: "static"
      }, ownerState.position === "relative" && {
        position: "relative"
      }, !theme.vars && _extends({}, ownerState.color === "default" && {
        backgroundColor: backgroundColorDefault,
        color: theme.palette.getContrastText(backgroundColorDefault)
      }, ownerState.color && ownerState.color !== "default" && ownerState.color !== "inherit" && ownerState.color !== "transparent" && {
        backgroundColor: theme.palette[ownerState.color].main,
        color: theme.palette[ownerState.color].contrastText
      }, ownerState.color === "inherit" && {
        color: "inherit"
      }, theme.palette.mode === "dark" && !ownerState.enableColorOnDark && {
        backgroundColor: null,
        color: null
      }, ownerState.color === "transparent" && _extends({
        backgroundColor: "transparent",
        color: "inherit"
      }, theme.palette.mode === "dark" && {
        backgroundImage: "none"
      })), theme.vars && _extends({}, ownerState.color === "default" && {
        "--AppBar-background": ownerState.enableColorOnDark ? theme.vars.palette.AppBar.defaultBg : joinVars(theme.vars.palette.AppBar.darkBg, theme.vars.palette.AppBar.defaultBg),
        "--AppBar-color": ownerState.enableColorOnDark ? theme.vars.palette.text.primary : joinVars(theme.vars.palette.AppBar.darkColor, theme.vars.palette.text.primary)
      }, ownerState.color && !ownerState.color.match(/^(default|inherit|transparent)$/) && {
        "--AppBar-background": ownerState.enableColorOnDark ? theme.vars.palette[ownerState.color].main : joinVars(theme.vars.palette.AppBar.darkBg, theme.vars.palette[ownerState.color].main),
        "--AppBar-color": ownerState.enableColorOnDark ? theme.vars.palette[ownerState.color].contrastText : joinVars(theme.vars.palette.AppBar.darkColor, theme.vars.palette[ownerState.color].contrastText)
      }, {
        backgroundColor: "var(--AppBar-background)",
        color: ownerState.color === "inherit" ? "inherit" : "var(--AppBar-color)"
      }, ownerState.color === "transparent" && {
        backgroundImage: "none",
        backgroundColor: "transparent",
        color: "inherit"
      }));
    });
    const AppBar = /* @__PURE__ */ react.exports.forwardRef(function AppBar2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiAppBar"
      });
      const {
        className,
        color: color2 = "primary",
        enableColorOnDark = false,
        position: position2 = "fixed"
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$1b);
      const ownerState = _extends({}, props2, {
        color: color2,
        position: position2,
        enableColorOnDark
      });
      const classes = useUtilityClasses$13(ownerState);
      return /* @__PURE__ */ jsx(AppBarRoot, _extends({
        square: true,
        component: "header",
        ownerState,
        elevation: 4,
        className: clsx(classes.root, className, position2 === "fixed" && "mui-fixed"),
        ref
      }, other));
    });
    const AppBar$1 = AppBar;
    const _excluded$1a = ["components", "componentsProps", "slots", "slotProps"];
    const PopperRoot = styled$1(PopperUnstyled$1, {
      name: "MuiPopper",
      slot: "Root",
      overridesResolver: (props2, styles2) => styles2.root
    })({});
    const Popper = /* @__PURE__ */ react.exports.forwardRef(function Popper2(inProps, ref) {
      var _slots$root;
      const theme = useTheme$2();
      const _useThemeProps = useThemeProps({
        props: inProps,
        name: "MuiPopper"
      }), {
        components,
        componentsProps,
        slots,
        slotProps
      } = _useThemeProps, other = _objectWithoutPropertiesLoose(_useThemeProps, _excluded$1a);
      const RootComponent = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : components == null ? void 0 : components.Root;
      return /* @__PURE__ */ jsx(PopperRoot, _extends({
        direction: theme == null ? void 0 : theme.direction,
        slots: {
          root: RootComponent
        },
        slotProps: slotProps != null ? slotProps : componentsProps
      }, other, {
        ref
      }));
    });
    const Popper$1 = Popper;
    function getListSubheaderUtilityClass(slot) {
      return generateUtilityClass("MuiListSubheader", slot);
    }
    generateUtilityClasses("MuiListSubheader", ["root", "colorPrimary", "colorInherit", "gutters", "inset", "sticky"]);
    const _excluded$19 = ["className", "color", "component", "disableGutters", "disableSticky", "inset"];
    const useUtilityClasses$12 = (ownerState) => {
      const {
        classes,
        color: color2,
        disableGutters,
        inset,
        disableSticky
      } = ownerState;
      const slots = {
        root: ["root", color2 !== "default" && `color${capitalize(color2)}`, !disableGutters && "gutters", inset && "inset", !disableSticky && "sticky"]
      };
      return composeClasses(slots, getListSubheaderUtilityClass, classes);
    };
    const ListSubheaderRoot = styled$1("li", {
      name: "MuiListSubheader",
      slot: "Root",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.root, ownerState.color !== "default" && styles2[`color${capitalize(ownerState.color)}`], !ownerState.disableGutters && styles2.gutters, ownerState.inset && styles2.inset, !ownerState.disableSticky && styles2.sticky];
      }
    })(({
      theme,
      ownerState
    }) => _extends({
      boxSizing: "border-box",
      lineHeight: "48px",
      listStyle: "none",
      color: (theme.vars || theme).palette.text.secondary,
      fontFamily: theme.typography.fontFamily,
      fontWeight: theme.typography.fontWeightMedium,
      fontSize: theme.typography.pxToRem(14)
    }, ownerState.color === "primary" && {
      color: (theme.vars || theme).palette.primary.main
    }, ownerState.color === "inherit" && {
      color: "inherit"
    }, !ownerState.disableGutters && {
      paddingLeft: 16,
      paddingRight: 16
    }, ownerState.inset && {
      paddingLeft: 72
    }, !ownerState.disableSticky && {
      position: "sticky",
      top: 0,
      zIndex: 1,
      backgroundColor: (theme.vars || theme).palette.background.paper
    }));
    const ListSubheader = /* @__PURE__ */ react.exports.forwardRef(function ListSubheader2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiListSubheader"
      });
      const {
        className,
        color: color2 = "default",
        component = "li",
        disableGutters = false,
        disableSticky = false,
        inset = false
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$19);
      const ownerState = _extends({}, props2, {
        color: color2,
        component,
        disableGutters,
        disableSticky,
        inset
      });
      const classes = useUtilityClasses$12(ownerState);
      return /* @__PURE__ */ jsx(ListSubheaderRoot, _extends({
        as: component,
        className: clsx(classes.root, className),
        ref,
        ownerState
      }, other));
    });
    const ListSubheader$1 = ListSubheader;
    const CancelIcon = createSvgIcon$1(/* @__PURE__ */ jsx("path", {
      d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"
    }), "Cancel");
    function getChipUtilityClass(slot) {
      return generateUtilityClass("MuiChip", slot);
    }
    const chipClasses = generateUtilityClasses("MuiChip", ["root", "sizeSmall", "sizeMedium", "colorError", "colorInfo", "colorPrimary", "colorSecondary", "colorSuccess", "colorWarning", "disabled", "clickable", "clickableColorPrimary", "clickableColorSecondary", "deletable", "deletableColorPrimary", "deletableColorSecondary", "outlined", "filled", "outlinedPrimary", "outlinedSecondary", "filledPrimary", "filledSecondary", "avatar", "avatarSmall", "avatarMedium", "avatarColorPrimary", "avatarColorSecondary", "icon", "iconSmall", "iconMedium", "iconColorPrimary", "iconColorSecondary", "label", "labelSmall", "labelMedium", "deleteIcon", "deleteIconSmall", "deleteIconMedium", "deleteIconColorPrimary", "deleteIconColorSecondary", "deleteIconOutlinedColorPrimary", "deleteIconOutlinedColorSecondary", "deleteIconFilledColorPrimary", "deleteIconFilledColorSecondary", "focusVisible"]);
    const chipClasses$1 = chipClasses;
    const _excluded$18 = ["avatar", "className", "clickable", "color", "component", "deleteIcon", "disabled", "icon", "label", "onClick", "onDelete", "onKeyDown", "onKeyUp", "size", "variant", "tabIndex", "skipFocusWhenDisabled"];
    const useUtilityClasses$11 = (ownerState) => {
      const {
        classes,
        disabled,
        size,
        color: color2,
        iconColor,
        onDelete,
        clickable,
        variant
      } = ownerState;
      const slots = {
        root: ["root", variant, disabled && "disabled", `size${capitalize(size)}`, `color${capitalize(color2)}`, clickable && "clickable", clickable && `clickableColor${capitalize(color2)}`, onDelete && "deletable", onDelete && `deletableColor${capitalize(color2)}`, `${variant}${capitalize(color2)}`],
        label: ["label", `label${capitalize(size)}`],
        avatar: ["avatar", `avatar${capitalize(size)}`, `avatarColor${capitalize(color2)}`],
        icon: ["icon", `icon${capitalize(size)}`, `iconColor${capitalize(iconColor)}`],
        deleteIcon: ["deleteIcon", `deleteIcon${capitalize(size)}`, `deleteIconColor${capitalize(color2)}`, `deleteIcon${capitalize(variant)}Color${capitalize(color2)}`]
      };
      return composeClasses(slots, getChipUtilityClass, classes);
    };
    const ChipRoot = styled$1("div", {
      name: "MuiChip",
      slot: "Root",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        const {
          color: color2,
          iconColor,
          clickable,
          onDelete,
          size,
          variant
        } = ownerState;
        return [{
          [`& .${chipClasses$1.avatar}`]: styles2.avatar
        }, {
          [`& .${chipClasses$1.avatar}`]: styles2[`avatar${capitalize(size)}`]
        }, {
          [`& .${chipClasses$1.avatar}`]: styles2[`avatarColor${capitalize(color2)}`]
        }, {
          [`& .${chipClasses$1.icon}`]: styles2.icon
        }, {
          [`& .${chipClasses$1.icon}`]: styles2[`icon${capitalize(size)}`]
        }, {
          [`& .${chipClasses$1.icon}`]: styles2[`iconColor${capitalize(iconColor)}`]
        }, {
          [`& .${chipClasses$1.deleteIcon}`]: styles2.deleteIcon
        }, {
          [`& .${chipClasses$1.deleteIcon}`]: styles2[`deleteIcon${capitalize(size)}`]
        }, {
          [`& .${chipClasses$1.deleteIcon}`]: styles2[`deleteIconColor${capitalize(color2)}`]
        }, {
          [`& .${chipClasses$1.deleteIcon}`]: styles2[`deleteIcon${capitalize(variant)}Color${capitalize(color2)}`]
        }, styles2.root, styles2[`size${capitalize(size)}`], styles2[`color${capitalize(color2)}`], clickable && styles2.clickable, clickable && color2 !== "default" && styles2[`clickableColor${capitalize(color2)})`], onDelete && styles2.deletable, onDelete && color2 !== "default" && styles2[`deletableColor${capitalize(color2)}`], styles2[variant], styles2[`${variant}${capitalize(color2)}`]];
      }
    })(({
      theme,
      ownerState
    }) => {
      const deleteIconColor = alpha(theme.palette.text.primary, 0.26);
      const textColor = theme.palette.mode === "light" ? theme.palette.grey[700] : theme.palette.grey[300];
      return _extends({
        maxWidth: "100%",
        fontFamily: theme.typography.fontFamily,
        fontSize: theme.typography.pxToRem(13),
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        height: 32,
        color: (theme.vars || theme).palette.text.primary,
        backgroundColor: (theme.vars || theme).palette.action.selected,
        borderRadius: 32 / 2,
        whiteSpace: "nowrap",
        transition: theme.transitions.create(["background-color", "box-shadow"]),
        cursor: "default",
        outline: 0,
        textDecoration: "none",
        border: 0,
        padding: 0,
        verticalAlign: "middle",
        boxSizing: "border-box",
        [`&.${chipClasses$1.disabled}`]: {
          opacity: (theme.vars || theme).palette.action.disabledOpacity,
          pointerEvents: "none"
        },
        [`& .${chipClasses$1.avatar}`]: {
          marginLeft: 5,
          marginRight: -6,
          width: 24,
          height: 24,
          color: theme.vars ? theme.vars.palette.Chip.defaultAvatarColor : textColor,
          fontSize: theme.typography.pxToRem(12)
        },
        [`& .${chipClasses$1.avatarColorPrimary}`]: {
          color: (theme.vars || theme).palette.primary.contrastText,
          backgroundColor: (theme.vars || theme).palette.primary.dark
        },
        [`& .${chipClasses$1.avatarColorSecondary}`]: {
          color: (theme.vars || theme).palette.secondary.contrastText,
          backgroundColor: (theme.vars || theme).palette.secondary.dark
        },
        [`& .${chipClasses$1.avatarSmall}`]: {
          marginLeft: 4,
          marginRight: -4,
          width: 18,
          height: 18,
          fontSize: theme.typography.pxToRem(10)
        },
        [`& .${chipClasses$1.icon}`]: _extends({
          marginLeft: 5,
          marginRight: -6
        }, ownerState.size === "small" && {
          fontSize: 18,
          marginLeft: 4,
          marginRight: -4
        }, ownerState.iconColor === ownerState.color && _extends({
          color: theme.vars ? theme.vars.palette.Chip.defaultIconColor : textColor
        }, ownerState.color !== "default" && {
          color: "inherit"
        })),
        [`& .${chipClasses$1.deleteIcon}`]: _extends({
          WebkitTapHighlightColor: "transparent",
          color: theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / 0.26)` : deleteIconColor,
          fontSize: 22,
          cursor: "pointer",
          margin: "0 5px 0 -6px",
          "&:hover": {
            color: theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / 0.4)` : alpha(deleteIconColor, 0.4)
          }
        }, ownerState.size === "small" && {
          fontSize: 16,
          marginRight: 4,
          marginLeft: -4
        }, ownerState.color !== "default" && {
          color: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].contrastTextChannel} / 0.7)` : alpha(theme.palette[ownerState.color].contrastText, 0.7),
          "&:hover, &:active": {
            color: (theme.vars || theme).palette[ownerState.color].contrastText
          }
        })
      }, ownerState.size === "small" && {
        height: 24
      }, ownerState.color !== "default" && {
        backgroundColor: (theme.vars || theme).palette[ownerState.color].main,
        color: (theme.vars || theme).palette[ownerState.color].contrastText
      }, ownerState.onDelete && {
        [`&.${chipClasses$1.focusVisible}`]: {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.selectedChannel} / calc(${theme.vars.palette.action.selectedOpacity + theme.vars.palette.action.focusOpacity}))` : alpha(theme.palette.action.selected, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
        }
      }, ownerState.onDelete && ownerState.color !== "default" && {
        [`&.${chipClasses$1.focusVisible}`]: {
          backgroundColor: (theme.vars || theme).palette[ownerState.color].dark
        }
      });
    }, ({
      theme,
      ownerState
    }) => _extends({}, ownerState.clickable && {
      userSelect: "none",
      WebkitTapHighlightColor: "transparent",
      cursor: "pointer",
      "&:hover": {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.selectedChannel} / calc(${theme.vars.palette.action.selectedOpacity + theme.vars.palette.action.hoverOpacity}))` : alpha(theme.palette.action.selected, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity)
      },
      [`&.${chipClasses$1.focusVisible}`]: {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.selectedChannel} / calc(${theme.vars.palette.action.selectedOpacity + theme.vars.palette.action.focusOpacity}))` : alpha(theme.palette.action.selected, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
      },
      "&:active": {
        boxShadow: (theme.vars || theme).shadows[1]
      }
    }, ownerState.clickable && ownerState.color !== "default" && {
      [`&:hover, &.${chipClasses$1.focusVisible}`]: {
        backgroundColor: (theme.vars || theme).palette[ownerState.color].dark
      }
    }), ({
      theme,
      ownerState
    }) => _extends({}, ownerState.variant === "outlined" && {
      backgroundColor: "transparent",
      border: theme.vars ? `1px solid ${theme.vars.palette.Chip.defaultBorder}` : `1px solid ${theme.palette.mode === "light" ? theme.palette.grey[400] : theme.palette.grey[700]}`,
      [`&.${chipClasses$1.clickable}:hover`]: {
        backgroundColor: (theme.vars || theme).palette.action.hover
      },
      [`&.${chipClasses$1.focusVisible}`]: {
        backgroundColor: (theme.vars || theme).palette.action.focus
      },
      [`& .${chipClasses$1.avatar}`]: {
        marginLeft: 4
      },
      [`& .${chipClasses$1.avatarSmall}`]: {
        marginLeft: 2
      },
      [`& .${chipClasses$1.icon}`]: {
        marginLeft: 4
      },
      [`& .${chipClasses$1.iconSmall}`]: {
        marginLeft: 2
      },
      [`& .${chipClasses$1.deleteIcon}`]: {
        marginRight: 5
      },
      [`& .${chipClasses$1.deleteIconSmall}`]: {
        marginRight: 3
      }
    }, ownerState.variant === "outlined" && ownerState.color !== "default" && {
      color: (theme.vars || theme).palette[ownerState.color].main,
      border: `1px solid ${theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.7)` : alpha(theme.palette[ownerState.color].main, 0.7)}`,
      [`&.${chipClasses$1.clickable}:hover`]: {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity)
      },
      [`&.${chipClasses$1.focusVisible}`]: {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.focusOpacity})` : alpha(theme.palette[ownerState.color].main, theme.palette.action.focusOpacity)
      },
      [`& .${chipClasses$1.deleteIcon}`]: {
        color: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.7)` : alpha(theme.palette[ownerState.color].main, 0.7),
        "&:hover, &:active": {
          color: (theme.vars || theme).palette[ownerState.color].main
        }
      }
    }));
    const ChipLabel = styled$1("span", {
      name: "MuiChip",
      slot: "Label",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        const {
          size
        } = ownerState;
        return [styles2.label, styles2[`label${capitalize(size)}`]];
      }
    })(({
      ownerState
    }) => _extends({
      overflow: "hidden",
      textOverflow: "ellipsis",
      paddingLeft: 12,
      paddingRight: 12,
      whiteSpace: "nowrap"
    }, ownerState.size === "small" && {
      paddingLeft: 8,
      paddingRight: 8
    }));
    function isDeleteKeyboardEvent(keyboardEvent) {
      return keyboardEvent.key === "Backspace" || keyboardEvent.key === "Delete";
    }
    const Chip = /* @__PURE__ */ react.exports.forwardRef(function Chip2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiChip"
      });
      const {
        avatar: avatarProp,
        className,
        clickable: clickableProp,
        color: color2 = "default",
        component: ComponentProp,
        deleteIcon: deleteIconProp,
        disabled = false,
        icon: iconProp,
        label,
        onClick,
        onDelete,
        onKeyDown,
        onKeyUp,
        size = "medium",
        variant = "filled",
        tabIndex,
        skipFocusWhenDisabled = false
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$18);
      const chipRef = react.exports.useRef(null);
      const handleRef = useForkRef(chipRef, ref);
      const handleDeleteIconClick = (event) => {
        event.stopPropagation();
        if (onDelete) {
          onDelete(event);
        }
      };
      const handleKeyDown2 = (event) => {
        if (event.currentTarget === event.target && isDeleteKeyboardEvent(event)) {
          event.preventDefault();
        }
        if (onKeyDown) {
          onKeyDown(event);
        }
      };
      const handleKeyUp = (event) => {
        if (event.currentTarget === event.target) {
          if (onDelete && isDeleteKeyboardEvent(event)) {
            onDelete(event);
          } else if (event.key === "Escape" && chipRef.current) {
            chipRef.current.blur();
          }
        }
        if (onKeyUp) {
          onKeyUp(event);
        }
      };
      const clickable = clickableProp !== false && onClick ? true : clickableProp;
      const component = clickable || onDelete ? ButtonBase$1 : ComponentProp || "div";
      const ownerState = _extends({}, props2, {
        component,
        disabled,
        size,
        color: color2,
        iconColor: /* @__PURE__ */ react.exports.isValidElement(iconProp) ? iconProp.props.color || color2 : color2,
        onDelete: !!onDelete,
        clickable,
        variant
      });
      const classes = useUtilityClasses$11(ownerState);
      const moreProps = component === ButtonBase$1 ? _extends({
        component: ComponentProp || "div",
        focusVisibleClassName: classes.focusVisible
      }, onDelete && {
        disableRipple: true
      }) : {};
      let deleteIcon = null;
      if (onDelete) {
        deleteIcon = deleteIconProp && /* @__PURE__ */ react.exports.isValidElement(deleteIconProp) ? /* @__PURE__ */ react.exports.cloneElement(deleteIconProp, {
          className: clsx(deleteIconProp.props.className, classes.deleteIcon),
          onClick: handleDeleteIconClick
        }) : /* @__PURE__ */ jsx(CancelIcon, {
          className: clsx(classes.deleteIcon),
          onClick: handleDeleteIconClick
        });
      }
      let avatar = null;
      if (avatarProp && /* @__PURE__ */ react.exports.isValidElement(avatarProp)) {
        avatar = /* @__PURE__ */ react.exports.cloneElement(avatarProp, {
          className: clsx(classes.avatar, avatarProp.props.className)
        });
      }
      let icon = null;
      if (iconProp && /* @__PURE__ */ react.exports.isValidElement(iconProp)) {
        icon = /* @__PURE__ */ react.exports.cloneElement(iconProp, {
          className: clsx(classes.icon, iconProp.props.className)
        });
      }
      return /* @__PURE__ */ jsxs(ChipRoot, _extends({
        as: component,
        className: clsx(classes.root, className),
        disabled: clickable && disabled ? true : void 0,
        onClick,
        onKeyDown: handleKeyDown2,
        onKeyUp: handleKeyUp,
        ref: handleRef,
        tabIndex: skipFocusWhenDisabled && disabled ? -1 : tabIndex,
        ownerState
      }, moreProps, other, {
        children: [avatar || icon, /* @__PURE__ */ jsx(ChipLabel, {
          className: clsx(classes.label),
          ownerState,
          children: label
        }), deleteIcon]
      }));
    });
    const Chip$1 = Chip;
    function formControlState({
      props: props2,
      states,
      muiFormControl
    }) {
      return states.reduce((acc, state) => {
        acc[state] = props2[state];
        if (muiFormControl) {
          if (typeof props2[state] === "undefined") {
            acc[state] = muiFormControl[state];
          }
        }
        return acc;
      }, {});
    }
    const FormControlContext = /* @__PURE__ */ react.exports.createContext(void 0);
    const FormControlContext$1 = FormControlContext;
    function useFormControl() {
      return react.exports.useContext(FormControlContext$1);
    }
    function GlobalStyles(props2) {
      return /* @__PURE__ */ jsx(GlobalStyles$1, _extends({}, props2, {
        defaultTheme: defaultTheme$2
      }));
    }
    function hasValue(value) {
      return value != null && !(Array.isArray(value) && value.length === 0);
    }
    function isFilled(obj, SSR = false) {
      return obj && (hasValue(obj.value) && obj.value !== "" || SSR && hasValue(obj.defaultValue) && obj.defaultValue !== "");
    }
    function isAdornedStart(obj) {
      return obj.startAdornment;
    }
    function getInputBaseUtilityClass(slot) {
      return generateUtilityClass("MuiInputBase", slot);
    }
    const inputBaseClasses = generateUtilityClasses("MuiInputBase", ["root", "formControl", "focused", "disabled", "adornedStart", "adornedEnd", "error", "sizeSmall", "multiline", "colorSecondary", "fullWidth", "hiddenLabel", "readOnly", "input", "inputSizeSmall", "inputMultiline", "inputTypeSearch", "inputAdornedStart", "inputAdornedEnd", "inputHiddenLabel"]);
    const inputBaseClasses$1 = inputBaseClasses;
    const _excluded$17 = ["aria-describedby", "autoComplete", "autoFocus", "className", "color", "components", "componentsProps", "defaultValue", "disabled", "disableInjectingGlobalStyles", "endAdornment", "error", "fullWidth", "id", "inputComponent", "inputProps", "inputRef", "margin", "maxRows", "minRows", "multiline", "name", "onBlur", "onChange", "onClick", "onFocus", "onKeyDown", "onKeyUp", "placeholder", "readOnly", "renderSuffix", "rows", "size", "slotProps", "slots", "startAdornment", "type", "value"];
    const rootOverridesResolver = (props2, styles2) => {
      const {
        ownerState
      } = props2;
      return [styles2.root, ownerState.formControl && styles2.formControl, ownerState.startAdornment && styles2.adornedStart, ownerState.endAdornment && styles2.adornedEnd, ownerState.error && styles2.error, ownerState.size === "small" && styles2.sizeSmall, ownerState.multiline && styles2.multiline, ownerState.color && styles2[`color${capitalize(ownerState.color)}`], ownerState.fullWidth && styles2.fullWidth, ownerState.hiddenLabel && styles2.hiddenLabel];
    };
    const inputOverridesResolver = (props2, styles2) => {
      const {
        ownerState
      } = props2;
      return [styles2.input, ownerState.size === "small" && styles2.inputSizeSmall, ownerState.multiline && styles2.inputMultiline, ownerState.type === "search" && styles2.inputTypeSearch, ownerState.startAdornment && styles2.inputAdornedStart, ownerState.endAdornment && styles2.inputAdornedEnd, ownerState.hiddenLabel && styles2.inputHiddenLabel];
    };
    const useUtilityClasses$10 = (ownerState) => {
      const {
        classes,
        color: color2,
        disabled,
        error,
        endAdornment,
        focused,
        formControl,
        fullWidth,
        hiddenLabel,
        multiline,
        readOnly,
        size,
        startAdornment,
        type: type2
      } = ownerState;
      const slots = {
        root: ["root", `color${capitalize(color2)}`, disabled && "disabled", error && "error", fullWidth && "fullWidth", focused && "focused", formControl && "formControl", size === "small" && "sizeSmall", multiline && "multiline", startAdornment && "adornedStart", endAdornment && "adornedEnd", hiddenLabel && "hiddenLabel", readOnly && "readOnly"],
        input: ["input", disabled && "disabled", type2 === "search" && "inputTypeSearch", multiline && "inputMultiline", size === "small" && "inputSizeSmall", hiddenLabel && "inputHiddenLabel", startAdornment && "inputAdornedStart", endAdornment && "inputAdornedEnd", readOnly && "readOnly"]
      };
      return composeClasses(slots, getInputBaseUtilityClass, classes);
    };
    const InputBaseRoot = styled$1("div", {
      name: "MuiInputBase",
      slot: "Root",
      overridesResolver: rootOverridesResolver
    })(({
      theme,
      ownerState
    }) => _extends({}, theme.typography.body1, {
      color: (theme.vars || theme).palette.text.primary,
      lineHeight: "1.4375em",
      boxSizing: "border-box",
      position: "relative",
      cursor: "text",
      display: "inline-flex",
      alignItems: "center",
      [`&.${inputBaseClasses$1.disabled}`]: {
        color: (theme.vars || theme).palette.text.disabled,
        cursor: "default"
      }
    }, ownerState.multiline && _extends({
      padding: "4px 0 5px"
    }, ownerState.size === "small" && {
      paddingTop: 1
    }), ownerState.fullWidth && {
      width: "100%"
    }));
    const InputBaseComponent = styled$1("input", {
      name: "MuiInputBase",
      slot: "Input",
      overridesResolver: inputOverridesResolver
    })(({
      theme,
      ownerState
    }) => {
      const light2 = theme.palette.mode === "light";
      const placeholder = _extends({
        color: "currentColor"
      }, theme.vars ? {
        opacity: theme.vars.opacity.inputPlaceholder
      } : {
        opacity: light2 ? 0.42 : 0.5
      }, {
        transition: theme.transitions.create("opacity", {
          duration: theme.transitions.duration.shorter
        })
      });
      const placeholderHidden = {
        opacity: "0 !important"
      };
      const placeholderVisible = theme.vars ? {
        opacity: theme.vars.opacity.inputPlaceholder
      } : {
        opacity: light2 ? 0.42 : 0.5
      };
      return _extends({
        font: "inherit",
        letterSpacing: "inherit",
        color: "currentColor",
        padding: "4px 0 5px",
        border: 0,
        boxSizing: "content-box",
        background: "none",
        height: "1.4375em",
        margin: 0,
        WebkitTapHighlightColor: "transparent",
        display: "block",
        minWidth: 0,
        width: "100%",
        animationName: "mui-auto-fill-cancel",
        animationDuration: "10ms",
        "&::-webkit-input-placeholder": placeholder,
        "&::-moz-placeholder": placeholder,
        "&:-ms-input-placeholder": placeholder,
        "&::-ms-input-placeholder": placeholder,
        "&:focus": {
          outline: 0
        },
        "&:invalid": {
          boxShadow: "none"
        },
        "&::-webkit-search-decoration": {
          WebkitAppearance: "none"
        },
        [`label[data-shrink=false] + .${inputBaseClasses$1.formControl} &`]: {
          "&::-webkit-input-placeholder": placeholderHidden,
          "&::-moz-placeholder": placeholderHidden,
          "&:-ms-input-placeholder": placeholderHidden,
          "&::-ms-input-placeholder": placeholderHidden,
          "&:focus::-webkit-input-placeholder": placeholderVisible,
          "&:focus::-moz-placeholder": placeholderVisible,
          "&:focus:-ms-input-placeholder": placeholderVisible,
          "&:focus::-ms-input-placeholder": placeholderVisible
        },
        [`&.${inputBaseClasses$1.disabled}`]: {
          opacity: 1,
          WebkitTextFillColor: (theme.vars || theme).palette.text.disabled
        },
        "&:-webkit-autofill": {
          animationDuration: "5000s",
          animationName: "mui-auto-fill"
        }
      }, ownerState.size === "small" && {
        paddingTop: 1
      }, ownerState.multiline && {
        height: "auto",
        resize: "none",
        padding: 0,
        paddingTop: 0
      }, ownerState.type === "search" && {
        MozAppearance: "textfield"
      });
    });
    const inputGlobalStyles = /* @__PURE__ */ jsx(GlobalStyles, {
      styles: {
        "@keyframes mui-auto-fill": {
          from: {
            display: "block"
          }
        },
        "@keyframes mui-auto-fill-cancel": {
          from: {
            display: "block"
          }
        }
      }
    });
    const InputBase = /* @__PURE__ */ react.exports.forwardRef(function InputBase2(inProps, ref) {
      var _slotProps$input;
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiInputBase"
      });
      const {
        "aria-describedby": ariaDescribedby,
        autoComplete,
        autoFocus,
        className,
        components = {},
        componentsProps = {},
        defaultValue,
        disabled,
        disableInjectingGlobalStyles,
        endAdornment,
        fullWidth = false,
        id: id2,
        inputComponent = "input",
        inputProps: inputPropsProp = {},
        inputRef: inputRefProp,
        maxRows,
        minRows,
        multiline = false,
        name,
        onBlur,
        onChange,
        onClick,
        onFocus,
        onKeyDown,
        onKeyUp,
        placeholder,
        readOnly,
        renderSuffix,
        rows,
        slotProps = {},
        slots = {},
        startAdornment,
        type: type2 = "text",
        value: valueProp
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$17);
      const value = inputPropsProp.value != null ? inputPropsProp.value : valueProp;
      const {
        current: isControlled
      } = react.exports.useRef(value != null);
      const inputRef = react.exports.useRef();
      const handleInputRefWarning = react.exports.useCallback((instance) => {
      }, []);
      const handleInputRef = useForkRef(inputRef, inputRefProp, inputPropsProp.ref, handleInputRefWarning);
      const [focused, setFocused] = react.exports.useState(false);
      const muiFormControl = useFormControl();
      const fcs = formControlState({
        props: props2,
        muiFormControl,
        states: ["color", "disabled", "error", "hiddenLabel", "size", "required", "filled"]
      });
      fcs.focused = muiFormControl ? muiFormControl.focused : focused;
      react.exports.useEffect(() => {
        if (!muiFormControl && disabled && focused) {
          setFocused(false);
          if (onBlur) {
            onBlur();
          }
        }
      }, [muiFormControl, disabled, focused, onBlur]);
      const onFilled = muiFormControl && muiFormControl.onFilled;
      const onEmpty = muiFormControl && muiFormControl.onEmpty;
      const checkDirty = react.exports.useCallback((obj) => {
        if (isFilled(obj)) {
          if (onFilled) {
            onFilled();
          }
        } else if (onEmpty) {
          onEmpty();
        }
      }, [onFilled, onEmpty]);
      useEnhancedEffect$1(() => {
        if (isControlled) {
          checkDirty({
            value
          });
        }
      }, [value, checkDirty, isControlled]);
      const handleFocus = (event) => {
        if (fcs.disabled) {
          event.stopPropagation();
          return;
        }
        if (onFocus) {
          onFocus(event);
        }
        if (inputPropsProp.onFocus) {
          inputPropsProp.onFocus(event);
        }
        if (muiFormControl && muiFormControl.onFocus) {
          muiFormControl.onFocus(event);
        } else {
          setFocused(true);
        }
      };
      const handleBlur = (event) => {
        if (onBlur) {
          onBlur(event);
        }
        if (inputPropsProp.onBlur) {
          inputPropsProp.onBlur(event);
        }
        if (muiFormControl && muiFormControl.onBlur) {
          muiFormControl.onBlur(event);
        } else {
          setFocused(false);
        }
      };
      const handleChange = (event, ...args) => {
        if (!isControlled) {
          const element = event.target || inputRef.current;
          if (element == null) {
            throw new Error(formatMuiErrorMessage(1));
          }
          checkDirty({
            value: element.value
          });
        }
        if (inputPropsProp.onChange) {
          inputPropsProp.onChange(event, ...args);
        }
        if (onChange) {
          onChange(event, ...args);
        }
      };
      react.exports.useEffect(() => {
        checkDirty(inputRef.current);
      }, []);
      const handleClick = (event) => {
        if (inputRef.current && event.currentTarget === event.target) {
          inputRef.current.focus();
        }
        if (onClick) {
          onClick(event);
        }
      };
      let InputComponent = inputComponent;
      let inputProps = inputPropsProp;
      if (multiline && InputComponent === "input") {
        if (rows) {
          inputProps = _extends({
            type: void 0,
            minRows: rows,
            maxRows: rows
          }, inputProps);
        } else {
          inputProps = _extends({
            type: void 0,
            maxRows,
            minRows
          }, inputProps);
        }
        InputComponent = TextareaAutosize$1;
      }
      const handleAutoFill = (event) => {
        checkDirty(event.animationName === "mui-auto-fill-cancel" ? inputRef.current : {
          value: "x"
        });
      };
      react.exports.useEffect(() => {
        if (muiFormControl) {
          muiFormControl.setAdornedStart(Boolean(startAdornment));
        }
      }, [muiFormControl, startAdornment]);
      const ownerState = _extends({}, props2, {
        color: fcs.color || "primary",
        disabled: fcs.disabled,
        endAdornment,
        error: fcs.error,
        focused: fcs.focused,
        formControl: muiFormControl,
        fullWidth,
        hiddenLabel: fcs.hiddenLabel,
        multiline,
        size: fcs.size,
        startAdornment,
        type: type2
      });
      const classes = useUtilityClasses$10(ownerState);
      const Root = slots.root || components.Root || InputBaseRoot;
      const rootProps = slotProps.root || componentsProps.root || {};
      const Input2 = slots.input || components.Input || InputBaseComponent;
      inputProps = _extends({}, inputProps, (_slotProps$input = slotProps.input) != null ? _slotProps$input : componentsProps.input);
      return /* @__PURE__ */ jsxs(react.exports.Fragment, {
        children: [!disableInjectingGlobalStyles && inputGlobalStyles, /* @__PURE__ */ jsxs(Root, _extends({}, rootProps, !isHostComponent(Root) && {
          ownerState: _extends({}, ownerState, rootProps.ownerState)
        }, {
          ref,
          onClick: handleClick
        }, other, {
          className: clsx(classes.root, rootProps.className, className),
          children: [startAdornment, /* @__PURE__ */ jsx(FormControlContext$1.Provider, {
            value: null,
            children: /* @__PURE__ */ jsx(Input2, _extends({
              ownerState,
              "aria-invalid": fcs.error,
              "aria-describedby": ariaDescribedby,
              autoComplete,
              autoFocus,
              defaultValue,
              disabled: fcs.disabled,
              id: id2,
              onAnimationStart: handleAutoFill,
              name,
              placeholder,
              readOnly,
              required: fcs.required,
              rows,
              value,
              onKeyDown,
              onKeyUp,
              type: type2
            }, inputProps, !isHostComponent(Input2) && {
              as: InputComponent,
              ownerState: _extends({}, ownerState, inputProps.ownerState)
            }, {
              ref: handleInputRef,
              className: clsx(classes.input, inputProps.className),
              onBlur: handleBlur,
              onChange: handleChange,
              onFocus: handleFocus
            }))
          }), endAdornment, renderSuffix ? renderSuffix(_extends({}, fcs, {
            startAdornment
          })) : null]
        }))]
      });
    });
    const InputBase$1 = InputBase;
    function getInputUtilityClass(slot) {
      return generateUtilityClass("MuiInput", slot);
    }
    const inputClasses = _extends({}, inputBaseClasses$1, generateUtilityClasses("MuiInput", ["root", "underline", "input"]));
    const inputClasses$1 = inputClasses;
    function getOutlinedInputUtilityClass(slot) {
      return generateUtilityClass("MuiOutlinedInput", slot);
    }
    const outlinedInputClasses = _extends({}, inputBaseClasses$1, generateUtilityClasses("MuiOutlinedInput", ["root", "notchedOutline", "input"]));
    const outlinedInputClasses$1 = outlinedInputClasses;
    function getFilledInputUtilityClass(slot) {
      return generateUtilityClass("MuiFilledInput", slot);
    }
    const filledInputClasses = _extends({}, inputBaseClasses$1, generateUtilityClasses("MuiFilledInput", ["root", "underline", "input"]));
    const filledInputClasses$1 = filledInputClasses;
    const ArrowDropDownIcon = createSvgIcon$1(/* @__PURE__ */ jsx("path", {
      d: "M7 10l5 5 5-5z"
    }), "ArrowDropDown");
    function getAutocompleteUtilityClass(slot) {
      return generateUtilityClass("MuiAutocomplete", slot);
    }
    const autocompleteClasses = generateUtilityClasses("MuiAutocomplete", ["root", "fullWidth", "focused", "focusVisible", "tag", "tagSizeSmall", "tagSizeMedium", "hasPopupIcon", "hasClearIcon", "inputRoot", "input", "inputFocused", "endAdornment", "clearIndicator", "popupIndicator", "popupIndicatorOpen", "popper", "popperDisablePortal", "paper", "listbox", "loading", "noOptions", "option", "groupLabel", "groupUl"]);
    const autocompleteClasses$1 = autocompleteClasses;
    var _ClearIcon, _ArrowDropDownIcon;
    const _excluded$16 = ["autoComplete", "autoHighlight", "autoSelect", "blurOnSelect", "ChipProps", "className", "clearIcon", "clearOnBlur", "clearOnEscape", "clearText", "closeText", "componentsProps", "defaultValue", "disableClearable", "disableCloseOnSelect", "disabled", "disabledItemsFocusable", "disableListWrap", "disablePortal", "filterOptions", "filterSelectedOptions", "forcePopupIcon", "freeSolo", "fullWidth", "getLimitTagsText", "getOptionDisabled", "getOptionLabel", "isOptionEqualToValue", "groupBy", "handleHomeEndKeys", "id", "includeInputInList", "inputValue", "limitTags", "ListboxComponent", "ListboxProps", "loading", "loadingText", "multiple", "noOptionsText", "onChange", "onClose", "onHighlightChange", "onInputChange", "onOpen", "open", "openOnFocus", "openText", "options", "PaperComponent", "PopperComponent", "popupIcon", "readOnly", "renderGroup", "renderInput", "renderOption", "renderTags", "selectOnFocus", "size", "slotProps", "value"];
    const useUtilityClasses$$ = (ownerState) => {
      const {
        classes,
        disablePortal,
        focused,
        fullWidth,
        hasClearIcon,
        hasPopupIcon,
        inputFocused,
        popupOpen,
        size
      } = ownerState;
      const slots = {
        root: ["root", focused && "focused", fullWidth && "fullWidth", hasClearIcon && "hasClearIcon", hasPopupIcon && "hasPopupIcon"],
        inputRoot: ["inputRoot"],
        input: ["input", inputFocused && "inputFocused"],
        tag: ["tag", `tagSize${capitalize(size)}`],
        endAdornment: ["endAdornment"],
        clearIndicator: ["clearIndicator"],
        popupIndicator: ["popupIndicator", popupOpen && "popupIndicatorOpen"],
        popper: ["popper", disablePortal && "popperDisablePortal"],
        paper: ["paper"],
        listbox: ["listbox"],
        loading: ["loading"],
        noOptions: ["noOptions"],
        option: ["option"],
        groupLabel: ["groupLabel"],
        groupUl: ["groupUl"]
      };
      return composeClasses(slots, getAutocompleteUtilityClass, classes);
    };
    const AutocompleteRoot = styled$1("div", {
      name: "MuiAutocomplete",
      slot: "Root",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        const {
          fullWidth,
          hasClearIcon,
          hasPopupIcon,
          inputFocused,
          size
        } = ownerState;
        return [{
          [`& .${autocompleteClasses$1.tag}`]: styles2.tag
        }, {
          [`& .${autocompleteClasses$1.tag}`]: styles2[`tagSize${capitalize(size)}`]
        }, {
          [`& .${autocompleteClasses$1.inputRoot}`]: styles2.inputRoot
        }, {
          [`& .${autocompleteClasses$1.input}`]: styles2.input
        }, {
          [`& .${autocompleteClasses$1.input}`]: inputFocused && styles2.inputFocused
        }, styles2.root, fullWidth && styles2.fullWidth, hasPopupIcon && styles2.hasPopupIcon, hasClearIcon && styles2.hasClearIcon];
      }
    })(({
      ownerState
    }) => _extends({
      [`&.${autocompleteClasses$1.focused} .${autocompleteClasses$1.clearIndicator}`]: {
        visibility: "visible"
      },
      "@media (pointer: fine)": {
        [`&:hover .${autocompleteClasses$1.clearIndicator}`]: {
          visibility: "visible"
        }
      }
    }, ownerState.fullWidth && {
      width: "100%"
    }, {
      [`& .${autocompleteClasses$1.tag}`]: _extends({
        margin: 3,
        maxWidth: "calc(100% - 6px)"
      }, ownerState.size === "small" && {
        margin: 2,
        maxWidth: "calc(100% - 4px)"
      }),
      [`& .${autocompleteClasses$1.inputRoot}`]: {
        flexWrap: "wrap",
        [`.${autocompleteClasses$1.hasPopupIcon}&, .${autocompleteClasses$1.hasClearIcon}&`]: {
          paddingRight: 26 + 4
        },
        [`.${autocompleteClasses$1.hasPopupIcon}.${autocompleteClasses$1.hasClearIcon}&`]: {
          paddingRight: 52 + 4
        },
        [`& .${autocompleteClasses$1.input}`]: {
          width: 0,
          minWidth: 30
        }
      },
      [`& .${inputClasses$1.root}`]: {
        paddingBottom: 1,
        "& .MuiInput-input": {
          padding: "4px 4px 4px 0px"
        }
      },
      [`& .${inputClasses$1.root}.${inputBaseClasses$1.sizeSmall}`]: {
        [`& .${inputClasses$1.input}`]: {
          padding: "2px 4px 3px 0"
        }
      },
      [`& .${outlinedInputClasses$1.root}`]: {
        padding: 9,
        [`.${autocompleteClasses$1.hasPopupIcon}&, .${autocompleteClasses$1.hasClearIcon}&`]: {
          paddingRight: 26 + 4 + 9
        },
        [`.${autocompleteClasses$1.hasPopupIcon}.${autocompleteClasses$1.hasClearIcon}&`]: {
          paddingRight: 52 + 4 + 9
        },
        [`& .${autocompleteClasses$1.input}`]: {
          padding: "7.5px 4px 7.5px 6px"
        },
        [`& .${autocompleteClasses$1.endAdornment}`]: {
          right: 9
        }
      },
      [`& .${outlinedInputClasses$1.root}.${inputBaseClasses$1.sizeSmall}`]: {
        paddingTop: 6,
        paddingBottom: 6,
        paddingLeft: 6,
        [`& .${autocompleteClasses$1.input}`]: {
          padding: "2.5px 4px 2.5px 6px"
        }
      },
      [`& .${filledInputClasses$1.root}`]: {
        paddingTop: 19,
        paddingLeft: 8,
        [`.${autocompleteClasses$1.hasPopupIcon}&, .${autocompleteClasses$1.hasClearIcon}&`]: {
          paddingRight: 26 + 4 + 9
        },
        [`.${autocompleteClasses$1.hasPopupIcon}.${autocompleteClasses$1.hasClearIcon}&`]: {
          paddingRight: 52 + 4 + 9
        },
        [`& .${filledInputClasses$1.input}`]: {
          padding: "7px 4px"
        },
        [`& .${autocompleteClasses$1.endAdornment}`]: {
          right: 9
        }
      },
      [`& .${filledInputClasses$1.root}.${inputBaseClasses$1.sizeSmall}`]: {
        paddingBottom: 1,
        [`& .${filledInputClasses$1.input}`]: {
          padding: "2.5px 4px"
        }
      },
      [`& .${inputBaseClasses$1.hiddenLabel}`]: {
        paddingTop: 8
      },
      [`& .${autocompleteClasses$1.input}`]: _extends({
        flexGrow: 1,
        textOverflow: "ellipsis",
        opacity: 0
      }, ownerState.inputFocused && {
        opacity: 1
      })
    }));
    const AutocompleteEndAdornment = styled$1("div", {
      name: "MuiAutocomplete",
      slot: "EndAdornment",
      overridesResolver: (props2, styles2) => styles2.endAdornment
    })({
      position: "absolute",
      right: 0,
      top: "calc(50% - 14px)"
    });
    const AutocompleteClearIndicator = styled$1(IconButton$1, {
      name: "MuiAutocomplete",
      slot: "ClearIndicator",
      overridesResolver: (props2, styles2) => styles2.clearIndicator
    })({
      marginRight: -2,
      padding: 4,
      visibility: "hidden"
    });
    const AutocompletePopupIndicator = styled$1(IconButton$1, {
      name: "MuiAutocomplete",
      slot: "PopupIndicator",
      overridesResolver: ({
        ownerState
      }, styles2) => _extends({}, styles2.popupIndicator, ownerState.popupOpen && styles2.popupIndicatorOpen)
    })(({
      ownerState
    }) => _extends({
      padding: 2,
      marginRight: -2
    }, ownerState.popupOpen && {
      transform: "rotate(180deg)"
    }));
    const AutocompletePopper = styled$1(Popper$1, {
      name: "MuiAutocomplete",
      slot: "Popper",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [{
          [`& .${autocompleteClasses$1.option}`]: styles2.option
        }, styles2.popper, ownerState.disablePortal && styles2.popperDisablePortal];
      }
    })(({
      theme,
      ownerState
    }) => _extends({
      zIndex: (theme.vars || theme).zIndex.modal
    }, ownerState.disablePortal && {
      position: "absolute"
    }));
    const AutocompletePaper = styled$1(Paper$1, {
      name: "MuiAutocomplete",
      slot: "Paper",
      overridesResolver: (props2, styles2) => styles2.paper
    })(({
      theme
    }) => _extends({}, theme.typography.body1, {
      overflow: "auto"
    }));
    const AutocompleteLoading = styled$1("div", {
      name: "MuiAutocomplete",
      slot: "Loading",
      overridesResolver: (props2, styles2) => styles2.loading
    })(({
      theme
    }) => ({
      color: (theme.vars || theme).palette.text.secondary,
      padding: "14px 16px"
    }));
    const AutocompleteNoOptions = styled$1("div", {
      name: "MuiAutocomplete",
      slot: "NoOptions",
      overridesResolver: (props2, styles2) => styles2.noOptions
    })(({
      theme
    }) => ({
      color: (theme.vars || theme).palette.text.secondary,
      padding: "14px 16px"
    }));
    const AutocompleteListbox = styled$1("div", {
      name: "MuiAutocomplete",
      slot: "Listbox",
      overridesResolver: (props2, styles2) => styles2.listbox
    })(({
      theme
    }) => ({
      listStyle: "none",
      margin: 0,
      padding: "8px 0",
      maxHeight: "40vh",
      overflow: "auto",
      position: "relative",
      [`& .${autocompleteClasses$1.option}`]: {
        minHeight: 48,
        display: "flex",
        overflow: "hidden",
        justifyContent: "flex-start",
        alignItems: "center",
        cursor: "pointer",
        paddingTop: 6,
        boxSizing: "border-box",
        outline: "0",
        WebkitTapHighlightColor: "transparent",
        paddingBottom: 6,
        paddingLeft: 16,
        paddingRight: 16,
        [theme.breakpoints.up("sm")]: {
          minHeight: "auto"
        },
        [`&.${autocompleteClasses$1.focused}`]: {
          backgroundColor: (theme.vars || theme).palette.action.hover,
          "@media (hover: none)": {
            backgroundColor: "transparent"
          }
        },
        '&[aria-disabled="true"]': {
          opacity: (theme.vars || theme).palette.action.disabledOpacity,
          pointerEvents: "none"
        },
        [`&.${autocompleteClasses$1.focusVisible}`]: {
          backgroundColor: (theme.vars || theme).palette.action.focus
        },
        '&[aria-selected="true"]': {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity),
          [`&.${autocompleteClasses$1.focused}`]: {
            backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
            "@media (hover: none)": {
              backgroundColor: (theme.vars || theme).palette.action.selected
            }
          },
          [`&.${autocompleteClasses$1.focusVisible}`]: {
            backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
          }
        }
      }
    }));
    const AutocompleteGroupLabel = styled$1(ListSubheader$1, {
      name: "MuiAutocomplete",
      slot: "GroupLabel",
      overridesResolver: (props2, styles2) => styles2.groupLabel
    })(({
      theme
    }) => ({
      backgroundColor: (theme.vars || theme).palette.background.paper,
      top: -8
    }));
    const AutocompleteGroupUl = styled$1("ul", {
      name: "MuiAutocomplete",
      slot: "GroupUl",
      overridesResolver: (props2, styles2) => styles2.groupUl
    })({
      padding: 0,
      [`& .${autocompleteClasses$1.option}`]: {
        paddingLeft: 24
      }
    });
    const Autocomplete = /* @__PURE__ */ react.exports.forwardRef(function Autocomplete2(inProps, ref) {
      var _slotProps$clearIndic, _slotProps$paper, _slotProps$popper, _slotProps$popupIndic;
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiAutocomplete"
      });
      const {
        autoComplete = false,
        autoHighlight = false,
        autoSelect = false,
        blurOnSelect = false,
        ChipProps,
        className,
        clearIcon = _ClearIcon || (_ClearIcon = /* @__PURE__ */ jsx(ClearIcon, {
          fontSize: "small"
        })),
        clearOnBlur = !props2.freeSolo,
        clearOnEscape = false,
        clearText = "Clear",
        closeText = "Close",
        componentsProps = {},
        defaultValue = props2.multiple ? [] : null,
        disableClearable = false,
        disableCloseOnSelect = false,
        disabled = false,
        disabledItemsFocusable = false,
        disableListWrap = false,
        disablePortal = false,
        filterSelectedOptions = false,
        forcePopupIcon = "auto",
        freeSolo = false,
        fullWidth = false,
        getLimitTagsText = (more) => `+${more}`,
        getOptionLabel = (option) => {
          var _option$label;
          return (_option$label = option.label) != null ? _option$label : option;
        },
        groupBy,
        handleHomeEndKeys = !props2.freeSolo,
        includeInputInList = false,
        limitTags = -1,
        ListboxComponent = "ul",
        ListboxProps,
        loading = false,
        loadingText = "Loading\u2026",
        multiple = false,
        noOptionsText = "No options",
        openOnFocus = false,
        openText = "Open",
        PaperComponent = Paper$1,
        PopperComponent = Popper$1,
        popupIcon = _ArrowDropDownIcon || (_ArrowDropDownIcon = /* @__PURE__ */ jsx(ArrowDropDownIcon, {})),
        readOnly = false,
        renderGroup: renderGroupProp,
        renderInput,
        renderOption: renderOptionProp,
        renderTags,
        selectOnFocus = !props2.freeSolo,
        size = "medium",
        slotProps = {}
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$16);
      const {
        getRootProps,
        getInputProps,
        getInputLabelProps,
        getPopupIndicatorProps,
        getClearProps,
        getTagProps,
        getListboxProps,
        getOptionProps,
        value,
        dirty,
        id: id2,
        popupOpen,
        focused,
        focusedTag,
        anchorEl,
        setAnchorEl,
        inputValue,
        groupedOptions
      } = useAutocomplete(_extends({}, props2, {
        componentName: "Autocomplete"
      }));
      const hasClearIcon = !disableClearable && !disabled && dirty && !readOnly;
      const hasPopupIcon = (!freeSolo || forcePopupIcon === true) && forcePopupIcon !== false;
      const ownerState = _extends({}, props2, {
        disablePortal,
        focused,
        fullWidth,
        hasClearIcon,
        hasPopupIcon,
        inputFocused: focusedTag === -1,
        popupOpen,
        size
      });
      const classes = useUtilityClasses$$(ownerState);
      let startAdornment;
      if (multiple && value.length > 0) {
        const getCustomizedTagProps = (params) => _extends({
          className: classes.tag,
          disabled
        }, getTagProps(params));
        if (renderTags) {
          startAdornment = renderTags(value, getCustomizedTagProps, ownerState);
        } else {
          startAdornment = value.map((option, index2) => /* @__PURE__ */ jsx(Chip$1, _extends({
            label: getOptionLabel(option),
            size
          }, getCustomizedTagProps({
            index: index2
          }), ChipProps)));
        }
      }
      if (limitTags > -1 && Array.isArray(startAdornment)) {
        const more = startAdornment.length - limitTags;
        if (!focused && more > 0) {
          startAdornment = startAdornment.splice(0, limitTags);
          startAdornment.push(/* @__PURE__ */ jsx("span", {
            className: classes.tag,
            children: getLimitTagsText(more)
          }, startAdornment.length));
        }
      }
      const defaultRenderGroup = (params) => /* @__PURE__ */ jsxs("li", {
        children: [/* @__PURE__ */ jsx(AutocompleteGroupLabel, {
          className: classes.groupLabel,
          ownerState,
          component: "div",
          children: params.group
        }), /* @__PURE__ */ jsx(AutocompleteGroupUl, {
          className: classes.groupUl,
          ownerState,
          children: params.children
        })]
      }, params.key);
      const renderGroup = renderGroupProp || defaultRenderGroup;
      const defaultRenderOption = (props22, option) => /* @__PURE__ */ jsx("li", _extends({}, props22, {
        children: getOptionLabel(option)
      }));
      const renderOption = renderOptionProp || defaultRenderOption;
      const renderListOption = (option, index2) => {
        const optionProps = getOptionProps({
          option,
          index: index2
        });
        return renderOption(_extends({}, optionProps, {
          className: classes.option
        }), option, {
          selected: optionProps["aria-selected"],
          inputValue
        });
      };
      const clearIndicatorSlotProps = (_slotProps$clearIndic = slotProps.clearIndicator) != null ? _slotProps$clearIndic : componentsProps.clearIndicator;
      const paperSlotProps = (_slotProps$paper = slotProps.paper) != null ? _slotProps$paper : componentsProps.paper;
      const popperSlotProps = (_slotProps$popper = slotProps.popper) != null ? _slotProps$popper : componentsProps.popper;
      const popupIndicatorSlotProps = (_slotProps$popupIndic = slotProps.popupIndicator) != null ? _slotProps$popupIndic : componentsProps.popupIndicator;
      return /* @__PURE__ */ jsxs(react.exports.Fragment, {
        children: [/* @__PURE__ */ jsx(AutocompleteRoot, _extends({
          ref,
          className: clsx(classes.root, className),
          ownerState
        }, getRootProps(other), {
          children: renderInput({
            id: id2,
            disabled,
            fullWidth: true,
            size: size === "small" ? "small" : void 0,
            InputLabelProps: getInputLabelProps(),
            InputProps: _extends({
              ref: setAnchorEl,
              className: classes.inputRoot,
              startAdornment
            }, (hasClearIcon || hasPopupIcon) && {
              endAdornment: /* @__PURE__ */ jsxs(AutocompleteEndAdornment, {
                className: classes.endAdornment,
                ownerState,
                children: [hasClearIcon ? /* @__PURE__ */ jsx(AutocompleteClearIndicator, _extends({}, getClearProps(), {
                  "aria-label": clearText,
                  title: clearText,
                  ownerState
                }, clearIndicatorSlotProps, {
                  className: clsx(classes.clearIndicator, clearIndicatorSlotProps == null ? void 0 : clearIndicatorSlotProps.className),
                  children: clearIcon
                })) : null, hasPopupIcon ? /* @__PURE__ */ jsx(AutocompletePopupIndicator, _extends({}, getPopupIndicatorProps(), {
                  disabled,
                  "aria-label": popupOpen ? closeText : openText,
                  title: popupOpen ? closeText : openText,
                  ownerState
                }, popupIndicatorSlotProps, {
                  className: clsx(classes.popupIndicator, popupIndicatorSlotProps == null ? void 0 : popupIndicatorSlotProps.className),
                  children: popupIcon
                })) : null]
              })
            }),
            inputProps: _extends({
              className: classes.input,
              disabled,
              readOnly
            }, getInputProps())
          })
        })), anchorEl ? /* @__PURE__ */ jsx(AutocompletePopper, _extends({
          as: PopperComponent,
          disablePortal,
          style: {
            width: anchorEl ? anchorEl.clientWidth : null
          },
          ownerState,
          role: "presentation",
          anchorEl,
          open: popupOpen
        }, popperSlotProps, {
          className: clsx(classes.popper, popperSlotProps == null ? void 0 : popperSlotProps.className),
          children: /* @__PURE__ */ jsxs(AutocompletePaper, _extends({
            ownerState,
            as: PaperComponent
          }, paperSlotProps, {
            className: clsx(classes.paper, paperSlotProps == null ? void 0 : paperSlotProps.className),
            children: [loading && groupedOptions.length === 0 ? /* @__PURE__ */ jsx(AutocompleteLoading, {
              className: classes.loading,
              ownerState,
              children: loadingText
            }) : null, groupedOptions.length === 0 && !freeSolo && !loading ? /* @__PURE__ */ jsx(AutocompleteNoOptions, {
              className: classes.noOptions,
              ownerState,
              role: "presentation",
              onMouseDown: (event) => {
                event.preventDefault();
              },
              children: noOptionsText
            }) : null, groupedOptions.length > 0 ? /* @__PURE__ */ jsx(AutocompleteListbox, _extends({
              as: ListboxComponent,
              className: classes.listbox,
              ownerState
            }, getListboxProps(), ListboxProps, {
              children: groupedOptions.map((option, index2) => {
                if (groupBy) {
                  return renderGroup({
                    key: option.key,
                    group: option.group,
                    children: option.options.map((option2, index22) => renderListOption(option2, option.index + index22))
                  });
                }
                return renderListOption(option, index2);
              })
            })) : null]
          }))
        })) : null]
      });
    });
    const Autocomplete$1 = Autocomplete;
    const Person = createSvgIcon$1(/* @__PURE__ */ jsx("path", {
      d: "M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"
    }), "Person");
    function getAvatarUtilityClass(slot) {
      return generateUtilityClass("MuiAvatar", slot);
    }
    generateUtilityClasses("MuiAvatar", ["root", "colorDefault", "circular", "rounded", "square", "img", "fallback"]);
    const _excluded$15 = ["alt", "children", "className", "component", "imgProps", "sizes", "src", "srcSet", "variant"];
    const useUtilityClasses$_ = (ownerState) => {
      const {
        classes,
        variant,
        colorDefault
      } = ownerState;
      const slots = {
        root: ["root", variant, colorDefault && "colorDefault"],
        img: ["img"],
        fallback: ["fallback"]
      };
      return composeClasses(slots, getAvatarUtilityClass, classes);
    };
    const AvatarRoot = styled$1("div", {
      name: "MuiAvatar",
      slot: "Root",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.root, styles2[ownerState.variant], ownerState.colorDefault && styles2.colorDefault];
      }
    })(({
      theme,
      ownerState
    }) => _extends({
      position: "relative",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: 0,
      width: 40,
      height: 40,
      fontFamily: theme.typography.fontFamily,
      fontSize: theme.typography.pxToRem(20),
      lineHeight: 1,
      borderRadius: "50%",
      overflow: "hidden",
      userSelect: "none"
    }, ownerState.variant === "rounded" && {
      borderRadius: (theme.vars || theme).shape.borderRadius
    }, ownerState.variant === "square" && {
      borderRadius: 0
    }, ownerState.colorDefault && _extends({
      color: (theme.vars || theme).palette.background.default
    }, theme.vars ? {
      backgroundColor: theme.vars.palette.Avatar.defaultBg
    } : {
      backgroundColor: theme.palette.mode === "light" ? theme.palette.grey[400] : theme.palette.grey[600]
    })));
    const AvatarImg = styled$1("img", {
      name: "MuiAvatar",
      slot: "Img",
      overridesResolver: (props2, styles2) => styles2.img
    })({
      width: "100%",
      height: "100%",
      textAlign: "center",
      objectFit: "cover",
      color: "transparent",
      textIndent: 1e4
    });
    const AvatarFallback = styled$1(Person, {
      name: "MuiAvatar",
      slot: "Fallback",
      overridesResolver: (props2, styles2) => styles2.fallback
    })({
      width: "75%",
      height: "75%"
    });
    function useLoaded({
      crossOrigin,
      referrerPolicy,
      src,
      srcSet
    }) {
      const [loaded, setLoaded] = react.exports.useState(false);
      react.exports.useEffect(() => {
        if (!src && !srcSet) {
          return void 0;
        }
        setLoaded(false);
        let active = true;
        const image = new Image();
        image.onload = () => {
          if (!active) {
            return;
          }
          setLoaded("loaded");
        };
        image.onerror = () => {
          if (!active) {
            return;
          }
          setLoaded("error");
        };
        image.crossOrigin = crossOrigin;
        image.referrerPolicy = referrerPolicy;
        image.src = src;
        if (srcSet) {
          image.srcset = srcSet;
        }
        return () => {
          active = false;
        };
      }, [crossOrigin, referrerPolicy, src, srcSet]);
      return loaded;
    }
    const Avatar = /* @__PURE__ */ react.exports.forwardRef(function Avatar2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiAvatar"
      });
      const {
        alt,
        children: childrenProp,
        className,
        component = "div",
        imgProps,
        sizes,
        src,
        srcSet,
        variant = "circular"
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$15);
      let children = null;
      const loaded = useLoaded(_extends({}, imgProps, {
        src,
        srcSet
      }));
      const hasImg = src || srcSet;
      const hasImgNotFailing = hasImg && loaded !== "error";
      const ownerState = _extends({}, props2, {
        colorDefault: !hasImgNotFailing,
        component,
        variant
      });
      const classes = useUtilityClasses$_(ownerState);
      if (hasImgNotFailing) {
        children = /* @__PURE__ */ jsx(AvatarImg, _extends({
          alt,
          src,
          srcSet,
          sizes,
          ownerState,
          className: classes.img
        }, imgProps));
      } else if (childrenProp != null) {
        children = childrenProp;
      } else if (hasImg && alt) {
        children = alt[0];
      } else {
        children = /* @__PURE__ */ jsx(AvatarFallback, {
          className: classes.fallback
        });
      }
      return /* @__PURE__ */ jsx(AvatarRoot, _extends({
        as: component,
        ownerState,
        className: clsx(classes.root, className),
        ref
      }, other, {
        children
      }));
    });
    const Avatar$1 = Avatar;
    const _excluded$14 = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
    const styles$3 = {
      entering: {
        opacity: 1
      },
      entered: {
        opacity: 1
      }
    };
    const Fade = /* @__PURE__ */ react.exports.forwardRef(function Fade2(props2, ref) {
      const theme = useTheme();
      const defaultTimeout = {
        enter: theme.transitions.duration.enteringScreen,
        exit: theme.transitions.duration.leavingScreen
      };
      const {
        addEndListener,
        appear = true,
        children,
        easing: easing2,
        in: inProp,
        onEnter,
        onEntered,
        onEntering,
        onExit,
        onExited,
        onExiting,
        style: style2,
        timeout = defaultTimeout,
        TransitionComponent = Transition$1
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$14);
      const nodeRef = react.exports.useRef(null);
      const handleRef = useForkRef(nodeRef, children.ref, ref);
      const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
        if (callback) {
          const node2 = nodeRef.current;
          if (maybeIsAppearing === void 0) {
            callback(node2);
          } else {
            callback(node2, maybeIsAppearing);
          }
        }
      };
      const handleEntering = normalizedTransitionCallback(onEntering);
      const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
        reflow(node2);
        const transitionProps = getTransitionProps({
          style: style2,
          timeout,
          easing: easing2
        }, {
          mode: "enter"
        });
        node2.style.webkitTransition = theme.transitions.create("opacity", transitionProps);
        node2.style.transition = theme.transitions.create("opacity", transitionProps);
        if (onEnter) {
          onEnter(node2, isAppearing);
        }
      });
      const handleEntered = normalizedTransitionCallback(onEntered);
      const handleExiting = normalizedTransitionCallback(onExiting);
      const handleExit = normalizedTransitionCallback((node2) => {
        const transitionProps = getTransitionProps({
          style: style2,
          timeout,
          easing: easing2
        }, {
          mode: "exit"
        });
        node2.style.webkitTransition = theme.transitions.create("opacity", transitionProps);
        node2.style.transition = theme.transitions.create("opacity", transitionProps);
        if (onExit) {
          onExit(node2);
        }
      });
      const handleExited = normalizedTransitionCallback(onExited);
      const handleAddEndListener = (next2) => {
        if (addEndListener) {
          addEndListener(nodeRef.current, next2);
        }
      };
      return /* @__PURE__ */ jsx(TransitionComponent, _extends({
        appear,
        in: inProp,
        nodeRef,
        onEnter: handleEnter,
        onEntered: handleEntered,
        onEntering: handleEntering,
        onExit: handleExit,
        onExited: handleExited,
        onExiting: handleExiting,
        addEndListener: handleAddEndListener,
        timeout
      }, other, {
        children: (state, childProps) => {
          return /* @__PURE__ */ react.exports.cloneElement(children, _extends({
            style: _extends({
              opacity: 0,
              visibility: state === "exited" && !inProp ? "hidden" : void 0
            }, styles$3[state], style2, children.props.style),
            ref: handleRef
          }, childProps));
        }
      }));
    });
    const Fade$1 = Fade;
    function getBackdropUtilityClass(slot) {
      return generateUtilityClass("MuiBackdrop", slot);
    }
    generateUtilityClasses("MuiBackdrop", ["root", "invisible"]);
    const _excluded$13 = ["children", "component", "components", "componentsProps", "className", "invisible", "open", "slotProps", "slots", "transitionDuration", "TransitionComponent"];
    const useUtilityClasses$Z = (ownerState) => {
      const {
        classes,
        invisible
      } = ownerState;
      const slots = {
        root: ["root", invisible && "invisible"]
      };
      return composeClasses(slots, getBackdropUtilityClass, classes);
    };
    const BackdropRoot = styled$1("div", {
      name: "MuiBackdrop",
      slot: "Root",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.root, ownerState.invisible && styles2.invisible];
      }
    })(({
      ownerState
    }) => _extends({
      position: "fixed",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      right: 0,
      bottom: 0,
      top: 0,
      left: 0,
      backgroundColor: "rgba(0, 0, 0, 0.5)",
      WebkitTapHighlightColor: "transparent"
    }, ownerState.invisible && {
      backgroundColor: "transparent"
    }));
    const Backdrop = /* @__PURE__ */ react.exports.forwardRef(function Backdrop2(inProps, ref) {
      var _slotProps$root, _ref, _slots$root;
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiBackdrop"
      });
      const {
        children,
        component = "div",
        components = {},
        componentsProps = {},
        className,
        invisible = false,
        open,
        slotProps = {},
        slots = {},
        transitionDuration,
        TransitionComponent = Fade$1
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$13);
      const ownerState = _extends({}, props2, {
        component,
        invisible
      });
      const classes = useUtilityClasses$Z(ownerState);
      const rootSlotProps = (_slotProps$root = slotProps.root) != null ? _slotProps$root : componentsProps.root;
      return /* @__PURE__ */ jsx(TransitionComponent, _extends({
        in: open,
        timeout: transitionDuration
      }, other, {
        children: /* @__PURE__ */ jsx(BackdropRoot, _extends({
          "aria-hidden": true
        }, rootSlotProps, {
          as: (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : component,
          className: clsx(classes.root, className, rootSlotProps == null ? void 0 : rootSlotProps.className),
          ownerState: _extends({}, ownerState, rootSlotProps == null ? void 0 : rootSlotProps.ownerState),
          classes,
          ref,
          children
        }))
      }));
    });
    const Backdrop$1 = Backdrop;
    const defaultTheme = createTheme();
    const Box = createBox({
      defaultTheme,
      defaultClassName: "MuiBox-root",
      generateClassName: ClassNameGenerator$1.generate
    });
    const Box$1 = Box;
    function getButtonUtilityClass(slot) {
      return generateUtilityClass("MuiButton", slot);
    }
    const buttonClasses = generateUtilityClasses("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge"]);
    const buttonClasses$1 = buttonClasses;
    const ButtonGroupContext = /* @__PURE__ */ react.exports.createContext({});
    const ButtonGroupContext$1 = ButtonGroupContext;
    const _excluded$12 = ["children", "color", "component", "className", "disabled", "disableElevation", "disableFocusRipple", "endIcon", "focusVisibleClassName", "fullWidth", "size", "startIcon", "type", "variant"];
    const useUtilityClasses$Y = (ownerState) => {
      const {
        color: color2,
        disableElevation,
        fullWidth,
        size,
        variant,
        classes
      } = ownerState;
      const slots = {
        root: ["root", variant, `${variant}${capitalize(color2)}`, `size${capitalize(size)}`, `${variant}Size${capitalize(size)}`, color2 === "inherit" && "colorInherit", disableElevation && "disableElevation", fullWidth && "fullWidth"],
        label: ["label"],
        startIcon: ["startIcon", `iconSize${capitalize(size)}`],
        endIcon: ["endIcon", `iconSize${capitalize(size)}`]
      };
      const composedClasses = composeClasses(slots, getButtonUtilityClass, classes);
      return _extends({}, classes, composedClasses);
    };
    const commonIconStyles = (ownerState) => _extends({}, ownerState.size === "small" && {
      "& > *:nth-of-type(1)": {
        fontSize: 18
      }
    }, ownerState.size === "medium" && {
      "& > *:nth-of-type(1)": {
        fontSize: 20
      }
    }, ownerState.size === "large" && {
      "& > *:nth-of-type(1)": {
        fontSize: 22
      }
    });
    const ButtonRoot = styled$1(ButtonBase$1, {
      shouldForwardProp: (prop) => rootShouldForwardProp$1(prop) || prop === "classes",
      name: "MuiButton",
      slot: "Root",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.root, styles2[ownerState.variant], styles2[`${ownerState.variant}${capitalize(ownerState.color)}`], styles2[`size${capitalize(ownerState.size)}`], styles2[`${ownerState.variant}Size${capitalize(ownerState.size)}`], ownerState.color === "inherit" && styles2.colorInherit, ownerState.disableElevation && styles2.disableElevation, ownerState.fullWidth && styles2.fullWidth];
      }
    })(({
      theme,
      ownerState
    }) => {
      var _theme$palette$getCon, _theme$palette;
      return _extends({}, theme.typography.button, {
        minWidth: 64,
        padding: "6px 16px",
        borderRadius: (theme.vars || theme).shape.borderRadius,
        transition: theme.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
          duration: theme.transitions.duration.short
        }),
        "&:hover": _extends({
          textDecoration: "none",
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.text.primary, theme.palette.action.hoverOpacity),
          "@media (hover: none)": {
            backgroundColor: "transparent"
          }
        }, ownerState.variant === "text" && ownerState.color !== "inherit" && {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity),
          "@media (hover: none)": {
            backgroundColor: "transparent"
          }
        }, ownerState.variant === "outlined" && ownerState.color !== "inherit" && {
          border: `1px solid ${(theme.vars || theme).palette[ownerState.color].main}`,
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity),
          "@media (hover: none)": {
            backgroundColor: "transparent"
          }
        }, ownerState.variant === "contained" && {
          backgroundColor: (theme.vars || theme).palette.grey.A100,
          boxShadow: (theme.vars || theme).shadows[4],
          "@media (hover: none)": {
            boxShadow: (theme.vars || theme).shadows[2],
            backgroundColor: (theme.vars || theme).palette.grey[300]
          }
        }, ownerState.variant === "contained" && ownerState.color !== "inherit" && {
          backgroundColor: (theme.vars || theme).palette[ownerState.color].dark,
          "@media (hover: none)": {
            backgroundColor: (theme.vars || theme).palette[ownerState.color].main
          }
        }),
        "&:active": _extends({}, ownerState.variant === "contained" && {
          boxShadow: (theme.vars || theme).shadows[8]
        }),
        [`&.${buttonClasses$1.focusVisible}`]: _extends({}, ownerState.variant === "contained" && {
          boxShadow: (theme.vars || theme).shadows[6]
        }),
        [`&.${buttonClasses$1.disabled}`]: _extends({
          color: (theme.vars || theme).palette.action.disabled
        }, ownerState.variant === "outlined" && {
          border: `1px solid ${(theme.vars || theme).palette.action.disabledBackground}`
        }, ownerState.variant === "outlined" && ownerState.color === "secondary" && {
          border: `1px solid ${(theme.vars || theme).palette.action.disabled}`
        }, ownerState.variant === "contained" && {
          color: (theme.vars || theme).palette.action.disabled,
          boxShadow: (theme.vars || theme).shadows[0],
          backgroundColor: (theme.vars || theme).palette.action.disabledBackground
        })
      }, ownerState.variant === "text" && {
        padding: "6px 8px"
      }, ownerState.variant === "text" && ownerState.color !== "inherit" && {
        color: (theme.vars || theme).palette[ownerState.color].main
      }, ownerState.variant === "outlined" && {
        padding: "5px 15px",
        border: "1px solid currentColor"
      }, ownerState.variant === "outlined" && ownerState.color !== "inherit" && {
        color: (theme.vars || theme).palette[ownerState.color].main,
        border: theme.vars ? `1px solid rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.5)` : `1px solid ${alpha(theme.palette[ownerState.color].main, 0.5)}`
      }, ownerState.variant === "contained" && {
        color: theme.vars ? theme.vars.palette.text.primary : (_theme$palette$getCon = (_theme$palette = theme.palette).getContrastText) == null ? void 0 : _theme$palette$getCon.call(_theme$palette, theme.palette.grey[300]),
        backgroundColor: (theme.vars || theme).palette.grey[300],
        boxShadow: (theme.vars || theme).shadows[2]
      }, ownerState.variant === "contained" && ownerState.color !== "inherit" && {
        color: (theme.vars || theme).palette[ownerState.color].contrastText,
        backgroundColor: (theme.vars || theme).palette[ownerState.color].main
      }, ownerState.color === "inherit" && {
        color: "inherit",
        borderColor: "currentColor"
      }, ownerState.size === "small" && ownerState.variant === "text" && {
        padding: "4px 5px",
        fontSize: theme.typography.pxToRem(13)
      }, ownerState.size === "large" && ownerState.variant === "text" && {
        padding: "8px 11px",
        fontSize: theme.typography.pxToRem(15)
      }, ownerState.size === "small" && ownerState.variant === "outlined" && {
        padding: "3px 9px",
        fontSize: theme.typography.pxToRem(13)
      }, ownerState.size === "large" && ownerState.variant === "outlined" && {
        padding: "7px 21px",
        fontSize: theme.typography.pxToRem(15)
      }, ownerState.size === "small" && ownerState.variant === "contained" && {
        padding: "4px 10px",
        fontSize: theme.typography.pxToRem(13)
      }, ownerState.size === "large" && ownerState.variant === "contained" && {
        padding: "8px 22px",
        fontSize: theme.typography.pxToRem(15)
      }, ownerState.fullWidth && {
        width: "100%"
      });
    }, ({
      ownerState
    }) => ownerState.disableElevation && {
      boxShadow: "none",
      "&:hover": {
        boxShadow: "none"
      },
      [`&.${buttonClasses$1.focusVisible}`]: {
        boxShadow: "none"
      },
      "&:active": {
        boxShadow: "none"
      },
      [`&.${buttonClasses$1.disabled}`]: {
        boxShadow: "none"
      }
    });
    const ButtonStartIcon = styled$1("span", {
      name: "MuiButton",
      slot: "StartIcon",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.startIcon, styles2[`iconSize${capitalize(ownerState.size)}`]];
      }
    })(({
      ownerState
    }) => _extends({
      display: "inherit",
      marginRight: 8,
      marginLeft: -4
    }, ownerState.size === "small" && {
      marginLeft: -2
    }, commonIconStyles(ownerState)));
    const ButtonEndIcon = styled$1("span", {
      name: "MuiButton",
      slot: "EndIcon",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.endIcon, styles2[`iconSize${capitalize(ownerState.size)}`]];
      }
    })(({
      ownerState
    }) => _extends({
      display: "inherit",
      marginRight: -4,
      marginLeft: 8
    }, ownerState.size === "small" && {
      marginRight: -2
    }, commonIconStyles(ownerState)));
    const Button = /* @__PURE__ */ react.exports.forwardRef(function Button2(inProps, ref) {
      const contextProps = react.exports.useContext(ButtonGroupContext$1);
      const resolvedProps = resolveProps(contextProps, inProps);
      const props2 = useThemeProps({
        props: resolvedProps,
        name: "MuiButton"
      });
      const {
        children,
        color: color2 = "primary",
        component = "button",
        className,
        disabled = false,
        disableElevation = false,
        disableFocusRipple = false,
        endIcon: endIconProp,
        focusVisibleClassName,
        fullWidth = false,
        size = "medium",
        startIcon: startIconProp,
        type: type2,
        variant = "text"
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$12);
      const ownerState = _extends({}, props2, {
        color: color2,
        component,
        disabled,
        disableElevation,
        disableFocusRipple,
        fullWidth,
        size,
        type: type2,
        variant
      });
      const classes = useUtilityClasses$Y(ownerState);
      const startIcon = startIconProp && /* @__PURE__ */ jsx(ButtonStartIcon, {
        className: classes.startIcon,
        ownerState,
        children: startIconProp
      });
      const endIcon = endIconProp && /* @__PURE__ */ jsx(ButtonEndIcon, {
        className: classes.endIcon,
        ownerState,
        children: endIconProp
      });
      return /* @__PURE__ */ jsxs(ButtonRoot, _extends({
        ownerState,
        className: clsx(contextProps.className, classes.root, className),
        component,
        disabled,
        focusRipple: !disableFocusRipple,
        focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
        ref,
        type: type2
      }, other, {
        classes,
        children: [startIcon, children, endIcon]
      }));
    });
    const Button$1 = Button;
    function getCardUtilityClass(slot) {
      return generateUtilityClass("MuiCard", slot);
    }
    generateUtilityClasses("MuiCard", ["root"]);
    const _excluded$11 = ["className", "raised"];
    const useUtilityClasses$X = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"]
      };
      return composeClasses(slots, getCardUtilityClass, classes);
    };
    const CardRoot = styled$1(Paper$1, {
      name: "MuiCard",
      slot: "Root",
      overridesResolver: (props2, styles2) => styles2.root
    })(() => {
      return {
        overflow: "hidden"
      };
    });
    const Card = /* @__PURE__ */ react.exports.forwardRef(function Card2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiCard"
      });
      const {
        className,
        raised = false
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$11);
      const ownerState = _extends({}, props2, {
        raised
      });
      const classes = useUtilityClasses$X(ownerState);
      return /* @__PURE__ */ jsx(CardRoot, _extends({
        className: clsx(classes.root, className),
        elevation: raised ? 8 : void 0,
        ref,
        ownerState
      }, other));
    });
    const Card$1 = Card;
    function getCardContentUtilityClass(slot) {
      return generateUtilityClass("MuiCardContent", slot);
    }
    generateUtilityClasses("MuiCardContent", ["root"]);
    const _excluded$10 = ["className", "component"];
    const useUtilityClasses$W = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"]
      };
      return composeClasses(slots, getCardContentUtilityClass, classes);
    };
    const CardContentRoot = styled$1("div", {
      name: "MuiCardContent",
      slot: "Root",
      overridesResolver: (props2, styles2) => styles2.root
    })(() => {
      return {
        padding: 16,
        "&:last-child": {
          paddingBottom: 24
        }
      };
    });
    const CardContent = /* @__PURE__ */ react.exports.forwardRef(function CardContent2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiCardContent"
      });
      const {
        className,
        component = "div"
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$10);
      const ownerState = _extends({}, props2, {
        component
      });
      const classes = useUtilityClasses$W(ownerState);
      return /* @__PURE__ */ jsx(CardContentRoot, _extends({
        as: component,
        className: clsx(classes.root, className),
        ownerState,
        ref
      }, other));
    });
    const CardContent$1 = CardContent;
    function getSwitchBaseUtilityClass(slot) {
      return generateUtilityClass("PrivateSwitchBase", slot);
    }
    generateUtilityClasses("PrivateSwitchBase", ["root", "checked", "disabled", "input", "edgeStart", "edgeEnd"]);
    const _excluded$$ = ["autoFocus", "checked", "checkedIcon", "className", "defaultChecked", "disabled", "disableFocusRipple", "edge", "icon", "id", "inputProps", "inputRef", "name", "onBlur", "onChange", "onFocus", "readOnly", "required", "tabIndex", "type", "value"];
    const useUtilityClasses$V = (ownerState) => {
      const {
        classes,
        checked,
        disabled,
        edge
      } = ownerState;
      const slots = {
        root: ["root", checked && "checked", disabled && "disabled", edge && `edge${capitalize(edge)}`],
        input: ["input"]
      };
      return composeClasses(slots, getSwitchBaseUtilityClass, classes);
    };
    const SwitchBaseRoot = styled$1(ButtonBase$1)(({
      ownerState
    }) => _extends({
      padding: 9,
      borderRadius: "50%"
    }, ownerState.edge === "start" && {
      marginLeft: ownerState.size === "small" ? -3 : -12
    }, ownerState.edge === "end" && {
      marginRight: ownerState.size === "small" ? -3 : -12
    }));
    const SwitchBaseInput = styled$1("input")({
      cursor: "inherit",
      position: "absolute",
      opacity: 0,
      width: "100%",
      height: "100%",
      top: 0,
      left: 0,
      margin: 0,
      padding: 0,
      zIndex: 1
    });
    const SwitchBase = /* @__PURE__ */ react.exports.forwardRef(function SwitchBase2(props2, ref) {
      const {
        autoFocus,
        checked: checkedProp,
        checkedIcon,
        className,
        defaultChecked,
        disabled: disabledProp,
        disableFocusRipple = false,
        edge = false,
        icon,
        id: id2,
        inputProps,
        inputRef,
        name,
        onBlur,
        onChange,
        onFocus,
        readOnly,
        required,
        tabIndex,
        type: type2,
        value
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$$);
      const [checked, setCheckedState] = useControlled({
        controlled: checkedProp,
        default: Boolean(defaultChecked),
        name: "SwitchBase",
        state: "checked"
      });
      const muiFormControl = useFormControl();
      const handleFocus = (event) => {
        if (onFocus) {
          onFocus(event);
        }
        if (muiFormControl && muiFormControl.onFocus) {
          muiFormControl.onFocus(event);
        }
      };
      const handleBlur = (event) => {
        if (onBlur) {
          onBlur(event);
        }
        if (muiFormControl && muiFormControl.onBlur) {
          muiFormControl.onBlur(event);
        }
      };
      const handleInputChange = (event) => {
        if (event.nativeEvent.defaultPrevented) {
          return;
        }
        const newChecked = event.target.checked;
        setCheckedState(newChecked);
        if (onChange) {
          onChange(event, newChecked);
        }
      };
      let disabled = disabledProp;
      if (muiFormControl) {
        if (typeof disabled === "undefined") {
          disabled = muiFormControl.disabled;
        }
      }
      const hasLabelFor = type2 === "checkbox" || type2 === "radio";
      const ownerState = _extends({}, props2, {
        checked,
        disabled,
        disableFocusRipple,
        edge
      });
      const classes = useUtilityClasses$V(ownerState);
      return /* @__PURE__ */ jsxs(SwitchBaseRoot, _extends({
        component: "span",
        className: clsx(classes.root, className),
        centerRipple: true,
        focusRipple: !disableFocusRipple,
        disabled,
        tabIndex: null,
        role: void 0,
        onFocus: handleFocus,
        onBlur: handleBlur,
        ownerState,
        ref
      }, other, {
        children: [/* @__PURE__ */ jsx(SwitchBaseInput, _extends({
          autoFocus,
          checked: checkedProp,
          defaultChecked,
          className: classes.input,
          disabled,
          id: hasLabelFor && id2,
          name,
          onChange: handleInputChange,
          readOnly,
          ref: inputRef,
          required,
          ownerState,
          tabIndex,
          type: type2
        }, type2 === "checkbox" && value === void 0 ? {} : {
          value
        }, inputProps)), checked ? checkedIcon : icon]
      }));
    });
    const SwitchBase$1 = SwitchBase;
    function getCircularProgressUtilityClass(slot) {
      return generateUtilityClass("MuiCircularProgress", slot);
    }
    generateUtilityClasses("MuiCircularProgress", ["root", "determinate", "indeterminate", "colorPrimary", "colorSecondary", "svg", "circle", "circleDeterminate", "circleIndeterminate", "circleDisableShrink"]);
    const _excluded$_ = ["className", "color", "disableShrink", "size", "style", "thickness", "value", "variant"];
    let _$1 = (t2) => t2, _t$1, _t2$1, _t3$1, _t4$1;
    const SIZE = 44;
    const circularRotateKeyframe = keyframes(_t$1 || (_t$1 = _$1`
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
`));
    const circularDashKeyframe = keyframes(_t2$1 || (_t2$1 = _$1`
  0% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: 0;
  }

  50% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -15px;
  }

  100% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -125px;
  }
`));
    const useUtilityClasses$U = (ownerState) => {
      const {
        classes,
        variant,
        color: color2,
        disableShrink
      } = ownerState;
      const slots = {
        root: ["root", variant, `color${capitalize(color2)}`],
        svg: ["svg"],
        circle: ["circle", `circle${capitalize(variant)}`, disableShrink && "circleDisableShrink"]
      };
      return composeClasses(slots, getCircularProgressUtilityClass, classes);
    };
    const CircularProgressRoot = styled$1("span", {
      name: "MuiCircularProgress",
      slot: "Root",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.root, styles2[ownerState.variant], styles2[`color${capitalize(ownerState.color)}`]];
      }
    })(({
      ownerState,
      theme
    }) => _extends({
      display: "inline-block"
    }, ownerState.variant === "determinate" && {
      transition: theme.transitions.create("transform")
    }, ownerState.color !== "inherit" && {
      color: (theme.vars || theme).palette[ownerState.color].main
    }), ({
      ownerState
    }) => ownerState.variant === "indeterminate" && css(_t3$1 || (_t3$1 = _$1`
      animation: ${0} 1.4s linear infinite;
    `), circularRotateKeyframe));
    const CircularProgressSVG = styled$1("svg", {
      name: "MuiCircularProgress",
      slot: "Svg",
      overridesResolver: (props2, styles2) => styles2.svg
    })({
      display: "block"
    });
    const CircularProgressCircle = styled$1("circle", {
      name: "MuiCircularProgress",
      slot: "Circle",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.circle, styles2[`circle${capitalize(ownerState.variant)}`], ownerState.disableShrink && styles2.circleDisableShrink];
      }
    })(({
      ownerState,
      theme
    }) => _extends({
      stroke: "currentColor"
    }, ownerState.variant === "determinate" && {
      transition: theme.transitions.create("stroke-dashoffset")
    }, ownerState.variant === "indeterminate" && {
      strokeDasharray: "80px, 200px",
      strokeDashoffset: 0
    }), ({
      ownerState
    }) => ownerState.variant === "indeterminate" && !ownerState.disableShrink && css(_t4$1 || (_t4$1 = _$1`
      animation: ${0} 1.4s ease-in-out infinite;
    `), circularDashKeyframe));
    const CircularProgress = /* @__PURE__ */ react.exports.forwardRef(function CircularProgress2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiCircularProgress"
      });
      const {
        className,
        color: color2 = "primary",
        disableShrink = false,
        size = 40,
        style: style2,
        thickness = 3.6,
        value = 0,
        variant = "indeterminate"
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$_);
      const ownerState = _extends({}, props2, {
        color: color2,
        disableShrink,
        size,
        thickness,
        value,
        variant
      });
      const classes = useUtilityClasses$U(ownerState);
      const circleStyle = {};
      const rootStyle = {};
      const rootProps = {};
      if (variant === "determinate") {
        const circumference = 2 * Math.PI * ((SIZE - thickness) / 2);
        circleStyle.strokeDasharray = circumference.toFixed(3);
        rootProps["aria-valuenow"] = Math.round(value);
        circleStyle.strokeDashoffset = `${((100 - value) / 100 * circumference).toFixed(3)}px`;
        rootStyle.transform = "rotate(-90deg)";
      }
      return /* @__PURE__ */ jsx(CircularProgressRoot, _extends({
        className: clsx(classes.root, className),
        style: _extends({
          width: size,
          height: size
        }, rootStyle, style2),
        ownerState,
        ref,
        role: "progressbar"
      }, rootProps, other, {
        children: /* @__PURE__ */ jsx(CircularProgressSVG, {
          className: classes.svg,
          ownerState,
          viewBox: `${SIZE / 2} ${SIZE / 2} ${SIZE} ${SIZE}`,
          children: /* @__PURE__ */ jsx(CircularProgressCircle, {
            className: classes.circle,
            style: circleStyle,
            ownerState,
            cx: SIZE,
            cy: SIZE,
            r: (SIZE - thickness) / 2,
            fill: "none",
            strokeWidth: thickness
          })
        })
      }));
    });
    const CircularProgress$1 = CircularProgress;
    const Container = createContainer({
      createStyledComponent: styled$1("div", {
        name: "MuiContainer",
        slot: "Root",
        overridesResolver: (props2, styles2) => {
          const {
            ownerState
          } = props2;
          return [styles2.root, styles2[`maxWidth${capitalize(String(ownerState.maxWidth))}`], ownerState.fixed && styles2.fixed, ownerState.disableGutters && styles2.disableGutters];
        }
      }),
      useThemeProps: (inProps) => useThemeProps({
        props: inProps,
        name: "MuiContainer"
      })
    });
    const Container$1 = Container;
    const html = (theme, enableColorScheme) => _extends({
      WebkitFontSmoothing: "antialiased",
      MozOsxFontSmoothing: "grayscale",
      boxSizing: "border-box",
      WebkitTextSizeAdjust: "100%"
    }, enableColorScheme && !theme.vars && {
      colorScheme: theme.palette.mode
    });
    const body = (theme) => _extends({
      color: (theme.vars || theme).palette.text.primary
    }, theme.typography.body1, {
      backgroundColor: (theme.vars || theme).palette.background.default,
      "@media print": {
        backgroundColor: (theme.vars || theme).palette.common.white
      }
    });
    const styles$2 = (theme, enableColorScheme = false) => {
      var _theme$components, _theme$components$Mui;
      const colorSchemeStyles = {};
      if (enableColorScheme && theme.colorSchemes) {
        Object.entries(theme.colorSchemes).forEach(([key, scheme]) => {
          var _scheme$palette;
          colorSchemeStyles[theme.getColorSchemeSelector(key).replace(/\s*&/, "")] = {
            colorScheme: (_scheme$palette = scheme.palette) == null ? void 0 : _scheme$palette.mode
          };
        });
      }
      let defaultStyles = _extends({
        html: html(theme, enableColorScheme),
        "*, *::before, *::after": {
          boxSizing: "inherit"
        },
        "strong, b": {
          fontWeight: theme.typography.fontWeightBold
        },
        body: _extends({
          margin: 0
        }, body(theme), {
          "&::backdrop": {
            backgroundColor: (theme.vars || theme).palette.background.default
          }
        })
      }, colorSchemeStyles);
      const themeOverrides = (_theme$components = theme.components) == null ? void 0 : (_theme$components$Mui = _theme$components.MuiCssBaseline) == null ? void 0 : _theme$components$Mui.styleOverrides;
      if (themeOverrides) {
        defaultStyles = [defaultStyles, themeOverrides];
      }
      return defaultStyles;
    };
    function CssBaseline(inProps) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiCssBaseline"
      });
      const {
        children,
        enableColorScheme = false
      } = props2;
      return /* @__PURE__ */ jsxs(react.exports.Fragment, {
        children: [/* @__PURE__ */ jsx(GlobalStyles, {
          styles: (theme) => styles$2(theme, enableColorScheme)
        }), children]
      });
    }
    const _excluded$Z = ["BackdropComponent", "BackdropProps", "closeAfterTransition", "children", "component", "components", "componentsProps", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "slotProps", "slots", "theme"];
    const extendUtilityClasses = (ownerState) => {
      return ownerState.classes;
    };
    const ModalRoot = styled$1("div", {
      name: "MuiModal",
      slot: "Root",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.root, !ownerState.open && ownerState.exited && styles2.hidden];
      }
    })(({
      theme,
      ownerState
    }) => _extends({
      position: "fixed",
      zIndex: (theme.vars || theme).zIndex.modal,
      right: 0,
      bottom: 0,
      top: 0,
      left: 0
    }, !ownerState.open && ownerState.exited && {
      visibility: "hidden"
    }));
    const ModalBackdrop = styled$1(Backdrop$1, {
      name: "MuiModal",
      slot: "Backdrop",
      overridesResolver: (props2, styles2) => {
        return styles2.backdrop;
      }
    })({
      zIndex: -1
    });
    const Modal = /* @__PURE__ */ react.exports.forwardRef(function Modal2(inProps, ref) {
      var _ref, _slots$root, _ref2, _slots$backdrop, _slotProps$root, _slotProps$backdrop;
      const props2 = useThemeProps({
        name: "MuiModal",
        props: inProps
      });
      const {
        BackdropComponent = ModalBackdrop,
        BackdropProps,
        closeAfterTransition = false,
        children,
        component,
        components = {},
        componentsProps = {},
        disableAutoFocus = false,
        disableEnforceFocus = false,
        disableEscapeKeyDown = false,
        disablePortal = false,
        disableRestoreFocus = false,
        disableScrollLock = false,
        hideBackdrop = false,
        keepMounted = false,
        slotProps,
        slots,
        theme
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$Z);
      const [exited, setExited] = react.exports.useState(true);
      const commonProps = {
        closeAfterTransition,
        disableAutoFocus,
        disableEnforceFocus,
        disableEscapeKeyDown,
        disablePortal,
        disableRestoreFocus,
        disableScrollLock,
        hideBackdrop,
        keepMounted
      };
      const ownerState = _extends({}, props2, commonProps, {
        exited
      });
      const classes = extendUtilityClasses(ownerState);
      const RootSlot = (_ref = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : components.Root) != null ? _ref : ModalRoot;
      const BackdropSlot = (_ref2 = (_slots$backdrop = slots == null ? void 0 : slots.backdrop) != null ? _slots$backdrop : components.Backdrop) != null ? _ref2 : BackdropComponent;
      const rootSlotProps = (_slotProps$root = slotProps == null ? void 0 : slotProps.root) != null ? _slotProps$root : componentsProps.root;
      const backdropSlotProps = (_slotProps$backdrop = slotProps == null ? void 0 : slotProps.backdrop) != null ? _slotProps$backdrop : componentsProps.backdrop;
      return /* @__PURE__ */ jsx(ModalUnstyled$1, _extends({
        slots: {
          root: RootSlot,
          backdrop: BackdropSlot
        },
        slotProps: {
          root: () => _extends({}, resolveComponentProps(rootSlotProps, ownerState), !isHostComponent(RootSlot) && {
            as: component,
            theme
          }),
          backdrop: () => _extends({}, BackdropProps, resolveComponentProps(backdropSlotProps, ownerState))
        },
        onTransitionEnter: () => setExited(false),
        onTransitionExited: () => setExited(true),
        ref
      }, other, {
        classes
      }, commonProps, {
        children
      }));
    });
    const Modal$1 = Modal;
    function getDialogUtilityClass(slot) {
      return generateUtilityClass("MuiDialog", slot);
    }
    const dialogClasses = generateUtilityClasses("MuiDialog", ["root", "scrollPaper", "scrollBody", "container", "paper", "paperScrollPaper", "paperScrollBody", "paperWidthFalse", "paperWidthXs", "paperWidthSm", "paperWidthMd", "paperWidthLg", "paperWidthXl", "paperFullWidth", "paperFullScreen"]);
    const dialogClasses$1 = dialogClasses;
    const DialogContext = /* @__PURE__ */ react.exports.createContext({});
    const DialogContext$1 = DialogContext;
    const _excluded$Y = ["aria-describedby", "aria-labelledby", "BackdropComponent", "BackdropProps", "children", "className", "disableEscapeKeyDown", "fullScreen", "fullWidth", "maxWidth", "onBackdropClick", "onClose", "open", "PaperComponent", "PaperProps", "scroll", "TransitionComponent", "transitionDuration", "TransitionProps"];
    const DialogBackdrop = styled$1(Backdrop$1, {
      name: "MuiDialog",
      slot: "Backdrop",
      overrides: (props2, styles2) => styles2.backdrop
    })({
      zIndex: -1
    });
    const useUtilityClasses$T = (ownerState) => {
      const {
        classes,
        scroll,
        maxWidth: maxWidth2,
        fullWidth,
        fullScreen
      } = ownerState;
      const slots = {
        root: ["root"],
        container: ["container", `scroll${capitalize(scroll)}`],
        paper: ["paper", `paperScroll${capitalize(scroll)}`, `paperWidth${capitalize(String(maxWidth2))}`, fullWidth && "paperFullWidth", fullScreen && "paperFullScreen"]
      };
      return composeClasses(slots, getDialogUtilityClass, classes);
    };
    const DialogRoot = styled$1(Modal$1, {
      name: "MuiDialog",
      slot: "Root",
      overridesResolver: (props2, styles2) => styles2.root
    })({
      "@media print": {
        position: "absolute !important"
      }
    });
    const DialogContainer = styled$1("div", {
      name: "MuiDialog",
      slot: "Container",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.container, styles2[`scroll${capitalize(ownerState.scroll)}`]];
      }
    })(({
      ownerState
    }) => _extends({
      height: "100%",
      "@media print": {
        height: "auto"
      },
      outline: 0
    }, ownerState.scroll === "paper" && {
      display: "flex",
      justifyContent: "center",
      alignItems: "center"
    }, ownerState.scroll === "body" && {
      overflowY: "auto",
      overflowX: "hidden",
      textAlign: "center",
      "&:after": {
        content: '""',
        display: "inline-block",
        verticalAlign: "middle",
        height: "100%",
        width: "0"
      }
    }));
    const DialogPaper = styled$1(Paper$1, {
      name: "MuiDialog",
      slot: "Paper",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.paper, styles2[`scrollPaper${capitalize(ownerState.scroll)}`], styles2[`paperWidth${capitalize(String(ownerState.maxWidth))}`], ownerState.fullWidth && styles2.paperFullWidth, ownerState.fullScreen && styles2.paperFullScreen];
      }
    })(({
      theme,
      ownerState
    }) => _extends({
      margin: 32,
      position: "relative",
      overflowY: "auto",
      "@media print": {
        overflowY: "visible",
        boxShadow: "none"
      }
    }, ownerState.scroll === "paper" && {
      display: "flex",
      flexDirection: "column",
      maxHeight: "calc(100% - 64px)"
    }, ownerState.scroll === "body" && {
      display: "inline-block",
      verticalAlign: "middle",
      textAlign: "left"
    }, !ownerState.maxWidth && {
      maxWidth: "calc(100% - 64px)"
    }, ownerState.maxWidth === "xs" && {
      maxWidth: theme.breakpoints.unit === "px" ? Math.max(theme.breakpoints.values.xs, 444) : `${theme.breakpoints.values.xs}${theme.breakpoints.unit}`,
      [`&.${dialogClasses$1.paperScrollBody}`]: {
        [theme.breakpoints.down(Math.max(theme.breakpoints.values.xs, 444) + 32 * 2)]: {
          maxWidth: "calc(100% - 64px)"
        }
      }
    }, ownerState.maxWidth && ownerState.maxWidth !== "xs" && {
      maxWidth: `${theme.breakpoints.values[ownerState.maxWidth]}${theme.breakpoints.unit}`,
      [`&.${dialogClasses$1.paperScrollBody}`]: {
        [theme.breakpoints.down(theme.breakpoints.values[ownerState.maxWidth] + 32 * 2)]: {
          maxWidth: "calc(100% - 64px)"
        }
      }
    }, ownerState.fullWidth && {
      width: "calc(100% - 64px)"
    }, ownerState.fullScreen && {
      margin: 0,
      width: "100%",
      maxWidth: "100%",
      height: "100%",
      maxHeight: "none",
      borderRadius: 0,
      [`&.${dialogClasses$1.paperScrollBody}`]: {
        margin: 0,
        maxWidth: "100%"
      }
    }));
    const Dialog = /* @__PURE__ */ react.exports.forwardRef(function Dialog2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiDialog"
      });
      const theme = useTheme();
      const defaultTransitionDuration = {
        enter: theme.transitions.duration.enteringScreen,
        exit: theme.transitions.duration.leavingScreen
      };
      const {
        "aria-describedby": ariaDescribedby,
        "aria-labelledby": ariaLabelledbyProp,
        BackdropComponent,
        BackdropProps,
        children,
        className,
        disableEscapeKeyDown = false,
        fullScreen = false,
        fullWidth = false,
        maxWidth: maxWidth2 = "sm",
        onBackdropClick,
        onClose,
        open,
        PaperComponent = Paper$1,
        PaperProps = {},
        scroll = "paper",
        TransitionComponent = Fade$1,
        transitionDuration = defaultTransitionDuration,
        TransitionProps
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$Y);
      const ownerState = _extends({}, props2, {
        disableEscapeKeyDown,
        fullScreen,
        fullWidth,
        maxWidth: maxWidth2,
        scroll
      });
      const classes = useUtilityClasses$T(ownerState);
      const backdropClick = react.exports.useRef();
      const handleMouseDown = (event) => {
        backdropClick.current = event.target === event.currentTarget;
      };
      const handleBackdropClick = (event) => {
        if (!backdropClick.current) {
          return;
        }
        backdropClick.current = null;
        if (onBackdropClick) {
          onBackdropClick(event);
        }
        if (onClose) {
          onClose(event, "backdropClick");
        }
      };
      const ariaLabelledby = useId(ariaLabelledbyProp);
      const dialogContextValue = react.exports.useMemo(() => {
        return {
          titleId: ariaLabelledby
        };
      }, [ariaLabelledby]);
      return /* @__PURE__ */ jsx(DialogRoot, _extends({
        className: clsx(classes.root, className),
        closeAfterTransition: true,
        components: {
          Backdrop: DialogBackdrop
        },
        componentsProps: {
          backdrop: _extends({
            transitionDuration,
            as: BackdropComponent
          }, BackdropProps)
        },
        disableEscapeKeyDown,
        onClose,
        open,
        ref,
        onClick: handleBackdropClick,
        ownerState
      }, other, {
        children: /* @__PURE__ */ jsx(TransitionComponent, _extends({
          appear: true,
          in: open,
          timeout: transitionDuration,
          role: "presentation"
        }, TransitionProps, {
          children: /* @__PURE__ */ jsx(DialogContainer, {
            className: clsx(classes.container),
            onMouseDown: handleMouseDown,
            ownerState,
            children: /* @__PURE__ */ jsx(DialogPaper, _extends({
              as: PaperComponent,
              elevation: 24,
              role: "dialog",
              "aria-describedby": ariaDescribedby,
              "aria-labelledby": ariaLabelledby
            }, PaperProps, {
              className: clsx(classes.paper, PaperProps.className),
              ownerState,
              children: /* @__PURE__ */ jsx(DialogContext$1.Provider, {
                value: dialogContextValue,
                children
              })
            }))
          })
        }))
      }));
    });
    const Dialog$1 = Dialog;
    function getDialogActionsUtilityClass(slot) {
      return generateUtilityClass("MuiDialogActions", slot);
    }
    generateUtilityClasses("MuiDialogActions", ["root", "spacing"]);
    const _excluded$X = ["className", "disableSpacing"];
    const useUtilityClasses$S = (ownerState) => {
      const {
        classes,
        disableSpacing
      } = ownerState;
      const slots = {
        root: ["root", !disableSpacing && "spacing"]
      };
      return composeClasses(slots, getDialogActionsUtilityClass, classes);
    };
    const DialogActionsRoot = styled$1("div", {
      name: "MuiDialogActions",
      slot: "Root",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.root, !ownerState.disableSpacing && styles2.spacing];
      }
    })(({
      ownerState
    }) => _extends({
      display: "flex",
      alignItems: "center",
      padding: 8,
      justifyContent: "flex-end",
      flex: "0 0 auto"
    }, !ownerState.disableSpacing && {
      "& > :not(:first-of-type)": {
        marginLeft: 8
      }
    }));
    const DialogActions = /* @__PURE__ */ react.exports.forwardRef(function DialogActions2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiDialogActions"
      });
      const {
        className,
        disableSpacing = false
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$X);
      const ownerState = _extends({}, props2, {
        disableSpacing
      });
      const classes = useUtilityClasses$S(ownerState);
      return /* @__PURE__ */ jsx(DialogActionsRoot, _extends({
        className: clsx(classes.root, className),
        ownerState,
        ref
      }, other));
    });
    const DialogActions$1 = DialogActions;
    function getDialogContentUtilityClass(slot) {
      return generateUtilityClass("MuiDialogContent", slot);
    }
    generateUtilityClasses("MuiDialogContent", ["root", "dividers"]);
    function getDialogTitleUtilityClass(slot) {
      return generateUtilityClass("MuiDialogTitle", slot);
    }
    const dialogTitleClasses = generateUtilityClasses("MuiDialogTitle", ["root"]);
    const dialogTitleClasses$1 = dialogTitleClasses;
    const _excluded$W = ["className", "dividers"];
    const useUtilityClasses$R = (ownerState) => {
      const {
        classes,
        dividers
      } = ownerState;
      const slots = {
        root: ["root", dividers && "dividers"]
      };
      return composeClasses(slots, getDialogContentUtilityClass, classes);
    };
    const DialogContentRoot = styled$1("div", {
      name: "MuiDialogContent",
      slot: "Root",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.root, ownerState.dividers && styles2.dividers];
      }
    })(({
      theme,
      ownerState
    }) => _extends({
      flex: "1 1 auto",
      WebkitOverflowScrolling: "touch",
      overflowY: "auto",
      padding: "20px 24px"
    }, ownerState.dividers ? {
      padding: "16px 24px",
      borderTop: `1px solid ${(theme.vars || theme).palette.divider}`,
      borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`
    } : {
      [`.${dialogTitleClasses$1.root} + &`]: {
        paddingTop: 0
      }
    }));
    const DialogContent = /* @__PURE__ */ react.exports.forwardRef(function DialogContent2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiDialogContent"
      });
      const {
        className,
        dividers = false
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$W);
      const ownerState = _extends({}, props2, {
        dividers
      });
      const classes = useUtilityClasses$R(ownerState);
      return /* @__PURE__ */ jsx(DialogContentRoot, _extends({
        className: clsx(classes.root, className),
        ownerState,
        ref
      }, other));
    });
    const DialogContent$1 = DialogContent;
    const _excluded$V = ["className", "id"];
    const useUtilityClasses$Q = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"]
      };
      return composeClasses(slots, getDialogTitleUtilityClass, classes);
    };
    const DialogTitleRoot = styled$1(Typography$1, {
      name: "MuiDialogTitle",
      slot: "Root",
      overridesResolver: (props2, styles2) => styles2.root
    })({
      padding: "16px 24px",
      flex: "0 0 auto"
    });
    const DialogTitle = /* @__PURE__ */ react.exports.forwardRef(function DialogTitle2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiDialogTitle"
      });
      const {
        className,
        id: idProp
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$V);
      const ownerState = props2;
      const classes = useUtilityClasses$Q(ownerState);
      const {
        titleId: id2 = idProp
      } = react.exports.useContext(DialogContext$1);
      return /* @__PURE__ */ jsx(DialogTitleRoot, _extends({
        component: "h2",
        className: clsx(classes.root, className),
        ownerState,
        ref,
        variant: "h6",
        id: id2
      }, other));
    });
    const DialogTitle$1 = DialogTitle;
    function getDividerUtilityClass(slot) {
      return generateUtilityClass("MuiDivider", slot);
    }
    const dividerClasses = generateUtilityClasses("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]);
    const dividerClasses$1 = dividerClasses;
    const _excluded$U = ["absolute", "children", "className", "component", "flexItem", "light", "orientation", "role", "textAlign", "variant"];
    const useUtilityClasses$P = (ownerState) => {
      const {
        absolute,
        children,
        classes,
        flexItem,
        light: light2,
        orientation,
        textAlign: textAlign2,
        variant
      } = ownerState;
      const slots = {
        root: ["root", absolute && "absolute", variant, light2 && "light", orientation === "vertical" && "vertical", flexItem && "flexItem", children && "withChildren", children && orientation === "vertical" && "withChildrenVertical", textAlign2 === "right" && orientation !== "vertical" && "textAlignRight", textAlign2 === "left" && orientation !== "vertical" && "textAlignLeft"],
        wrapper: ["wrapper", orientation === "vertical" && "wrapperVertical"]
      };
      return composeClasses(slots, getDividerUtilityClass, classes);
    };
    const DividerRoot = styled$1("div", {
      name: "MuiDivider",
      slot: "Root",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.root, ownerState.absolute && styles2.absolute, styles2[ownerState.variant], ownerState.light && styles2.light, ownerState.orientation === "vertical" && styles2.vertical, ownerState.flexItem && styles2.flexItem, ownerState.children && styles2.withChildren, ownerState.children && ownerState.orientation === "vertical" && styles2.withChildrenVertical, ownerState.textAlign === "right" && ownerState.orientation !== "vertical" && styles2.textAlignRight, ownerState.textAlign === "left" && ownerState.orientation !== "vertical" && styles2.textAlignLeft];
      }
    })(({
      theme,
      ownerState
    }) => _extends({
      margin: 0,
      flexShrink: 0,
      borderWidth: 0,
      borderStyle: "solid",
      borderColor: (theme.vars || theme).palette.divider,
      borderBottomWidth: "thin"
    }, ownerState.absolute && {
      position: "absolute",
      bottom: 0,
      left: 0,
      width: "100%"
    }, ownerState.light && {
      borderColor: theme.vars ? `rgba(${theme.vars.palette.dividerChannel} / 0.08)` : alpha(theme.palette.divider, 0.08)
    }, ownerState.variant === "inset" && {
      marginLeft: 72
    }, ownerState.variant === "middle" && ownerState.orientation === "horizontal" && {
      marginLeft: theme.spacing(2),
      marginRight: theme.spacing(2)
    }, ownerState.variant === "middle" && ownerState.orientation === "vertical" && {
      marginTop: theme.spacing(1),
      marginBottom: theme.spacing(1)
    }, ownerState.orientation === "vertical" && {
      height: "100%",
      borderBottomWidth: 0,
      borderRightWidth: "thin"
    }, ownerState.flexItem && {
      alignSelf: "stretch",
      height: "auto"
    }), ({
      theme,
      ownerState
    }) => _extends({}, ownerState.children && {
      display: "flex",
      whiteSpace: "nowrap",
      textAlign: "center",
      border: 0,
      "&::before, &::after": {
        position: "relative",
        width: "100%",
        borderTop: `thin solid ${(theme.vars || theme).palette.divider}`,
        top: "50%",
        content: '""',
        transform: "translateY(50%)"
      }
    }), ({
      theme,
      ownerState
    }) => _extends({}, ownerState.children && ownerState.orientation === "vertical" && {
      flexDirection: "column",
      "&::before, &::after": {
        height: "100%",
        top: "0%",
        left: "50%",
        borderTop: 0,
        borderLeft: `thin solid ${(theme.vars || theme).palette.divider}`,
        transform: "translateX(0%)"
      }
    }), ({
      ownerState
    }) => _extends({}, ownerState.textAlign === "right" && ownerState.orientation !== "vertical" && {
      "&::before": {
        width: "90%"
      },
      "&::after": {
        width: "10%"
      }
    }, ownerState.textAlign === "left" && ownerState.orientation !== "vertical" && {
      "&::before": {
        width: "10%"
      },
      "&::after": {
        width: "90%"
      }
    }));
    const DividerWrapper = styled$1("span", {
      name: "MuiDivider",
      slot: "Wrapper",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.wrapper, ownerState.orientation === "vertical" && styles2.wrapperVertical];
      }
    })(({
      theme,
      ownerState
    }) => _extends({
      display: "inline-block",
      paddingLeft: `calc(${theme.spacing(1)} * 1.2)`,
      paddingRight: `calc(${theme.spacing(1)} * 1.2)`
    }, ownerState.orientation === "vertical" && {
      paddingTop: `calc(${theme.spacing(1)} * 1.2)`,
      paddingBottom: `calc(${theme.spacing(1)} * 1.2)`
    }));
    const Divider = /* @__PURE__ */ react.exports.forwardRef(function Divider2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiDivider"
      });
      const {
        absolute = false,
        children,
        className,
        component = children ? "div" : "hr",
        flexItem = false,
        light: light2 = false,
        orientation = "horizontal",
        role = component !== "hr" ? "separator" : void 0,
        textAlign: textAlign2 = "center",
        variant = "fullWidth"
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$U);
      const ownerState = _extends({}, props2, {
        absolute,
        component,
        flexItem,
        light: light2,
        orientation,
        role,
        textAlign: textAlign2,
        variant
      });
      const classes = useUtilityClasses$P(ownerState);
      return /* @__PURE__ */ jsx(DividerRoot, _extends({
        as: component,
        className: clsx(classes.root, className),
        role,
        ref,
        ownerState
      }, other, {
        children: children ? /* @__PURE__ */ jsx(DividerWrapper, {
          className: classes.wrapper,
          ownerState,
          children
        }) : null
      }));
    });
    const Divider$1 = Divider;
    const _excluded$T = ["addEndListener", "appear", "children", "container", "direction", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
    function getTranslateValue(direction, node2, resolvedContainer) {
      const rect = node2.getBoundingClientRect();
      const containerRect = resolvedContainer && resolvedContainer.getBoundingClientRect();
      const containerWindow = ownerWindow(node2);
      let transform2;
      if (node2.fakeTransform) {
        transform2 = node2.fakeTransform;
      } else {
        const computedStyle = containerWindow.getComputedStyle(node2);
        transform2 = computedStyle.getPropertyValue("-webkit-transform") || computedStyle.getPropertyValue("transform");
      }
      let offsetX = 0;
      let offsetY = 0;
      if (transform2 && transform2 !== "none" && typeof transform2 === "string") {
        const transformValues = transform2.split("(")[1].split(")")[0].split(",");
        offsetX = parseInt(transformValues[4], 10);
        offsetY = parseInt(transformValues[5], 10);
      }
      if (direction === "left") {
        if (containerRect) {
          return `translateX(${containerRect.right + offsetX - rect.left}px)`;
        }
        return `translateX(${containerWindow.innerWidth + offsetX - rect.left}px)`;
      }
      if (direction === "right") {
        if (containerRect) {
          return `translateX(-${rect.right - containerRect.left - offsetX}px)`;
        }
        return `translateX(-${rect.left + rect.width - offsetX}px)`;
      }
      if (direction === "up") {
        if (containerRect) {
          return `translateY(${containerRect.bottom + offsetY - rect.top}px)`;
        }
        return `translateY(${containerWindow.innerHeight + offsetY - rect.top}px)`;
      }
      if (containerRect) {
        return `translateY(-${rect.top - containerRect.top + rect.height - offsetY}px)`;
      }
      return `translateY(-${rect.top + rect.height - offsetY}px)`;
    }
    function resolveContainer(containerPropProp) {
      return typeof containerPropProp === "function" ? containerPropProp() : containerPropProp;
    }
    function setTranslateValue(direction, node2, containerProp) {
      const resolvedContainer = resolveContainer(containerProp);
      const transform2 = getTranslateValue(direction, node2, resolvedContainer);
      if (transform2) {
        node2.style.webkitTransform = transform2;
        node2.style.transform = transform2;
      }
    }
    const Slide = /* @__PURE__ */ react.exports.forwardRef(function Slide2(props2, ref) {
      const theme = useTheme();
      const defaultEasing = {
        enter: theme.transitions.easing.easeOut,
        exit: theme.transitions.easing.sharp
      };
      const defaultTimeout = {
        enter: theme.transitions.duration.enteringScreen,
        exit: theme.transitions.duration.leavingScreen
      };
      const {
        addEndListener,
        appear = true,
        children,
        container: containerProp,
        direction = "down",
        easing: easingProp = defaultEasing,
        in: inProp,
        onEnter,
        onEntered,
        onEntering,
        onExit,
        onExited,
        onExiting,
        style: style2,
        timeout = defaultTimeout,
        TransitionComponent = Transition$1
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$T);
      const childrenRef = react.exports.useRef(null);
      const handleRef = useForkRef(children.ref, childrenRef, ref);
      const normalizedTransitionCallback = (callback) => (isAppearing) => {
        if (callback) {
          if (isAppearing === void 0) {
            callback(childrenRef.current);
          } else {
            callback(childrenRef.current, isAppearing);
          }
        }
      };
      const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
        setTranslateValue(direction, node2, containerProp);
        reflow(node2);
        if (onEnter) {
          onEnter(node2, isAppearing);
        }
      });
      const handleEntering = normalizedTransitionCallback((node2, isAppearing) => {
        const transitionProps = getTransitionProps({
          timeout,
          style: style2,
          easing: easingProp
        }, {
          mode: "enter"
        });
        node2.style.webkitTransition = theme.transitions.create("-webkit-transform", _extends({}, transitionProps));
        node2.style.transition = theme.transitions.create("transform", _extends({}, transitionProps));
        node2.style.webkitTransform = "none";
        node2.style.transform = "none";
        if (onEntering) {
          onEntering(node2, isAppearing);
        }
      });
      const handleEntered = normalizedTransitionCallback(onEntered);
      const handleExiting = normalizedTransitionCallback(onExiting);
      const handleExit = normalizedTransitionCallback((node2) => {
        const transitionProps = getTransitionProps({
          timeout,
          style: style2,
          easing: easingProp
        }, {
          mode: "exit"
        });
        node2.style.webkitTransition = theme.transitions.create("-webkit-transform", transitionProps);
        node2.style.transition = theme.transitions.create("transform", transitionProps);
        setTranslateValue(direction, node2, containerProp);
        if (onExit) {
          onExit(node2);
        }
      });
      const handleExited = normalizedTransitionCallback((node2) => {
        node2.style.webkitTransition = "";
        node2.style.transition = "";
        if (onExited) {
          onExited(node2);
        }
      });
      const handleAddEndListener = (next2) => {
        if (addEndListener) {
          addEndListener(childrenRef.current, next2);
        }
      };
      const updatePosition = react.exports.useCallback(() => {
        if (childrenRef.current) {
          setTranslateValue(direction, childrenRef.current, containerProp);
        }
      }, [direction, containerProp]);
      react.exports.useEffect(() => {
        if (inProp || direction === "down" || direction === "right") {
          return void 0;
        }
        const handleResize = debounce$1(() => {
          if (childrenRef.current) {
            setTranslateValue(direction, childrenRef.current, containerProp);
          }
        });
        const containerWindow = ownerWindow(childrenRef.current);
        containerWindow.addEventListener("resize", handleResize);
        return () => {
          handleResize.clear();
          containerWindow.removeEventListener("resize", handleResize);
        };
      }, [direction, inProp, containerProp]);
      react.exports.useEffect(() => {
        if (!inProp) {
          updatePosition();
        }
      }, [inProp, updatePosition]);
      return /* @__PURE__ */ jsx(TransitionComponent, _extends({
        nodeRef: childrenRef,
        onEnter: handleEnter,
        onEntered: handleEntered,
        onEntering: handleEntering,
        onExit: handleExit,
        onExited: handleExited,
        onExiting: handleExiting,
        addEndListener: handleAddEndListener,
        appear,
        in: inProp,
        timeout
      }, other, {
        children: (state, childProps) => {
          return /* @__PURE__ */ react.exports.cloneElement(children, _extends({
            ref: handleRef,
            style: _extends({
              visibility: state === "exited" && !inProp ? "hidden" : void 0
            }, style2, children.props.style)
          }, childProps));
        }
      }));
    });
    const Slide$1 = Slide;
    function getDrawerUtilityClass(slot) {
      return generateUtilityClass("MuiDrawer", slot);
    }
    generateUtilityClasses("MuiDrawer", ["root", "docked", "paper", "paperAnchorLeft", "paperAnchorRight", "paperAnchorTop", "paperAnchorBottom", "paperAnchorDockedLeft", "paperAnchorDockedRight", "paperAnchorDockedTop", "paperAnchorDockedBottom", "modal"]);
    const _excluded$S = ["BackdropProps"], _excluded2$3 = ["anchor", "BackdropProps", "children", "className", "elevation", "hideBackdrop", "ModalProps", "onClose", "open", "PaperProps", "SlideProps", "TransitionComponent", "transitionDuration", "variant"];
    const overridesResolver$5 = (props2, styles2) => {
      const {
        ownerState
      } = props2;
      return [styles2.root, (ownerState.variant === "permanent" || ownerState.variant === "persistent") && styles2.docked, styles2.modal];
    };
    const useUtilityClasses$O = (ownerState) => {
      const {
        classes,
        anchor,
        variant
      } = ownerState;
      const slots = {
        root: ["root"],
        docked: [(variant === "permanent" || variant === "persistent") && "docked"],
        modal: ["modal"],
        paper: ["paper", `paperAnchor${capitalize(anchor)}`, variant !== "temporary" && `paperAnchorDocked${capitalize(anchor)}`]
      };
      return composeClasses(slots, getDrawerUtilityClass, classes);
    };
    const DrawerRoot = styled$1(Modal$1, {
      name: "MuiDrawer",
      slot: "Root",
      overridesResolver: overridesResolver$5
    })(({
      theme
    }) => ({
      zIndex: (theme.vars || theme).zIndex.drawer
    }));
    const DrawerDockedRoot = styled$1("div", {
      shouldForwardProp: rootShouldForwardProp$1,
      name: "MuiDrawer",
      slot: "Docked",
      skipVariantsResolver: false,
      overridesResolver: overridesResolver$5
    })({
      flex: "0 0 auto"
    });
    const DrawerPaper = styled$1(Paper$1, {
      name: "MuiDrawer",
      slot: "Paper",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.paper, styles2[`paperAnchor${capitalize(ownerState.anchor)}`], ownerState.variant !== "temporary" && styles2[`paperAnchorDocked${capitalize(ownerState.anchor)}`]];
      }
    })(({
      theme,
      ownerState
    }) => _extends({
      overflowY: "auto",
      display: "flex",
      flexDirection: "column",
      height: "100%",
      flex: "1 0 auto",
      zIndex: (theme.vars || theme).zIndex.drawer,
      WebkitOverflowScrolling: "touch",
      position: "fixed",
      top: 0,
      outline: 0
    }, ownerState.anchor === "left" && {
      left: 0
    }, ownerState.anchor === "top" && {
      top: 0,
      left: 0,
      right: 0,
      height: "auto",
      maxHeight: "100%"
    }, ownerState.anchor === "right" && {
      right: 0
    }, ownerState.anchor === "bottom" && {
      top: "auto",
      left: 0,
      bottom: 0,
      right: 0,
      height: "auto",
      maxHeight: "100%"
    }, ownerState.anchor === "left" && ownerState.variant !== "temporary" && {
      borderRight: `1px solid ${(theme.vars || theme).palette.divider}`
    }, ownerState.anchor === "top" && ownerState.variant !== "temporary" && {
      borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`
    }, ownerState.anchor === "right" && ownerState.variant !== "temporary" && {
      borderLeft: `1px solid ${(theme.vars || theme).palette.divider}`
    }, ownerState.anchor === "bottom" && ownerState.variant !== "temporary" && {
      borderTop: `1px solid ${(theme.vars || theme).palette.divider}`
    }));
    const oppositeDirection = {
      left: "right",
      right: "left",
      top: "down",
      bottom: "up"
    };
    function isHorizontal(anchor) {
      return ["left", "right"].indexOf(anchor) !== -1;
    }
    function getAnchor(theme, anchor) {
      return theme.direction === "rtl" && isHorizontal(anchor) ? oppositeDirection[anchor] : anchor;
    }
    const Drawer = /* @__PURE__ */ react.exports.forwardRef(function Drawer2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiDrawer"
      });
      const theme = useTheme();
      const defaultTransitionDuration = {
        enter: theme.transitions.duration.enteringScreen,
        exit: theme.transitions.duration.leavingScreen
      };
      const {
        anchor: anchorProp = "left",
        BackdropProps,
        children,
        className,
        elevation = 16,
        hideBackdrop = false,
        ModalProps: {
          BackdropProps: BackdropPropsProp
        } = {},
        onClose,
        open = false,
        PaperProps = {},
        SlideProps,
        TransitionComponent = Slide$1,
        transitionDuration = defaultTransitionDuration,
        variant = "temporary"
      } = props2, ModalProps = _objectWithoutPropertiesLoose(props2.ModalProps, _excluded$S), other = _objectWithoutPropertiesLoose(props2, _excluded2$3);
      const mounted = react.exports.useRef(false);
      react.exports.useEffect(() => {
        mounted.current = true;
      }, []);
      const anchorInvariant = getAnchor(theme, anchorProp);
      const anchor = anchorProp;
      const ownerState = _extends({}, props2, {
        anchor,
        elevation,
        open,
        variant
      }, other);
      const classes = useUtilityClasses$O(ownerState);
      const drawer = /* @__PURE__ */ jsx(DrawerPaper, _extends({
        elevation: variant === "temporary" ? elevation : 0,
        square: true
      }, PaperProps, {
        className: clsx(classes.paper, PaperProps.className),
        ownerState,
        children
      }));
      if (variant === "permanent") {
        return /* @__PURE__ */ jsx(DrawerDockedRoot, _extends({
          className: clsx(classes.root, classes.docked, className),
          ownerState,
          ref
        }, other, {
          children: drawer
        }));
      }
      const slidingDrawer = /* @__PURE__ */ jsx(TransitionComponent, _extends({
        in: open,
        direction: oppositeDirection[anchorInvariant],
        timeout: transitionDuration,
        appear: mounted.current
      }, SlideProps, {
        children: drawer
      }));
      if (variant === "persistent") {
        return /* @__PURE__ */ jsx(DrawerDockedRoot, _extends({
          className: clsx(classes.root, classes.docked, className),
          ownerState,
          ref
        }, other, {
          children: slidingDrawer
        }));
      }
      return /* @__PURE__ */ jsx(DrawerRoot, _extends({
        BackdropProps: _extends({}, BackdropProps, BackdropPropsProp, {
          transitionDuration
        }),
        className: clsx(classes.root, classes.modal, className),
        open,
        ownerState,
        onClose,
        hideBackdrop,
        ref
      }, other, ModalProps, {
        children: slidingDrawer
      }));
    });
    const Drawer$1 = Drawer;
    function getFabUtilityClass(slot) {
      return generateUtilityClass("MuiFab", slot);
    }
    const fabClasses = generateUtilityClasses("MuiFab", ["root", "primary", "secondary", "extended", "circular", "focusVisible", "disabled", "colorInherit", "sizeSmall", "sizeMedium", "sizeLarge", "info", "error", "warning", "success"]);
    const fabClasses$1 = fabClasses;
    const _excluded$R = ["children", "className", "color", "component", "disabled", "disableFocusRipple", "focusVisibleClassName", "size", "variant"];
    const useUtilityClasses$N = (ownerState) => {
      const {
        color: color2,
        variant,
        classes,
        size
      } = ownerState;
      const slots = {
        root: ["root", variant, `size${capitalize(size)}`, color2 === "inherit" ? "colorInherit" : color2]
      };
      const composedClasses = composeClasses(slots, getFabUtilityClass, classes);
      return _extends({}, classes, composedClasses);
    };
    const FabRoot = styled$1(ButtonBase$1, {
      name: "MuiFab",
      slot: "Root",
      shouldForwardProp: (prop) => rootShouldForwardProp$1(prop) || prop === "classes",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.root, styles2[ownerState.variant], styles2[`size${capitalize(ownerState.size)}`], ownerState.color === "inherit" && styles2.colorInherit, styles2[capitalize(ownerState.size)], styles2[ownerState.color]];
      }
    })(({
      theme,
      ownerState
    }) => {
      var _theme$palette$getCon, _theme$palette;
      return _extends({}, theme.typography.button, {
        minHeight: 36,
        transition: theme.transitions.create(["background-color", "box-shadow", "border-color"], {
          duration: theme.transitions.duration.short
        }),
        borderRadius: "50%",
        padding: 0,
        minWidth: 0,
        width: 56,
        height: 56,
        zIndex: (theme.vars || theme).zIndex.fab,
        boxShadow: (theme.vars || theme).shadows[6],
        "&:active": {
          boxShadow: (theme.vars || theme).shadows[12]
        },
        color: theme.vars ? theme.vars.palette.text.primary : (_theme$palette$getCon = (_theme$palette = theme.palette).getContrastText) == null ? void 0 : _theme$palette$getCon.call(_theme$palette, theme.palette.grey[300]),
        backgroundColor: (theme.vars || theme).palette.grey[300],
        "&:hover": {
          backgroundColor: (theme.vars || theme).palette.grey.A100,
          "@media (hover: none)": {
            backgroundColor: (theme.vars || theme).palette.grey[300]
          },
          textDecoration: "none"
        },
        [`&.${fabClasses$1.focusVisible}`]: {
          boxShadow: (theme.vars || theme).shadows[6]
        },
        [`&.${fabClasses$1.disabled}`]: {
          color: (theme.vars || theme).palette.action.disabled,
          boxShadow: (theme.vars || theme).shadows[0],
          backgroundColor: (theme.vars || theme).palette.action.disabledBackground
        }
      }, ownerState.size === "small" && {
        width: 40,
        height: 40
      }, ownerState.size === "medium" && {
        width: 48,
        height: 48
      }, ownerState.variant === "extended" && {
        borderRadius: 48 / 2,
        padding: "0 16px",
        width: "auto",
        minHeight: "auto",
        minWidth: 48,
        height: 48
      }, ownerState.variant === "extended" && ownerState.size === "small" && {
        width: "auto",
        padding: "0 8px",
        borderRadius: 34 / 2,
        minWidth: 34,
        height: 34
      }, ownerState.variant === "extended" && ownerState.size === "medium" && {
        width: "auto",
        padding: "0 16px",
        borderRadius: 40 / 2,
        minWidth: 40,
        height: 40
      }, ownerState.color === "inherit" && {
        color: "inherit"
      });
    }, ({
      theme,
      ownerState
    }) => _extends({}, ownerState.color !== "inherit" && ownerState.color !== "default" && (theme.vars || theme).palette[ownerState.color] != null && {
      color: (theme.vars || theme).palette[ownerState.color].contrastText,
      backgroundColor: (theme.vars || theme).palette[ownerState.color].main,
      "&:hover": {
        backgroundColor: (theme.vars || theme).palette[ownerState.color].dark,
        "@media (hover: none)": {
          backgroundColor: (theme.vars || theme).palette[ownerState.color].main
        }
      }
    }));
    const Fab = /* @__PURE__ */ react.exports.forwardRef(function Fab2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiFab"
      });
      const {
        children,
        className,
        color: color2 = "default",
        component = "button",
        disabled = false,
        disableFocusRipple = false,
        focusVisibleClassName,
        size = "large",
        variant = "circular"
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$R);
      const ownerState = _extends({}, props2, {
        color: color2,
        component,
        disabled,
        disableFocusRipple,
        size,
        variant
      });
      const classes = useUtilityClasses$N(ownerState);
      return /* @__PURE__ */ jsx(FabRoot, _extends({
        className: clsx(classes.root, className),
        component,
        disabled,
        focusRipple: !disableFocusRipple,
        focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
        ownerState,
        ref
      }, other, {
        classes,
        children
      }));
    });
    const Fab$1 = Fab;
    const _excluded$Q = ["disableUnderline", "components", "componentsProps", "fullWidth", "hiddenLabel", "inputComponent", "multiline", "slotProps", "slots", "type"];
    const useUtilityClasses$M = (ownerState) => {
      const {
        classes,
        disableUnderline
      } = ownerState;
      const slots = {
        root: ["root", !disableUnderline && "underline"],
        input: ["input"]
      };
      const composedClasses = composeClasses(slots, getFilledInputUtilityClass, classes);
      return _extends({}, classes, composedClasses);
    };
    const FilledInputRoot = styled$1(InputBaseRoot, {
      shouldForwardProp: (prop) => rootShouldForwardProp$1(prop) || prop === "classes",
      name: "MuiFilledInput",
      slot: "Root",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [...rootOverridesResolver(props2, styles2), !ownerState.disableUnderline && styles2.underline];
      }
    })(({
      theme,
      ownerState
    }) => {
      var _palette;
      const light2 = theme.palette.mode === "light";
      const bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
      const backgroundColor2 = light2 ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)";
      const hoverBackground = light2 ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)";
      const disabledBackground = light2 ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
      return _extends({
        position: "relative",
        backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor2,
        borderTopLeftRadius: (theme.vars || theme).shape.borderRadius,
        borderTopRightRadius: (theme.vars || theme).shape.borderRadius,
        transition: theme.transitions.create("background-color", {
          duration: theme.transitions.duration.shorter,
          easing: theme.transitions.easing.easeOut
        }),
        "&:hover": {
          backgroundColor: theme.vars ? theme.vars.palette.FilledInput.hoverBg : hoverBackground,
          "@media (hover: none)": {
            backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor2
          }
        },
        [`&.${filledInputClasses$1.focused}`]: {
          backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor2
        },
        [`&.${filledInputClasses$1.disabled}`]: {
          backgroundColor: theme.vars ? theme.vars.palette.FilledInput.disabledBg : disabledBackground
        }
      }, !ownerState.disableUnderline && {
        "&:after": {
          borderBottom: `2px solid ${(_palette = (theme.vars || theme).palette[ownerState.color || "primary"]) == null ? void 0 : _palette.main}`,
          left: 0,
          bottom: 0,
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: theme.transitions.create("transform", {
            duration: theme.transitions.duration.shorter,
            easing: theme.transitions.easing.easeOut
          }),
          pointerEvents: "none"
        },
        [`&.${filledInputClasses$1.focused}:after`]: {
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${filledInputClasses$1.error}:after`]: {
          borderBottomColor: (theme.vars || theme).palette.error.main,
          transform: "scaleX(1)"
        },
        "&:before": {
          borderBottom: `1px solid ${theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / ${theme.vars.opacity.inputUnderline})` : bottomLineColor}`,
          left: 0,
          bottom: 0,
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: theme.transitions.create("border-bottom-color", {
            duration: theme.transitions.duration.shorter
          }),
          pointerEvents: "none"
        },
        [`&:hover:not(.${filledInputClasses$1.disabled}):before`]: {
          borderBottom: `1px solid ${(theme.vars || theme).palette.text.primary}`
        },
        [`&.${filledInputClasses$1.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      }, ownerState.startAdornment && {
        paddingLeft: 12
      }, ownerState.endAdornment && {
        paddingRight: 12
      }, ownerState.multiline && _extends({
        padding: "25px 12px 8px"
      }, ownerState.size === "small" && {
        paddingTop: 21,
        paddingBottom: 4
      }, ownerState.hiddenLabel && {
        paddingTop: 16,
        paddingBottom: 17
      }));
    });
    const FilledInputInput = styled$1(InputBaseComponent, {
      name: "MuiFilledInput",
      slot: "Input",
      overridesResolver: inputOverridesResolver
    })(({
      theme,
      ownerState
    }) => _extends({
      paddingTop: 25,
      paddingRight: 12,
      paddingBottom: 8,
      paddingLeft: 12
    }, !theme.vars && {
      "&:-webkit-autofill": {
        WebkitBoxShadow: theme.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
        WebkitTextFillColor: theme.palette.mode === "light" ? null : "#fff",
        caretColor: theme.palette.mode === "light" ? null : "#fff",
        borderTopLeftRadius: "inherit",
        borderTopRightRadius: "inherit"
      }
    }, theme.vars && {
      "&:-webkit-autofill": {
        borderTopLeftRadius: "inherit",
        borderTopRightRadius: "inherit"
      },
      [theme.getColorSchemeSelector("dark")]: {
        "&:-webkit-autofill": {
          WebkitBoxShadow: "0 0 0 100px #266798 inset",
          WebkitTextFillColor: "#fff",
          caretColor: "#fff"
        }
      }
    }, ownerState.size === "small" && {
      paddingTop: 21,
      paddingBottom: 4
    }, ownerState.hiddenLabel && {
      paddingTop: 16,
      paddingBottom: 17
    }, ownerState.multiline && {
      paddingTop: 0,
      paddingBottom: 0,
      paddingLeft: 0,
      paddingRight: 0
    }, ownerState.startAdornment && {
      paddingLeft: 0
    }, ownerState.endAdornment && {
      paddingRight: 0
    }, ownerState.hiddenLabel && ownerState.size === "small" && {
      paddingTop: 8,
      paddingBottom: 9
    }));
    const FilledInput = /* @__PURE__ */ react.exports.forwardRef(function FilledInput2(inProps, ref) {
      var _ref, _slots$root, _ref2, _slots$input;
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiFilledInput"
      });
      const {
        components = {},
        componentsProps: componentsPropsProp,
        fullWidth = false,
        inputComponent = "input",
        multiline = false,
        slotProps,
        slots = {},
        type: type2 = "text"
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$Q);
      const ownerState = _extends({}, props2, {
        fullWidth,
        inputComponent,
        multiline,
        type: type2
      });
      const classes = useUtilityClasses$M(props2);
      const filledInputComponentsProps = {
        root: {
          ownerState
        },
        input: {
          ownerState
        }
      };
      const componentsProps = (slotProps != null ? slotProps : componentsPropsProp) ? deepmerge(slotProps != null ? slotProps : componentsPropsProp, filledInputComponentsProps) : filledInputComponentsProps;
      const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : FilledInputRoot;
      const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : FilledInputInput;
      return /* @__PURE__ */ jsx(InputBase$1, _extends({
        slots: {
          root: RootSlot,
          input: InputSlot
        },
        componentsProps,
        fullWidth,
        inputComponent,
        multiline,
        ref,
        type: type2
      }, other, {
        classes
      }));
    });
    FilledInput.muiName = "Input";
    const FilledInput$1 = FilledInput;
    function getFormControlUtilityClasses(slot) {
      return generateUtilityClass("MuiFormControl", slot);
    }
    generateUtilityClasses("MuiFormControl", ["root", "marginNone", "marginNormal", "marginDense", "fullWidth", "disabled"]);
    const _excluded$P = ["children", "className", "color", "component", "disabled", "error", "focused", "fullWidth", "hiddenLabel", "margin", "required", "size", "variant"];
    const useUtilityClasses$L = (ownerState) => {
      const {
        classes,
        margin,
        fullWidth
      } = ownerState;
      const slots = {
        root: ["root", margin !== "none" && `margin${capitalize(margin)}`, fullWidth && "fullWidth"]
      };
      return composeClasses(slots, getFormControlUtilityClasses, classes);
    };
    const FormControlRoot = styled$1("div", {
      name: "MuiFormControl",
      slot: "Root",
      overridesResolver: ({
        ownerState
      }, styles2) => {
        return _extends({}, styles2.root, styles2[`margin${capitalize(ownerState.margin)}`], ownerState.fullWidth && styles2.fullWidth);
      }
    })(({
      ownerState
    }) => _extends({
      display: "inline-flex",
      flexDirection: "column",
      position: "relative",
      minWidth: 0,
      padding: 0,
      margin: 0,
      border: 0,
      verticalAlign: "top"
    }, ownerState.margin === "normal" && {
      marginTop: 16,
      marginBottom: 8
    }, ownerState.margin === "dense" && {
      marginTop: 8,
      marginBottom: 4
    }, ownerState.fullWidth && {
      width: "100%"
    }));
    const FormControl = /* @__PURE__ */ react.exports.forwardRef(function FormControl2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiFormControl"
      });
      const {
        children,
        className,
        color: color2 = "primary",
        component = "div",
        disabled = false,
        error = false,
        focused: visuallyFocused,
        fullWidth = false,
        hiddenLabel = false,
        margin = "none",
        required = false,
        size = "medium",
        variant = "outlined"
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$P);
      const ownerState = _extends({}, props2, {
        color: color2,
        component,
        disabled,
        error,
        fullWidth,
        hiddenLabel,
        margin,
        required,
        size,
        variant
      });
      const classes = useUtilityClasses$L(ownerState);
      const [adornedStart, setAdornedStart] = react.exports.useState(() => {
        let initialAdornedStart = false;
        if (children) {
          react.exports.Children.forEach(children, (child) => {
            if (!isMuiElement(child, ["Input", "Select"])) {
              return;
            }
            const input = isMuiElement(child, ["Select"]) ? child.props.input : child;
            if (input && isAdornedStart(input.props)) {
              initialAdornedStart = true;
            }
          });
        }
        return initialAdornedStart;
      });
      const [filled, setFilled] = react.exports.useState(() => {
        let initialFilled = false;
        if (children) {
          react.exports.Children.forEach(children, (child) => {
            if (!isMuiElement(child, ["Input", "Select"])) {
              return;
            }
            if (isFilled(child.props, true)) {
              initialFilled = true;
            }
          });
        }
        return initialFilled;
      });
      const [focusedState, setFocused] = react.exports.useState(false);
      if (disabled && focusedState) {
        setFocused(false);
      }
      const focused = visuallyFocused !== void 0 && !disabled ? visuallyFocused : focusedState;
      let registerEffect;
      const childContext = react.exports.useMemo(() => {
        return {
          adornedStart,
          setAdornedStart,
          color: color2,
          disabled,
          error,
          filled,
          focused,
          fullWidth,
          hiddenLabel,
          size,
          onBlur: () => {
            setFocused(false);
          },
          onEmpty: () => {
            setFilled(false);
          },
          onFilled: () => {
            setFilled(true);
          },
          onFocus: () => {
            setFocused(true);
          },
          registerEffect,
          required,
          variant
        };
      }, [adornedStart, color2, disabled, error, filled, focused, fullWidth, hiddenLabel, registerEffect, required, size, variant]);
      return /* @__PURE__ */ jsx(FormControlContext$1.Provider, {
        value: childContext,
        children: /* @__PURE__ */ jsx(FormControlRoot, _extends({
          as: component,
          ownerState,
          className: clsx(classes.root, className),
          ref
        }, other, {
          children
        }))
      });
    });
    const FormControl$1 = FormControl;
    function getFormHelperTextUtilityClasses(slot) {
      return generateUtilityClass("MuiFormHelperText", slot);
    }
    const formHelperTextClasses = generateUtilityClasses("MuiFormHelperText", ["root", "error", "disabled", "sizeSmall", "sizeMedium", "contained", "focused", "filled", "required"]);
    const formHelperTextClasses$1 = formHelperTextClasses;
    var _span$3;
    const _excluded$O = ["children", "className", "component", "disabled", "error", "filled", "focused", "margin", "required", "variant"];
    const useUtilityClasses$K = (ownerState) => {
      const {
        classes,
        contained,
        size,
        disabled,
        error,
        filled,
        focused,
        required
      } = ownerState;
      const slots = {
        root: ["root", disabled && "disabled", error && "error", size && `size${capitalize(size)}`, contained && "contained", focused && "focused", filled && "filled", required && "required"]
      };
      return composeClasses(slots, getFormHelperTextUtilityClasses, classes);
    };
    const FormHelperTextRoot = styled$1("p", {
      name: "MuiFormHelperText",
      slot: "Root",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.root, ownerState.size && styles2[`size${capitalize(ownerState.size)}`], ownerState.contained && styles2.contained, ownerState.filled && styles2.filled];
      }
    })(({
      theme,
      ownerState
    }) => _extends({
      color: (theme.vars || theme).palette.text.secondary
    }, theme.typography.caption, {
      textAlign: "left",
      marginTop: 3,
      marginRight: 0,
      marginBottom: 0,
      marginLeft: 0,
      [`&.${formHelperTextClasses$1.disabled}`]: {
        color: (theme.vars || theme).palette.text.disabled
      },
      [`&.${formHelperTextClasses$1.error}`]: {
        color: (theme.vars || theme).palette.error.main
      }
    }, ownerState.size === "small" && {
      marginTop: 4
    }, ownerState.contained && {
      marginLeft: 14,
      marginRight: 14
    }));
    const FormHelperText = /* @__PURE__ */ react.exports.forwardRef(function FormHelperText2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiFormHelperText"
      });
      const {
        children,
        className,
        component = "p"
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$O);
      const muiFormControl = useFormControl();
      const fcs = formControlState({
        props: props2,
        muiFormControl,
        states: ["variant", "size", "disabled", "error", "filled", "focused", "required"]
      });
      const ownerState = _extends({}, props2, {
        component,
        contained: fcs.variant === "filled" || fcs.variant === "outlined",
        variant: fcs.variant,
        size: fcs.size,
        disabled: fcs.disabled,
        error: fcs.error,
        filled: fcs.filled,
        focused: fcs.focused,
        required: fcs.required
      });
      const classes = useUtilityClasses$K(ownerState);
      return /* @__PURE__ */ jsx(FormHelperTextRoot, _extends({
        as: component,
        ownerState,
        className: clsx(classes.root, className),
        ref
      }, other, {
        children: children === " " ? _span$3 || (_span$3 = /* @__PURE__ */ jsx("span", {
          className: "notranslate",
          children: "\u200B"
        })) : children
      }));
    });
    const FormHelperText$1 = FormHelperText;
    function getFormLabelUtilityClasses(slot) {
      return generateUtilityClass("MuiFormLabel", slot);
    }
    const formLabelClasses = generateUtilityClasses("MuiFormLabel", ["root", "colorSecondary", "focused", "disabled", "error", "filled", "required", "asterisk"]);
    const formLabelClasses$1 = formLabelClasses;
    const _excluded$N = ["children", "className", "color", "component", "disabled", "error", "filled", "focused", "required"];
    const useUtilityClasses$J = (ownerState) => {
      const {
        classes,
        color: color2,
        focused,
        disabled,
        error,
        filled,
        required
      } = ownerState;
      const slots = {
        root: ["root", `color${capitalize(color2)}`, disabled && "disabled", error && "error", filled && "filled", focused && "focused", required && "required"],
        asterisk: ["asterisk", error && "error"]
      };
      return composeClasses(slots, getFormLabelUtilityClasses, classes);
    };
    const FormLabelRoot = styled$1("label", {
      name: "MuiFormLabel",
      slot: "Root",
      overridesResolver: ({
        ownerState
      }, styles2) => {
        return _extends({}, styles2.root, ownerState.color === "secondary" && styles2.colorSecondary, ownerState.filled && styles2.filled);
      }
    })(({
      theme,
      ownerState
    }) => _extends({
      color: (theme.vars || theme).palette.text.secondary
    }, theme.typography.body1, {
      lineHeight: "1.4375em",
      padding: 0,
      position: "relative",
      [`&.${formLabelClasses$1.focused}`]: {
        color: (theme.vars || theme).palette[ownerState.color].main
      },
      [`&.${formLabelClasses$1.disabled}`]: {
        color: (theme.vars || theme).palette.text.disabled
      },
      [`&.${formLabelClasses$1.error}`]: {
        color: (theme.vars || theme).palette.error.main
      }
    }));
    const AsteriskComponent = styled$1("span", {
      name: "MuiFormLabel",
      slot: "Asterisk",
      overridesResolver: (props2, styles2) => styles2.asterisk
    })(({
      theme
    }) => ({
      [`&.${formLabelClasses$1.error}`]: {
        color: (theme.vars || theme).palette.error.main
      }
    }));
    const FormLabel = /* @__PURE__ */ react.exports.forwardRef(function FormLabel2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiFormLabel"
      });
      const {
        children,
        className,
        component = "label"
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$N);
      const muiFormControl = useFormControl();
      const fcs = formControlState({
        props: props2,
        muiFormControl,
        states: ["color", "required", "focused", "disabled", "error", "filled"]
      });
      const ownerState = _extends({}, props2, {
        color: fcs.color || "primary",
        component,
        disabled: fcs.disabled,
        error: fcs.error,
        filled: fcs.filled,
        focused: fcs.focused,
        required: fcs.required
      });
      const classes = useUtilityClasses$J(ownerState);
      return /* @__PURE__ */ jsxs(FormLabelRoot, _extends({
        as: component,
        ownerState,
        className: clsx(classes.root, className),
        ref
      }, other, {
        children: [children, fcs.required && /* @__PURE__ */ jsxs(AsteriskComponent, {
          ownerState,
          "aria-hidden": true,
          className: classes.asterisk,
          children: ["\u2009", "*"]
        })]
      }));
    });
    const FormLabel$1 = FormLabel;
    const GridContext = /* @__PURE__ */ react.exports.createContext();
    const GridContext$1 = GridContext;
    function getGridUtilityClass(slot) {
      return generateUtilityClass("MuiGrid", slot);
    }
    const SPACINGS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    const DIRECTIONS = ["column-reverse", "column", "row-reverse", "row"];
    const WRAPS = ["nowrap", "wrap-reverse", "wrap"];
    const GRID_SIZES = ["auto", true, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
    const gridClasses = generateUtilityClasses("MuiGrid", [
      "root",
      "container",
      "item",
      "zeroMinWidth",
      ...SPACINGS.map((spacing2) => `spacing-xs-${spacing2}`),
      ...DIRECTIONS.map((direction) => `direction-xs-${direction}`),
      ...WRAPS.map((wrap2) => `wrap-xs-${wrap2}`),
      ...GRID_SIZES.map((size) => `grid-xs-${size}`),
      ...GRID_SIZES.map((size) => `grid-sm-${size}`),
      ...GRID_SIZES.map((size) => `grid-md-${size}`),
      ...GRID_SIZES.map((size) => `grid-lg-${size}`),
      ...GRID_SIZES.map((size) => `grid-xl-${size}`)
    ]);
    const _excluded$M = ["className", "columns", "columnSpacing", "component", "container", "direction", "item", "rowSpacing", "spacing", "wrap", "zeroMinWidth"];
    function getOffset(val) {
      const parse2 = parseFloat(val);
      return `${parse2}${String(val).replace(String(parse2), "") || "px"}`;
    }
    function generateGrid({
      theme,
      ownerState
    }) {
      let size;
      return theme.breakpoints.keys.reduce((globalStyles, breakpoint) => {
        let styles2 = {};
        if (ownerState[breakpoint]) {
          size = ownerState[breakpoint];
        }
        if (!size) {
          return globalStyles;
        }
        if (size === true) {
          styles2 = {
            flexBasis: 0,
            flexGrow: 1,
            maxWidth: "100%"
          };
        } else if (size === "auto") {
          styles2 = {
            flexBasis: "auto",
            flexGrow: 0,
            flexShrink: 0,
            maxWidth: "none",
            width: "auto"
          };
        } else {
          const columnsBreakpointValues = resolveBreakpointValues({
            values: ownerState.columns,
            breakpoints: theme.breakpoints.values
          });
          const columnValue = typeof columnsBreakpointValues === "object" ? columnsBreakpointValues[breakpoint] : columnsBreakpointValues;
          if (columnValue === void 0 || columnValue === null) {
            return globalStyles;
          }
          const width2 = `${Math.round(size / columnValue * 1e8) / 1e6}%`;
          let more = {};
          if (ownerState.container && ownerState.item && ownerState.columnSpacing !== 0) {
            const themeSpacing = theme.spacing(ownerState.columnSpacing);
            if (themeSpacing !== "0px") {
              const fullWidth = `calc(${width2} + ${getOffset(themeSpacing)})`;
              more = {
                flexBasis: fullWidth,
                maxWidth: fullWidth
              };
            }
          }
          styles2 = _extends({
            flexBasis: width2,
            flexGrow: 0,
            maxWidth: width2
          }, more);
        }
        if (theme.breakpoints.values[breakpoint] === 0) {
          Object.assign(globalStyles, styles2);
        } else {
          globalStyles[theme.breakpoints.up(breakpoint)] = styles2;
        }
        return globalStyles;
      }, {});
    }
    function generateDirection({
      theme,
      ownerState
    }) {
      const directionValues = resolveBreakpointValues({
        values: ownerState.direction,
        breakpoints: theme.breakpoints.values
      });
      return handleBreakpoints({
        theme
      }, directionValues, (propValue) => {
        const output = {
          flexDirection: propValue
        };
        if (propValue.indexOf("column") === 0) {
          output[`& > .${gridClasses.item}`] = {
            maxWidth: "none"
          };
        }
        return output;
      });
    }
    function extractZeroValueBreakpointKeys({
      breakpoints,
      values: values2
    }) {
      let nonZeroKey = "";
      Object.keys(values2).forEach((key) => {
        if (nonZeroKey !== "") {
          return;
        }
        if (values2[key] !== 0) {
          nonZeroKey = key;
        }
      });
      const sortedBreakpointKeysByValue = Object.keys(breakpoints).sort((a, b2) => {
        return breakpoints[a] - breakpoints[b2];
      });
      return sortedBreakpointKeysByValue.slice(0, sortedBreakpointKeysByValue.indexOf(nonZeroKey));
    }
    function generateRowGap({
      theme,
      ownerState
    }) {
      const {
        container,
        rowSpacing
      } = ownerState;
      let styles2 = {};
      if (container && rowSpacing !== 0) {
        const rowSpacingValues = resolveBreakpointValues({
          values: rowSpacing,
          breakpoints: theme.breakpoints.values
        });
        let zeroValueBreakpointKeys;
        if (typeof rowSpacingValues === "object") {
          zeroValueBreakpointKeys = extractZeroValueBreakpointKeys({
            breakpoints: theme.breakpoints.values,
            values: rowSpacingValues
          });
        }
        styles2 = handleBreakpoints({
          theme
        }, rowSpacingValues, (propValue, breakpoint) => {
          var _zeroValueBreakpointK;
          const themeSpacing = theme.spacing(propValue);
          if (themeSpacing !== "0px") {
            return {
              marginTop: `-${getOffset(themeSpacing)}`,
              [`& > .${gridClasses.item}`]: {
                paddingTop: getOffset(themeSpacing)
              }
            };
          }
          if ((_zeroValueBreakpointK = zeroValueBreakpointKeys) != null && _zeroValueBreakpointK.includes(breakpoint)) {
            return {};
          }
          return {
            marginTop: 0,
            [`& > .${gridClasses.item}`]: {
              paddingTop: 0
            }
          };
        });
      }
      return styles2;
    }
    function generateColumnGap({
      theme,
      ownerState
    }) {
      const {
        container,
        columnSpacing
      } = ownerState;
      let styles2 = {};
      if (container && columnSpacing !== 0) {
        const columnSpacingValues = resolveBreakpointValues({
          values: columnSpacing,
          breakpoints: theme.breakpoints.values
        });
        let zeroValueBreakpointKeys;
        if (typeof columnSpacingValues === "object") {
          zeroValueBreakpointKeys = extractZeroValueBreakpointKeys({
            breakpoints: theme.breakpoints.values,
            values: columnSpacingValues
          });
        }
        styles2 = handleBreakpoints({
          theme
        }, columnSpacingValues, (propValue, breakpoint) => {
          var _zeroValueBreakpointK2;
          const themeSpacing = theme.spacing(propValue);
          if (themeSpacing !== "0px") {
            return {
              width: `calc(100% + ${getOffset(themeSpacing)})`,
              marginLeft: `-${getOffset(themeSpacing)}`,
              [`& > .${gridClasses.item}`]: {
                paddingLeft: getOffset(themeSpacing)
              }
            };
          }
          if ((_zeroValueBreakpointK2 = zeroValueBreakpointKeys) != null && _zeroValueBreakpointK2.includes(breakpoint)) {
            return {};
          }
          return {
            width: "100%",
            marginLeft: 0,
            [`& > .${gridClasses.item}`]: {
              paddingLeft: 0
            }
          };
        });
      }
      return styles2;
    }
    function resolveSpacingStyles(spacing2, breakpoints, styles2 = {}) {
      if (!spacing2 || spacing2 <= 0) {
        return [];
      }
      if (typeof spacing2 === "string" && !Number.isNaN(Number(spacing2)) || typeof spacing2 === "number") {
        return [styles2[`spacing-xs-${String(spacing2)}`]];
      }
      const spacingStyles = [];
      breakpoints.forEach((breakpoint) => {
        const value = spacing2[breakpoint];
        if (Number(value) > 0) {
          spacingStyles.push(styles2[`spacing-${breakpoint}-${String(value)}`]);
        }
      });
      return spacingStyles;
    }
    const GridRoot = styled$1("div", {
      name: "MuiGrid",
      slot: "Root",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        const {
          container,
          direction,
          item,
          spacing: spacing2,
          wrap: wrap2,
          zeroMinWidth,
          breakpoints
        } = ownerState;
        let spacingStyles = [];
        if (container) {
          spacingStyles = resolveSpacingStyles(spacing2, breakpoints, styles2);
        }
        const breakpointsStyles = [];
        breakpoints.forEach((breakpoint) => {
          const value = ownerState[breakpoint];
          if (value) {
            breakpointsStyles.push(styles2[`grid-${breakpoint}-${String(value)}`]);
          }
        });
        return [styles2.root, container && styles2.container, item && styles2.item, zeroMinWidth && styles2.zeroMinWidth, ...spacingStyles, direction !== "row" && styles2[`direction-xs-${String(direction)}`], wrap2 !== "wrap" && styles2[`wrap-xs-${String(wrap2)}`], ...breakpointsStyles];
      }
    })(({
      ownerState
    }) => _extends({
      boxSizing: "border-box"
    }, ownerState.container && {
      display: "flex",
      flexWrap: "wrap",
      width: "100%"
    }, ownerState.item && {
      margin: 0
    }, ownerState.zeroMinWidth && {
      minWidth: 0
    }, ownerState.wrap !== "wrap" && {
      flexWrap: ownerState.wrap
    }), generateDirection, generateRowGap, generateColumnGap, generateGrid);
    function resolveSpacingClasses(spacing2, breakpoints) {
      if (!spacing2 || spacing2 <= 0) {
        return [];
      }
      if (typeof spacing2 === "string" && !Number.isNaN(Number(spacing2)) || typeof spacing2 === "number") {
        return [`spacing-xs-${String(spacing2)}`];
      }
      const classes = [];
      breakpoints.forEach((breakpoint) => {
        const value = spacing2[breakpoint];
        if (Number(value) > 0) {
          const className = `spacing-${breakpoint}-${String(value)}`;
          classes.push(className);
        }
      });
      return classes;
    }
    const useUtilityClasses$I = (ownerState) => {
      const {
        classes,
        container,
        direction,
        item,
        spacing: spacing2,
        wrap: wrap2,
        zeroMinWidth,
        breakpoints
      } = ownerState;
      let spacingClasses = [];
      if (container) {
        spacingClasses = resolveSpacingClasses(spacing2, breakpoints);
      }
      const breakpointsClasses = [];
      breakpoints.forEach((breakpoint) => {
        const value = ownerState[breakpoint];
        if (value) {
          breakpointsClasses.push(`grid-${breakpoint}-${String(value)}`);
        }
      });
      const slots = {
        root: ["root", container && "container", item && "item", zeroMinWidth && "zeroMinWidth", ...spacingClasses, direction !== "row" && `direction-xs-${String(direction)}`, wrap2 !== "wrap" && `wrap-xs-${String(wrap2)}`, ...breakpointsClasses]
      };
      return composeClasses(slots, getGridUtilityClass, classes);
    };
    const Grid = /* @__PURE__ */ react.exports.forwardRef(function Grid2(inProps, ref) {
      const themeProps = useThemeProps({
        props: inProps,
        name: "MuiGrid"
      });
      const {
        breakpoints
      } = useTheme();
      const props2 = extendSxProp(themeProps);
      const {
        className,
        columns: columnsProp,
        columnSpacing: columnSpacingProp,
        component = "div",
        container = false,
        direction = "row",
        item = false,
        rowSpacing: rowSpacingProp,
        spacing: spacing2 = 0,
        wrap: wrap2 = "wrap",
        zeroMinWidth = false
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$M);
      const rowSpacing = rowSpacingProp || spacing2;
      const columnSpacing = columnSpacingProp || spacing2;
      const columnsContext = react.exports.useContext(GridContext$1);
      const columns = container ? columnsProp || 12 : columnsContext;
      const breakpointsValues = {};
      const otherFiltered = _extends({}, other);
      breakpoints.keys.forEach((breakpoint) => {
        if (other[breakpoint] != null) {
          breakpointsValues[breakpoint] = other[breakpoint];
          delete otherFiltered[breakpoint];
        }
      });
      const ownerState = _extends({}, props2, {
        columns,
        container,
        direction,
        item,
        rowSpacing,
        columnSpacing,
        wrap: wrap2,
        zeroMinWidth,
        spacing: spacing2
      }, breakpointsValues, {
        breakpoints: breakpoints.keys
      });
      const classes = useUtilityClasses$I(ownerState);
      return /* @__PURE__ */ jsx(GridContext$1.Provider, {
        value: columns,
        children: /* @__PURE__ */ jsx(GridRoot, _extends({
          ownerState,
          className: clsx(classes.root, className),
          as: component,
          ref
        }, otherFiltered))
      });
    });
    const Grid$1 = Grid;
    const _excluded$L = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
    function getScale(value) {
      return `scale(${value}, ${value ** 2})`;
    }
    const styles$1 = {
      entering: {
        opacity: 1,
        transform: getScale(1)
      },
      entered: {
        opacity: 1,
        transform: "none"
      }
    };
    const isWebKit154 = typeof navigator !== "undefined" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent);
    const Grow = /* @__PURE__ */ react.exports.forwardRef(function Grow2(props2, ref) {
      const {
        addEndListener,
        appear = true,
        children,
        easing: easing2,
        in: inProp,
        onEnter,
        onEntered,
        onEntering,
        onExit,
        onExited,
        onExiting,
        style: style2,
        timeout = "auto",
        TransitionComponent = Transition$1
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$L);
      const timer = react.exports.useRef();
      const autoTimeout = react.exports.useRef();
      const theme = useTheme();
      const nodeRef = react.exports.useRef(null);
      const handleRef = useForkRef(nodeRef, children.ref, ref);
      const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
        if (callback) {
          const node2 = nodeRef.current;
          if (maybeIsAppearing === void 0) {
            callback(node2);
          } else {
            callback(node2, maybeIsAppearing);
          }
        }
      };
      const handleEntering = normalizedTransitionCallback(onEntering);
      const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
        reflow(node2);
        const {
          duration: transitionDuration,
          delay,
          easing: transitionTimingFunction
        } = getTransitionProps({
          style: style2,
          timeout,
          easing: easing2
        }, {
          mode: "enter"
        });
        let duration2;
        if (timeout === "auto") {
          duration2 = theme.transitions.getAutoHeightDuration(node2.clientHeight);
          autoTimeout.current = duration2;
        } else {
          duration2 = transitionDuration;
        }
        node2.style.transition = [theme.transitions.create("opacity", {
          duration: duration2,
          delay
        }), theme.transitions.create("transform", {
          duration: isWebKit154 ? duration2 : duration2 * 0.666,
          delay,
          easing: transitionTimingFunction
        })].join(",");
        if (onEnter) {
          onEnter(node2, isAppearing);
        }
      });
      const handleEntered = normalizedTransitionCallback(onEntered);
      const handleExiting = normalizedTransitionCallback(onExiting);
      const handleExit = normalizedTransitionCallback((node2) => {
        const {
          duration: transitionDuration,
          delay,
          easing: transitionTimingFunction
        } = getTransitionProps({
          style: style2,
          timeout,
          easing: easing2
        }, {
          mode: "exit"
        });
        let duration2;
        if (timeout === "auto") {
          duration2 = theme.transitions.getAutoHeightDuration(node2.clientHeight);
          autoTimeout.current = duration2;
        } else {
          duration2 = transitionDuration;
        }
        node2.style.transition = [theme.transitions.create("opacity", {
          duration: duration2,
          delay
        }), theme.transitions.create("transform", {
          duration: isWebKit154 ? duration2 : duration2 * 0.666,
          delay: isWebKit154 ? delay : delay || duration2 * 0.333,
          easing: transitionTimingFunction
        })].join(",");
        node2.style.opacity = 0;
        node2.style.transform = getScale(0.75);
        if (onExit) {
          onExit(node2);
        }
      });
      const handleExited = normalizedTransitionCallback(onExited);
      const handleAddEndListener = (next2) => {
        if (timeout === "auto") {
          timer.current = setTimeout(next2, autoTimeout.current || 0);
        }
        if (addEndListener) {
          addEndListener(nodeRef.current, next2);
        }
      };
      react.exports.useEffect(() => {
        return () => {
          clearTimeout(timer.current);
        };
      }, []);
      return /* @__PURE__ */ jsx(TransitionComponent, _extends({
        appear,
        in: inProp,
        nodeRef,
        onEnter: handleEnter,
        onEntered: handleEntered,
        onEntering: handleEntering,
        onExit: handleExit,
        onExited: handleExited,
        onExiting: handleExiting,
        addEndListener: handleAddEndListener,
        timeout: timeout === "auto" ? null : timeout
      }, other, {
        children: (state, childProps) => {
          return /* @__PURE__ */ react.exports.cloneElement(children, _extends({
            style: _extends({
              opacity: 0,
              transform: getScale(0.75),
              visibility: state === "exited" && !inProp ? "hidden" : void 0
            }, styles$1[state], style2, children.props.style),
            ref: handleRef
          }, childProps));
        }
      }));
    });
    Grow.muiSupportAuto = true;
    const Grow$1 = Grow;
    const _excluded$K = ["disableUnderline", "components", "componentsProps", "fullWidth", "inputComponent", "multiline", "slotProps", "slots", "type"];
    const useUtilityClasses$H = (ownerState) => {
      const {
        classes,
        disableUnderline
      } = ownerState;
      const slots = {
        root: ["root", !disableUnderline && "underline"],
        input: ["input"]
      };
      const composedClasses = composeClasses(slots, getInputUtilityClass, classes);
      return _extends({}, classes, composedClasses);
    };
    const InputRoot = styled$1(InputBaseRoot, {
      shouldForwardProp: (prop) => rootShouldForwardProp$1(prop) || prop === "classes",
      name: "MuiInput",
      slot: "Root",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [...rootOverridesResolver(props2, styles2), !ownerState.disableUnderline && styles2.underline];
      }
    })(({
      theme,
      ownerState
    }) => {
      const light2 = theme.palette.mode === "light";
      let bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
      if (theme.vars) {
        bottomLineColor = `rgba(${theme.vars.palette.common.onBackgroundChannel} / ${theme.vars.opacity.inputUnderline})`;
      }
      return _extends({
        position: "relative"
      }, ownerState.formControl && {
        "label + &": {
          marginTop: 16
        }
      }, !ownerState.disableUnderline && {
        "&:after": {
          borderBottom: `2px solid ${(theme.vars || theme).palette[ownerState.color].main}`,
          left: 0,
          bottom: 0,
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: theme.transitions.create("transform", {
            duration: theme.transitions.duration.shorter,
            easing: theme.transitions.easing.easeOut
          }),
          pointerEvents: "none"
        },
        [`&.${inputClasses$1.focused}:after`]: {
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${inputClasses$1.error}:after`]: {
          borderBottomColor: (theme.vars || theme).palette.error.main,
          transform: "scaleX(1)"
        },
        "&:before": {
          borderBottom: `1px solid ${bottomLineColor}`,
          left: 0,
          bottom: 0,
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: theme.transitions.create("border-bottom-color", {
            duration: theme.transitions.duration.shorter
          }),
          pointerEvents: "none"
        },
        [`&:hover:not(.${inputClasses$1.disabled}):before`]: {
          borderBottom: `2px solid ${(theme.vars || theme).palette.text.primary}`,
          "@media (hover: none)": {
            borderBottom: `1px solid ${bottomLineColor}`
          }
        },
        [`&.${inputClasses$1.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      });
    });
    const InputInput = styled$1(InputBaseComponent, {
      name: "MuiInput",
      slot: "Input",
      overridesResolver: inputOverridesResolver
    })({});
    const Input = /* @__PURE__ */ react.exports.forwardRef(function Input2(inProps, ref) {
      var _ref, _slots$root, _ref2, _slots$input;
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiInput"
      });
      const {
        disableUnderline,
        components = {},
        componentsProps: componentsPropsProp,
        fullWidth = false,
        inputComponent = "input",
        multiline = false,
        slotProps,
        slots = {},
        type: type2 = "text"
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$K);
      const classes = useUtilityClasses$H(props2);
      const ownerState = {
        disableUnderline
      };
      const inputComponentsProps = {
        root: {
          ownerState
        }
      };
      const componentsProps = (slotProps != null ? slotProps : componentsPropsProp) ? deepmerge(slotProps != null ? slotProps : componentsPropsProp, inputComponentsProps) : inputComponentsProps;
      const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : InputRoot;
      const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : InputInput;
      return /* @__PURE__ */ jsx(InputBase$1, _extends({
        slots: {
          root: RootSlot,
          input: InputSlot
        },
        slotProps: componentsProps,
        fullWidth,
        inputComponent,
        multiline,
        ref,
        type: type2
      }, other, {
        classes
      }));
    });
    Input.muiName = "Input";
    const Input$1 = Input;
    function getInputAdornmentUtilityClass(slot) {
      return generateUtilityClass("MuiInputAdornment", slot);
    }
    const inputAdornmentClasses = generateUtilityClasses("MuiInputAdornment", ["root", "filled", "standard", "outlined", "positionStart", "positionEnd", "disablePointerEvents", "hiddenLabel", "sizeSmall"]);
    const inputAdornmentClasses$1 = inputAdornmentClasses;
    var _span$2;
    const _excluded$J = ["children", "className", "component", "disablePointerEvents", "disableTypography", "position", "variant"];
    const overridesResolver$4 = (props2, styles2) => {
      const {
        ownerState
      } = props2;
      return [styles2.root, styles2[`position${capitalize(ownerState.position)}`], ownerState.disablePointerEvents === true && styles2.disablePointerEvents, styles2[ownerState.variant]];
    };
    const useUtilityClasses$G = (ownerState) => {
      const {
        classes,
        disablePointerEvents,
        hiddenLabel,
        position: position2,
        size,
        variant
      } = ownerState;
      const slots = {
        root: ["root", disablePointerEvents && "disablePointerEvents", position2 && `position${capitalize(position2)}`, variant, hiddenLabel && "hiddenLabel", size && `size${capitalize(size)}`]
      };
      return composeClasses(slots, getInputAdornmentUtilityClass, classes);
    };
    const InputAdornmentRoot = styled$1("div", {
      name: "MuiInputAdornment",
      slot: "Root",
      overridesResolver: overridesResolver$4
    })(({
      theme,
      ownerState
    }) => _extends({
      display: "flex",
      height: "0.01em",
      maxHeight: "2em",
      alignItems: "center",
      whiteSpace: "nowrap",
      color: (theme.vars || theme).palette.action.active
    }, ownerState.variant === "filled" && {
      [`&.${inputAdornmentClasses$1.positionStart}&:not(.${inputAdornmentClasses$1.hiddenLabel})`]: {
        marginTop: 16
      }
    }, ownerState.position === "start" && {
      marginRight: 8
    }, ownerState.position === "end" && {
      marginLeft: 8
    }, ownerState.disablePointerEvents === true && {
      pointerEvents: "none"
    }));
    const InputAdornment = /* @__PURE__ */ react.exports.forwardRef(function InputAdornment2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiInputAdornment"
      });
      const {
        children,
        className,
        component = "div",
        disablePointerEvents = false,
        disableTypography = false,
        position: position2,
        variant: variantProp
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$J);
      const muiFormControl = useFormControl() || {};
      let variant = variantProp;
      if (variantProp && muiFormControl.variant)
        ;
      if (muiFormControl && !variant) {
        variant = muiFormControl.variant;
      }
      const ownerState = _extends({}, props2, {
        hiddenLabel: muiFormControl.hiddenLabel,
        size: muiFormControl.size,
        disablePointerEvents,
        position: position2,
        variant
      });
      const classes = useUtilityClasses$G(ownerState);
      return /* @__PURE__ */ jsx(FormControlContext$1.Provider, {
        value: null,
        children: /* @__PURE__ */ jsx(InputAdornmentRoot, _extends({
          as: component,
          ownerState,
          className: clsx(classes.root, className),
          ref
        }, other, {
          children: typeof children === "string" && !disableTypography ? /* @__PURE__ */ jsx(Typography$1, {
            color: "text.secondary",
            children
          }) : /* @__PURE__ */ jsxs(react.exports.Fragment, {
            children: [position2 === "start" ? _span$2 || (_span$2 = /* @__PURE__ */ jsx("span", {
              className: "notranslate",
              children: "\u200B"
            })) : null, children]
          })
        }))
      });
    });
    const InputAdornment$1 = InputAdornment;
    function getInputLabelUtilityClasses(slot) {
      return generateUtilityClass("MuiInputLabel", slot);
    }
    generateUtilityClasses("MuiInputLabel", ["root", "focused", "disabled", "error", "required", "asterisk", "formControl", "sizeSmall", "shrink", "animated", "standard", "filled", "outlined"]);
    const _excluded$I = ["disableAnimation", "margin", "shrink", "variant", "className"];
    const useUtilityClasses$F = (ownerState) => {
      const {
        classes,
        formControl,
        size,
        shrink,
        disableAnimation,
        variant,
        required
      } = ownerState;
      const slots = {
        root: ["root", formControl && "formControl", !disableAnimation && "animated", shrink && "shrink", size === "small" && "sizeSmall", variant],
        asterisk: [required && "asterisk"]
      };
      const composedClasses = composeClasses(slots, getInputLabelUtilityClasses, classes);
      return _extends({}, classes, composedClasses);
    };
    const InputLabelRoot = styled$1(FormLabel$1, {
      shouldForwardProp: (prop) => rootShouldForwardProp$1(prop) || prop === "classes",
      name: "MuiInputLabel",
      slot: "Root",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [{
          [`& .${formLabelClasses$1.asterisk}`]: styles2.asterisk
        }, styles2.root, ownerState.formControl && styles2.formControl, ownerState.size === "small" && styles2.sizeSmall, ownerState.shrink && styles2.shrink, !ownerState.disableAnimation && styles2.animated, styles2[ownerState.variant]];
      }
    })(({
      theme,
      ownerState
    }) => _extends({
      display: "block",
      transformOrigin: "top left",
      whiteSpace: "nowrap",
      overflow: "hidden",
      textOverflow: "ellipsis",
      maxWidth: "100%"
    }, ownerState.formControl && {
      position: "absolute",
      left: 0,
      top: 0,
      transform: "translate(0, 20px) scale(1)"
    }, ownerState.size === "small" && {
      transform: "translate(0, 17px) scale(1)"
    }, ownerState.shrink && {
      transform: "translate(0, -1.5px) scale(0.75)",
      transformOrigin: "top left",
      maxWidth: "133%"
    }, !ownerState.disableAnimation && {
      transition: theme.transitions.create(["color", "transform", "max-width"], {
        duration: theme.transitions.duration.shorter,
        easing: theme.transitions.easing.easeOut
      })
    }, ownerState.variant === "filled" && _extends({
      zIndex: 1,
      pointerEvents: "none",
      transform: "translate(12px, 16px) scale(1)",
      maxWidth: "calc(100% - 24px)"
    }, ownerState.size === "small" && {
      transform: "translate(12px, 13px) scale(1)"
    }, ownerState.shrink && _extends({
      userSelect: "none",
      pointerEvents: "auto",
      transform: "translate(12px, 7px) scale(0.75)",
      maxWidth: "calc(133% - 24px)"
    }, ownerState.size === "small" && {
      transform: "translate(12px, 4px) scale(0.75)"
    })), ownerState.variant === "outlined" && _extends({
      zIndex: 1,
      pointerEvents: "none",
      transform: "translate(14px, 16px) scale(1)",
      maxWidth: "calc(100% - 24px)"
    }, ownerState.size === "small" && {
      transform: "translate(14px, 9px) scale(1)"
    }, ownerState.shrink && {
      userSelect: "none",
      pointerEvents: "auto",
      maxWidth: "calc(133% - 24px)",
      transform: "translate(14px, -9px) scale(0.75)"
    })));
    const InputLabel = /* @__PURE__ */ react.exports.forwardRef(function InputLabel2(inProps, ref) {
      const props2 = useThemeProps({
        name: "MuiInputLabel",
        props: inProps
      });
      const {
        disableAnimation = false,
        shrink: shrinkProp,
        className
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$I);
      const muiFormControl = useFormControl();
      let shrink = shrinkProp;
      if (typeof shrink === "undefined" && muiFormControl) {
        shrink = muiFormControl.filled || muiFormControl.focused || muiFormControl.adornedStart;
      }
      const fcs = formControlState({
        props: props2,
        muiFormControl,
        states: ["size", "variant", "required"]
      });
      const ownerState = _extends({}, props2, {
        disableAnimation,
        formControl: muiFormControl,
        shrink,
        size: fcs.size,
        variant: fcs.variant,
        required: fcs.required
      });
      const classes = useUtilityClasses$F(ownerState);
      return /* @__PURE__ */ jsx(InputLabelRoot, _extends({
        "data-shrink": shrink,
        ownerState,
        ref,
        className: clsx(classes.root, className)
      }, other, {
        classes
      }));
    });
    const InputLabel$1 = InputLabel;
    function getLinearProgressUtilityClass(slot) {
      return generateUtilityClass("MuiLinearProgress", slot);
    }
    generateUtilityClasses("MuiLinearProgress", ["root", "colorPrimary", "colorSecondary", "determinate", "indeterminate", "buffer", "query", "dashed", "dashedColorPrimary", "dashedColorSecondary", "bar", "barColorPrimary", "barColorSecondary", "bar1Indeterminate", "bar1Determinate", "bar1Buffer", "bar2Indeterminate", "bar2Buffer"]);
    const _excluded$H = ["className", "color", "value", "valueBuffer", "variant"];
    let _ = (t2) => t2, _t, _t2, _t3, _t4, _t5, _t6;
    const TRANSITION_DURATION = 4;
    const indeterminate1Keyframe = keyframes(_t || (_t = _`
  0% {
    left: -35%;
    right: 100%;
  }

  60% {
    left: 100%;
    right: -90%;
  }

  100% {
    left: 100%;
    right: -90%;
  }
`));
    const indeterminate2Keyframe = keyframes(_t2 || (_t2 = _`
  0% {
    left: -200%;
    right: 100%;
  }

  60% {
    left: 107%;
    right: -8%;
  }

  100% {
    left: 107%;
    right: -8%;
  }
`));
    const bufferKeyframe = keyframes(_t3 || (_t3 = _`
  0% {
    opacity: 1;
    background-position: 0 -23px;
  }

  60% {
    opacity: 0;
    background-position: 0 -23px;
  }

  100% {
    opacity: 1;
    background-position: -200px -23px;
  }
`));
    const useUtilityClasses$E = (ownerState) => {
      const {
        classes,
        variant,
        color: color2
      } = ownerState;
      const slots = {
        root: ["root", `color${capitalize(color2)}`, variant],
        dashed: ["dashed", `dashedColor${capitalize(color2)}`],
        bar1: ["bar", `barColor${capitalize(color2)}`, (variant === "indeterminate" || variant === "query") && "bar1Indeterminate", variant === "determinate" && "bar1Determinate", variant === "buffer" && "bar1Buffer"],
        bar2: ["bar", variant !== "buffer" && `barColor${capitalize(color2)}`, variant === "buffer" && `color${capitalize(color2)}`, (variant === "indeterminate" || variant === "query") && "bar2Indeterminate", variant === "buffer" && "bar2Buffer"]
      };
      return composeClasses(slots, getLinearProgressUtilityClass, classes);
    };
    const getColorShade = (theme, color2) => {
      if (color2 === "inherit") {
        return "currentColor";
      }
      if (theme.vars) {
        return theme.vars.palette.LinearProgress[`${color2}Bg`];
      }
      return theme.palette.mode === "light" ? lighten(theme.palette[color2].main, 0.62) : darken(theme.palette[color2].main, 0.5);
    };
    const LinearProgressRoot = styled$1("span", {
      name: "MuiLinearProgress",
      slot: "Root",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.root, styles2[`color${capitalize(ownerState.color)}`], styles2[ownerState.variant]];
      }
    })(({
      ownerState,
      theme
    }) => _extends({
      position: "relative",
      overflow: "hidden",
      display: "block",
      height: 4,
      zIndex: 0,
      "@media print": {
        colorAdjust: "exact"
      },
      backgroundColor: getColorShade(theme, ownerState.color)
    }, ownerState.color === "inherit" && ownerState.variant !== "buffer" && {
      backgroundColor: "none",
      "&::before": {
        content: '""',
        position: "absolute",
        left: 0,
        top: 0,
        right: 0,
        bottom: 0,
        backgroundColor: "currentColor",
        opacity: 0.3
      }
    }, ownerState.variant === "buffer" && {
      backgroundColor: "transparent"
    }, ownerState.variant === "query" && {
      transform: "rotate(180deg)"
    }));
    const LinearProgressDashed = styled$1("span", {
      name: "MuiLinearProgress",
      slot: "Dashed",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.dashed, styles2[`dashedColor${capitalize(ownerState.color)}`]];
      }
    })(({
      ownerState,
      theme
    }) => {
      const backgroundColor2 = getColorShade(theme, ownerState.color);
      return _extends({
        position: "absolute",
        marginTop: 0,
        height: "100%",
        width: "100%"
      }, ownerState.color === "inherit" && {
        opacity: 0.3
      }, {
        backgroundImage: `radial-gradient(${backgroundColor2} 0%, ${backgroundColor2} 16%, transparent 42%)`,
        backgroundSize: "10px 10px",
        backgroundPosition: "0 -23px"
      });
    }, css(_t4 || (_t4 = _`
    animation: ${0} 3s infinite linear;
  `), bufferKeyframe));
    const LinearProgressBar1 = styled$1("span", {
      name: "MuiLinearProgress",
      slot: "Bar1",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.bar, styles2[`barColor${capitalize(ownerState.color)}`], (ownerState.variant === "indeterminate" || ownerState.variant === "query") && styles2.bar1Indeterminate, ownerState.variant === "determinate" && styles2.bar1Determinate, ownerState.variant === "buffer" && styles2.bar1Buffer];
      }
    })(({
      ownerState,
      theme
    }) => _extends({
      width: "100%",
      position: "absolute",
      left: 0,
      bottom: 0,
      top: 0,
      transition: "transform 0.2s linear",
      transformOrigin: "left",
      backgroundColor: ownerState.color === "inherit" ? "currentColor" : (theme.vars || theme).palette[ownerState.color].main
    }, ownerState.variant === "determinate" && {
      transition: `transform .${TRANSITION_DURATION}s linear`
    }, ownerState.variant === "buffer" && {
      zIndex: 1,
      transition: `transform .${TRANSITION_DURATION}s linear`
    }), ({
      ownerState
    }) => (ownerState.variant === "indeterminate" || ownerState.variant === "query") && css(_t5 || (_t5 = _`
      width: auto;
      animation: ${0} 2.1s cubic-bezier(0.65, 0.815, 0.735, 0.395) infinite;
    `), indeterminate1Keyframe));
    const LinearProgressBar2 = styled$1("span", {
      name: "MuiLinearProgress",
      slot: "Bar2",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.bar, styles2[`barColor${capitalize(ownerState.color)}`], (ownerState.variant === "indeterminate" || ownerState.variant === "query") && styles2.bar2Indeterminate, ownerState.variant === "buffer" && styles2.bar2Buffer];
      }
    })(({
      ownerState,
      theme
    }) => _extends({
      width: "100%",
      position: "absolute",
      left: 0,
      bottom: 0,
      top: 0,
      transition: "transform 0.2s linear",
      transformOrigin: "left"
    }, ownerState.variant !== "buffer" && {
      backgroundColor: ownerState.color === "inherit" ? "currentColor" : (theme.vars || theme).palette[ownerState.color].main
    }, ownerState.color === "inherit" && {
      opacity: 0.3
    }, ownerState.variant === "buffer" && {
      backgroundColor: getColorShade(theme, ownerState.color),
      transition: `transform .${TRANSITION_DURATION}s linear`
    }), ({
      ownerState
    }) => (ownerState.variant === "indeterminate" || ownerState.variant === "query") && css(_t6 || (_t6 = _`
      width: auto;
      animation: ${0} 2.1s cubic-bezier(0.165, 0.84, 0.44, 1) 1.15s infinite;
    `), indeterminate2Keyframe));
    const LinearProgress = /* @__PURE__ */ react.exports.forwardRef(function LinearProgress2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiLinearProgress"
      });
      const {
        className,
        color: color2 = "primary",
        value,
        valueBuffer,
        variant = "indeterminate"
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$H);
      const ownerState = _extends({}, props2, {
        color: color2,
        variant
      });
      const classes = useUtilityClasses$E(ownerState);
      const theme = useTheme();
      const rootProps = {};
      const inlineStyles = {
        bar1: {},
        bar2: {}
      };
      if (variant === "determinate" || variant === "buffer") {
        if (value !== void 0) {
          rootProps["aria-valuenow"] = Math.round(value);
          rootProps["aria-valuemin"] = 0;
          rootProps["aria-valuemax"] = 100;
          let transform2 = value - 100;
          if (theme.direction === "rtl") {
            transform2 = -transform2;
          }
          inlineStyles.bar1.transform = `translateX(${transform2}%)`;
        }
      }
      if (variant === "buffer") {
        if (valueBuffer !== void 0) {
          let transform2 = (valueBuffer || 0) - 100;
          if (theme.direction === "rtl") {
            transform2 = -transform2;
          }
          inlineStyles.bar2.transform = `translateX(${transform2}%)`;
        }
      }
      return /* @__PURE__ */ jsxs(LinearProgressRoot, _extends({
        className: clsx(classes.root, className),
        ownerState,
        role: "progressbar"
      }, rootProps, {
        ref
      }, other, {
        children: [variant === "buffer" ? /* @__PURE__ */ jsx(LinearProgressDashed, {
          className: classes.dashed,
          ownerState
        }) : null, /* @__PURE__ */ jsx(LinearProgressBar1, {
          className: classes.bar1,
          ownerState,
          style: inlineStyles.bar1
        }), variant === "determinate" ? null : /* @__PURE__ */ jsx(LinearProgressBar2, {
          className: classes.bar2,
          ownerState,
          style: inlineStyles.bar2
        })]
      }));
    });
    const LinearProgress$1 = LinearProgress;
    const ListContext = /* @__PURE__ */ react.exports.createContext({});
    const ListContext$1 = ListContext;
    function getListUtilityClass(slot) {
      return generateUtilityClass("MuiList", slot);
    }
    generateUtilityClasses("MuiList", ["root", "padding", "dense", "subheader"]);
    const _excluded$G = ["children", "className", "component", "dense", "disablePadding", "subheader"];
    const useUtilityClasses$D = (ownerState) => {
      const {
        classes,
        disablePadding,
        dense,
        subheader
      } = ownerState;
      const slots = {
        root: ["root", !disablePadding && "padding", dense && "dense", subheader && "subheader"]
      };
      return composeClasses(slots, getListUtilityClass, classes);
    };
    const ListRoot = styled$1("ul", {
      name: "MuiList",
      slot: "Root",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.root, !ownerState.disablePadding && styles2.padding, ownerState.dense && styles2.dense, ownerState.subheader && styles2.subheader];
      }
    })(({
      ownerState
    }) => _extends({
      listStyle: "none",
      margin: 0,
      padding: 0,
      position: "relative"
    }, !ownerState.disablePadding && {
      paddingTop: 8,
      paddingBottom: 8
    }, ownerState.subheader && {
      paddingTop: 0
    }));
    const List = /* @__PURE__ */ react.exports.forwardRef(function List2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiList"
      });
      const {
        children,
        className,
        component = "ul",
        dense = false,
        disablePadding = false,
        subheader
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$G);
      const context = react.exports.useMemo(() => ({
        dense
      }), [dense]);
      const ownerState = _extends({}, props2, {
        component,
        dense,
        disablePadding
      });
      const classes = useUtilityClasses$D(ownerState);
      return /* @__PURE__ */ jsx(ListContext$1.Provider, {
        value: context,
        children: /* @__PURE__ */ jsxs(ListRoot, _extends({
          as: component,
          className: clsx(classes.root, className),
          ref,
          ownerState
        }, other, {
          children: [subheader, children]
        }))
      });
    });
    const List$1 = List;
    function getListItemUtilityClass(slot) {
      return generateUtilityClass("MuiListItem", slot);
    }
    const listItemClasses = generateUtilityClasses("MuiListItem", ["root", "container", "focusVisible", "dense", "alignItemsFlexStart", "disabled", "divider", "gutters", "padding", "button", "secondaryAction", "selected"]);
    const listItemClasses$1 = listItemClasses;
    function getListItemButtonUtilityClass(slot) {
      return generateUtilityClass("MuiListItemButton", slot);
    }
    const listItemButtonClasses = generateUtilityClasses("MuiListItemButton", ["root", "focusVisible", "dense", "alignItemsFlexStart", "disabled", "divider", "gutters", "selected"]);
    const listItemButtonClasses$1 = listItemButtonClasses;
    const _excluded$F = ["alignItems", "autoFocus", "component", "children", "dense", "disableGutters", "divider", "focusVisibleClassName", "selected", "className"];
    const overridesResolver$3 = (props2, styles2) => {
      const {
        ownerState
      } = props2;
      return [styles2.root, ownerState.dense && styles2.dense, ownerState.alignItems === "flex-start" && styles2.alignItemsFlexStart, ownerState.divider && styles2.divider, !ownerState.disableGutters && styles2.gutters];
    };
    const useUtilityClasses$C = (ownerState) => {
      const {
        alignItems: alignItems2,
        classes,
        dense,
        disabled,
        disableGutters,
        divider,
        selected
      } = ownerState;
      const slots = {
        root: ["root", dense && "dense", !disableGutters && "gutters", divider && "divider", disabled && "disabled", alignItems2 === "flex-start" && "alignItemsFlexStart", selected && "selected"]
      };
      const composedClasses = composeClasses(slots, getListItemButtonUtilityClass, classes);
      return _extends({}, classes, composedClasses);
    };
    const ListItemButtonRoot = styled$1(ButtonBase$1, {
      shouldForwardProp: (prop) => rootShouldForwardProp$1(prop) || prop === "classes",
      name: "MuiListItemButton",
      slot: "Root",
      overridesResolver: overridesResolver$3
    })(({
      theme,
      ownerState
    }) => _extends({
      display: "flex",
      flexGrow: 1,
      justifyContent: "flex-start",
      alignItems: "center",
      position: "relative",
      textDecoration: "none",
      minWidth: 0,
      boxSizing: "border-box",
      textAlign: "left",
      paddingTop: 8,
      paddingBottom: 8,
      transition: theme.transitions.create("background-color", {
        duration: theme.transitions.duration.shortest
      }),
      "&:hover": {
        textDecoration: "none",
        backgroundColor: (theme.vars || theme).palette.action.hover,
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      },
      [`&.${listItemButtonClasses$1.selected}`]: {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity),
        [`&.${listItemButtonClasses$1.focusVisible}`]: {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
        }
      },
      [`&.${listItemButtonClasses$1.selected}:hover`]: {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
        "@media (hover: none)": {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity)
        }
      },
      [`&.${listItemButtonClasses$1.focusVisible}`]: {
        backgroundColor: (theme.vars || theme).palette.action.focus
      },
      [`&.${listItemButtonClasses$1.disabled}`]: {
        opacity: (theme.vars || theme).palette.action.disabledOpacity
      }
    }, ownerState.divider && {
      borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`,
      backgroundClip: "padding-box"
    }, ownerState.alignItems === "flex-start" && {
      alignItems: "flex-start"
    }, !ownerState.disableGutters && {
      paddingLeft: 16,
      paddingRight: 16
    }, ownerState.dense && {
      paddingTop: 4,
      paddingBottom: 4
    }));
    const ListItemButton = /* @__PURE__ */ react.exports.forwardRef(function ListItemButton2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiListItemButton"
      });
      const {
        alignItems: alignItems2 = "center",
        autoFocus = false,
        component = "div",
        children,
        dense = false,
        disableGutters = false,
        divider = false,
        focusVisibleClassName,
        selected = false,
        className
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$F);
      const context = react.exports.useContext(ListContext$1);
      const childContext = react.exports.useMemo(() => ({
        dense: dense || context.dense || false,
        alignItems: alignItems2,
        disableGutters
      }), [alignItems2, context.dense, dense, disableGutters]);
      const listItemRef = react.exports.useRef(null);
      useEnhancedEffect$1(() => {
        if (autoFocus) {
          if (listItemRef.current) {
            listItemRef.current.focus();
          }
        }
      }, [autoFocus]);
      const ownerState = _extends({}, props2, {
        alignItems: alignItems2,
        dense: childContext.dense,
        disableGutters,
        divider,
        selected
      });
      const classes = useUtilityClasses$C(ownerState);
      const handleRef = useForkRef(listItemRef, ref);
      return /* @__PURE__ */ jsx(ListContext$1.Provider, {
        value: childContext,
        children: /* @__PURE__ */ jsx(ListItemButtonRoot, _extends({
          ref: handleRef,
          href: other.href || other.to,
          component: (other.href || other.to) && component === "div" ? "a" : component,
          focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
          ownerState,
          className: clsx(classes.root, className)
        }, other, {
          classes,
          children
        }))
      });
    });
    const ListItemButton$1 = ListItemButton;
    function getListItemSecondaryActionClassesUtilityClass(slot) {
      return generateUtilityClass("MuiListItemSecondaryAction", slot);
    }
    generateUtilityClasses("MuiListItemSecondaryAction", ["root", "disableGutters"]);
    const _excluded$E = ["className"];
    const useUtilityClasses$B = (ownerState) => {
      const {
        disableGutters,
        classes
      } = ownerState;
      const slots = {
        root: ["root", disableGutters && "disableGutters"]
      };
      return composeClasses(slots, getListItemSecondaryActionClassesUtilityClass, classes);
    };
    const ListItemSecondaryActionRoot = styled$1("div", {
      name: "MuiListItemSecondaryAction",
      slot: "Root",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.root, ownerState.disableGutters && styles2.disableGutters];
      }
    })(({
      ownerState
    }) => _extends({
      position: "absolute",
      right: 16,
      top: "50%",
      transform: "translateY(-50%)"
    }, ownerState.disableGutters && {
      right: 0
    }));
    const ListItemSecondaryAction = /* @__PURE__ */ react.exports.forwardRef(function ListItemSecondaryAction2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiListItemSecondaryAction"
      });
      const {
        className
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$E);
      const context = react.exports.useContext(ListContext$1);
      const ownerState = _extends({}, props2, {
        disableGutters: context.disableGutters
      });
      const classes = useUtilityClasses$B(ownerState);
      return /* @__PURE__ */ jsx(ListItemSecondaryActionRoot, _extends({
        className: clsx(classes.root, className),
        ownerState,
        ref
      }, other));
    });
    ListItemSecondaryAction.muiName = "ListItemSecondaryAction";
    const ListItemSecondaryAction$1 = ListItemSecondaryAction;
    const _excluded$D = ["className"], _excluded2$2 = ["alignItems", "autoFocus", "button", "children", "className", "component", "components", "componentsProps", "ContainerComponent", "ContainerProps", "dense", "disabled", "disableGutters", "disablePadding", "divider", "focusVisibleClassName", "secondaryAction", "selected", "slotProps", "slots"];
    const overridesResolver$2 = (props2, styles2) => {
      const {
        ownerState
      } = props2;
      return [styles2.root, ownerState.dense && styles2.dense, ownerState.alignItems === "flex-start" && styles2.alignItemsFlexStart, ownerState.divider && styles2.divider, !ownerState.disableGutters && styles2.gutters, !ownerState.disablePadding && styles2.padding, ownerState.button && styles2.button, ownerState.hasSecondaryAction && styles2.secondaryAction];
    };
    const useUtilityClasses$A = (ownerState) => {
      const {
        alignItems: alignItems2,
        button,
        classes,
        dense,
        disabled,
        disableGutters,
        disablePadding,
        divider,
        hasSecondaryAction,
        selected
      } = ownerState;
      const slots = {
        root: ["root", dense && "dense", !disableGutters && "gutters", !disablePadding && "padding", divider && "divider", disabled && "disabled", button && "button", alignItems2 === "flex-start" && "alignItemsFlexStart", hasSecondaryAction && "secondaryAction", selected && "selected"],
        container: ["container"]
      };
      return composeClasses(slots, getListItemUtilityClass, classes);
    };
    const ListItemRoot = styled$1("div", {
      name: "MuiListItem",
      slot: "Root",
      overridesResolver: overridesResolver$2
    })(({
      theme,
      ownerState
    }) => _extends({
      display: "flex",
      justifyContent: "flex-start",
      alignItems: "center",
      position: "relative",
      textDecoration: "none",
      width: "100%",
      boxSizing: "border-box",
      textAlign: "left"
    }, !ownerState.disablePadding && _extends({
      paddingTop: 8,
      paddingBottom: 8
    }, ownerState.dense && {
      paddingTop: 4,
      paddingBottom: 4
    }, !ownerState.disableGutters && {
      paddingLeft: 16,
      paddingRight: 16
    }, !!ownerState.secondaryAction && {
      paddingRight: 48
    }), !!ownerState.secondaryAction && {
      [`& > .${listItemButtonClasses$1.root}`]: {
        paddingRight: 48
      }
    }, {
      [`&.${listItemClasses$1.focusVisible}`]: {
        backgroundColor: (theme.vars || theme).palette.action.focus
      },
      [`&.${listItemClasses$1.selected}`]: {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity),
        [`&.${listItemClasses$1.focusVisible}`]: {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
        }
      },
      [`&.${listItemClasses$1.disabled}`]: {
        opacity: (theme.vars || theme).palette.action.disabledOpacity
      }
    }, ownerState.alignItems === "flex-start" && {
      alignItems: "flex-start"
    }, ownerState.divider && {
      borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`,
      backgroundClip: "padding-box"
    }, ownerState.button && {
      transition: theme.transitions.create("background-color", {
        duration: theme.transitions.duration.shortest
      }),
      "&:hover": {
        textDecoration: "none",
        backgroundColor: (theme.vars || theme).palette.action.hover,
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      },
      [`&.${listItemClasses$1.selected}:hover`]: {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
        "@media (hover: none)": {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity)
        }
      }
    }, ownerState.hasSecondaryAction && {
      paddingRight: 48
    }));
    const ListItemContainer = styled$1("li", {
      name: "MuiListItem",
      slot: "Container",
      overridesResolver: (props2, styles2) => styles2.container
    })({
      position: "relative"
    });
    const ListItem = /* @__PURE__ */ react.exports.forwardRef(function ListItem2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiListItem"
      });
      const {
        alignItems: alignItems2 = "center",
        autoFocus = false,
        button = false,
        children: childrenProp,
        className,
        component: componentProp,
        components = {},
        componentsProps = {},
        ContainerComponent = "li",
        ContainerProps: {
          className: ContainerClassName
        } = {},
        dense = false,
        disabled = false,
        disableGutters = false,
        disablePadding = false,
        divider = false,
        focusVisibleClassName,
        secondaryAction,
        selected = false,
        slotProps = {},
        slots = {}
      } = props2, ContainerProps = _objectWithoutPropertiesLoose(props2.ContainerProps, _excluded$D), other = _objectWithoutPropertiesLoose(props2, _excluded2$2);
      const context = react.exports.useContext(ListContext$1);
      const childContext = react.exports.useMemo(() => ({
        dense: dense || context.dense || false,
        alignItems: alignItems2,
        disableGutters
      }), [alignItems2, context.dense, dense, disableGutters]);
      const listItemRef = react.exports.useRef(null);
      useEnhancedEffect$1(() => {
        if (autoFocus) {
          if (listItemRef.current) {
            listItemRef.current.focus();
          }
        }
      }, [autoFocus]);
      const children = react.exports.Children.toArray(childrenProp);
      const hasSecondaryAction = children.length && isMuiElement(children[children.length - 1], ["ListItemSecondaryAction"]);
      const ownerState = _extends({}, props2, {
        alignItems: alignItems2,
        autoFocus,
        button,
        dense: childContext.dense,
        disabled,
        disableGutters,
        disablePadding,
        divider,
        hasSecondaryAction,
        selected
      });
      const classes = useUtilityClasses$A(ownerState);
      const handleRef = useForkRef(listItemRef, ref);
      const Root = slots.root || components.Root || ListItemRoot;
      const rootProps = slotProps.root || componentsProps.root || {};
      const componentProps = _extends({
        className: clsx(classes.root, rootProps.className, className),
        disabled
      }, other);
      let Component = componentProp || "li";
      if (button) {
        componentProps.component = componentProp || "div";
        componentProps.focusVisibleClassName = clsx(listItemClasses$1.focusVisible, focusVisibleClassName);
        Component = ButtonBase$1;
      }
      if (hasSecondaryAction) {
        Component = !componentProps.component && !componentProp ? "div" : Component;
        if (ContainerComponent === "li") {
          if (Component === "li") {
            Component = "div";
          } else if (componentProps.component === "li") {
            componentProps.component = "div";
          }
        }
        return /* @__PURE__ */ jsx(ListContext$1.Provider, {
          value: childContext,
          children: /* @__PURE__ */ jsxs(ListItemContainer, _extends({
            as: ContainerComponent,
            className: clsx(classes.container, ContainerClassName),
            ref: handleRef,
            ownerState
          }, ContainerProps, {
            children: [/* @__PURE__ */ jsx(Root, _extends({}, rootProps, !isHostComponent(Root) && {
              as: Component,
              ownerState: _extends({}, ownerState, rootProps.ownerState)
            }, componentProps, {
              children
            })), children.pop()]
          }))
        });
      }
      return /* @__PURE__ */ jsx(ListContext$1.Provider, {
        value: childContext,
        children: /* @__PURE__ */ jsxs(Root, _extends({}, rootProps, {
          as: Component,
          ref: handleRef
        }, !isHostComponent(Root) && {
          ownerState: _extends({}, ownerState, rootProps.ownerState)
        }, componentProps, {
          children: [children, secondaryAction && /* @__PURE__ */ jsx(ListItemSecondaryAction$1, {
            children: secondaryAction
          })]
        }))
      });
    });
    const ListItem$1 = ListItem;
    function getListItemAvatarUtilityClass(slot) {
      return generateUtilityClass("MuiListItemAvatar", slot);
    }
    generateUtilityClasses("MuiListItemAvatar", ["root", "alignItemsFlexStart"]);
    const _excluded$C = ["className"];
    const useUtilityClasses$z = (ownerState) => {
      const {
        alignItems: alignItems2,
        classes
      } = ownerState;
      const slots = {
        root: ["root", alignItems2 === "flex-start" && "alignItemsFlexStart"]
      };
      return composeClasses(slots, getListItemAvatarUtilityClass, classes);
    };
    const ListItemAvatarRoot = styled$1("div", {
      name: "MuiListItemAvatar",
      slot: "Root",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.root, ownerState.alignItems === "flex-start" && styles2.alignItemsFlexStart];
      }
    })(({
      ownerState
    }) => _extends({
      minWidth: 56,
      flexShrink: 0
    }, ownerState.alignItems === "flex-start" && {
      marginTop: 8
    }));
    const ListItemAvatar = /* @__PURE__ */ react.exports.forwardRef(function ListItemAvatar2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiListItemAvatar"
      });
      const {
        className
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$C);
      const context = react.exports.useContext(ListContext$1);
      const ownerState = _extends({}, props2, {
        alignItems: context.alignItems
      });
      const classes = useUtilityClasses$z(ownerState);
      return /* @__PURE__ */ jsx(ListItemAvatarRoot, _extends({
        className: clsx(classes.root, className),
        ownerState,
        ref
      }, other));
    });
    const ListItemAvatar$1 = ListItemAvatar;
    function getListItemIconUtilityClass(slot) {
      return generateUtilityClass("MuiListItemIcon", slot);
    }
    const listItemIconClasses = generateUtilityClasses("MuiListItemIcon", ["root", "alignItemsFlexStart"]);
    const listItemIconClasses$1 = listItemIconClasses;
    const _excluded$B = ["className"];
    const useUtilityClasses$y = (ownerState) => {
      const {
        alignItems: alignItems2,
        classes
      } = ownerState;
      const slots = {
        root: ["root", alignItems2 === "flex-start" && "alignItemsFlexStart"]
      };
      return composeClasses(slots, getListItemIconUtilityClass, classes);
    };
    const ListItemIconRoot = styled$1("div", {
      name: "MuiListItemIcon",
      slot: "Root",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.root, ownerState.alignItems === "flex-start" && styles2.alignItemsFlexStart];
      }
    })(({
      theme,
      ownerState
    }) => _extends({
      minWidth: 56,
      color: (theme.vars || theme).palette.action.active,
      flexShrink: 0,
      display: "inline-flex"
    }, ownerState.alignItems === "flex-start" && {
      marginTop: 8
    }));
    const ListItemIcon = /* @__PURE__ */ react.exports.forwardRef(function ListItemIcon2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiListItemIcon"
      });
      const {
        className
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$B);
      const context = react.exports.useContext(ListContext$1);
      const ownerState = _extends({}, props2, {
        alignItems: context.alignItems
      });
      const classes = useUtilityClasses$y(ownerState);
      return /* @__PURE__ */ jsx(ListItemIconRoot, _extends({
        className: clsx(classes.root, className),
        ownerState,
        ref
      }, other));
    });
    const ListItemIcon$1 = ListItemIcon;
    function getListItemTextUtilityClass(slot) {
      return generateUtilityClass("MuiListItemText", slot);
    }
    const listItemTextClasses = generateUtilityClasses("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]);
    const listItemTextClasses$1 = listItemTextClasses;
    const _excluded$A = ["children", "className", "disableTypography", "inset", "primary", "primaryTypographyProps", "secondary", "secondaryTypographyProps"];
    const useUtilityClasses$x = (ownerState) => {
      const {
        classes,
        inset,
        primary,
        secondary,
        dense
      } = ownerState;
      const slots = {
        root: ["root", inset && "inset", dense && "dense", primary && secondary && "multiline"],
        primary: ["primary"],
        secondary: ["secondary"]
      };
      return composeClasses(slots, getListItemTextUtilityClass, classes);
    };
    const ListItemTextRoot = styled$1("div", {
      name: "MuiListItemText",
      slot: "Root",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [{
          [`& .${listItemTextClasses$1.primary}`]: styles2.primary
        }, {
          [`& .${listItemTextClasses$1.secondary}`]: styles2.secondary
        }, styles2.root, ownerState.inset && styles2.inset, ownerState.primary && ownerState.secondary && styles2.multiline, ownerState.dense && styles2.dense];
      }
    })(({
      ownerState
    }) => _extends({
      flex: "1 1 auto",
      minWidth: 0,
      marginTop: 4,
      marginBottom: 4
    }, ownerState.primary && ownerState.secondary && {
      marginTop: 6,
      marginBottom: 6
    }, ownerState.inset && {
      paddingLeft: 56
    }));
    const ListItemText = /* @__PURE__ */ react.exports.forwardRef(function ListItemText2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiListItemText"
      });
      const {
        children,
        className,
        disableTypography = false,
        inset = false,
        primary: primaryProp,
        primaryTypographyProps,
        secondary: secondaryProp,
        secondaryTypographyProps
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$A);
      const {
        dense
      } = react.exports.useContext(ListContext$1);
      let primary = primaryProp != null ? primaryProp : children;
      let secondary = secondaryProp;
      const ownerState = _extends({}, props2, {
        disableTypography,
        inset,
        primary: !!primary,
        secondary: !!secondary,
        dense
      });
      const classes = useUtilityClasses$x(ownerState);
      if (primary != null && primary.type !== Typography$1 && !disableTypography) {
        primary = /* @__PURE__ */ jsx(Typography$1, _extends({
          variant: dense ? "body2" : "body1",
          className: classes.primary,
          component: primaryTypographyProps != null && primaryTypographyProps.variant ? void 0 : "span",
          display: "block"
        }, primaryTypographyProps, {
          children: primary
        }));
      }
      if (secondary != null && secondary.type !== Typography$1 && !disableTypography) {
        secondary = /* @__PURE__ */ jsx(Typography$1, _extends({
          variant: "body2",
          className: classes.secondary,
          color: "text.secondary",
          display: "block"
        }, secondaryTypographyProps, {
          children: secondary
        }));
      }
      return /* @__PURE__ */ jsxs(ListItemTextRoot, _extends({
        className: clsx(classes.root, className),
        ownerState,
        ref
      }, other, {
        children: [primary, secondary]
      }));
    });
    const ListItemText$1 = ListItemText;
    const _excluded$z = ["actions", "autoFocus", "autoFocusItem", "children", "className", "disabledItemsFocusable", "disableListWrap", "onKeyDown", "variant"];
    function nextItem$1(list, item, disableListWrap) {
      if (list === item) {
        return list.firstChild;
      }
      if (item && item.nextElementSibling) {
        return item.nextElementSibling;
      }
      return disableListWrap ? null : list.firstChild;
    }
    function previousItem$1(list, item, disableListWrap) {
      if (list === item) {
        return disableListWrap ? list.firstChild : list.lastChild;
      }
      if (item && item.previousElementSibling) {
        return item.previousElementSibling;
      }
      return disableListWrap ? null : list.lastChild;
    }
    function textCriteriaMatches(nextFocus, textCriteria) {
      if (textCriteria === void 0) {
        return true;
      }
      let text = nextFocus.innerText;
      if (text === void 0) {
        text = nextFocus.textContent;
      }
      text = text.trim().toLowerCase();
      if (text.length === 0) {
        return false;
      }
      if (textCriteria.repeating) {
        return text[0] === textCriteria.keys[0];
      }
      return text.indexOf(textCriteria.keys.join("")) === 0;
    }
    function moveFocus$1(list, currentFocus, disableListWrap, disabledItemsFocusable, traversalFunction, textCriteria) {
      let wrappedOnce = false;
      let nextFocus = traversalFunction(list, currentFocus, currentFocus ? disableListWrap : false);
      while (nextFocus) {
        if (nextFocus === list.firstChild) {
          if (wrappedOnce) {
            return false;
          }
          wrappedOnce = true;
        }
        const nextFocusDisabled = disabledItemsFocusable ? false : nextFocus.disabled || nextFocus.getAttribute("aria-disabled") === "true";
        if (!nextFocus.hasAttribute("tabindex") || !textCriteriaMatches(nextFocus, textCriteria) || nextFocusDisabled) {
          nextFocus = traversalFunction(list, nextFocus, disableListWrap);
        } else {
          nextFocus.focus();
          return true;
        }
      }
      return false;
    }
    const MenuList = /* @__PURE__ */ react.exports.forwardRef(function MenuList2(props2, ref) {
      const {
        actions,
        autoFocus = false,
        autoFocusItem = false,
        children,
        className,
        disabledItemsFocusable = false,
        disableListWrap = false,
        onKeyDown,
        variant = "selectedMenu"
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$z);
      const listRef = react.exports.useRef(null);
      const textCriteriaRef = react.exports.useRef({
        keys: [],
        repeating: true,
        previousKeyMatched: true,
        lastTime: null
      });
      useEnhancedEffect$1(() => {
        if (autoFocus) {
          listRef.current.focus();
        }
      }, [autoFocus]);
      react.exports.useImperativeHandle(actions, () => ({
        adjustStyleForScrollbar: (containerElement, theme) => {
          const noExplicitWidth = !listRef.current.style.width;
          if (containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth) {
            const scrollbarSize = `${getScrollbarSize(ownerDocument(containerElement))}px`;
            listRef.current.style[theme.direction === "rtl" ? "paddingLeft" : "paddingRight"] = scrollbarSize;
            listRef.current.style.width = `calc(100% + ${scrollbarSize})`;
          }
          return listRef.current;
        }
      }), []);
      const handleKeyDown2 = (event) => {
        const list = listRef.current;
        const key = event.key;
        const currentFocus = ownerDocument(list).activeElement;
        if (key === "ArrowDown") {
          event.preventDefault();
          moveFocus$1(list, currentFocus, disableListWrap, disabledItemsFocusable, nextItem$1);
        } else if (key === "ArrowUp") {
          event.preventDefault();
          moveFocus$1(list, currentFocus, disableListWrap, disabledItemsFocusable, previousItem$1);
        } else if (key === "Home") {
          event.preventDefault();
          moveFocus$1(list, null, disableListWrap, disabledItemsFocusable, nextItem$1);
        } else if (key === "End") {
          event.preventDefault();
          moveFocus$1(list, null, disableListWrap, disabledItemsFocusable, previousItem$1);
        } else if (key.length === 1) {
          const criteria = textCriteriaRef.current;
          const lowerKey = key.toLowerCase();
          const currTime = performance.now();
          if (criteria.keys.length > 0) {
            if (currTime - criteria.lastTime > 500) {
              criteria.keys = [];
              criteria.repeating = true;
              criteria.previousKeyMatched = true;
            } else if (criteria.repeating && lowerKey !== criteria.keys[0]) {
              criteria.repeating = false;
            }
          }
          criteria.lastTime = currTime;
          criteria.keys.push(lowerKey);
          const keepFocusOnCurrent = currentFocus && !criteria.repeating && textCriteriaMatches(currentFocus, criteria);
          if (criteria.previousKeyMatched && (keepFocusOnCurrent || moveFocus$1(list, currentFocus, false, disabledItemsFocusable, nextItem$1, criteria))) {
            event.preventDefault();
          } else {
            criteria.previousKeyMatched = false;
          }
        }
        if (onKeyDown) {
          onKeyDown(event);
        }
      };
      const handleRef = useForkRef(listRef, ref);
      let activeItemIndex = -1;
      react.exports.Children.forEach(children, (child, index2) => {
        if (!/* @__PURE__ */ react.exports.isValidElement(child)) {
          return;
        }
        if (!child.props.disabled) {
          if (variant === "selectedMenu" && child.props.selected) {
            activeItemIndex = index2;
          } else if (activeItemIndex === -1) {
            activeItemIndex = index2;
          }
        }
      });
      const items = react.exports.Children.map(children, (child, index2) => {
        if (index2 === activeItemIndex) {
          const newChildProps = {};
          if (autoFocusItem) {
            newChildProps.autoFocus = true;
          }
          if (child.props.tabIndex === void 0 && variant === "selectedMenu") {
            newChildProps.tabIndex = 0;
          }
          return /* @__PURE__ */ react.exports.cloneElement(child, newChildProps);
        }
        return child;
      });
      return /* @__PURE__ */ jsx(List$1, _extends({
        role: "menu",
        ref: handleRef,
        className,
        onKeyDown: handleKeyDown2,
        tabIndex: autoFocus ? 0 : -1
      }, other, {
        children: items
      }));
    });
    const MenuList$1 = MenuList;
    function getPopoverUtilityClass(slot) {
      return generateUtilityClass("MuiPopover", slot);
    }
    generateUtilityClasses("MuiPopover", ["root", "paper"]);
    const _excluded$y = ["onEntering"], _excluded2$1 = ["action", "anchorEl", "anchorOrigin", "anchorPosition", "anchorReference", "children", "className", "container", "elevation", "marginThreshold", "open", "PaperProps", "transformOrigin", "TransitionComponent", "transitionDuration", "TransitionProps"];
    function getOffsetTop(rect, vertical) {
      let offset2 = 0;
      if (typeof vertical === "number") {
        offset2 = vertical;
      } else if (vertical === "center") {
        offset2 = rect.height / 2;
      } else if (vertical === "bottom") {
        offset2 = rect.height;
      }
      return offset2;
    }
    function getOffsetLeft(rect, horizontal) {
      let offset2 = 0;
      if (typeof horizontal === "number") {
        offset2 = horizontal;
      } else if (horizontal === "center") {
        offset2 = rect.width / 2;
      } else if (horizontal === "right") {
        offset2 = rect.width;
      }
      return offset2;
    }
    function getTransformOriginValue(transformOrigin) {
      return [transformOrigin.horizontal, transformOrigin.vertical].map((n2) => typeof n2 === "number" ? `${n2}px` : n2).join(" ");
    }
    function resolveAnchorEl(anchorEl) {
      return typeof anchorEl === "function" ? anchorEl() : anchorEl;
    }
    const useUtilityClasses$w = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        paper: ["paper"]
      };
      return composeClasses(slots, getPopoverUtilityClass, classes);
    };
    const PopoverRoot = styled$1(Modal$1, {
      name: "MuiPopover",
      slot: "Root",
      overridesResolver: (props2, styles2) => styles2.root
    })({});
    const PopoverPaper = styled$1(Paper$1, {
      name: "MuiPopover",
      slot: "Paper",
      overridesResolver: (props2, styles2) => styles2.paper
    })({
      position: "absolute",
      overflowY: "auto",
      overflowX: "hidden",
      minWidth: 16,
      minHeight: 16,
      maxWidth: "calc(100% - 32px)",
      maxHeight: "calc(100% - 32px)",
      outline: 0
    });
    const Popover = /* @__PURE__ */ react.exports.forwardRef(function Popover2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiPopover"
      });
      const {
        action,
        anchorEl,
        anchorOrigin = {
          vertical: "top",
          horizontal: "left"
        },
        anchorPosition,
        anchorReference = "anchorEl",
        children,
        className,
        container: containerProp,
        elevation = 8,
        marginThreshold = 16,
        open,
        PaperProps = {},
        transformOrigin = {
          vertical: "top",
          horizontal: "left"
        },
        TransitionComponent = Grow$1,
        transitionDuration: transitionDurationProp = "auto",
        TransitionProps: {
          onEntering
        } = {}
      } = props2, TransitionProps = _objectWithoutPropertiesLoose(props2.TransitionProps, _excluded$y), other = _objectWithoutPropertiesLoose(props2, _excluded2$1);
      const paperRef = react.exports.useRef();
      const handlePaperRef = useForkRef(paperRef, PaperProps.ref);
      const ownerState = _extends({}, props2, {
        anchorOrigin,
        anchorReference,
        elevation,
        marginThreshold,
        PaperProps,
        transformOrigin,
        TransitionComponent,
        transitionDuration: transitionDurationProp,
        TransitionProps
      });
      const classes = useUtilityClasses$w(ownerState);
      const getAnchorOffset = react.exports.useCallback(() => {
        if (anchorReference === "anchorPosition") {
          return anchorPosition;
        }
        const resolvedAnchorEl = resolveAnchorEl(anchorEl);
        const anchorElement = resolvedAnchorEl && resolvedAnchorEl.nodeType === 1 ? resolvedAnchorEl : ownerDocument(paperRef.current).body;
        const anchorRect = anchorElement.getBoundingClientRect();
        return {
          top: anchorRect.top + getOffsetTop(anchorRect, anchorOrigin.vertical),
          left: anchorRect.left + getOffsetLeft(anchorRect, anchorOrigin.horizontal)
        };
      }, [anchorEl, anchorOrigin.horizontal, anchorOrigin.vertical, anchorPosition, anchorReference]);
      const getTransformOrigin = react.exports.useCallback((elemRect) => {
        return {
          vertical: getOffsetTop(elemRect, transformOrigin.vertical),
          horizontal: getOffsetLeft(elemRect, transformOrigin.horizontal)
        };
      }, [transformOrigin.horizontal, transformOrigin.vertical]);
      const getPositioningStyle = react.exports.useCallback((element) => {
        const elemRect = {
          width: element.offsetWidth,
          height: element.offsetHeight
        };
        const elemTransformOrigin = getTransformOrigin(elemRect);
        if (anchorReference === "none") {
          return {
            top: null,
            left: null,
            transformOrigin: getTransformOriginValue(elemTransformOrigin)
          };
        }
        const anchorOffset = getAnchorOffset();
        let top2 = anchorOffset.top - elemTransformOrigin.vertical;
        let left2 = anchorOffset.left - elemTransformOrigin.horizontal;
        const bottom2 = top2 + elemRect.height;
        const right2 = left2 + elemRect.width;
        const containerWindow = ownerWindow(resolveAnchorEl(anchorEl));
        const heightThreshold = containerWindow.innerHeight - marginThreshold;
        const widthThreshold = containerWindow.innerWidth - marginThreshold;
        if (top2 < marginThreshold) {
          const diff2 = top2 - marginThreshold;
          top2 -= diff2;
          elemTransformOrigin.vertical += diff2;
        } else if (bottom2 > heightThreshold) {
          const diff2 = bottom2 - heightThreshold;
          top2 -= diff2;
          elemTransformOrigin.vertical += diff2;
        }
        if (left2 < marginThreshold) {
          const diff2 = left2 - marginThreshold;
          left2 -= diff2;
          elemTransformOrigin.horizontal += diff2;
        } else if (right2 > widthThreshold) {
          const diff2 = right2 - widthThreshold;
          left2 -= diff2;
          elemTransformOrigin.horizontal += diff2;
        }
        return {
          top: `${Math.round(top2)}px`,
          left: `${Math.round(left2)}px`,
          transformOrigin: getTransformOriginValue(elemTransformOrigin)
        };
      }, [anchorEl, anchorReference, getAnchorOffset, getTransformOrigin, marginThreshold]);
      const [isPositioned, setIsPositioned] = react.exports.useState(open);
      const setPositioningStyles = react.exports.useCallback(() => {
        const element = paperRef.current;
        if (!element) {
          return;
        }
        const positioning = getPositioningStyle(element);
        if (positioning.top !== null) {
          element.style.top = positioning.top;
        }
        if (positioning.left !== null) {
          element.style.left = positioning.left;
        }
        element.style.transformOrigin = positioning.transformOrigin;
        setIsPositioned(true);
      }, [getPositioningStyle]);
      const handleEntering = (element, isAppearing) => {
        if (onEntering) {
          onEntering(element, isAppearing);
        }
        setPositioningStyles();
      };
      const handleExited = () => {
        setIsPositioned(false);
      };
      react.exports.useEffect(() => {
        if (open) {
          setPositioningStyles();
        }
      });
      react.exports.useImperativeHandle(action, () => open ? {
        updatePosition: () => {
          setPositioningStyles();
        }
      } : null, [open, setPositioningStyles]);
      react.exports.useEffect(() => {
        if (!open) {
          return void 0;
        }
        const handleResize = debounce$1(() => {
          setPositioningStyles();
        });
        const containerWindow = ownerWindow(anchorEl);
        containerWindow.addEventListener("resize", handleResize);
        return () => {
          handleResize.clear();
          containerWindow.removeEventListener("resize", handleResize);
        };
      }, [anchorEl, open, setPositioningStyles]);
      let transitionDuration = transitionDurationProp;
      if (transitionDurationProp === "auto" && !TransitionComponent.muiSupportAuto) {
        transitionDuration = void 0;
      }
      const container = containerProp || (anchorEl ? ownerDocument(resolveAnchorEl(anchorEl)).body : void 0);
      return /* @__PURE__ */ jsx(PopoverRoot, _extends({
        BackdropProps: {
          invisible: true
        },
        className: clsx(classes.root, className),
        container,
        open,
        ref,
        ownerState
      }, other, {
        children: /* @__PURE__ */ jsx(TransitionComponent, _extends({
          appear: true,
          in: open,
          onEntering: handleEntering,
          onExited: handleExited,
          timeout: transitionDuration
        }, TransitionProps, {
          children: /* @__PURE__ */ jsx(PopoverPaper, _extends({
            elevation
          }, PaperProps, {
            ref: handlePaperRef,
            className: clsx(classes.paper, PaperProps.className)
          }, isPositioned ? void 0 : {
            style: _extends({}, PaperProps.style, {
              opacity: 0
            })
          }, {
            ownerState,
            children
          }))
        }))
      }));
    });
    const Popover$1 = Popover;
    function getMenuUtilityClass(slot) {
      return generateUtilityClass("MuiMenu", slot);
    }
    generateUtilityClasses("MuiMenu", ["root", "paper", "list"]);
    const _excluded$x = ["onEntering"], _excluded2 = ["autoFocus", "children", "disableAutoFocusItem", "MenuListProps", "onClose", "open", "PaperProps", "PopoverClasses", "transitionDuration", "TransitionProps", "variant"];
    const RTL_ORIGIN = {
      vertical: "top",
      horizontal: "right"
    };
    const LTR_ORIGIN = {
      vertical: "top",
      horizontal: "left"
    };
    const useUtilityClasses$v = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        paper: ["paper"],
        list: ["list"]
      };
      return composeClasses(slots, getMenuUtilityClass, classes);
    };
    const MenuRoot = styled$1(Popover$1, {
      shouldForwardProp: (prop) => rootShouldForwardProp$1(prop) || prop === "classes",
      name: "MuiMenu",
      slot: "Root",
      overridesResolver: (props2, styles2) => styles2.root
    })({});
    const MenuPaper = styled$1(Paper$1, {
      name: "MuiMenu",
      slot: "Paper",
      overridesResolver: (props2, styles2) => styles2.paper
    })({
      maxHeight: "calc(100% - 96px)",
      WebkitOverflowScrolling: "touch"
    });
    const MenuMenuList = styled$1(MenuList$1, {
      name: "MuiMenu",
      slot: "List",
      overridesResolver: (props2, styles2) => styles2.list
    })({
      outline: 0
    });
    const Menu$1 = /* @__PURE__ */ react.exports.forwardRef(function Menu2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiMenu"
      });
      const {
        autoFocus = true,
        children,
        disableAutoFocusItem = false,
        MenuListProps = {},
        onClose,
        open,
        PaperProps = {},
        PopoverClasses,
        transitionDuration = "auto",
        TransitionProps: {
          onEntering
        } = {},
        variant = "selectedMenu"
      } = props2, TransitionProps = _objectWithoutPropertiesLoose(props2.TransitionProps, _excluded$x), other = _objectWithoutPropertiesLoose(props2, _excluded2);
      const theme = useTheme();
      const isRtl = theme.direction === "rtl";
      const ownerState = _extends({}, props2, {
        autoFocus,
        disableAutoFocusItem,
        MenuListProps,
        onEntering,
        PaperProps,
        transitionDuration,
        TransitionProps,
        variant
      });
      const classes = useUtilityClasses$v(ownerState);
      const autoFocusItem = autoFocus && !disableAutoFocusItem && open;
      const menuListActionsRef = react.exports.useRef(null);
      const handleEntering = (element, isAppearing) => {
        if (menuListActionsRef.current) {
          menuListActionsRef.current.adjustStyleForScrollbar(element, theme);
        }
        if (onEntering) {
          onEntering(element, isAppearing);
        }
      };
      const handleListKeyDown = (event) => {
        if (event.key === "Tab") {
          event.preventDefault();
          if (onClose) {
            onClose(event, "tabKeyDown");
          }
        }
      };
      let activeItemIndex = -1;
      react.exports.Children.map(children, (child, index2) => {
        if (!/* @__PURE__ */ react.exports.isValidElement(child)) {
          return;
        }
        if (!child.props.disabled) {
          if (variant === "selectedMenu" && child.props.selected) {
            activeItemIndex = index2;
          } else if (activeItemIndex === -1) {
            activeItemIndex = index2;
          }
        }
      });
      return /* @__PURE__ */ jsx(MenuRoot, _extends({
        classes: PopoverClasses,
        onClose,
        anchorOrigin: {
          vertical: "bottom",
          horizontal: isRtl ? "right" : "left"
        },
        transformOrigin: isRtl ? RTL_ORIGIN : LTR_ORIGIN,
        PaperProps: _extends({
          component: MenuPaper
        }, PaperProps, {
          classes: _extends({}, PaperProps.classes, {
            root: classes.paper
          })
        }),
        className: classes.root,
        open,
        ref,
        transitionDuration,
        TransitionProps: _extends({
          onEntering: handleEntering
        }, TransitionProps),
        ownerState
      }, other, {
        children: /* @__PURE__ */ jsx(MenuMenuList, _extends({
          onKeyDown: handleListKeyDown,
          actions: menuListActionsRef,
          autoFocus: autoFocus && (activeItemIndex === -1 || disableAutoFocusItem),
          autoFocusItem,
          variant
        }, MenuListProps, {
          className: clsx(classes.list, MenuListProps.className),
          children
        }))
      }));
    });
    const Menu$2 = Menu$1;
    function getMenuItemUtilityClass(slot) {
      return generateUtilityClass("MuiMenuItem", slot);
    }
    const menuItemClasses = generateUtilityClasses("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"]);
    const menuItemClasses$1 = menuItemClasses;
    const _excluded$w = ["autoFocus", "component", "dense", "divider", "disableGutters", "focusVisibleClassName", "role", "tabIndex", "className"];
    const overridesResolver$1 = (props2, styles2) => {
      const {
        ownerState
      } = props2;
      return [styles2.root, ownerState.dense && styles2.dense, ownerState.divider && styles2.divider, !ownerState.disableGutters && styles2.gutters];
    };
    const useUtilityClasses$u = (ownerState) => {
      const {
        disabled,
        dense,
        divider,
        disableGutters,
        selected,
        classes
      } = ownerState;
      const slots = {
        root: ["root", dense && "dense", disabled && "disabled", !disableGutters && "gutters", divider && "divider", selected && "selected"]
      };
      const composedClasses = composeClasses(slots, getMenuItemUtilityClass, classes);
      return _extends({}, classes, composedClasses);
    };
    const MenuItemRoot = styled$1(ButtonBase$1, {
      shouldForwardProp: (prop) => rootShouldForwardProp$1(prop) || prop === "classes",
      name: "MuiMenuItem",
      slot: "Root",
      overridesResolver: overridesResolver$1
    })(({
      theme,
      ownerState
    }) => _extends({}, theme.typography.body1, {
      display: "flex",
      justifyContent: "flex-start",
      alignItems: "center",
      position: "relative",
      textDecoration: "none",
      minHeight: 48,
      paddingTop: 6,
      paddingBottom: 6,
      boxSizing: "border-box",
      whiteSpace: "nowrap"
    }, !ownerState.disableGutters && {
      paddingLeft: 16,
      paddingRight: 16
    }, ownerState.divider && {
      borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`,
      backgroundClip: "padding-box"
    }, {
      "&:hover": {
        textDecoration: "none",
        backgroundColor: (theme.vars || theme).palette.action.hover,
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      },
      [`&.${menuItemClasses$1.selected}`]: {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity),
        [`&.${menuItemClasses$1.focusVisible}`]: {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
        }
      },
      [`&.${menuItemClasses$1.selected}:hover`]: {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
        "@media (hover: none)": {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity)
        }
      },
      [`&.${menuItemClasses$1.focusVisible}`]: {
        backgroundColor: (theme.vars || theme).palette.action.focus
      },
      [`&.${menuItemClasses$1.disabled}`]: {
        opacity: (theme.vars || theme).palette.action.disabledOpacity
      },
      [`& + .${dividerClasses$1.root}`]: {
        marginTop: theme.spacing(1),
        marginBottom: theme.spacing(1)
      },
      [`& + .${dividerClasses$1.inset}`]: {
        marginLeft: 52
      },
      [`& .${listItemTextClasses$1.root}`]: {
        marginTop: 0,
        marginBottom: 0
      },
      [`& .${listItemTextClasses$1.inset}`]: {
        paddingLeft: 36
      },
      [`& .${listItemIconClasses$1.root}`]: {
        minWidth: 36
      }
    }, !ownerState.dense && {
      [theme.breakpoints.up("sm")]: {
        minHeight: "auto"
      }
    }, ownerState.dense && _extends({
      minHeight: 32,
      paddingTop: 4,
      paddingBottom: 4
    }, theme.typography.body2, {
      [`& .${listItemIconClasses$1.root} svg`]: {
        fontSize: "1.25rem"
      }
    })));
    const MenuItem = /* @__PURE__ */ react.exports.forwardRef(function MenuItem2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiMenuItem"
      });
      const {
        autoFocus = false,
        component = "li",
        dense = false,
        divider = false,
        disableGutters = false,
        focusVisibleClassName,
        role = "menuitem",
        tabIndex: tabIndexProp,
        className
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$w);
      const context = react.exports.useContext(ListContext$1);
      const childContext = react.exports.useMemo(() => ({
        dense: dense || context.dense || false,
        disableGutters
      }), [context.dense, dense, disableGutters]);
      const menuItemRef = react.exports.useRef(null);
      useEnhancedEffect$1(() => {
        if (autoFocus) {
          if (menuItemRef.current) {
            menuItemRef.current.focus();
          }
        }
      }, [autoFocus]);
      const ownerState = _extends({}, props2, {
        dense: childContext.dense,
        divider,
        disableGutters
      });
      const classes = useUtilityClasses$u(props2);
      const handleRef = useForkRef(menuItemRef, ref);
      let tabIndex;
      if (!props2.disabled) {
        tabIndex = tabIndexProp !== void 0 ? tabIndexProp : -1;
      }
      return /* @__PURE__ */ jsx(ListContext$1.Provider, {
        value: childContext,
        children: /* @__PURE__ */ jsx(MenuItemRoot, _extends({
          ref: handleRef,
          role,
          tabIndex,
          component,
          focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
          className: clsx(classes.root, className)
        }, other, {
          ownerState,
          classes
        }))
      });
    });
    const MenuItem$1 = MenuItem;
    function getNativeSelectUtilityClasses(slot) {
      return generateUtilityClass("MuiNativeSelect", slot);
    }
    const nativeSelectClasses = generateUtilityClasses("MuiNativeSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput"]);
    const nativeSelectClasses$1 = nativeSelectClasses;
    const _excluded$v = ["className", "disabled", "IconComponent", "inputRef", "variant"];
    const useUtilityClasses$t = (ownerState) => {
      const {
        classes,
        variant,
        disabled,
        multiple,
        open
      } = ownerState;
      const slots = {
        select: ["select", variant, disabled && "disabled", multiple && "multiple"],
        icon: ["icon", `icon${capitalize(variant)}`, open && "iconOpen", disabled && "disabled"]
      };
      return composeClasses(slots, getNativeSelectUtilityClasses, classes);
    };
    const nativeSelectSelectStyles = ({
      ownerState,
      theme
    }) => _extends({
      MozAppearance: "none",
      WebkitAppearance: "none",
      userSelect: "none",
      borderRadius: 0,
      cursor: "pointer",
      "&:focus": _extends({}, theme.vars ? {
        backgroundColor: `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.05)`
      } : {
        backgroundColor: theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.05)" : "rgba(255, 255, 255, 0.05)"
      }, {
        borderRadius: 0
      }),
      "&::-ms-expand": {
        display: "none"
      },
      [`&.${nativeSelectClasses$1.disabled}`]: {
        cursor: "default"
      },
      "&[multiple]": {
        height: "auto"
      },
      "&:not([multiple]) option, &:not([multiple]) optgroup": {
        backgroundColor: (theme.vars || theme).palette.background.paper
      },
      "&&&": {
        paddingRight: 24,
        minWidth: 16
      }
    }, ownerState.variant === "filled" && {
      "&&&": {
        paddingRight: 32
      }
    }, ownerState.variant === "outlined" && {
      borderRadius: (theme.vars || theme).shape.borderRadius,
      "&:focus": {
        borderRadius: (theme.vars || theme).shape.borderRadius
      },
      "&&&": {
        paddingRight: 32
      }
    });
    const NativeSelectSelect = styled$1("select", {
      name: "MuiNativeSelect",
      slot: "Select",
      shouldForwardProp: rootShouldForwardProp$1,
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.select, styles2[ownerState.variant], {
          [`&.${nativeSelectClasses$1.multiple}`]: styles2.multiple
        }];
      }
    })(nativeSelectSelectStyles);
    const nativeSelectIconStyles = ({
      ownerState,
      theme
    }) => _extends({
      position: "absolute",
      right: 0,
      top: "calc(50% - .5em)",
      pointerEvents: "none",
      color: (theme.vars || theme).palette.action.active,
      [`&.${nativeSelectClasses$1.disabled}`]: {
        color: (theme.vars || theme).palette.action.disabled
      }
    }, ownerState.open && {
      transform: "rotate(180deg)"
    }, ownerState.variant === "filled" && {
      right: 7
    }, ownerState.variant === "outlined" && {
      right: 7
    });
    const NativeSelectIcon = styled$1("svg", {
      name: "MuiNativeSelect",
      slot: "Icon",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.icon, ownerState.variant && styles2[`icon${capitalize(ownerState.variant)}`], ownerState.open && styles2.iconOpen];
      }
    })(nativeSelectIconStyles);
    const NativeSelectInput = /* @__PURE__ */ react.exports.forwardRef(function NativeSelectInput2(props2, ref) {
      const {
        className,
        disabled,
        IconComponent,
        inputRef,
        variant = "standard"
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$v);
      const ownerState = _extends({}, props2, {
        disabled,
        variant
      });
      const classes = useUtilityClasses$t(ownerState);
      return /* @__PURE__ */ jsxs(react.exports.Fragment, {
        children: [/* @__PURE__ */ jsx(NativeSelectSelect, _extends({
          ownerState,
          className: clsx(classes.select, className),
          disabled,
          ref: inputRef || ref
        }, other)), props2.multiple ? null : /* @__PURE__ */ jsx(NativeSelectIcon, {
          as: IconComponent,
          ownerState,
          className: classes.icon
        })]
      });
    });
    const NativeSelectInput$1 = NativeSelectInput;
    var _span$1;
    const _excluded$u = ["children", "classes", "className", "label", "notched"];
    const NotchedOutlineRoot$1 = styled$1("fieldset")({
      textAlign: "left",
      position: "absolute",
      bottom: 0,
      right: 0,
      top: -5,
      left: 0,
      margin: 0,
      padding: "0 8px",
      pointerEvents: "none",
      borderRadius: "inherit",
      borderStyle: "solid",
      borderWidth: 1,
      overflow: "hidden",
      minWidth: "0%"
    });
    const NotchedOutlineLegend = styled$1("legend")(({
      ownerState,
      theme
    }) => _extends({
      float: "unset",
      width: "auto",
      overflow: "hidden"
    }, !ownerState.withLabel && {
      padding: 0,
      lineHeight: "11px",
      transition: theme.transitions.create("width", {
        duration: 150,
        easing: theme.transitions.easing.easeOut
      })
    }, ownerState.withLabel && _extends({
      display: "block",
      padding: 0,
      height: 11,
      fontSize: "0.75em",
      visibility: "hidden",
      maxWidth: 0.01,
      transition: theme.transitions.create("max-width", {
        duration: 50,
        easing: theme.transitions.easing.easeOut
      }),
      whiteSpace: "nowrap",
      "& > span": {
        paddingLeft: 5,
        paddingRight: 5,
        display: "inline-block",
        opacity: 0,
        visibility: "visible"
      }
    }, ownerState.notched && {
      maxWidth: "100%",
      transition: theme.transitions.create("max-width", {
        duration: 100,
        easing: theme.transitions.easing.easeOut,
        delay: 50
      })
    })));
    function NotchedOutline(props2) {
      const {
        className,
        label,
        notched
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$u);
      const withLabel = label != null && label !== "";
      const ownerState = _extends({}, props2, {
        notched,
        withLabel
      });
      return /* @__PURE__ */ jsx(NotchedOutlineRoot$1, _extends({
        "aria-hidden": true,
        className,
        ownerState
      }, other, {
        children: /* @__PURE__ */ jsx(NotchedOutlineLegend, {
          ownerState,
          children: withLabel ? /* @__PURE__ */ jsx("span", {
            children: label
          }) : _span$1 || (_span$1 = /* @__PURE__ */ jsx("span", {
            className: "notranslate",
            children: "\u200B"
          }))
        })
      }));
    }
    const _excluded$t = ["components", "fullWidth", "inputComponent", "label", "multiline", "notched", "slots", "type"];
    const useUtilityClasses$s = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        notchedOutline: ["notchedOutline"],
        input: ["input"]
      };
      const composedClasses = composeClasses(slots, getOutlinedInputUtilityClass, classes);
      return _extends({}, classes, composedClasses);
    };
    const OutlinedInputRoot = styled$1(InputBaseRoot, {
      shouldForwardProp: (prop) => rootShouldForwardProp$1(prop) || prop === "classes",
      name: "MuiOutlinedInput",
      slot: "Root",
      overridesResolver: rootOverridesResolver
    })(({
      theme,
      ownerState
    }) => {
      const borderColor2 = theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
      return _extends({
        position: "relative",
        borderRadius: (theme.vars || theme).shape.borderRadius,
        [`&:hover .${outlinedInputClasses$1.notchedOutline}`]: {
          borderColor: (theme.vars || theme).palette.text.primary
        },
        "@media (hover: none)": {
          [`&:hover .${outlinedInputClasses$1.notchedOutline}`]: {
            borderColor: theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor2
          }
        },
        [`&.${outlinedInputClasses$1.focused} .${outlinedInputClasses$1.notchedOutline}`]: {
          borderColor: (theme.vars || theme).palette[ownerState.color].main,
          borderWidth: 2
        },
        [`&.${outlinedInputClasses$1.error} .${outlinedInputClasses$1.notchedOutline}`]: {
          borderColor: (theme.vars || theme).palette.error.main
        },
        [`&.${outlinedInputClasses$1.disabled} .${outlinedInputClasses$1.notchedOutline}`]: {
          borderColor: (theme.vars || theme).palette.action.disabled
        }
      }, ownerState.startAdornment && {
        paddingLeft: 14
      }, ownerState.endAdornment && {
        paddingRight: 14
      }, ownerState.multiline && _extends({
        padding: "16.5px 14px"
      }, ownerState.size === "small" && {
        padding: "8.5px 14px"
      }));
    });
    const NotchedOutlineRoot = styled$1(NotchedOutline, {
      name: "MuiOutlinedInput",
      slot: "NotchedOutline",
      overridesResolver: (props2, styles2) => styles2.notchedOutline
    })(({
      theme
    }) => {
      const borderColor2 = theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
      return {
        borderColor: theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor2
      };
    });
    const OutlinedInputInput = styled$1(InputBaseComponent, {
      name: "MuiOutlinedInput",
      slot: "Input",
      overridesResolver: inputOverridesResolver
    })(({
      theme,
      ownerState
    }) => _extends({
      padding: "16.5px 14px"
    }, !theme.vars && {
      "&:-webkit-autofill": {
        WebkitBoxShadow: theme.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
        WebkitTextFillColor: theme.palette.mode === "light" ? null : "#fff",
        caretColor: theme.palette.mode === "light" ? null : "#fff",
        borderRadius: "inherit"
      }
    }, theme.vars && {
      "&:-webkit-autofill": {
        borderRadius: "inherit"
      },
      [theme.getColorSchemeSelector("dark")]: {
        "&:-webkit-autofill": {
          WebkitBoxShadow: "0 0 0 100px #266798 inset",
          WebkitTextFillColor: "#fff",
          caretColor: "#fff"
        }
      }
    }, ownerState.size === "small" && {
      padding: "8.5px 14px"
    }, ownerState.multiline && {
      padding: 0
    }, ownerState.startAdornment && {
      paddingLeft: 0
    }, ownerState.endAdornment && {
      paddingRight: 0
    }));
    const OutlinedInput = /* @__PURE__ */ react.exports.forwardRef(function OutlinedInput2(inProps, ref) {
      var _ref, _slots$root, _ref2, _slots$input, _React$Fragment;
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiOutlinedInput"
      });
      const {
        components = {},
        fullWidth = false,
        inputComponent = "input",
        label,
        multiline = false,
        notched,
        slots = {},
        type: type2 = "text"
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$t);
      const classes = useUtilityClasses$s(props2);
      const muiFormControl = useFormControl();
      const fcs = formControlState({
        props: props2,
        muiFormControl,
        states: ["required"]
      });
      const ownerState = _extends({}, props2, {
        color: fcs.color || "primary",
        disabled: fcs.disabled,
        error: fcs.error,
        focused: fcs.focused,
        formControl: muiFormControl,
        fullWidth,
        hiddenLabel: fcs.hiddenLabel,
        multiline,
        size: fcs.size,
        type: type2
      });
      const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : OutlinedInputRoot;
      const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : OutlinedInputInput;
      return /* @__PURE__ */ jsx(InputBase$1, _extends({
        slots: {
          root: RootSlot,
          input: InputSlot
        },
        renderSuffix: (state) => /* @__PURE__ */ jsx(NotchedOutlineRoot, {
          ownerState,
          className: classes.notchedOutline,
          label: label != null && label !== "" && fcs.required ? _React$Fragment || (_React$Fragment = /* @__PURE__ */ jsxs(react.exports.Fragment, {
            children: [label, "\xA0", "*"]
          })) : label,
          notched: typeof notched !== "undefined" ? notched : Boolean(state.startAdornment || state.filled || state.focused)
        }),
        fullWidth,
        inputComponent,
        multiline,
        ref,
        type: type2
      }, other, {
        classes: _extends({}, classes, {
          notchedOutline: null
        })
      }));
    });
    OutlinedInput.muiName = "Input";
    const OutlinedInput$1 = OutlinedInput;
    function getSelectUtilityClasses(slot) {
      return generateUtilityClass("MuiSelect", slot);
    }
    const selectClasses = generateUtilityClasses("MuiSelect", ["select", "multiple", "filled", "outlined", "standard", "disabled", "focused", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput"]);
    const selectClasses$1 = selectClasses;
    var _span;
    const _excluded$s = ["aria-describedby", "aria-label", "autoFocus", "autoWidth", "children", "className", "defaultOpen", "defaultValue", "disabled", "displayEmpty", "IconComponent", "inputRef", "labelId", "MenuProps", "multiple", "name", "onBlur", "onChange", "onClose", "onFocus", "onOpen", "open", "readOnly", "renderValue", "SelectDisplayProps", "tabIndex", "type", "value", "variant"];
    const SelectSelect = styled$1("div", {
      name: "MuiSelect",
      slot: "Select",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [
          {
            [`&.${selectClasses$1.select}`]: styles2.select
          },
          {
            [`&.${selectClasses$1.select}`]: styles2[ownerState.variant]
          },
          {
            [`&.${selectClasses$1.multiple}`]: styles2.multiple
          }
        ];
      }
    })(nativeSelectSelectStyles, {
      [`&.${selectClasses$1.select}`]: {
        height: "auto",
        minHeight: "1.4375em",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap",
        overflow: "hidden"
      }
    });
    const SelectIcon = styled$1("svg", {
      name: "MuiSelect",
      slot: "Icon",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.icon, ownerState.variant && styles2[`icon${capitalize(ownerState.variant)}`], ownerState.open && styles2.iconOpen];
      }
    })(nativeSelectIconStyles);
    const SelectNativeInput = styled$1("input", {
      shouldForwardProp: (prop) => slotShouldForwardProp(prop) && prop !== "classes",
      name: "MuiSelect",
      slot: "NativeInput",
      overridesResolver: (props2, styles2) => styles2.nativeInput
    })({
      bottom: 0,
      left: 0,
      position: "absolute",
      opacity: 0,
      pointerEvents: "none",
      width: "100%",
      boxSizing: "border-box"
    });
    function areEqualValues(a, b2) {
      if (typeof b2 === "object" && b2 !== null) {
        return a === b2;
      }
      return String(a) === String(b2);
    }
    function isEmpty(display2) {
      return display2 == null || typeof display2 === "string" && !display2.trim();
    }
    const useUtilityClasses$r = (ownerState) => {
      const {
        classes,
        variant,
        disabled,
        multiple,
        open
      } = ownerState;
      const slots = {
        select: ["select", variant, disabled && "disabled", multiple && "multiple"],
        icon: ["icon", `icon${capitalize(variant)}`, open && "iconOpen", disabled && "disabled"],
        nativeInput: ["nativeInput"]
      };
      return composeClasses(slots, getSelectUtilityClasses, classes);
    };
    const SelectInput = /* @__PURE__ */ react.exports.forwardRef(function SelectInput2(props2, ref) {
      const {
        "aria-describedby": ariaDescribedby,
        "aria-label": ariaLabel,
        autoFocus,
        autoWidth,
        children,
        className,
        defaultOpen,
        defaultValue,
        disabled,
        displayEmpty,
        IconComponent,
        inputRef: inputRefProp,
        labelId,
        MenuProps = {},
        multiple,
        name,
        onBlur,
        onChange,
        onClose,
        onFocus,
        onOpen,
        open: openProp,
        readOnly,
        renderValue,
        SelectDisplayProps = {},
        tabIndex: tabIndexProp,
        value: valueProp,
        variant = "standard"
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$s);
      const [value, setValueState] = useControlled({
        controlled: valueProp,
        default: defaultValue,
        name: "Select"
      });
      const [openState, setOpenState] = useControlled({
        controlled: openProp,
        default: defaultOpen,
        name: "Select"
      });
      const inputRef = react.exports.useRef(null);
      const displayRef = react.exports.useRef(null);
      const [displayNode, setDisplayNode] = react.exports.useState(null);
      const {
        current: isOpenControlled
      } = react.exports.useRef(openProp != null);
      const [menuMinWidthState, setMenuMinWidthState] = react.exports.useState();
      const handleRef = useForkRef(ref, inputRefProp);
      const handleDisplayRef = react.exports.useCallback((node2) => {
        displayRef.current = node2;
        if (node2) {
          setDisplayNode(node2);
        }
      }, []);
      react.exports.useImperativeHandle(handleRef, () => ({
        focus: () => {
          displayRef.current.focus();
        },
        node: inputRef.current,
        value
      }), [value]);
      react.exports.useEffect(() => {
        if (defaultOpen && openState && displayNode && !isOpenControlled) {
          setMenuMinWidthState(autoWidth ? null : displayNode.clientWidth);
          displayRef.current.focus();
        }
      }, [displayNode, autoWidth]);
      react.exports.useEffect(() => {
        if (autoFocus) {
          displayRef.current.focus();
        }
      }, [autoFocus]);
      react.exports.useEffect(() => {
        if (!labelId) {
          return void 0;
        }
        const label = ownerDocument(displayRef.current).getElementById(labelId);
        if (label) {
          const handler = () => {
            if (getSelection().isCollapsed) {
              displayRef.current.focus();
            }
          };
          label.addEventListener("click", handler);
          return () => {
            label.removeEventListener("click", handler);
          };
        }
        return void 0;
      }, [labelId]);
      const update = (open2, event) => {
        if (open2) {
          if (onOpen) {
            onOpen(event);
          }
        } else if (onClose) {
          onClose(event);
        }
        if (!isOpenControlled) {
          setMenuMinWidthState(autoWidth ? null : displayNode.clientWidth);
          setOpenState(open2);
        }
      };
      const handleMouseDown = (event) => {
        if (event.button !== 0) {
          return;
        }
        event.preventDefault();
        displayRef.current.focus();
        update(true, event);
      };
      const handleClose = (event) => {
        update(false, event);
      };
      const childrenArray = react.exports.Children.toArray(children);
      const handleChange = (event) => {
        const index2 = childrenArray.map((child2) => child2.props.value).indexOf(event.target.value);
        if (index2 === -1) {
          return;
        }
        const child = childrenArray[index2];
        setValueState(child.props.value);
        if (onChange) {
          onChange(event, child);
        }
      };
      const handleItemClick = (child) => (event) => {
        let newValue;
        if (!event.currentTarget.hasAttribute("tabindex")) {
          return;
        }
        if (multiple) {
          newValue = Array.isArray(value) ? value.slice() : [];
          const itemIndex = value.indexOf(child.props.value);
          if (itemIndex === -1) {
            newValue.push(child.props.value);
          } else {
            newValue.splice(itemIndex, 1);
          }
        } else {
          newValue = child.props.value;
        }
        if (child.props.onClick) {
          child.props.onClick(event);
        }
        if (value !== newValue) {
          setValueState(newValue);
          if (onChange) {
            const nativeEvent = event.nativeEvent || event;
            const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
            Object.defineProperty(clonedEvent, "target", {
              writable: true,
              value: {
                value: newValue,
                name
              }
            });
            onChange(clonedEvent, child);
          }
        }
        if (!multiple) {
          update(false, event);
        }
      };
      const handleKeyDown2 = (event) => {
        if (!readOnly) {
          const validKeys = [
            " ",
            "ArrowUp",
            "ArrowDown",
            "Enter"
          ];
          if (validKeys.indexOf(event.key) !== -1) {
            event.preventDefault();
            update(true, event);
          }
        }
      };
      const open = displayNode !== null && openState;
      const handleBlur = (event) => {
        if (!open && onBlur) {
          Object.defineProperty(event, "target", {
            writable: true,
            value: {
              value,
              name
            }
          });
          onBlur(event);
        }
      };
      delete other["aria-invalid"];
      let display2;
      let displaySingle;
      const displayMultiple = [];
      let computeDisplay = false;
      if (isFilled({
        value
      }) || displayEmpty) {
        if (renderValue) {
          display2 = renderValue(value);
        } else {
          computeDisplay = true;
        }
      }
      const items = childrenArray.map((child, index2, arr) => {
        if (!/* @__PURE__ */ react.exports.isValidElement(child)) {
          return null;
        }
        let selected;
        if (multiple) {
          if (!Array.isArray(value)) {
            throw new Error(formatMuiErrorMessage(2));
          }
          selected = value.some((v2) => areEqualValues(v2, child.props.value));
          if (selected && computeDisplay) {
            displayMultiple.push(child.props.children);
          }
        } else {
          selected = areEqualValues(value, child.props.value);
          if (selected && computeDisplay) {
            displaySingle = child.props.children;
          }
        }
        if (child.props.value === void 0) {
          return /* @__PURE__ */ react.exports.cloneElement(child, {
            "aria-readonly": true,
            role: "option"
          });
        }
        const isFirstSelectableElement = () => {
          if (value) {
            return selected;
          }
          const firstSelectableElement = arr.find((item) => item.props.value !== void 0 && item.props.disabled !== true);
          if (child === firstSelectableElement) {
            return true;
          }
          return selected;
        };
        return /* @__PURE__ */ react.exports.cloneElement(child, {
          "aria-selected": selected ? "true" : "false",
          onClick: handleItemClick(child),
          onKeyUp: (event) => {
            if (event.key === " ") {
              event.preventDefault();
            }
            if (child.props.onKeyUp) {
              child.props.onKeyUp(event);
            }
          },
          role: "option",
          selected: arr[0].props.value === void 0 || arr[0].props.disabled === true ? isFirstSelectableElement() : selected,
          value: void 0,
          "data-value": child.props.value
        });
      });
      if (computeDisplay) {
        if (multiple) {
          if (displayMultiple.length === 0) {
            display2 = null;
          } else {
            display2 = displayMultiple.reduce((output, child, index2) => {
              output.push(child);
              if (index2 < displayMultiple.length - 1) {
                output.push(", ");
              }
              return output;
            }, []);
          }
        } else {
          display2 = displaySingle;
        }
      }
      let menuMinWidth = menuMinWidthState;
      if (!autoWidth && isOpenControlled && displayNode) {
        menuMinWidth = displayNode.clientWidth;
      }
      let tabIndex;
      if (typeof tabIndexProp !== "undefined") {
        tabIndex = tabIndexProp;
      } else {
        tabIndex = disabled ? null : 0;
      }
      const buttonId = SelectDisplayProps.id || (name ? `mui-component-select-${name}` : void 0);
      const ownerState = _extends({}, props2, {
        variant,
        value,
        open
      });
      const classes = useUtilityClasses$r(ownerState);
      return /* @__PURE__ */ jsxs(react.exports.Fragment, {
        children: [/* @__PURE__ */ jsx(SelectSelect, _extends({
          ref: handleDisplayRef,
          tabIndex,
          role: "button",
          "aria-disabled": disabled ? "true" : void 0,
          "aria-expanded": open ? "true" : "false",
          "aria-haspopup": "listbox",
          "aria-label": ariaLabel,
          "aria-labelledby": [labelId, buttonId].filter(Boolean).join(" ") || void 0,
          "aria-describedby": ariaDescribedby,
          onKeyDown: handleKeyDown2,
          onMouseDown: disabled || readOnly ? null : handleMouseDown,
          onBlur: handleBlur,
          onFocus
        }, SelectDisplayProps, {
          ownerState,
          className: clsx(SelectDisplayProps.className, classes.select, className),
          id: buttonId,
          children: isEmpty(display2) ? _span || (_span = /* @__PURE__ */ jsx("span", {
            className: "notranslate",
            children: "\u200B"
          })) : display2
        })), /* @__PURE__ */ jsx(SelectNativeInput, _extends({
          value: Array.isArray(value) ? value.join(",") : value,
          name,
          ref: inputRef,
          "aria-hidden": true,
          onChange: handleChange,
          tabIndex: -1,
          disabled,
          className: classes.nativeInput,
          autoFocus,
          ownerState
        }, other)), /* @__PURE__ */ jsx(SelectIcon, {
          as: IconComponent,
          className: classes.icon,
          ownerState
        }), /* @__PURE__ */ jsx(Menu$2, _extends({
          id: `menu-${name || ""}`,
          anchorEl: displayNode,
          open,
          onClose: handleClose,
          anchorOrigin: {
            vertical: "bottom",
            horizontal: "center"
          },
          transformOrigin: {
            vertical: "top",
            horizontal: "center"
          }
        }, MenuProps, {
          MenuListProps: _extends({
            "aria-labelledby": labelId,
            role: "listbox",
            disableListWrap: true
          }, MenuProps.MenuListProps),
          PaperProps: _extends({}, MenuProps.PaperProps, {
            style: _extends({
              minWidth: menuMinWidth
            }, MenuProps.PaperProps != null ? MenuProps.PaperProps.style : null)
          }),
          children: items
        }))]
      });
    });
    const SelectInput$1 = SelectInput;
    var _StyledInput, _StyledFilledInput;
    const _excluded$r = ["autoWidth", "children", "classes", "className", "defaultOpen", "displayEmpty", "IconComponent", "id", "input", "inputProps", "label", "labelId", "MenuProps", "multiple", "native", "onClose", "onOpen", "open", "renderValue", "SelectDisplayProps", "variant"];
    const useUtilityClasses$q = (ownerState) => {
      const {
        classes
      } = ownerState;
      return classes;
    };
    const styledRootConfig = {
      name: "MuiSelect",
      overridesResolver: (props2, styles2) => styles2.root,
      shouldForwardProp: (prop) => rootShouldForwardProp$1(prop) && prop !== "variant",
      slot: "Root"
    };
    const StyledInput = styled$1(Input$1, styledRootConfig)("");
    const StyledOutlinedInput = styled$1(OutlinedInput$1, styledRootConfig)("");
    const StyledFilledInput = styled$1(FilledInput$1, styledRootConfig)("");
    const Select = /* @__PURE__ */ react.exports.forwardRef(function Select2(inProps, ref) {
      const props2 = useThemeProps({
        name: "MuiSelect",
        props: inProps
      });
      const {
        autoWidth = false,
        children,
        classes: classesProp = {},
        className,
        defaultOpen = false,
        displayEmpty = false,
        IconComponent = ArrowDropDownIcon,
        id: id2,
        input,
        inputProps,
        label,
        labelId,
        MenuProps,
        multiple = false,
        native = false,
        onClose,
        onOpen,
        open,
        renderValue,
        SelectDisplayProps,
        variant: variantProp = "outlined"
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$r);
      const inputComponent = native ? NativeSelectInput$1 : SelectInput$1;
      const muiFormControl = useFormControl();
      const fcs = formControlState({
        props: props2,
        muiFormControl,
        states: ["variant"]
      });
      const variant = fcs.variant || variantProp;
      const InputComponent = input || {
        standard: _StyledInput || (_StyledInput = /* @__PURE__ */ jsx(StyledInput, {})),
        outlined: /* @__PURE__ */ jsx(StyledOutlinedInput, {
          label
        }),
        filled: _StyledFilledInput || (_StyledFilledInput = /* @__PURE__ */ jsx(StyledFilledInput, {}))
      }[variant];
      const ownerState = _extends({}, props2, {
        variant,
        classes: classesProp
      });
      const classes = useUtilityClasses$q(ownerState);
      const inputComponentRef = useForkRef(ref, InputComponent.ref);
      return /* @__PURE__ */ jsx(react.exports.Fragment, {
        children: /* @__PURE__ */ react.exports.cloneElement(InputComponent, _extends({
          inputComponent,
          inputProps: _extends({
            children,
            IconComponent,
            variant,
            type: void 0,
            multiple
          }, native ? {
            id: id2
          } : {
            autoWidth,
            defaultOpen,
            displayEmpty,
            labelId,
            MenuProps,
            onClose,
            onOpen,
            open,
            renderValue,
            SelectDisplayProps: _extends({
              id: id2
            }, SelectDisplayProps)
          }, inputProps, {
            classes: inputProps ? deepmerge(classes, inputProps.classes) : classes
          }, input ? input.props.inputProps : {})
        }, multiple && native && variant === "outlined" ? {
          notched: true
        } : {}, {
          ref: inputComponentRef,
          className: clsx(InputComponent.props.className, className)
        }, !input && {
          variant
        }, other))
      });
    });
    Select.muiName = "Select";
    const Select$1 = Select;
    const _excluded$q = ["component", "direction", "spacing", "divider", "children"];
    function joinChildren(children, separator) {
      const childrenArray = react.exports.Children.toArray(children).filter(Boolean);
      return childrenArray.reduce((output, child, index2) => {
        output.push(child);
        if (index2 < childrenArray.length - 1) {
          output.push(/* @__PURE__ */ react.exports.cloneElement(separator, {
            key: `separator-${index2}`
          }));
        }
        return output;
      }, []);
    }
    const getSideFromDirection = (direction) => {
      return {
        row: "Left",
        "row-reverse": "Right",
        column: "Top",
        "column-reverse": "Bottom"
      }[direction];
    };
    const style = ({
      ownerState,
      theme
    }) => {
      let styles2 = _extends({
        display: "flex",
        flexDirection: "column"
      }, handleBreakpoints({
        theme
      }, resolveBreakpointValues({
        values: ownerState.direction,
        breakpoints: theme.breakpoints.values
      }), (propValue) => ({
        flexDirection: propValue
      })));
      if (ownerState.spacing) {
        const transformer = createUnarySpacing(theme);
        const base = Object.keys(theme.breakpoints.values).reduce((acc, breakpoint) => {
          if (typeof ownerState.spacing === "object" && ownerState.spacing[breakpoint] != null || typeof ownerState.direction === "object" && ownerState.direction[breakpoint] != null) {
            acc[breakpoint] = true;
          }
          return acc;
        }, {});
        const directionValues = resolveBreakpointValues({
          values: ownerState.direction,
          base
        });
        const spacingValues = resolveBreakpointValues({
          values: ownerState.spacing,
          base
        });
        if (typeof directionValues === "object") {
          Object.keys(directionValues).forEach((breakpoint, index2, breakpoints) => {
            const directionValue = directionValues[breakpoint];
            if (!directionValue) {
              const previousDirectionValue = index2 > 0 ? directionValues[breakpoints[index2 - 1]] : "column";
              directionValues[breakpoint] = previousDirectionValue;
            }
          });
        }
        const styleFromPropValue = (propValue, breakpoint) => {
          return {
            "& > :not(style) + :not(style)": {
              margin: 0,
              [`margin${getSideFromDirection(breakpoint ? directionValues[breakpoint] : ownerState.direction)}`]: getValue(transformer, propValue)
            }
          };
        };
        styles2 = deepmerge(styles2, handleBreakpoints({
          theme
        }, spacingValues, styleFromPropValue));
      }
      styles2 = mergeBreakpointsInOrder(theme.breakpoints, styles2);
      return styles2;
    };
    const StackRoot = styled$1("div", {
      name: "MuiStack",
      slot: "Root",
      overridesResolver: (props2, styles2) => {
        return [styles2.root];
      }
    })(style);
    const Stack = /* @__PURE__ */ react.exports.forwardRef(function Stack2(inProps, ref) {
      const themeProps = useThemeProps({
        props: inProps,
        name: "MuiStack"
      });
      const props2 = extendSxProp(themeProps);
      const {
        component = "div",
        direction = "column",
        spacing: spacing2 = 0,
        divider,
        children
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$q);
      const ownerState = {
        direction,
        spacing: spacing2
      };
      return /* @__PURE__ */ jsx(StackRoot, _extends({
        as: component,
        ownerState,
        ref
      }, other, {
        children: divider ? joinChildren(children, divider) : children
      }));
    });
    const Stack$1 = Stack;
    function getSwitchUtilityClass(slot) {
      return generateUtilityClass("MuiSwitch", slot);
    }
    const switchClasses = generateUtilityClasses("MuiSwitch", ["root", "edgeStart", "edgeEnd", "switchBase", "colorPrimary", "colorSecondary", "sizeSmall", "sizeMedium", "checked", "disabled", "input", "thumb", "track"]);
    const switchClasses$1 = switchClasses;
    const _excluded$p = ["className", "color", "edge", "size", "sx"];
    const useUtilityClasses$p = (ownerState) => {
      const {
        classes,
        edge,
        size,
        color: color2,
        checked,
        disabled
      } = ownerState;
      const slots = {
        root: ["root", edge && `edge${capitalize(edge)}`, `size${capitalize(size)}`],
        switchBase: ["switchBase", `color${capitalize(color2)}`, checked && "checked", disabled && "disabled"],
        thumb: ["thumb"],
        track: ["track"],
        input: ["input"]
      };
      const composedClasses = composeClasses(slots, getSwitchUtilityClass, classes);
      return _extends({}, classes, composedClasses);
    };
    const SwitchRoot = styled$1("span", {
      name: "MuiSwitch",
      slot: "Root",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.root, ownerState.edge && styles2[`edge${capitalize(ownerState.edge)}`], styles2[`size${capitalize(ownerState.size)}`]];
      }
    })(({
      ownerState
    }) => _extends({
      display: "inline-flex",
      width: 34 + 12 * 2,
      height: 14 + 12 * 2,
      overflow: "hidden",
      padding: 12,
      boxSizing: "border-box",
      position: "relative",
      flexShrink: 0,
      zIndex: 0,
      verticalAlign: "middle",
      "@media print": {
        colorAdjust: "exact"
      }
    }, ownerState.edge === "start" && {
      marginLeft: -8
    }, ownerState.edge === "end" && {
      marginRight: -8
    }, ownerState.size === "small" && {
      width: 40,
      height: 24,
      padding: 7,
      [`& .${switchClasses$1.thumb}`]: {
        width: 16,
        height: 16
      },
      [`& .${switchClasses$1.switchBase}`]: {
        padding: 4,
        [`&.${switchClasses$1.checked}`]: {
          transform: "translateX(16px)"
        }
      }
    }));
    const SwitchSwitchBase = styled$1(SwitchBase$1, {
      name: "MuiSwitch",
      slot: "SwitchBase",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.switchBase, {
          [`& .${switchClasses$1.input}`]: styles2.input
        }, ownerState.color !== "default" && styles2[`color${capitalize(ownerState.color)}`]];
      }
    })(({
      theme
    }) => ({
      position: "absolute",
      top: 0,
      left: 0,
      zIndex: 1,
      color: theme.vars ? theme.vars.palette.Switch.defaultColor : `${theme.palette.mode === "light" ? theme.palette.common.white : theme.palette.grey[300]}`,
      transition: theme.transitions.create(["left", "transform"], {
        duration: theme.transitions.duration.shortest
      }),
      [`&.${switchClasses$1.checked}`]: {
        transform: "translateX(20px)"
      },
      [`&.${switchClasses$1.disabled}`]: {
        color: theme.vars ? theme.vars.palette.Switch.defaultDisabledColor : `${theme.palette.mode === "light" ? theme.palette.grey[100] : theme.palette.grey[600]}`
      },
      [`&.${switchClasses$1.checked} + .${switchClasses$1.track}`]: {
        opacity: 0.5
      },
      [`&.${switchClasses$1.disabled} + .${switchClasses$1.track}`]: {
        opacity: theme.vars ? theme.vars.opacity.switchTrackDisabled : `${theme.palette.mode === "light" ? 0.12 : 0.2}`
      },
      [`& .${switchClasses$1.input}`]: {
        left: "-100%",
        width: "300%"
      }
    }), ({
      theme,
      ownerState
    }) => _extends({
      "&:hover": {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity),
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    }, ownerState.color !== "default" && {
      [`&.${switchClasses$1.checked}`]: {
        color: (theme.vars || theme).palette[ownerState.color].main,
        "&:hover": {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity),
          "@media (hover: none)": {
            backgroundColor: "transparent"
          }
        },
        [`&.${switchClasses$1.disabled}`]: {
          color: theme.vars ? theme.vars.palette.Switch[`${ownerState.color}DisabledColor`] : `${theme.palette.mode === "light" ? lighten(theme.palette[ownerState.color].main, 0.62) : darken(theme.palette[ownerState.color].main, 0.55)}`
        }
      },
      [`&.${switchClasses$1.checked} + .${switchClasses$1.track}`]: {
        backgroundColor: (theme.vars || theme).palette[ownerState.color].main
      }
    }));
    const SwitchTrack = styled$1("span", {
      name: "MuiSwitch",
      slot: "Track",
      overridesResolver: (props2, styles2) => styles2.track
    })(({
      theme
    }) => ({
      height: "100%",
      width: "100%",
      borderRadius: 14 / 2,
      zIndex: -1,
      transition: theme.transitions.create(["opacity", "background-color"], {
        duration: theme.transitions.duration.shortest
      }),
      backgroundColor: theme.vars ? theme.vars.palette.common.onBackground : `${theme.palette.mode === "light" ? theme.palette.common.black : theme.palette.common.white}`,
      opacity: theme.vars ? theme.vars.opacity.switchTrack : `${theme.palette.mode === "light" ? 0.38 : 0.3}`
    }));
    const SwitchThumb = styled$1("span", {
      name: "MuiSwitch",
      slot: "Thumb",
      overridesResolver: (props2, styles2) => styles2.thumb
    })(({
      theme
    }) => ({
      boxShadow: (theme.vars || theme).shadows[1],
      backgroundColor: "currentColor",
      width: 20,
      height: 20,
      borderRadius: "50%"
    }));
    const Switch = /* @__PURE__ */ react.exports.forwardRef(function Switch2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiSwitch"
      });
      const {
        className,
        color: color2 = "primary",
        edge = false,
        size = "medium",
        sx
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$p);
      const ownerState = _extends({}, props2, {
        color: color2,
        edge,
        size
      });
      const classes = useUtilityClasses$p(ownerState);
      const icon = /* @__PURE__ */ jsx(SwitchThumb, {
        className: classes.thumb,
        ownerState
      });
      return /* @__PURE__ */ jsxs(SwitchRoot, {
        className: clsx(classes.root, className),
        sx,
        ownerState,
        children: [/* @__PURE__ */ jsx(SwitchSwitchBase, _extends({
          type: "checkbox",
          icon,
          checkedIcon: icon,
          ref,
          ownerState
        }, other, {
          classes: _extends({}, classes, {
            root: classes.switchBase
          })
        })), /* @__PURE__ */ jsx(SwitchTrack, {
          className: classes.track,
          ownerState
        })]
      });
    });
    const Switch$1 = Switch;
    function getTabUtilityClass(slot) {
      return generateUtilityClass("MuiTab", slot);
    }
    const tabClasses = generateUtilityClasses("MuiTab", ["root", "labelIcon", "textColorInherit", "textColorPrimary", "textColorSecondary", "selected", "disabled", "fullWidth", "wrapped", "iconWrapper"]);
    const tabClasses$1 = tabClasses;
    const _excluded$o = ["className", "disabled", "disableFocusRipple", "fullWidth", "icon", "iconPosition", "indicator", "label", "onChange", "onClick", "onFocus", "selected", "selectionFollowsFocus", "textColor", "value", "wrapped"];
    const useUtilityClasses$o = (ownerState) => {
      const {
        classes,
        textColor,
        fullWidth,
        wrapped,
        icon,
        label,
        selected,
        disabled
      } = ownerState;
      const slots = {
        root: ["root", icon && label && "labelIcon", `textColor${capitalize(textColor)}`, fullWidth && "fullWidth", wrapped && "wrapped", selected && "selected", disabled && "disabled"],
        iconWrapper: ["iconWrapper"]
      };
      return composeClasses(slots, getTabUtilityClass, classes);
    };
    const TabRoot = styled$1(ButtonBase$1, {
      name: "MuiTab",
      slot: "Root",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.root, ownerState.label && ownerState.icon && styles2.labelIcon, styles2[`textColor${capitalize(ownerState.textColor)}`], ownerState.fullWidth && styles2.fullWidth, ownerState.wrapped && styles2.wrapped];
      }
    })(({
      theme,
      ownerState
    }) => _extends({}, theme.typography.button, {
      maxWidth: 360,
      minWidth: 90,
      position: "relative",
      minHeight: 48,
      flexShrink: 0,
      padding: "12px 16px",
      overflow: "hidden",
      whiteSpace: "normal",
      textAlign: "center"
    }, ownerState.label && {
      flexDirection: ownerState.iconPosition === "top" || ownerState.iconPosition === "bottom" ? "column" : "row"
    }, {
      lineHeight: 1.25
    }, ownerState.icon && ownerState.label && {
      minHeight: 72,
      paddingTop: 9,
      paddingBottom: 9,
      [`& > .${tabClasses$1.iconWrapper}`]: _extends({}, ownerState.iconPosition === "top" && {
        marginBottom: 6
      }, ownerState.iconPosition === "bottom" && {
        marginTop: 6
      }, ownerState.iconPosition === "start" && {
        marginRight: theme.spacing(1)
      }, ownerState.iconPosition === "end" && {
        marginLeft: theme.spacing(1)
      })
    }, ownerState.textColor === "inherit" && {
      color: "inherit",
      opacity: 0.6,
      [`&.${tabClasses$1.selected}`]: {
        opacity: 1
      },
      [`&.${tabClasses$1.disabled}`]: {
        opacity: (theme.vars || theme).palette.action.disabledOpacity
      }
    }, ownerState.textColor === "primary" && {
      color: (theme.vars || theme).palette.text.secondary,
      [`&.${tabClasses$1.selected}`]: {
        color: (theme.vars || theme).palette.primary.main
      },
      [`&.${tabClasses$1.disabled}`]: {
        color: (theme.vars || theme).palette.text.disabled
      }
    }, ownerState.textColor === "secondary" && {
      color: (theme.vars || theme).palette.text.secondary,
      [`&.${tabClasses$1.selected}`]: {
        color: (theme.vars || theme).palette.secondary.main
      },
      [`&.${tabClasses$1.disabled}`]: {
        color: (theme.vars || theme).palette.text.disabled
      }
    }, ownerState.fullWidth && {
      flexShrink: 1,
      flexGrow: 1,
      flexBasis: 0,
      maxWidth: "none"
    }, ownerState.wrapped && {
      fontSize: theme.typography.pxToRem(12)
    }));
    const Tab = /* @__PURE__ */ react.exports.forwardRef(function Tab2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiTab"
      });
      const {
        className,
        disabled = false,
        disableFocusRipple = false,
        fullWidth,
        icon: iconProp,
        iconPosition = "top",
        indicator,
        label,
        onChange,
        onClick,
        onFocus,
        selected,
        selectionFollowsFocus,
        textColor = "inherit",
        value,
        wrapped = false
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$o);
      const ownerState = _extends({}, props2, {
        disabled,
        disableFocusRipple,
        selected,
        icon: !!iconProp,
        iconPosition,
        label: !!label,
        fullWidth,
        textColor,
        wrapped
      });
      const classes = useUtilityClasses$o(ownerState);
      const icon = iconProp && label && /* @__PURE__ */ react.exports.isValidElement(iconProp) ? /* @__PURE__ */ react.exports.cloneElement(iconProp, {
        className: clsx(classes.iconWrapper, iconProp.props.className)
      }) : iconProp;
      const handleClick = (event) => {
        if (!selected && onChange) {
          onChange(event, value);
        }
        if (onClick) {
          onClick(event);
        }
      };
      const handleFocus = (event) => {
        if (selectionFollowsFocus && !selected && onChange) {
          onChange(event, value);
        }
        if (onFocus) {
          onFocus(event);
        }
      };
      return /* @__PURE__ */ jsxs(TabRoot, _extends({
        focusRipple: !disableFocusRipple,
        className: clsx(classes.root, className),
        ref,
        role: "tab",
        "aria-selected": selected,
        disabled,
        onClick: handleClick,
        onFocus: handleFocus,
        ownerState,
        tabIndex: selected ? 0 : -1
      }, other, {
        children: [iconPosition === "top" || iconPosition === "start" ? /* @__PURE__ */ jsxs(react.exports.Fragment, {
          children: [icon, label]
        }) : /* @__PURE__ */ jsxs(react.exports.Fragment, {
          children: [label, icon]
        }), indicator]
      }));
    });
    const Tab$1 = Tab;
    function getToolbarUtilityClass(slot) {
      return generateUtilityClass("MuiToolbar", slot);
    }
    generateUtilityClasses("MuiToolbar", ["root", "gutters", "regular", "dense"]);
    const _excluded$n = ["className", "component", "disableGutters", "variant"];
    const useUtilityClasses$n = (ownerState) => {
      const {
        classes,
        disableGutters,
        variant
      } = ownerState;
      const slots = {
        root: ["root", !disableGutters && "gutters", variant]
      };
      return composeClasses(slots, getToolbarUtilityClass, classes);
    };
    const ToolbarRoot = styled$1("div", {
      name: "MuiToolbar",
      slot: "Root",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.root, !ownerState.disableGutters && styles2.gutters, styles2[ownerState.variant]];
      }
    })(({
      theme,
      ownerState
    }) => _extends({
      position: "relative",
      display: "flex",
      alignItems: "center"
    }, !ownerState.disableGutters && {
      paddingLeft: theme.spacing(2),
      paddingRight: theme.spacing(2),
      [theme.breakpoints.up("sm")]: {
        paddingLeft: theme.spacing(3),
        paddingRight: theme.spacing(3)
      }
    }, ownerState.variant === "dense" && {
      minHeight: 48
    }), ({
      theme,
      ownerState
    }) => ownerState.variant === "regular" && theme.mixins.toolbar);
    const Toolbar = /* @__PURE__ */ react.exports.forwardRef(function Toolbar2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiToolbar"
      });
      const {
        className,
        component = "div",
        disableGutters = false,
        variant = "regular"
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$n);
      const ownerState = _extends({}, props2, {
        component,
        disableGutters,
        variant
      });
      const classes = useUtilityClasses$n(ownerState);
      return /* @__PURE__ */ jsx(ToolbarRoot, _extends({
        as: component,
        className: clsx(classes.root, className),
        ref,
        ownerState
      }, other));
    });
    const Toolbar$1 = Toolbar;
    const KeyboardArrowLeft = createSvgIcon$1(/* @__PURE__ */ jsx("path", {
      d: "M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z"
    }), "KeyboardArrowLeft");
    const KeyboardArrowRight = createSvgIcon$1(/* @__PURE__ */ jsx("path", {
      d: "M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"
    }), "KeyboardArrowRight");
    function easeInOutSin(time) {
      return (1 + Math.sin(Math.PI * time - Math.PI / 2)) / 2;
    }
    function animate(property, element, to2, options = {}, cb2 = () => {
    }) {
      const {
        ease = easeInOutSin,
        duration: duration2 = 300
      } = options;
      let start2 = null;
      const from2 = element[property];
      let cancelled = false;
      const cancel = () => {
        cancelled = true;
      };
      const step = (timestamp) => {
        if (cancelled) {
          cb2(new Error("Animation cancelled"));
          return;
        }
        if (start2 === null) {
          start2 = timestamp;
        }
        const time = Math.min(1, (timestamp - start2) / duration2);
        element[property] = ease(time) * (to2 - from2) + from2;
        if (time >= 1) {
          requestAnimationFrame(() => {
            cb2(null);
          });
          return;
        }
        requestAnimationFrame(step);
      };
      if (from2 === to2) {
        cb2(new Error("Element already at target position"));
        return cancel;
      }
      requestAnimationFrame(step);
      return cancel;
    }
    const _excluded$m = ["onChange"];
    const styles = {
      width: 99,
      height: 99,
      position: "absolute",
      top: -9999,
      overflow: "scroll"
    };
    function ScrollbarSize(props2) {
      const {
        onChange
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$m);
      const scrollbarHeight = react.exports.useRef();
      const nodeRef = react.exports.useRef(null);
      const setMeasurements = () => {
        scrollbarHeight.current = nodeRef.current.offsetHeight - nodeRef.current.clientHeight;
      };
      react.exports.useEffect(() => {
        const handleResize = debounce$1(() => {
          const prevHeight = scrollbarHeight.current;
          setMeasurements();
          if (prevHeight !== scrollbarHeight.current) {
            onChange(scrollbarHeight.current);
          }
        });
        const containerWindow = ownerWindow(nodeRef.current);
        containerWindow.addEventListener("resize", handleResize);
        return () => {
          handleResize.clear();
          containerWindow.removeEventListener("resize", handleResize);
        };
      }, [onChange]);
      react.exports.useEffect(() => {
        setMeasurements();
        onChange(scrollbarHeight.current);
      }, [onChange]);
      return /* @__PURE__ */ jsx("div", _extends({
        style: styles,
        ref: nodeRef
      }, other));
    }
    function getTabScrollButtonUtilityClass(slot) {
      return generateUtilityClass("MuiTabScrollButton", slot);
    }
    const tabScrollButtonClasses = generateUtilityClasses("MuiTabScrollButton", ["root", "vertical", "horizontal", "disabled"]);
    const tabScrollButtonClasses$1 = tabScrollButtonClasses;
    var _KeyboardArrowLeft, _KeyboardArrowRight;
    const _excluded$l = ["className", "direction", "orientation", "disabled"];
    const useUtilityClasses$m = (ownerState) => {
      const {
        classes,
        orientation,
        disabled
      } = ownerState;
      const slots = {
        root: ["root", orientation, disabled && "disabled"]
      };
      return composeClasses(slots, getTabScrollButtonUtilityClass, classes);
    };
    const TabScrollButtonRoot = styled$1(ButtonBase$1, {
      name: "MuiTabScrollButton",
      slot: "Root",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.root, ownerState.orientation && styles2[ownerState.orientation]];
      }
    })(({
      ownerState
    }) => _extends({
      width: 40,
      flexShrink: 0,
      opacity: 0.8,
      [`&.${tabScrollButtonClasses$1.disabled}`]: {
        opacity: 0
      }
    }, ownerState.orientation === "vertical" && {
      width: "100%",
      height: 40,
      "& svg": {
        transform: `rotate(${ownerState.isRtl ? -90 : 90}deg)`
      }
    }));
    const TabScrollButton = /* @__PURE__ */ react.exports.forwardRef(function TabScrollButton2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiTabScrollButton"
      });
      const {
        className,
        direction
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$l);
      const theme = useTheme();
      const isRtl = theme.direction === "rtl";
      const ownerState = _extends({
        isRtl
      }, props2);
      const classes = useUtilityClasses$m(ownerState);
      return /* @__PURE__ */ jsx(TabScrollButtonRoot, _extends({
        component: "div",
        className: clsx(classes.root, className),
        ref,
        role: null,
        ownerState,
        tabIndex: null
      }, other, {
        children: direction === "left" ? _KeyboardArrowLeft || (_KeyboardArrowLeft = /* @__PURE__ */ jsx(KeyboardArrowLeft, {
          fontSize: "small"
        })) : _KeyboardArrowRight || (_KeyboardArrowRight = /* @__PURE__ */ jsx(KeyboardArrowRight, {
          fontSize: "small"
        }))
      }));
    });
    const TabScrollButton$1 = TabScrollButton;
    function getTabsUtilityClass(slot) {
      return generateUtilityClass("MuiTabs", slot);
    }
    const tabsClasses = generateUtilityClasses("MuiTabs", ["root", "vertical", "flexContainer", "flexContainerVertical", "centered", "scroller", "fixed", "scrollableX", "scrollableY", "hideScrollbar", "scrollButtons", "scrollButtonsHideMobile", "indicator"]);
    const tabsClasses$1 = tabsClasses;
    const _excluded$k = ["aria-label", "aria-labelledby", "action", "centered", "children", "className", "component", "allowScrollButtonsMobile", "indicatorColor", "onChange", "orientation", "ScrollButtonComponent", "scrollButtons", "selectionFollowsFocus", "TabIndicatorProps", "TabScrollButtonProps", "textColor", "value", "variant", "visibleScrollbar"];
    const nextItem = (list, item) => {
      if (list === item) {
        return list.firstChild;
      }
      if (item && item.nextElementSibling) {
        return item.nextElementSibling;
      }
      return list.firstChild;
    };
    const previousItem = (list, item) => {
      if (list === item) {
        return list.lastChild;
      }
      if (item && item.previousElementSibling) {
        return item.previousElementSibling;
      }
      return list.lastChild;
    };
    const moveFocus = (list, currentFocus, traversalFunction) => {
      let wrappedOnce = false;
      let nextFocus = traversalFunction(list, currentFocus);
      while (nextFocus) {
        if (nextFocus === list.firstChild) {
          if (wrappedOnce) {
            return;
          }
          wrappedOnce = true;
        }
        const nextFocusDisabled = nextFocus.disabled || nextFocus.getAttribute("aria-disabled") === "true";
        if (!nextFocus.hasAttribute("tabindex") || nextFocusDisabled) {
          nextFocus = traversalFunction(list, nextFocus);
        } else {
          nextFocus.focus();
          return;
        }
      }
    };
    const useUtilityClasses$l = (ownerState) => {
      const {
        vertical,
        fixed,
        hideScrollbar,
        scrollableX,
        scrollableY,
        centered,
        scrollButtonsHideMobile,
        classes
      } = ownerState;
      const slots = {
        root: ["root", vertical && "vertical"],
        scroller: ["scroller", fixed && "fixed", hideScrollbar && "hideScrollbar", scrollableX && "scrollableX", scrollableY && "scrollableY"],
        flexContainer: ["flexContainer", vertical && "flexContainerVertical", centered && "centered"],
        indicator: ["indicator"],
        scrollButtons: ["scrollButtons", scrollButtonsHideMobile && "scrollButtonsHideMobile"],
        scrollableX: [scrollableX && "scrollableX"],
        hideScrollbar: [hideScrollbar && "hideScrollbar"]
      };
      return composeClasses(slots, getTabsUtilityClass, classes);
    };
    const TabsRoot = styled$1("div", {
      name: "MuiTabs",
      slot: "Root",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [{
          [`& .${tabsClasses$1.scrollButtons}`]: styles2.scrollButtons
        }, {
          [`& .${tabsClasses$1.scrollButtons}`]: ownerState.scrollButtonsHideMobile && styles2.scrollButtonsHideMobile
        }, styles2.root, ownerState.vertical && styles2.vertical];
      }
    })(({
      ownerState,
      theme
    }) => _extends({
      overflow: "hidden",
      minHeight: 48,
      WebkitOverflowScrolling: "touch",
      display: "flex"
    }, ownerState.vertical && {
      flexDirection: "column"
    }, ownerState.scrollButtonsHideMobile && {
      [`& .${tabsClasses$1.scrollButtons}`]: {
        [theme.breakpoints.down("sm")]: {
          display: "none"
        }
      }
    }));
    const TabsScroller = styled$1("div", {
      name: "MuiTabs",
      slot: "Scroller",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.scroller, ownerState.fixed && styles2.fixed, ownerState.hideScrollbar && styles2.hideScrollbar, ownerState.scrollableX && styles2.scrollableX, ownerState.scrollableY && styles2.scrollableY];
      }
    })(({
      ownerState
    }) => _extends({
      position: "relative",
      display: "inline-block",
      flex: "1 1 auto",
      whiteSpace: "nowrap"
    }, ownerState.fixed && {
      overflowX: "hidden",
      width: "100%"
    }, ownerState.hideScrollbar && {
      scrollbarWidth: "none",
      "&::-webkit-scrollbar": {
        display: "none"
      }
    }, ownerState.scrollableX && {
      overflowX: "auto",
      overflowY: "hidden"
    }, ownerState.scrollableY && {
      overflowY: "auto",
      overflowX: "hidden"
    }));
    const FlexContainer = styled$1("div", {
      name: "MuiTabs",
      slot: "FlexContainer",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.flexContainer, ownerState.vertical && styles2.flexContainerVertical, ownerState.centered && styles2.centered];
      }
    })(({
      ownerState
    }) => _extends({
      display: "flex"
    }, ownerState.vertical && {
      flexDirection: "column"
    }, ownerState.centered && {
      justifyContent: "center"
    }));
    const TabsIndicator = styled$1("span", {
      name: "MuiTabs",
      slot: "Indicator",
      overridesResolver: (props2, styles2) => styles2.indicator
    })(({
      ownerState,
      theme
    }) => _extends({
      position: "absolute",
      height: 2,
      bottom: 0,
      width: "100%",
      transition: theme.transitions.create()
    }, ownerState.indicatorColor === "primary" && {
      backgroundColor: (theme.vars || theme).palette.primary.main
    }, ownerState.indicatorColor === "secondary" && {
      backgroundColor: (theme.vars || theme).palette.secondary.main
    }, ownerState.vertical && {
      height: "100%",
      width: 2,
      right: 0
    }));
    const TabsScrollbarSize = styled$1(ScrollbarSize, {
      name: "MuiTabs",
      slot: "ScrollbarSize"
    })({
      overflowX: "auto",
      overflowY: "hidden",
      scrollbarWidth: "none",
      "&::-webkit-scrollbar": {
        display: "none"
      }
    });
    const defaultIndicatorStyle = {};
    const Tabs = /* @__PURE__ */ react.exports.forwardRef(function Tabs2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiTabs"
      });
      const theme = useTheme();
      const isRtl = theme.direction === "rtl";
      const {
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledBy,
        action,
        centered = false,
        children: childrenProp,
        className,
        component = "div",
        allowScrollButtonsMobile = false,
        indicatorColor = "primary",
        onChange,
        orientation = "horizontal",
        ScrollButtonComponent = TabScrollButton$1,
        scrollButtons = "auto",
        selectionFollowsFocus,
        TabIndicatorProps = {},
        TabScrollButtonProps = {},
        textColor = "primary",
        value,
        variant = "standard",
        visibleScrollbar = false
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$k);
      const scrollable = variant === "scrollable";
      const vertical = orientation === "vertical";
      const scrollStart = vertical ? "scrollTop" : "scrollLeft";
      const start2 = vertical ? "top" : "left";
      const end2 = vertical ? "bottom" : "right";
      const clientSize = vertical ? "clientHeight" : "clientWidth";
      const size = vertical ? "height" : "width";
      const ownerState = _extends({}, props2, {
        component,
        allowScrollButtonsMobile,
        indicatorColor,
        orientation,
        vertical,
        scrollButtons,
        textColor,
        variant,
        visibleScrollbar,
        fixed: !scrollable,
        hideScrollbar: scrollable && !visibleScrollbar,
        scrollableX: scrollable && !vertical,
        scrollableY: scrollable && vertical,
        centered: centered && !scrollable,
        scrollButtonsHideMobile: !allowScrollButtonsMobile
      });
      const classes = useUtilityClasses$l(ownerState);
      const [mounted, setMounted] = react.exports.useState(false);
      const [indicatorStyle, setIndicatorStyle] = react.exports.useState(defaultIndicatorStyle);
      const [displayScroll, setDisplayScroll] = react.exports.useState({
        start: false,
        end: false
      });
      const [scrollerStyle, setScrollerStyle] = react.exports.useState({
        overflow: "hidden",
        scrollbarWidth: 0
      });
      const valueToIndex = /* @__PURE__ */ new Map();
      const tabsRef = react.exports.useRef(null);
      const tabListRef = react.exports.useRef(null);
      const getTabsMeta = () => {
        const tabsNode = tabsRef.current;
        let tabsMeta;
        if (tabsNode) {
          const rect = tabsNode.getBoundingClientRect();
          tabsMeta = {
            clientWidth: tabsNode.clientWidth,
            scrollLeft: tabsNode.scrollLeft,
            scrollTop: tabsNode.scrollTop,
            scrollLeftNormalized: getNormalizedScrollLeft(tabsNode, theme.direction),
            scrollWidth: tabsNode.scrollWidth,
            top: rect.top,
            bottom: rect.bottom,
            left: rect.left,
            right: rect.right
          };
        }
        let tabMeta;
        if (tabsNode && value !== false) {
          const children2 = tabListRef.current.children;
          if (children2.length > 0) {
            const tab = children2[valueToIndex.get(value)];
            tabMeta = tab ? tab.getBoundingClientRect() : null;
          }
        }
        return {
          tabsMeta,
          tabMeta
        };
      };
      const updateIndicatorState = useEventCallback(() => {
        const {
          tabsMeta,
          tabMeta
        } = getTabsMeta();
        let startValue = 0;
        let startIndicator;
        if (vertical) {
          startIndicator = "top";
          if (tabMeta && tabsMeta) {
            startValue = tabMeta.top - tabsMeta.top + tabsMeta.scrollTop;
          }
        } else {
          startIndicator = isRtl ? "right" : "left";
          if (tabMeta && tabsMeta) {
            const correction = isRtl ? tabsMeta.scrollLeftNormalized + tabsMeta.clientWidth - tabsMeta.scrollWidth : tabsMeta.scrollLeft;
            startValue = (isRtl ? -1 : 1) * (tabMeta[startIndicator] - tabsMeta[startIndicator] + correction);
          }
        }
        const newIndicatorStyle = {
          [startIndicator]: startValue,
          [size]: tabMeta ? tabMeta[size] : 0
        };
        if (isNaN(indicatorStyle[startIndicator]) || isNaN(indicatorStyle[size])) {
          setIndicatorStyle(newIndicatorStyle);
        } else {
          const dStart = Math.abs(indicatorStyle[startIndicator] - newIndicatorStyle[startIndicator]);
          const dSize = Math.abs(indicatorStyle[size] - newIndicatorStyle[size]);
          if (dStart >= 1 || dSize >= 1) {
            setIndicatorStyle(newIndicatorStyle);
          }
        }
      });
      const scroll = (scrollValue, {
        animation = true
      } = {}) => {
        if (animation) {
          animate(scrollStart, tabsRef.current, scrollValue, {
            duration: theme.transitions.duration.standard
          });
        } else {
          tabsRef.current[scrollStart] = scrollValue;
        }
      };
      const moveTabsScroll = (delta) => {
        let scrollValue = tabsRef.current[scrollStart];
        if (vertical) {
          scrollValue += delta;
        } else {
          scrollValue += delta * (isRtl ? -1 : 1);
          scrollValue *= isRtl && detectScrollType() === "reverse" ? -1 : 1;
        }
        scroll(scrollValue);
      };
      const getScrollSize = () => {
        const containerSize = tabsRef.current[clientSize];
        let totalSize = 0;
        const children2 = Array.from(tabListRef.current.children);
        for (let i = 0; i < children2.length; i += 1) {
          const tab = children2[i];
          if (totalSize + tab[clientSize] > containerSize) {
            if (i === 0) {
              totalSize = containerSize;
            }
            break;
          }
          totalSize += tab[clientSize];
        }
        return totalSize;
      };
      const handleStartScrollClick = () => {
        moveTabsScroll(-1 * getScrollSize());
      };
      const handleEndScrollClick = () => {
        moveTabsScroll(getScrollSize());
      };
      const handleScrollbarSizeChange = react.exports.useCallback((scrollbarWidth) => {
        setScrollerStyle({
          overflow: null,
          scrollbarWidth
        });
      }, []);
      const getConditionalElements = () => {
        const conditionalElements2 = {};
        conditionalElements2.scrollbarSizeListener = scrollable ? /* @__PURE__ */ jsx(TabsScrollbarSize, {
          onChange: handleScrollbarSizeChange,
          className: clsx(classes.scrollableX, classes.hideScrollbar)
        }) : null;
        const scrollButtonsActive = displayScroll.start || displayScroll.end;
        const showScrollButtons = scrollable && (scrollButtons === "auto" && scrollButtonsActive || scrollButtons === true);
        conditionalElements2.scrollButtonStart = showScrollButtons ? /* @__PURE__ */ jsx(ScrollButtonComponent, _extends({
          orientation,
          direction: isRtl ? "right" : "left",
          onClick: handleStartScrollClick,
          disabled: !displayScroll.start
        }, TabScrollButtonProps, {
          className: clsx(classes.scrollButtons, TabScrollButtonProps.className)
        })) : null;
        conditionalElements2.scrollButtonEnd = showScrollButtons ? /* @__PURE__ */ jsx(ScrollButtonComponent, _extends({
          orientation,
          direction: isRtl ? "left" : "right",
          onClick: handleEndScrollClick,
          disabled: !displayScroll.end
        }, TabScrollButtonProps, {
          className: clsx(classes.scrollButtons, TabScrollButtonProps.className)
        })) : null;
        return conditionalElements2;
      };
      const scrollSelectedIntoView = useEventCallback((animation) => {
        const {
          tabsMeta,
          tabMeta
        } = getTabsMeta();
        if (!tabMeta || !tabsMeta) {
          return;
        }
        if (tabMeta[start2] < tabsMeta[start2]) {
          const nextScrollStart = tabsMeta[scrollStart] + (tabMeta[start2] - tabsMeta[start2]);
          scroll(nextScrollStart, {
            animation
          });
        } else if (tabMeta[end2] > tabsMeta[end2]) {
          const nextScrollStart = tabsMeta[scrollStart] + (tabMeta[end2] - tabsMeta[end2]);
          scroll(nextScrollStart, {
            animation
          });
        }
      });
      const updateScrollButtonState = useEventCallback(() => {
        if (scrollable && scrollButtons !== false) {
          const {
            scrollTop,
            scrollHeight,
            clientHeight,
            scrollWidth,
            clientWidth
          } = tabsRef.current;
          let showStartScroll;
          let showEndScroll;
          if (vertical) {
            showStartScroll = scrollTop > 1;
            showEndScroll = scrollTop < scrollHeight - clientHeight - 1;
          } else {
            const scrollLeft = getNormalizedScrollLeft(tabsRef.current, theme.direction);
            showStartScroll = isRtl ? scrollLeft < scrollWidth - clientWidth - 1 : scrollLeft > 1;
            showEndScroll = !isRtl ? scrollLeft < scrollWidth - clientWidth - 1 : scrollLeft > 1;
          }
          if (showStartScroll !== displayScroll.start || showEndScroll !== displayScroll.end) {
            setDisplayScroll({
              start: showStartScroll,
              end: showEndScroll
            });
          }
        }
      });
      react.exports.useEffect(() => {
        const handleResize = debounce$1(() => {
          if (tabsRef.current) {
            updateIndicatorState();
            updateScrollButtonState();
          }
        });
        const win = ownerWindow(tabsRef.current);
        win.addEventListener("resize", handleResize);
        let resizeObserver;
        if (typeof ResizeObserver !== "undefined") {
          resizeObserver = new ResizeObserver(handleResize);
          Array.from(tabListRef.current.children).forEach((child) => {
            resizeObserver.observe(child);
          });
        }
        return () => {
          handleResize.clear();
          win.removeEventListener("resize", handleResize);
          if (resizeObserver) {
            resizeObserver.disconnect();
          }
        };
      }, [updateIndicatorState, updateScrollButtonState]);
      const handleTabsScroll = react.exports.useMemo(() => debounce$1(() => {
        updateScrollButtonState();
      }), [updateScrollButtonState]);
      react.exports.useEffect(() => {
        return () => {
          handleTabsScroll.clear();
        };
      }, [handleTabsScroll]);
      react.exports.useEffect(() => {
        setMounted(true);
      }, []);
      react.exports.useEffect(() => {
        updateIndicatorState();
        updateScrollButtonState();
      });
      react.exports.useEffect(() => {
        scrollSelectedIntoView(defaultIndicatorStyle !== indicatorStyle);
      }, [scrollSelectedIntoView, indicatorStyle]);
      react.exports.useImperativeHandle(action, () => ({
        updateIndicator: updateIndicatorState,
        updateScrollButtons: updateScrollButtonState
      }), [updateIndicatorState, updateScrollButtonState]);
      const indicator = /* @__PURE__ */ jsx(TabsIndicator, _extends({}, TabIndicatorProps, {
        className: clsx(classes.indicator, TabIndicatorProps.className),
        ownerState,
        style: _extends({}, indicatorStyle, TabIndicatorProps.style)
      }));
      let childIndex = 0;
      const children = react.exports.Children.map(childrenProp, (child) => {
        if (!/* @__PURE__ */ react.exports.isValidElement(child)) {
          return null;
        }
        const childValue = child.props.value === void 0 ? childIndex : child.props.value;
        valueToIndex.set(childValue, childIndex);
        const selected = childValue === value;
        childIndex += 1;
        return /* @__PURE__ */ react.exports.cloneElement(child, _extends({
          fullWidth: variant === "fullWidth",
          indicator: selected && !mounted && indicator,
          selected,
          selectionFollowsFocus,
          onChange,
          textColor,
          value: childValue
        }, childIndex === 1 && value === false && !child.props.tabIndex ? {
          tabIndex: 0
        } : {}));
      });
      const handleKeyDown2 = (event) => {
        const list = tabListRef.current;
        const currentFocus = ownerDocument(list).activeElement;
        const role = currentFocus.getAttribute("role");
        if (role !== "tab") {
          return;
        }
        let previousItemKey = orientation === "horizontal" ? "ArrowLeft" : "ArrowUp";
        let nextItemKey = orientation === "horizontal" ? "ArrowRight" : "ArrowDown";
        if (orientation === "horizontal" && isRtl) {
          previousItemKey = "ArrowRight";
          nextItemKey = "ArrowLeft";
        }
        switch (event.key) {
          case previousItemKey:
            event.preventDefault();
            moveFocus(list, currentFocus, previousItem);
            break;
          case nextItemKey:
            event.preventDefault();
            moveFocus(list, currentFocus, nextItem);
            break;
          case "Home":
            event.preventDefault();
            moveFocus(list, null, nextItem);
            break;
          case "End":
            event.preventDefault();
            moveFocus(list, null, previousItem);
            break;
        }
      };
      const conditionalElements = getConditionalElements();
      return /* @__PURE__ */ jsxs(TabsRoot, _extends({
        className: clsx(classes.root, className),
        ownerState,
        ref,
        as: component
      }, other, {
        children: [conditionalElements.scrollButtonStart, conditionalElements.scrollbarSizeListener, /* @__PURE__ */ jsxs(TabsScroller, {
          className: classes.scroller,
          ownerState,
          style: {
            overflow: scrollerStyle.overflow,
            [vertical ? `margin${isRtl ? "Left" : "Right"}` : "marginBottom"]: visibleScrollbar ? void 0 : -scrollerStyle.scrollbarWidth
          },
          ref: tabsRef,
          onScroll: handleTabsScroll,
          children: [/* @__PURE__ */ jsx(FlexContainer, {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-orientation": orientation === "vertical" ? "vertical" : null,
            className: classes.flexContainer,
            ownerState,
            onKeyDown: handleKeyDown2,
            ref: tabListRef,
            role: "tablist",
            children
          }), mounted && indicator]
        }), conditionalElements.scrollButtonEnd]
      }));
    });
    const Tabs$1 = Tabs;
    function getTextFieldUtilityClass(slot) {
      return generateUtilityClass("MuiTextField", slot);
    }
    generateUtilityClasses("MuiTextField", ["root"]);
    const _excluded$j = ["autoComplete", "autoFocus", "children", "className", "color", "defaultValue", "disabled", "error", "FormHelperTextProps", "fullWidth", "helperText", "id", "InputLabelProps", "inputProps", "InputProps", "inputRef", "label", "maxRows", "minRows", "multiline", "name", "onBlur", "onChange", "onFocus", "placeholder", "required", "rows", "select", "SelectProps", "type", "value", "variant"];
    const variantComponent = {
      standard: Input$1,
      filled: FilledInput$1,
      outlined: OutlinedInput$1
    };
    const useUtilityClasses$k = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"]
      };
      return composeClasses(slots, getTextFieldUtilityClass, classes);
    };
    const TextFieldRoot = styled$1(FormControl$1, {
      name: "MuiTextField",
      slot: "Root",
      overridesResolver: (props2, styles2) => styles2.root
    })({});
    const TextField = /* @__PURE__ */ react.exports.forwardRef(function TextField2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiTextField"
      });
      const {
        autoComplete,
        autoFocus = false,
        children,
        className,
        color: color2 = "primary",
        defaultValue,
        disabled = false,
        error = false,
        FormHelperTextProps,
        fullWidth = false,
        helperText,
        id: idOverride,
        InputLabelProps,
        inputProps,
        InputProps,
        inputRef,
        label,
        maxRows,
        minRows,
        multiline = false,
        name,
        onBlur,
        onChange,
        onFocus,
        placeholder,
        required = false,
        rows,
        select = false,
        SelectProps,
        type: type2,
        value,
        variant = "outlined"
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$j);
      const ownerState = _extends({}, props2, {
        autoFocus,
        color: color2,
        disabled,
        error,
        fullWidth,
        multiline,
        required,
        select,
        variant
      });
      const classes = useUtilityClasses$k(ownerState);
      const InputMore = {};
      if (variant === "outlined") {
        if (InputLabelProps && typeof InputLabelProps.shrink !== "undefined") {
          InputMore.notched = InputLabelProps.shrink;
        }
        InputMore.label = label;
      }
      if (select) {
        if (!SelectProps || !SelectProps.native) {
          InputMore.id = void 0;
        }
        InputMore["aria-describedby"] = void 0;
      }
      const id2 = useId(idOverride);
      const helperTextId = helperText && id2 ? `${id2}-helper-text` : void 0;
      const inputLabelId = label && id2 ? `${id2}-label` : void 0;
      const InputComponent = variantComponent[variant];
      const InputElement = /* @__PURE__ */ jsx(InputComponent, _extends({
        "aria-describedby": helperTextId,
        autoComplete,
        autoFocus,
        defaultValue,
        fullWidth,
        multiline,
        name,
        rows,
        maxRows,
        minRows,
        type: type2,
        value,
        id: id2,
        inputRef,
        onBlur,
        onChange,
        onFocus,
        placeholder,
        inputProps
      }, InputMore, InputProps));
      return /* @__PURE__ */ jsxs(TextFieldRoot, _extends({
        className: clsx(classes.root, className),
        disabled,
        error,
        fullWidth,
        ref,
        required,
        color: color2,
        variant,
        ownerState
      }, other, {
        children: [label != null && label !== "" && /* @__PURE__ */ jsx(InputLabel$1, _extends({
          htmlFor: id2,
          id: inputLabelId
        }, InputLabelProps, {
          children: label
        })), select ? /* @__PURE__ */ jsx(Select$1, _extends({
          "aria-describedby": helperTextId,
          id: id2,
          labelId: inputLabelId,
          value,
          input: InputElement
        }, SelectProps, {
          children
        })) : InputElement, helperText && /* @__PURE__ */ jsx(FormHelperText$1, _extends({
          id: helperTextId
        }, FormHelperTextProps, {
          children: helperText
        }))]
      }));
    });
    const TextField$1 = TextField;
    const _excluded$i = ["getTrigger", "target"];
    function defaultTrigger(store, options) {
      const {
        disableHysteresis = false,
        threshold = 100,
        target
      } = options;
      const previous = store.current;
      if (target) {
        store.current = target.pageYOffset !== void 0 ? target.pageYOffset : target.scrollTop;
      }
      if (!disableHysteresis && previous !== void 0) {
        if (store.current < previous) {
          return false;
        }
      }
      return store.current > threshold;
    }
    const defaultTarget = typeof window !== "undefined" ? window : null;
    function useScrollTrigger(options = {}) {
      const {
        getTrigger = defaultTrigger,
        target = defaultTarget
      } = options, other = _objectWithoutPropertiesLoose(options, _excluded$i);
      const store = react.exports.useRef();
      const [trigger, setTrigger] = react.exports.useState(() => getTrigger(store, other));
      react.exports.useEffect(() => {
        const handleScroll = () => {
          setTrigger(getTrigger(store, _extends({
            target
          }, other)));
        };
        handleScroll();
        target.addEventListener("scroll", handleScroll, {
          passive: true
        });
        return () => {
          target.removeEventListener("scroll", handleScroll, {
            passive: true
          });
        };
      }, [target, getTrigger, JSON.stringify(other)]);
      return trigger;
    }
    var Login$1 = {};
    var interopRequireDefault = { exports: {} };
    (function(module2) {
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }
      module2.exports = _interopRequireDefault2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    })(interopRequireDefault);
    var createSvgIcon = {};
    const require$$0 = /* @__PURE__ */ getAugmentedNamespace(utils);
    var hasRequiredCreateSvgIcon;
    function requireCreateSvgIcon() {
      if (hasRequiredCreateSvgIcon)
        return createSvgIcon;
      hasRequiredCreateSvgIcon = 1;
      (function(exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        Object.defineProperty(exports2, "default", {
          enumerable: true,
          get: function() {
            return _utils.createSvgIcon;
          }
        });
        var _utils = require$$0;
      })(createSvgIcon);
      return createSvgIcon;
    }
    const require$$2 = /* @__PURE__ */ getAugmentedNamespace(jsxRuntime);
    var _interopRequireDefault$e = interopRequireDefault.exports;
    Object.defineProperty(Login$1, "__esModule", {
      value: true
    });
    var default_1$e = Login$1.default = void 0;
    var _createSvgIcon$e = _interopRequireDefault$e(requireCreateSvgIcon());
    var _jsxRuntime$e = require$$2;
    var _default$e = (0, _createSvgIcon$e.default)(/* @__PURE__ */ (0, _jsxRuntime$e.jsx)("path", {
      d: "M11 7 9.6 8.4l2.6 2.6H2v2h10.2l-2.6 2.6L11 17l5-5-5-5zm9 12h-8v2h8c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2h-8v2h8v14z"
    }), "Login");
    default_1$e = Login$1.default = _default$e;
    const LogoCayalti = "/assets/LogoCayalti.eaedeb6d.jpg";
    const LogoYarabamba = "/assets/Yarabamba_Logo.0d94149c.jpeg";
    function DialogSincronize({
      isOpen,
      isLoadingServer,
      progress
    }) {
      return /* @__PURE__ */ jsxs(Dialog$1, {
        open: isOpen,
        fullWidth: true,
        maxWidth: "sm",
        "aria-labelledby": "alert-dialogsincronize-title",
        "aria-describedby": "alert-dialogsincronize-description",
        children: [/* @__PURE__ */ jsxs(DialogTitle$1, {
          id: "alert-dialogsincronize-title",
          children: ["Sincronizando", /* @__PURE__ */ jsx("p", {
            style: {
              fontSize: "small"
            },
            children: isLoadingServer ? `Cargando data del servidor.` : progress >= 100 ? /* @__PURE__ */ jsx("b", {
              children: "COMPLETADO."
            }) : `Insertando data en el m\xF3vil.`
          })]
        }), /* @__PURE__ */ jsx(DialogContent$1, {
          children: isLoadingServer ? /* @__PURE__ */ jsx(LinearProgress$1, {}) : /* @__PURE__ */ jsx(LinearProgress$1, {
            variant: "determinate",
            value: progress
          })
        })]
      });
    }
    function getLoadingButtonUtilityClass(slot) {
      return generateUtilityClass("MuiLoadingButton", slot);
    }
    const loadingButtonClasses = generateUtilityClasses("MuiLoadingButton", ["root", "loading", "loadingIndicator", "loadingIndicatorCenter", "loadingIndicatorStart", "loadingIndicatorEnd", "endIconLoadingEnd", "startIconLoadingStart"]);
    const loadingButtonClasses$1 = loadingButtonClasses;
    const _excluded$h = ["children", "disabled", "id", "loading", "loadingIndicator", "loadingPosition", "variant"];
    const useUtilityClasses$j = (ownerState) => {
      const {
        loading,
        loadingPosition,
        classes
      } = ownerState;
      const slots = {
        root: ["root", loading && "loading"],
        startIcon: [loading && `startIconLoading${capitalize(loadingPosition)}`],
        endIcon: [loading && `endIconLoading${capitalize(loadingPosition)}`],
        loadingIndicator: ["loadingIndicator", loading && `loadingIndicator${capitalize(loadingPosition)}`]
      };
      const composedClasses = composeClasses(slots, getLoadingButtonUtilityClass, classes);
      return _extends({}, classes, composedClasses);
    };
    const rootShouldForwardProp = (prop) => prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as" && prop !== "classes";
    const LoadingButtonRoot = styled$1(Button$1, {
      shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
      name: "MuiLoadingButton",
      slot: "Root",
      overridesResolver: (props2, styles2) => {
        return [styles2.root, styles2.startIconLoadingStart && {
          [`& .${loadingButtonClasses$1.startIconLoadingStart}`]: styles2.startIconLoadingStart
        }, styles2.endIconLoadingEnd && {
          [`& .${loadingButtonClasses$1.endIconLoadingEnd}`]: styles2.endIconLoadingEnd
        }];
      }
    })(({
      ownerState,
      theme
    }) => _extends({
      [`& .${loadingButtonClasses$1.startIconLoadingStart}, & .${loadingButtonClasses$1.endIconLoadingEnd}`]: {
        transition: theme.transitions.create(["opacity"], {
          duration: theme.transitions.duration.short
        }),
        opacity: 0
      }
    }, ownerState.loadingPosition === "center" && {
      transition: theme.transitions.create(["background-color", "box-shadow", "border-color"], {
        duration: theme.transitions.duration.short
      }),
      [`&.${loadingButtonClasses$1.loading}`]: {
        color: "transparent"
      }
    }, ownerState.loadingPosition === "start" && ownerState.fullWidth && {
      [`& .${loadingButtonClasses$1.startIconLoadingStart}, & .${loadingButtonClasses$1.endIconLoadingEnd}`]: {
        transition: theme.transitions.create(["opacity"], {
          duration: theme.transitions.duration.short
        }),
        opacity: 0,
        marginRight: -8
      }
    }, ownerState.loadingPosition === "end" && ownerState.fullWidth && {
      [`& .${loadingButtonClasses$1.startIconLoadingStart}, & .${loadingButtonClasses$1.endIconLoadingEnd}`]: {
        transition: theme.transitions.create(["opacity"], {
          duration: theme.transitions.duration.short
        }),
        opacity: 0,
        marginLeft: -8
      }
    }));
    const LoadingButtonLoadingIndicator = styled$1("div", {
      name: "MuiLoadingButton",
      slot: "LoadingIndicator",
      overridesResolver: (props2, styles2) => {
        const {
          ownerState
        } = props2;
        return [styles2.loadingIndicator, styles2[`loadingIndicator${capitalize(ownerState.loadingPosition)}`]];
      }
    })(({
      theme,
      ownerState
    }) => _extends({
      position: "absolute",
      visibility: "visible",
      display: "flex"
    }, ownerState.loadingPosition === "start" && (ownerState.variant === "outlined" || ownerState.variant === "contained") && {
      left: ownerState.size === "small" ? 10 : 14
    }, ownerState.loadingPosition === "start" && ownerState.variant === "text" && {
      left: 6
    }, ownerState.loadingPosition === "center" && {
      left: "50%",
      transform: "translate(-50%)",
      color: (theme.vars || theme).palette.action.disabled
    }, ownerState.loadingPosition === "end" && (ownerState.variant === "outlined" || ownerState.variant === "contained") && {
      right: ownerState.size === "small" ? 10 : 14
    }, ownerState.loadingPosition === "end" && ownerState.variant === "text" && {
      right: 6
    }, ownerState.loadingPosition === "start" && ownerState.fullWidth && {
      position: "relative",
      left: -10
    }, ownerState.loadingPosition === "end" && ownerState.fullWidth && {
      position: "relative",
      right: -10
    }));
    const LoadingButton = /* @__PURE__ */ react.exports.forwardRef(function LoadingButton2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiLoadingButton"
      });
      const {
        children,
        disabled = false,
        id: idProp,
        loading = false,
        loadingIndicator: loadingIndicatorProp,
        loadingPosition = "center",
        variant = "text"
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$h);
      const id2 = useId(idProp);
      const loadingIndicator = loadingIndicatorProp != null ? loadingIndicatorProp : /* @__PURE__ */ jsx(CircularProgress$1, {
        "aria-labelledby": id2,
        color: "inherit",
        size: 16
      });
      const ownerState = _extends({}, props2, {
        disabled,
        loading,
        loadingIndicator,
        loadingPosition,
        variant
      });
      const classes = useUtilityClasses$j(ownerState);
      const loadingButtonLoadingIndicator = loading ? /* @__PURE__ */ jsx(LoadingButtonLoadingIndicator, {
        className: classes.loadingIndicator,
        ownerState,
        children: loadingIndicator
      }) : null;
      return /* @__PURE__ */ jsxs(LoadingButtonRoot, _extends({
        disabled: disabled || loading,
        id: id2,
        ref
      }, other, {
        variant,
        classes,
        ownerState,
        children: [ownerState.loadingPosition === "end" ? children : loadingButtonLoadingIndicator, ownerState.loadingPosition === "end" ? loadingButtonLoadingIndicator : children]
      }));
    });
    const LoadingButton$1 = LoadingButton;
    const Context$1 = React.createContext({});
    const EMPRESA_DEFAULT = "002";
    const CULTIVO_DEFAULT = " ";
    const ETAPAFENOLOGICA_DEFAU\u00D1T = "";
    function AuthContextProvider({
      children
    }) {
      const SESSION_NAME = "usuario";
      const CACHE_EMPRESA = "empresa";
      const CACHE_CULTIVO = "ussanidadcultivo";
      const CACHE_ETAPAFENOLOGICA = "ussanidadetapafenologica";
      const [auth, setAuth] = react.exports.useState(() => JSON.parse(window.localStorage.getItem(`${SESSION_NAME}`)));
      const [empresa, setEmpresa] = react.exports.useState(() => {
        const localStorageEmpresa = window.localStorage.getItem(`${CACHE_EMPRESA}`);
        if (!localStorageEmpresa) {
          return EMPRESA_DEFAULT;
        }
        return localStorageEmpresa;
      });
      const [cultivo, setCultivo] = react.exports.useState(() => {
        const localStorageCultivo = window.localStorage.getItem(`${CACHE_CULTIVO}`);
        if (!localStorageCultivo) {
          return CULTIVO_DEFAULT;
        }
        return localStorageCultivo;
      });
      const [etapaFenologica, setEtapaFenologica] = react.exports.useState(() => {
        const localStorageEtapaFenolgica = window.localStorage.getItem(`${CACHE_ETAPAFENOLOGICA}`);
        if (!localStorageEtapaFenolgica) {
          return ETAPAFENOLOGICA_DEFAU\u00D1T;
        }
        return localStorageEtapaFenolgica;
      });
      const [aplicativo, setAplicativo] = react.exports.useState("");
      return /* @__PURE__ */ jsx(Context$1.Provider, {
        value: {
          auth,
          setAuth,
          cultivo,
          setCultivo,
          empresa,
          setEmpresa,
          aplicativo,
          setAplicativo,
          etapaFenologica,
          setEtapaFenologica
        },
        children
      });
    }
    var md5$1 = { exports: {} };
    /**
     * [js-md5]{@link https://github.com/emn178/js-md5}
     *
     * @namespace md5
     * @version 0.7.3
     * @author Chen, Yi-Cyuan [emn178@gmail.com]
     * @copyright Chen, Yi-Cyuan 2014-2017
     * @license MIT
     */
    (function(module) {
      (function() {
        var ERROR = "input is invalid type";
        var WINDOW = typeof window === "object";
        var root = WINDOW ? window : {};
        if (root.JS_MD5_NO_WINDOW) {
          WINDOW = false;
        }
        var WEB_WORKER = !WINDOW && typeof self === "object";
        var NODE_JS = !root.JS_MD5_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
        if (NODE_JS) {
          root = commonjsGlobal;
        } else if (WEB_WORKER) {
          root = self;
        }
        var COMMON_JS = !root.JS_MD5_NO_COMMON_JS && true && module.exports;
        var ARRAY_BUFFER = !root.JS_MD5_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
        var HEX_CHARS = "0123456789abcdef".split("");
        var EXTRA = [128, 32768, 8388608, -2147483648];
        var SHIFT = [0, 8, 16, 24];
        var OUTPUT_TYPES = ["hex", "array", "digest", "buffer", "arrayBuffer", "base64"];
        var BASE64_ENCODE_CHAR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
        var blocks = [], buffer8;
        if (ARRAY_BUFFER) {
          var buffer = new ArrayBuffer(68);
          buffer8 = new Uint8Array(buffer);
          blocks = new Uint32Array(buffer);
        }
        if (root.JS_MD5_NO_NODE_JS || !Array.isArray) {
          Array.isArray = function(obj) {
            return Object.prototype.toString.call(obj) === "[object Array]";
          };
        }
        if (ARRAY_BUFFER && (root.JS_MD5_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
          ArrayBuffer.isView = function(obj) {
            return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
          };
        }
        var createOutputMethod = function(outputType) {
          return function(message) {
            return new Md5(true).update(message)[outputType]();
          };
        };
        var createMethod = function() {
          var method2 = createOutputMethod("hex");
          if (NODE_JS) {
            method2 = nodeWrap(method2);
          }
          method2.create = function() {
            return new Md5();
          };
          method2.update = function(message) {
            return method2.create().update(message);
          };
          for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
            var type2 = OUTPUT_TYPES[i];
            method2[type2] = createOutputMethod(type2);
          }
          return method2;
        };
        var nodeWrap = function(method) {
          var crypto = eval("require('crypto')");
          var Buffer = eval("require('buffer').Buffer");
          var nodeMethod = function(message) {
            if (typeof message === "string") {
              return crypto.createHash("md5").update(message, "utf8").digest("hex");
            } else {
              if (message === null || message === void 0) {
                throw ERROR;
              } else if (message.constructor === ArrayBuffer) {
                message = new Uint8Array(message);
              }
            }
            if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer) {
              return crypto.createHash("md5").update(new Buffer(message)).digest("hex");
            } else {
              return method(message);
            }
          };
          return nodeMethod;
        };
        function Md5(sharedMemory) {
          if (sharedMemory) {
            blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
            this.blocks = blocks;
            this.buffer8 = buffer8;
          } else {
            if (ARRAY_BUFFER) {
              var buffer2 = new ArrayBuffer(68);
              this.buffer8 = new Uint8Array(buffer2);
              this.blocks = new Uint32Array(buffer2);
            } else {
              this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            }
          }
          this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = this.hBytes = 0;
          this.finalized = this.hashed = false;
          this.first = true;
        }
        Md5.prototype.update = function(message) {
          if (this.finalized) {
            return;
          }
          var notString, type2 = typeof message;
          if (type2 !== "string") {
            if (type2 === "object") {
              if (message === null) {
                throw ERROR;
              } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
                message = new Uint8Array(message);
              } else if (!Array.isArray(message)) {
                if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                  throw ERROR;
                }
              }
            } else {
              throw ERROR;
            }
            notString = true;
          }
          var code, index2 = 0, i, length2 = message.length, blocks2 = this.blocks;
          var buffer82 = this.buffer8;
          while (index2 < length2) {
            if (this.hashed) {
              this.hashed = false;
              blocks2[0] = blocks2[16];
              blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
            }
            if (notString) {
              if (ARRAY_BUFFER) {
                for (i = this.start; index2 < length2 && i < 64; ++index2) {
                  buffer82[i++] = message[index2];
                }
              } else {
                for (i = this.start; index2 < length2 && i < 64; ++index2) {
                  blocks2[i >> 2] |= message[index2] << SHIFT[i++ & 3];
                }
              }
            } else {
              if (ARRAY_BUFFER) {
                for (i = this.start; index2 < length2 && i < 64; ++index2) {
                  code = message.charCodeAt(index2);
                  if (code < 128) {
                    buffer82[i++] = code;
                  } else if (code < 2048) {
                    buffer82[i++] = 192 | code >> 6;
                    buffer82[i++] = 128 | code & 63;
                  } else if (code < 55296 || code >= 57344) {
                    buffer82[i++] = 224 | code >> 12;
                    buffer82[i++] = 128 | code >> 6 & 63;
                    buffer82[i++] = 128 | code & 63;
                  } else {
                    code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index2) & 1023);
                    buffer82[i++] = 240 | code >> 18;
                    buffer82[i++] = 128 | code >> 12 & 63;
                    buffer82[i++] = 128 | code >> 6 & 63;
                    buffer82[i++] = 128 | code & 63;
                  }
                }
              } else {
                for (i = this.start; index2 < length2 && i < 64; ++index2) {
                  code = message.charCodeAt(index2);
                  if (code < 128) {
                    blocks2[i >> 2] |= code << SHIFT[i++ & 3];
                  } else if (code < 2048) {
                    blocks2[i >> 2] |= (192 | code >> 6) << SHIFT[i++ & 3];
                    blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                  } else if (code < 55296 || code >= 57344) {
                    blocks2[i >> 2] |= (224 | code >> 12) << SHIFT[i++ & 3];
                    blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                    blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                  } else {
                    code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index2) & 1023);
                    blocks2[i >> 2] |= (240 | code >> 18) << SHIFT[i++ & 3];
                    blocks2[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[i++ & 3];
                    blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                    blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                  }
                }
              }
            }
            this.lastByteIndex = i;
            this.bytes += i - this.start;
            if (i >= 64) {
              this.start = i - 64;
              this.hash();
              this.hashed = true;
            } else {
              this.start = i;
            }
          }
          if (this.bytes > 4294967295) {
            this.hBytes += this.bytes / 4294967296 << 0;
            this.bytes = this.bytes % 4294967296;
          }
          return this;
        };
        Md5.prototype.finalize = function() {
          if (this.finalized) {
            return;
          }
          this.finalized = true;
          var blocks2 = this.blocks, i = this.lastByteIndex;
          blocks2[i >> 2] |= EXTRA[i & 3];
          if (i >= 56) {
            if (!this.hashed) {
              this.hash();
            }
            blocks2[0] = blocks2[16];
            blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
          }
          blocks2[14] = this.bytes << 3;
          blocks2[15] = this.hBytes << 3 | this.bytes >>> 29;
          this.hash();
        };
        Md5.prototype.hash = function() {
          var a, b2, c2, d2, bc2, da2, blocks2 = this.blocks;
          if (this.first) {
            a = blocks2[0] - 680876937;
            a = (a << 7 | a >>> 25) - 271733879 << 0;
            d2 = (-1732584194 ^ a & 2004318071) + blocks2[1] - 117830708;
            d2 = (d2 << 12 | d2 >>> 20) + a << 0;
            c2 = (-271733879 ^ d2 & (a ^ -271733879)) + blocks2[2] - 1126478375;
            c2 = (c2 << 17 | c2 >>> 15) + d2 << 0;
            b2 = (a ^ c2 & (d2 ^ a)) + blocks2[3] - 1316259209;
            b2 = (b2 << 22 | b2 >>> 10) + c2 << 0;
          } else {
            a = this.h0;
            b2 = this.h1;
            c2 = this.h2;
            d2 = this.h3;
            a += (d2 ^ b2 & (c2 ^ d2)) + blocks2[0] - 680876936;
            a = (a << 7 | a >>> 25) + b2 << 0;
            d2 += (c2 ^ a & (b2 ^ c2)) + blocks2[1] - 389564586;
            d2 = (d2 << 12 | d2 >>> 20) + a << 0;
            c2 += (b2 ^ d2 & (a ^ b2)) + blocks2[2] + 606105819;
            c2 = (c2 << 17 | c2 >>> 15) + d2 << 0;
            b2 += (a ^ c2 & (d2 ^ a)) + blocks2[3] - 1044525330;
            b2 = (b2 << 22 | b2 >>> 10) + c2 << 0;
          }
          a += (d2 ^ b2 & (c2 ^ d2)) + blocks2[4] - 176418897;
          a = (a << 7 | a >>> 25) + b2 << 0;
          d2 += (c2 ^ a & (b2 ^ c2)) + blocks2[5] + 1200080426;
          d2 = (d2 << 12 | d2 >>> 20) + a << 0;
          c2 += (b2 ^ d2 & (a ^ b2)) + blocks2[6] - 1473231341;
          c2 = (c2 << 17 | c2 >>> 15) + d2 << 0;
          b2 += (a ^ c2 & (d2 ^ a)) + blocks2[7] - 45705983;
          b2 = (b2 << 22 | b2 >>> 10) + c2 << 0;
          a += (d2 ^ b2 & (c2 ^ d2)) + blocks2[8] + 1770035416;
          a = (a << 7 | a >>> 25) + b2 << 0;
          d2 += (c2 ^ a & (b2 ^ c2)) + blocks2[9] - 1958414417;
          d2 = (d2 << 12 | d2 >>> 20) + a << 0;
          c2 += (b2 ^ d2 & (a ^ b2)) + blocks2[10] - 42063;
          c2 = (c2 << 17 | c2 >>> 15) + d2 << 0;
          b2 += (a ^ c2 & (d2 ^ a)) + blocks2[11] - 1990404162;
          b2 = (b2 << 22 | b2 >>> 10) + c2 << 0;
          a += (d2 ^ b2 & (c2 ^ d2)) + blocks2[12] + 1804603682;
          a = (a << 7 | a >>> 25) + b2 << 0;
          d2 += (c2 ^ a & (b2 ^ c2)) + blocks2[13] - 40341101;
          d2 = (d2 << 12 | d2 >>> 20) + a << 0;
          c2 += (b2 ^ d2 & (a ^ b2)) + blocks2[14] - 1502002290;
          c2 = (c2 << 17 | c2 >>> 15) + d2 << 0;
          b2 += (a ^ c2 & (d2 ^ a)) + blocks2[15] + 1236535329;
          b2 = (b2 << 22 | b2 >>> 10) + c2 << 0;
          a += (c2 ^ d2 & (b2 ^ c2)) + blocks2[1] - 165796510;
          a = (a << 5 | a >>> 27) + b2 << 0;
          d2 += (b2 ^ c2 & (a ^ b2)) + blocks2[6] - 1069501632;
          d2 = (d2 << 9 | d2 >>> 23) + a << 0;
          c2 += (a ^ b2 & (d2 ^ a)) + blocks2[11] + 643717713;
          c2 = (c2 << 14 | c2 >>> 18) + d2 << 0;
          b2 += (d2 ^ a & (c2 ^ d2)) + blocks2[0] - 373897302;
          b2 = (b2 << 20 | b2 >>> 12) + c2 << 0;
          a += (c2 ^ d2 & (b2 ^ c2)) + blocks2[5] - 701558691;
          a = (a << 5 | a >>> 27) + b2 << 0;
          d2 += (b2 ^ c2 & (a ^ b2)) + blocks2[10] + 38016083;
          d2 = (d2 << 9 | d2 >>> 23) + a << 0;
          c2 += (a ^ b2 & (d2 ^ a)) + blocks2[15] - 660478335;
          c2 = (c2 << 14 | c2 >>> 18) + d2 << 0;
          b2 += (d2 ^ a & (c2 ^ d2)) + blocks2[4] - 405537848;
          b2 = (b2 << 20 | b2 >>> 12) + c2 << 0;
          a += (c2 ^ d2 & (b2 ^ c2)) + blocks2[9] + 568446438;
          a = (a << 5 | a >>> 27) + b2 << 0;
          d2 += (b2 ^ c2 & (a ^ b2)) + blocks2[14] - 1019803690;
          d2 = (d2 << 9 | d2 >>> 23) + a << 0;
          c2 += (a ^ b2 & (d2 ^ a)) + blocks2[3] - 187363961;
          c2 = (c2 << 14 | c2 >>> 18) + d2 << 0;
          b2 += (d2 ^ a & (c2 ^ d2)) + blocks2[8] + 1163531501;
          b2 = (b2 << 20 | b2 >>> 12) + c2 << 0;
          a += (c2 ^ d2 & (b2 ^ c2)) + blocks2[13] - 1444681467;
          a = (a << 5 | a >>> 27) + b2 << 0;
          d2 += (b2 ^ c2 & (a ^ b2)) + blocks2[2] - 51403784;
          d2 = (d2 << 9 | d2 >>> 23) + a << 0;
          c2 += (a ^ b2 & (d2 ^ a)) + blocks2[7] + 1735328473;
          c2 = (c2 << 14 | c2 >>> 18) + d2 << 0;
          b2 += (d2 ^ a & (c2 ^ d2)) + blocks2[12] - 1926607734;
          b2 = (b2 << 20 | b2 >>> 12) + c2 << 0;
          bc2 = b2 ^ c2;
          a += (bc2 ^ d2) + blocks2[5] - 378558;
          a = (a << 4 | a >>> 28) + b2 << 0;
          d2 += (bc2 ^ a) + blocks2[8] - 2022574463;
          d2 = (d2 << 11 | d2 >>> 21) + a << 0;
          da2 = d2 ^ a;
          c2 += (da2 ^ b2) + blocks2[11] + 1839030562;
          c2 = (c2 << 16 | c2 >>> 16) + d2 << 0;
          b2 += (da2 ^ c2) + blocks2[14] - 35309556;
          b2 = (b2 << 23 | b2 >>> 9) + c2 << 0;
          bc2 = b2 ^ c2;
          a += (bc2 ^ d2) + blocks2[1] - 1530992060;
          a = (a << 4 | a >>> 28) + b2 << 0;
          d2 += (bc2 ^ a) + blocks2[4] + 1272893353;
          d2 = (d2 << 11 | d2 >>> 21) + a << 0;
          da2 = d2 ^ a;
          c2 += (da2 ^ b2) + blocks2[7] - 155497632;
          c2 = (c2 << 16 | c2 >>> 16) + d2 << 0;
          b2 += (da2 ^ c2) + blocks2[10] - 1094730640;
          b2 = (b2 << 23 | b2 >>> 9) + c2 << 0;
          bc2 = b2 ^ c2;
          a += (bc2 ^ d2) + blocks2[13] + 681279174;
          a = (a << 4 | a >>> 28) + b2 << 0;
          d2 += (bc2 ^ a) + blocks2[0] - 358537222;
          d2 = (d2 << 11 | d2 >>> 21) + a << 0;
          da2 = d2 ^ a;
          c2 += (da2 ^ b2) + blocks2[3] - 722521979;
          c2 = (c2 << 16 | c2 >>> 16) + d2 << 0;
          b2 += (da2 ^ c2) + blocks2[6] + 76029189;
          b2 = (b2 << 23 | b2 >>> 9) + c2 << 0;
          bc2 = b2 ^ c2;
          a += (bc2 ^ d2) + blocks2[9] - 640364487;
          a = (a << 4 | a >>> 28) + b2 << 0;
          d2 += (bc2 ^ a) + blocks2[12] - 421815835;
          d2 = (d2 << 11 | d2 >>> 21) + a << 0;
          da2 = d2 ^ a;
          c2 += (da2 ^ b2) + blocks2[15] + 530742520;
          c2 = (c2 << 16 | c2 >>> 16) + d2 << 0;
          b2 += (da2 ^ c2) + blocks2[2] - 995338651;
          b2 = (b2 << 23 | b2 >>> 9) + c2 << 0;
          a += (c2 ^ (b2 | ~d2)) + blocks2[0] - 198630844;
          a = (a << 6 | a >>> 26) + b2 << 0;
          d2 += (b2 ^ (a | ~c2)) + blocks2[7] + 1126891415;
          d2 = (d2 << 10 | d2 >>> 22) + a << 0;
          c2 += (a ^ (d2 | ~b2)) + blocks2[14] - 1416354905;
          c2 = (c2 << 15 | c2 >>> 17) + d2 << 0;
          b2 += (d2 ^ (c2 | ~a)) + blocks2[5] - 57434055;
          b2 = (b2 << 21 | b2 >>> 11) + c2 << 0;
          a += (c2 ^ (b2 | ~d2)) + blocks2[12] + 1700485571;
          a = (a << 6 | a >>> 26) + b2 << 0;
          d2 += (b2 ^ (a | ~c2)) + blocks2[3] - 1894986606;
          d2 = (d2 << 10 | d2 >>> 22) + a << 0;
          c2 += (a ^ (d2 | ~b2)) + blocks2[10] - 1051523;
          c2 = (c2 << 15 | c2 >>> 17) + d2 << 0;
          b2 += (d2 ^ (c2 | ~a)) + blocks2[1] - 2054922799;
          b2 = (b2 << 21 | b2 >>> 11) + c2 << 0;
          a += (c2 ^ (b2 | ~d2)) + blocks2[8] + 1873313359;
          a = (a << 6 | a >>> 26) + b2 << 0;
          d2 += (b2 ^ (a | ~c2)) + blocks2[15] - 30611744;
          d2 = (d2 << 10 | d2 >>> 22) + a << 0;
          c2 += (a ^ (d2 | ~b2)) + blocks2[6] - 1560198380;
          c2 = (c2 << 15 | c2 >>> 17) + d2 << 0;
          b2 += (d2 ^ (c2 | ~a)) + blocks2[13] + 1309151649;
          b2 = (b2 << 21 | b2 >>> 11) + c2 << 0;
          a += (c2 ^ (b2 | ~d2)) + blocks2[4] - 145523070;
          a = (a << 6 | a >>> 26) + b2 << 0;
          d2 += (b2 ^ (a | ~c2)) + blocks2[11] - 1120210379;
          d2 = (d2 << 10 | d2 >>> 22) + a << 0;
          c2 += (a ^ (d2 | ~b2)) + blocks2[2] + 718787259;
          c2 = (c2 << 15 | c2 >>> 17) + d2 << 0;
          b2 += (d2 ^ (c2 | ~a)) + blocks2[9] - 343485551;
          b2 = (b2 << 21 | b2 >>> 11) + c2 << 0;
          if (this.first) {
            this.h0 = a + 1732584193 << 0;
            this.h1 = b2 - 271733879 << 0;
            this.h2 = c2 - 1732584194 << 0;
            this.h3 = d2 + 271733878 << 0;
            this.first = false;
          } else {
            this.h0 = this.h0 + a << 0;
            this.h1 = this.h1 + b2 << 0;
            this.h2 = this.h2 + c2 << 0;
            this.h3 = this.h3 + d2 << 0;
          }
        };
        Md5.prototype.hex = function() {
          this.finalize();
          var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;
          return HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15];
        };
        Md5.prototype.toString = Md5.prototype.hex;
        Md5.prototype.digest = function() {
          this.finalize();
          var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;
          return [
            h0 & 255,
            h0 >> 8 & 255,
            h0 >> 16 & 255,
            h0 >> 24 & 255,
            h1 & 255,
            h1 >> 8 & 255,
            h1 >> 16 & 255,
            h1 >> 24 & 255,
            h2 & 255,
            h2 >> 8 & 255,
            h2 >> 16 & 255,
            h2 >> 24 & 255,
            h3 & 255,
            h3 >> 8 & 255,
            h3 >> 16 & 255,
            h3 >> 24 & 255
          ];
        };
        Md5.prototype.array = Md5.prototype.digest;
        Md5.prototype.arrayBuffer = function() {
          this.finalize();
          var buffer2 = new ArrayBuffer(16);
          var blocks2 = new Uint32Array(buffer2);
          blocks2[0] = this.h0;
          blocks2[1] = this.h1;
          blocks2[2] = this.h2;
          blocks2[3] = this.h3;
          return buffer2;
        };
        Md5.prototype.buffer = Md5.prototype.arrayBuffer;
        Md5.prototype.base64 = function() {
          var v1, v2, v3, base64Str = "", bytes = this.array();
          for (var i = 0; i < 15; ) {
            v1 = bytes[i++];
            v2 = bytes[i++];
            v3 = bytes[i++];
            base64Str += BASE64_ENCODE_CHAR[v1 >>> 2] + BASE64_ENCODE_CHAR[(v1 << 4 | v2 >>> 4) & 63] + BASE64_ENCODE_CHAR[(v2 << 2 | v3 >>> 6) & 63] + BASE64_ENCODE_CHAR[v3 & 63];
          }
          v1 = bytes[i];
          base64Str += BASE64_ENCODE_CHAR[v1 >>> 2] + BASE64_ENCODE_CHAR[v1 << 4 & 63] + "==";
          return base64Str;
        };
        var exports = createMethod();
        if (COMMON_JS) {
          module.exports = exports;
        } else {
          root.md5 = exports;
        }
      })();
    })(md5$1);
    const md5 = md5$1.exports;
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.
    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    var __assign = function() {
      __assign = Object.assign || function __assign2(t2) {
        for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
          s = arguments[i];
          for (var p2 in s)
            if (Object.prototype.hasOwnProperty.call(s, p2))
              t2[p2] = s[p2];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    function __spreadArray(to2, from2, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l2 = from2.length, ar; i < l2; i++) {
          if (ar || !(i in from2)) {
            if (!ar)
              ar = Array.prototype.slice.call(from2, 0, i);
            ar[i] = from2[i];
          }
        }
      return to2.concat(ar || Array.prototype.slice.call(from2));
    }
    var _global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
    var keys$1 = Object.keys;
    var isArray$1 = Array.isArray;
    if (typeof Promise !== "undefined" && !_global.Promise) {
      _global.Promise = Promise;
    }
    function extend$1(obj, extension) {
      if (typeof extension !== "object")
        return obj;
      keys$1(extension).forEach(function(key) {
        obj[key] = extension[key];
      });
      return obj;
    }
    var getProto = Object.getPrototypeOf;
    var _hasOwn = {}.hasOwnProperty;
    function hasOwn(obj, prop) {
      return _hasOwn.call(obj, prop);
    }
    function props(proto2, extension) {
      if (typeof extension === "function")
        extension = extension(getProto(proto2));
      (typeof Reflect === "undefined" ? keys$1 : Reflect.ownKeys)(extension).forEach(function(key) {
        setProp(proto2, key, extension[key]);
      });
    }
    var defineProperty = Object.defineProperty;
    function setProp(obj, prop, functionOrGetSet, options) {
      defineProperty(obj, prop, extend$1(functionOrGetSet && hasOwn(functionOrGetSet, "get") && typeof functionOrGetSet.get === "function" ? { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } : { value: functionOrGetSet, configurable: true, writable: true }, options));
    }
    function derive(Child) {
      return {
        from: function(Parent) {
          Child.prototype = Object.create(Parent.prototype);
          setProp(Child.prototype, "constructor", Child);
          return {
            extend: props.bind(null, Child.prototype)
          };
        }
      };
    }
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    function getPropertyDescriptor(obj, prop) {
      var pd2 = getOwnPropertyDescriptor(obj, prop);
      var proto2;
      return pd2 || (proto2 = getProto(obj)) && getPropertyDescriptor(proto2, prop);
    }
    var _slice = [].slice;
    function slice(args, start2, end2) {
      return _slice.call(args, start2, end2);
    }
    function override(origFunc, overridedFactory) {
      return overridedFactory(origFunc);
    }
    function assert(b2) {
      if (!b2)
        throw new Error("Assertion Failed");
    }
    function asap$1(fn) {
      if (_global.setImmediate)
        setImmediate(fn);
      else
        setTimeout(fn, 0);
    }
    function arrayToObject(array, extractor) {
      return array.reduce(function(result, item, i) {
        var nameAndValue = extractor(item, i);
        if (nameAndValue)
          result[nameAndValue[0]] = nameAndValue[1];
        return result;
      }, {});
    }
    function tryCatch(fn, onerror, args) {
      try {
        fn.apply(null, args);
      } catch (ex) {
        onerror && onerror(ex);
      }
    }
    function getByKeyPath(obj, keyPath) {
      if (hasOwn(obj, keyPath))
        return obj[keyPath];
      if (!keyPath)
        return obj;
      if (typeof keyPath !== "string") {
        var rv = [];
        for (var i = 0, l2 = keyPath.length; i < l2; ++i) {
          var val = getByKeyPath(obj, keyPath[i]);
          rv.push(val);
        }
        return rv;
      }
      var period = keyPath.indexOf(".");
      if (period !== -1) {
        var innerObj = obj[keyPath.substr(0, period)];
        return innerObj === void 0 ? void 0 : getByKeyPath(innerObj, keyPath.substr(period + 1));
      }
      return void 0;
    }
    function setByKeyPath(obj, keyPath, value) {
      if (!obj || keyPath === void 0)
        return;
      if ("isFrozen" in Object && Object.isFrozen(obj))
        return;
      if (typeof keyPath !== "string" && "length" in keyPath) {
        assert(typeof value !== "string" && "length" in value);
        for (var i = 0, l2 = keyPath.length; i < l2; ++i) {
          setByKeyPath(obj, keyPath[i], value[i]);
        }
      } else {
        var period = keyPath.indexOf(".");
        if (period !== -1) {
          var currentKeyPath = keyPath.substr(0, period);
          var remainingKeyPath = keyPath.substr(period + 1);
          if (remainingKeyPath === "")
            if (value === void 0) {
              if (isArray$1(obj) && !isNaN(parseInt(currentKeyPath)))
                obj.splice(currentKeyPath, 1);
              else
                delete obj[currentKeyPath];
            } else
              obj[currentKeyPath] = value;
          else {
            var innerObj = obj[currentKeyPath];
            if (!innerObj || !hasOwn(obj, currentKeyPath))
              innerObj = obj[currentKeyPath] = {};
            setByKeyPath(innerObj, remainingKeyPath, value);
          }
        } else {
          if (value === void 0) {
            if (isArray$1(obj) && !isNaN(parseInt(keyPath)))
              obj.splice(keyPath, 1);
            else
              delete obj[keyPath];
          } else
            obj[keyPath] = value;
        }
      }
    }
    function delByKeyPath(obj, keyPath) {
      if (typeof keyPath === "string")
        setByKeyPath(obj, keyPath, void 0);
      else if ("length" in keyPath)
        [].map.call(keyPath, function(kp) {
          setByKeyPath(obj, kp, void 0);
        });
    }
    function shallowClone(obj) {
      var rv = {};
      for (var m2 in obj) {
        if (hasOwn(obj, m2))
          rv[m2] = obj[m2];
      }
      return rv;
    }
    var concat = [].concat;
    function flatten(a) {
      return concat.apply([], a);
    }
    var intrinsicTypeNames = "Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(flatten([8, 16, 32, 64].map(function(num) {
      return ["Int", "Uint", "Float"].map(function(t2) {
        return t2 + num + "Array";
      });
    }))).filter(function(t2) {
      return _global[t2];
    });
    var intrinsicTypes = intrinsicTypeNames.map(function(t2) {
      return _global[t2];
    });
    arrayToObject(intrinsicTypeNames, function(x2) {
      return [x2, true];
    });
    var circularRefs = null;
    function deepClone(any) {
      circularRefs = typeof WeakMap !== "undefined" && /* @__PURE__ */ new WeakMap();
      var rv = innerDeepClone(any);
      circularRefs = null;
      return rv;
    }
    function innerDeepClone(any) {
      if (!any || typeof any !== "object")
        return any;
      var rv = circularRefs && circularRefs.get(any);
      if (rv)
        return rv;
      if (isArray$1(any)) {
        rv = [];
        circularRefs && circularRefs.set(any, rv);
        for (var i = 0, l2 = any.length; i < l2; ++i) {
          rv.push(innerDeepClone(any[i]));
        }
      } else if (intrinsicTypes.indexOf(any.constructor) >= 0) {
        rv = any;
      } else {
        var proto2 = getProto(any);
        rv = proto2 === Object.prototype ? {} : Object.create(proto2);
        circularRefs && circularRefs.set(any, rv);
        for (var prop in any) {
          if (hasOwn(any, prop)) {
            rv[prop] = innerDeepClone(any[prop]);
          }
        }
      }
      return rv;
    }
    var toString$1 = {}.toString;
    function toStringTag(o) {
      return toString$1.call(o).slice(8, -1);
    }
    var iteratorSymbol = typeof Symbol !== "undefined" ? Symbol.iterator : "@@iterator";
    var getIteratorOf = typeof iteratorSymbol === "symbol" ? function(x2) {
      var i;
      return x2 != null && (i = x2[iteratorSymbol]) && i.apply(x2);
    } : function() {
      return null;
    };
    var NO_CHAR_ARRAY = {};
    function getArrayOf(arrayLike) {
      var i, a, x2, it;
      if (arguments.length === 1) {
        if (isArray$1(arrayLike))
          return arrayLike.slice();
        if (this === NO_CHAR_ARRAY && typeof arrayLike === "string")
          return [arrayLike];
        if (it = getIteratorOf(arrayLike)) {
          a = [];
          while (x2 = it.next(), !x2.done)
            a.push(x2.value);
          return a;
        }
        if (arrayLike == null)
          return [arrayLike];
        i = arrayLike.length;
        if (typeof i === "number") {
          a = new Array(i);
          while (i--)
            a[i] = arrayLike[i];
          return a;
        }
        return [arrayLike];
      }
      i = arguments.length;
      a = new Array(i);
      while (i--)
        a[i] = arguments[i];
      return a;
    }
    var isAsyncFunction = typeof Symbol !== "undefined" ? function(fn) {
      return fn[Symbol.toStringTag] === "AsyncFunction";
    } : function() {
      return false;
    };
    var debug = typeof location !== "undefined" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
    function setDebug(value, filter) {
      debug = value;
      libraryFilter = filter;
    }
    var libraryFilter = function() {
      return true;
    };
    var NEEDS_THROW_FOR_STACK = !new Error("").stack;
    function getErrorWithStack() {
      if (NEEDS_THROW_FOR_STACK)
        try {
          getErrorWithStack.arguments;
          throw new Error();
        } catch (e2) {
          return e2;
        }
      return new Error();
    }
    function prettyStack(exception, numIgnoredFrames) {
      var stack = exception.stack;
      if (!stack)
        return "";
      numIgnoredFrames = numIgnoredFrames || 0;
      if (stack.indexOf(exception.name) === 0)
        numIgnoredFrames += (exception.name + exception.message).split("\n").length;
      return stack.split("\n").slice(numIgnoredFrames).filter(libraryFilter).map(function(frame) {
        return "\n" + frame;
      }).join("");
    }
    var dexieErrorNames = [
      "Modify",
      "Bulk",
      "OpenFailed",
      "VersionChange",
      "Schema",
      "Upgrade",
      "InvalidTable",
      "MissingAPI",
      "NoSuchDatabase",
      "InvalidArgument",
      "SubTransaction",
      "Unsupported",
      "Internal",
      "DatabaseClosed",
      "PrematureCommit",
      "ForeignAwait"
    ];
    var idbDomErrorNames = [
      "Unknown",
      "Constraint",
      "Data",
      "TransactionInactive",
      "ReadOnly",
      "Version",
      "NotFound",
      "InvalidState",
      "InvalidAccess",
      "Abort",
      "Timeout",
      "QuotaExceeded",
      "Syntax",
      "DataClone"
    ];
    var errorList = dexieErrorNames.concat(idbDomErrorNames);
    var defaultTexts = {
      VersionChanged: "Database version changed by other database connection",
      DatabaseClosed: "Database has been closed",
      Abort: "Transaction aborted",
      TransactionInactive: "Transaction has already completed or failed",
      MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb"
    };
    function DexieError(name, msg) {
      this._e = getErrorWithStack();
      this.name = name;
      this.message = msg;
    }
    derive(DexieError).from(Error).extend({
      stack: {
        get: function() {
          return this._stack || (this._stack = this.name + ": " + this.message + prettyStack(this._e, 2));
        }
      },
      toString: function() {
        return this.name + ": " + this.message;
      }
    });
    function getMultiErrorMessage(msg, failures) {
      return msg + ". Errors: " + Object.keys(failures).map(function(key) {
        return failures[key].toString();
      }).filter(function(v2, i, s) {
        return s.indexOf(v2) === i;
      }).join("\n");
    }
    function ModifyError(msg, failures, successCount, failedKeys) {
      this._e = getErrorWithStack();
      this.failures = failures;
      this.failedKeys = failedKeys;
      this.successCount = successCount;
      this.message = getMultiErrorMessage(msg, failures);
    }
    derive(ModifyError).from(DexieError);
    function BulkError(msg, failures) {
      this._e = getErrorWithStack();
      this.name = "BulkError";
      this.failures = Object.keys(failures).map(function(pos) {
        return failures[pos];
      });
      this.failuresByPos = failures;
      this.message = getMultiErrorMessage(msg, failures);
    }
    derive(BulkError).from(DexieError);
    var errnames = errorList.reduce(function(obj, name) {
      return obj[name] = name + "Error", obj;
    }, {});
    var BaseException = DexieError;
    var exceptions = errorList.reduce(function(obj, name) {
      var fullName = name + "Error";
      function DexieError2(msgOrInner, inner) {
        this._e = getErrorWithStack();
        this.name = fullName;
        if (!msgOrInner) {
          this.message = defaultTexts[name] || fullName;
          this.inner = null;
        } else if (typeof msgOrInner === "string") {
          this.message = "" + msgOrInner + (!inner ? "" : "\n " + inner);
          this.inner = inner || null;
        } else if (typeof msgOrInner === "object") {
          this.message = msgOrInner.name + " " + msgOrInner.message;
          this.inner = msgOrInner;
        }
      }
      derive(DexieError2).from(BaseException);
      obj[name] = DexieError2;
      return obj;
    }, {});
    exceptions.Syntax = SyntaxError;
    exceptions.Type = TypeError;
    exceptions.Range = RangeError;
    var exceptionMap = idbDomErrorNames.reduce(function(obj, name) {
      obj[name + "Error"] = exceptions[name];
      return obj;
    }, {});
    function mapError(domError, message) {
      if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])
        return domError;
      var rv = new exceptionMap[domError.name](message || domError.message, domError);
      if ("stack" in domError) {
        setProp(rv, "stack", { get: function() {
          return this.inner.stack;
        } });
      }
      return rv;
    }
    var fullNameExceptions = errorList.reduce(function(obj, name) {
      if (["Syntax", "Type", "Range"].indexOf(name) === -1)
        obj[name + "Error"] = exceptions[name];
      return obj;
    }, {});
    fullNameExceptions.ModifyError = ModifyError;
    fullNameExceptions.DexieError = DexieError;
    fullNameExceptions.BulkError = BulkError;
    function nop() {
    }
    function mirror(val) {
      return val;
    }
    function pureFunctionChain(f1, f2) {
      if (f1 == null || f1 === mirror)
        return f2;
      return function(val) {
        return f2(f1(val));
      };
    }
    function callBoth(on1, on2) {
      return function() {
        on1.apply(this, arguments);
        on2.apply(this, arguments);
      };
    }
    function hookCreatingChain(f1, f2) {
      if (f1 === nop)
        return f2;
      return function() {
        var res = f1.apply(this, arguments);
        if (res !== void 0)
          arguments[0] = res;
        var onsuccess = this.onsuccess, onerror = this.onerror;
        this.onsuccess = null;
        this.onerror = null;
        var res2 = f2.apply(this, arguments);
        if (onsuccess)
          this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
        if (onerror)
          this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
        return res2 !== void 0 ? res2 : res;
      };
    }
    function hookDeletingChain(f1, f2) {
      if (f1 === nop)
        return f2;
      return function() {
        f1.apply(this, arguments);
        var onsuccess = this.onsuccess, onerror = this.onerror;
        this.onsuccess = this.onerror = null;
        f2.apply(this, arguments);
        if (onsuccess)
          this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
        if (onerror)
          this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
      };
    }
    function hookUpdatingChain(f1, f2) {
      if (f1 === nop)
        return f2;
      return function(modifications) {
        var res = f1.apply(this, arguments);
        extend$1(modifications, res);
        var onsuccess = this.onsuccess, onerror = this.onerror;
        this.onsuccess = null;
        this.onerror = null;
        var res2 = f2.apply(this, arguments);
        if (onsuccess)
          this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
        if (onerror)
          this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
        return res === void 0 ? res2 === void 0 ? void 0 : res2 : extend$1(res, res2);
      };
    }
    function reverseStoppableEventChain(f1, f2) {
      if (f1 === nop)
        return f2;
      return function() {
        if (f2.apply(this, arguments) === false)
          return false;
        return f1.apply(this, arguments);
      };
    }
    function promisableChain(f1, f2) {
      if (f1 === nop)
        return f2;
      return function() {
        var res = f1.apply(this, arguments);
        if (res && typeof res.then === "function") {
          var thiz = this, i = arguments.length, args = new Array(i);
          while (i--)
            args[i] = arguments[i];
          return res.then(function() {
            return f2.apply(thiz, args);
          });
        }
        return f2.apply(this, arguments);
      };
    }
    var INTERNAL = {};
    var LONG_STACKS_CLIP_LIMIT = 100, MAX_LONG_STACKS = 20, ZONE_ECHO_LIMIT = 100, _a$1 = typeof Promise === "undefined" ? [] : function() {
      var globalP = Promise.resolve();
      if (typeof crypto === "undefined" || !crypto.subtle)
        return [globalP, getProto(globalP), globalP];
      var nativeP = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
      return [
        nativeP,
        getProto(nativeP),
        globalP
      ];
    }(), resolvedNativePromise = _a$1[0], nativePromiseProto = _a$1[1], resolvedGlobalPromise = _a$1[2], nativePromiseThen = nativePromiseProto && nativePromiseProto.then;
    var NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;
    var patchGlobalPromise = !!resolvedGlobalPromise;
    var stack_being_generated = false;
    var schedulePhysicalTick = resolvedGlobalPromise ? function() {
      resolvedGlobalPromise.then(physicalTick);
    } : _global.setImmediate ? setImmediate.bind(null, physicalTick) : _global.MutationObserver ? function() {
      var hiddenDiv = document.createElement("div");
      new MutationObserver(function() {
        physicalTick();
        hiddenDiv = null;
      }).observe(hiddenDiv, { attributes: true });
      hiddenDiv.setAttribute("i", "1");
    } : function() {
      setTimeout(physicalTick, 0);
    };
    var asap = function(callback, args) {
      microtickQueue.push([callback, args]);
      if (needsNewPhysicalTick) {
        schedulePhysicalTick();
        needsNewPhysicalTick = false;
      }
    };
    var isOutsideMicroTick = true, needsNewPhysicalTick = true, unhandledErrors = [], rejectingErrors = [], currentFulfiller = null, rejectionMapper = mirror;
    var globalPSD = {
      id: "global",
      global: true,
      ref: 0,
      unhandleds: [],
      onunhandled: globalError,
      pgp: false,
      env: {},
      finalize: function() {
        this.unhandleds.forEach(function(uh2) {
          try {
            globalError(uh2[0], uh2[1]);
          } catch (e2) {
          }
        });
      }
    };
    var PSD = globalPSD;
    var microtickQueue = [];
    var numScheduledCalls = 0;
    var tickFinalizers = [];
    function DexiePromise(fn) {
      if (typeof this !== "object")
        throw new TypeError("Promises must be constructed via new");
      this._listeners = [];
      this.onuncatched = nop;
      this._lib = false;
      var psd = this._PSD = PSD;
      if (debug) {
        this._stackHolder = getErrorWithStack();
        this._prev = null;
        this._numPrev = 0;
      }
      if (typeof fn !== "function") {
        if (fn !== INTERNAL)
          throw new TypeError("Not a function");
        this._state = arguments[1];
        this._value = arguments[2];
        if (this._state === false)
          handleRejection(this, this._value);
        return;
      }
      this._state = null;
      this._value = null;
      ++psd.ref;
      executePromiseTask(this, fn);
    }
    var thenProp = {
      get: function() {
        var psd = PSD, microTaskId = totalEchoes;
        function then(onFulfilled, onRejected) {
          var _this = this;
          var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);
          var cleanup = possibleAwait && !decrementExpectedAwaits();
          var rv = new DexiePromise(function(resolve, reject) {
            propagateToListener(_this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));
          });
          debug && linkToPreviousPromise(rv, this);
          return rv;
        }
        then.prototype = INTERNAL;
        return then;
      },
      set: function(value) {
        setProp(this, "then", value && value.prototype === INTERNAL ? thenProp : {
          get: function() {
            return value;
          },
          set: thenProp.set
        });
      }
    };
    props(DexiePromise.prototype, {
      then: thenProp,
      _then: function(onFulfilled, onRejected) {
        propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));
      },
      catch: function(onRejected) {
        if (arguments.length === 1)
          return this.then(null, onRejected);
        var type2 = arguments[0], handler = arguments[1];
        return typeof type2 === "function" ? this.then(null, function(err) {
          return err instanceof type2 ? handler(err) : PromiseReject(err);
        }) : this.then(null, function(err) {
          return err && err.name === type2 ? handler(err) : PromiseReject(err);
        });
      },
      finally: function(onFinally) {
        return this.then(function(value) {
          onFinally();
          return value;
        }, function(err) {
          onFinally();
          return PromiseReject(err);
        });
      },
      stack: {
        get: function() {
          if (this._stack)
            return this._stack;
          try {
            stack_being_generated = true;
            var stacks = getStack(this, [], MAX_LONG_STACKS);
            var stack = stacks.join("\nFrom previous: ");
            if (this._state !== null)
              this._stack = stack;
            return stack;
          } finally {
            stack_being_generated = false;
          }
        }
      },
      timeout: function(ms, msg) {
        var _this = this;
        return ms < Infinity ? new DexiePromise(function(resolve, reject) {
          var handle = setTimeout(function() {
            return reject(new exceptions.Timeout(msg));
          }, ms);
          _this.then(resolve, reject).finally(clearTimeout.bind(null, handle));
        }) : this;
      }
    });
    if (typeof Symbol !== "undefined" && Symbol.toStringTag)
      setProp(DexiePromise.prototype, Symbol.toStringTag, "Dexie.Promise");
    globalPSD.env = snapShot();
    function Listener(onFulfilled, onRejected, resolve, reject, zone) {
      this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
      this.onRejected = typeof onRejected === "function" ? onRejected : null;
      this.resolve = resolve;
      this.reject = reject;
      this.psd = zone;
    }
    props(DexiePromise, {
      all: function() {
        var values2 = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
        return new DexiePromise(function(resolve, reject) {
          if (values2.length === 0)
            resolve([]);
          var remaining = values2.length;
          values2.forEach(function(a, i) {
            return DexiePromise.resolve(a).then(function(x2) {
              values2[i] = x2;
              if (!--remaining)
                resolve(values2);
            }, reject);
          });
        });
      },
      resolve: function(value) {
        if (value instanceof DexiePromise)
          return value;
        if (value && typeof value.then === "function")
          return new DexiePromise(function(resolve, reject) {
            value.then(resolve, reject);
          });
        var rv = new DexiePromise(INTERNAL, true, value);
        linkToPreviousPromise(rv, currentFulfiller);
        return rv;
      },
      reject: PromiseReject,
      race: function() {
        var values2 = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
        return new DexiePromise(function(resolve, reject) {
          values2.map(function(value) {
            return DexiePromise.resolve(value).then(resolve, reject);
          });
        });
      },
      PSD: {
        get: function() {
          return PSD;
        },
        set: function(value) {
          return PSD = value;
        }
      },
      totalEchoes: { get: function() {
        return totalEchoes;
      } },
      newPSD: newScope,
      usePSD,
      scheduler: {
        get: function() {
          return asap;
        },
        set: function(value) {
          asap = value;
        }
      },
      rejectionMapper: {
        get: function() {
          return rejectionMapper;
        },
        set: function(value) {
          rejectionMapper = value;
        }
      },
      follow: function(fn, zoneProps) {
        return new DexiePromise(function(resolve, reject) {
          return newScope(function(resolve2, reject2) {
            var psd = PSD;
            psd.unhandleds = [];
            psd.onunhandled = reject2;
            psd.finalize = callBoth(function() {
              var _this = this;
              run_at_end_of_this_or_next_physical_tick(function() {
                _this.unhandleds.length === 0 ? resolve2() : reject2(_this.unhandleds[0]);
              });
            }, psd.finalize);
            fn();
          }, zoneProps, resolve, reject);
        });
      }
    });
    if (NativePromise) {
      if (NativePromise.allSettled)
        setProp(DexiePromise, "allSettled", function() {
          var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
          return new DexiePromise(function(resolve) {
            if (possiblePromises.length === 0)
              resolve([]);
            var remaining = possiblePromises.length;
            var results = new Array(remaining);
            possiblePromises.forEach(function(p2, i) {
              return DexiePromise.resolve(p2).then(function(value) {
                return results[i] = { status: "fulfilled", value };
              }, function(reason) {
                return results[i] = { status: "rejected", reason };
              }).then(function() {
                return --remaining || resolve(results);
              });
            });
          });
        });
      if (NativePromise.any && typeof AggregateError !== "undefined")
        setProp(DexiePromise, "any", function() {
          var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
          return new DexiePromise(function(resolve, reject) {
            if (possiblePromises.length === 0)
              reject(new AggregateError([]));
            var remaining = possiblePromises.length;
            var failures = new Array(remaining);
            possiblePromises.forEach(function(p2, i) {
              return DexiePromise.resolve(p2).then(function(value) {
                return resolve(value);
              }, function(failure) {
                failures[i] = failure;
                if (!--remaining)
                  reject(new AggregateError(failures));
              });
            });
          });
        });
    }
    function executePromiseTask(promise, fn) {
      try {
        fn(function(value) {
          if (promise._state !== null)
            return;
          if (value === promise)
            throw new TypeError("A promise cannot be resolved with itself.");
          var shouldExecuteTick = promise._lib && beginMicroTickScope();
          if (value && typeof value.then === "function") {
            executePromiseTask(promise, function(resolve, reject) {
              value instanceof DexiePromise ? value._then(resolve, reject) : value.then(resolve, reject);
            });
          } else {
            promise._state = true;
            promise._value = value;
            propagateAllListeners(promise);
          }
          if (shouldExecuteTick)
            endMicroTickScope();
        }, handleRejection.bind(null, promise));
      } catch (ex) {
        handleRejection(promise, ex);
      }
    }
    function handleRejection(promise, reason) {
      rejectingErrors.push(reason);
      if (promise._state !== null)
        return;
      var shouldExecuteTick = promise._lib && beginMicroTickScope();
      reason = rejectionMapper(reason);
      promise._state = false;
      promise._value = reason;
      debug && reason !== null && typeof reason === "object" && !reason._promise && tryCatch(function() {
        var origProp = getPropertyDescriptor(reason, "stack");
        reason._promise = promise;
        setProp(reason, "stack", {
          get: function() {
            return stack_being_generated ? origProp && (origProp.get ? origProp.get.apply(reason) : origProp.value) : promise.stack;
          }
        });
      });
      addPossiblyUnhandledError(promise);
      propagateAllListeners(promise);
      if (shouldExecuteTick)
        endMicroTickScope();
    }
    function propagateAllListeners(promise) {
      var listeners = promise._listeners;
      promise._listeners = [];
      for (var i = 0, len = listeners.length; i < len; ++i) {
        propagateToListener(promise, listeners[i]);
      }
      var psd = promise._PSD;
      --psd.ref || psd.finalize();
      if (numScheduledCalls === 0) {
        ++numScheduledCalls;
        asap(function() {
          if (--numScheduledCalls === 0)
            finalizePhysicalTick();
        }, []);
      }
    }
    function propagateToListener(promise, listener) {
      if (promise._state === null) {
        promise._listeners.push(listener);
        return;
      }
      var cb2 = promise._state ? listener.onFulfilled : listener.onRejected;
      if (cb2 === null) {
        return (promise._state ? listener.resolve : listener.reject)(promise._value);
      }
      ++listener.psd.ref;
      ++numScheduledCalls;
      asap(callListener, [cb2, promise, listener]);
    }
    function callListener(cb2, promise, listener) {
      try {
        currentFulfiller = promise;
        var ret, value = promise._value;
        if (promise._state) {
          ret = cb2(value);
        } else {
          if (rejectingErrors.length)
            rejectingErrors = [];
          ret = cb2(value);
          if (rejectingErrors.indexOf(value) === -1)
            markErrorAsHandled(promise);
        }
        listener.resolve(ret);
      } catch (e2) {
        listener.reject(e2);
      } finally {
        currentFulfiller = null;
        if (--numScheduledCalls === 0)
          finalizePhysicalTick();
        --listener.psd.ref || listener.psd.finalize();
      }
    }
    function getStack(promise, stacks, limit) {
      if (stacks.length === limit)
        return stacks;
      var stack = "";
      if (promise._state === false) {
        var failure = promise._value, errorName, message;
        if (failure != null) {
          errorName = failure.name || "Error";
          message = failure.message || failure;
          stack = prettyStack(failure, 0);
        } else {
          errorName = failure;
          message = "";
        }
        stacks.push(errorName + (message ? ": " + message : "") + stack);
      }
      if (debug) {
        stack = prettyStack(promise._stackHolder, 2);
        if (stack && stacks.indexOf(stack) === -1)
          stacks.push(stack);
        if (promise._prev)
          getStack(promise._prev, stacks, limit);
      }
      return stacks;
    }
    function linkToPreviousPromise(promise, prev2) {
      var numPrev = prev2 ? prev2._numPrev + 1 : 0;
      if (numPrev < LONG_STACKS_CLIP_LIMIT) {
        promise._prev = prev2;
        promise._numPrev = numPrev;
      }
    }
    function physicalTick() {
      beginMicroTickScope() && endMicroTickScope();
    }
    function beginMicroTickScope() {
      var wasRootExec = isOutsideMicroTick;
      isOutsideMicroTick = false;
      needsNewPhysicalTick = false;
      return wasRootExec;
    }
    function endMicroTickScope() {
      var callbacks, i, l2;
      do {
        while (microtickQueue.length > 0) {
          callbacks = microtickQueue;
          microtickQueue = [];
          l2 = callbacks.length;
          for (i = 0; i < l2; ++i) {
            var item = callbacks[i];
            item[0].apply(null, item[1]);
          }
        }
      } while (microtickQueue.length > 0);
      isOutsideMicroTick = true;
      needsNewPhysicalTick = true;
    }
    function finalizePhysicalTick() {
      var unhandledErrs = unhandledErrors;
      unhandledErrors = [];
      unhandledErrs.forEach(function(p2) {
        p2._PSD.onunhandled.call(null, p2._value, p2);
      });
      var finalizers = tickFinalizers.slice(0);
      var i = finalizers.length;
      while (i)
        finalizers[--i]();
    }
    function run_at_end_of_this_or_next_physical_tick(fn) {
      function finalizer() {
        fn();
        tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);
      }
      tickFinalizers.push(finalizer);
      ++numScheduledCalls;
      asap(function() {
        if (--numScheduledCalls === 0)
          finalizePhysicalTick();
      }, []);
    }
    function addPossiblyUnhandledError(promise) {
      if (!unhandledErrors.some(function(p2) {
        return p2._value === promise._value;
      }))
        unhandledErrors.push(promise);
    }
    function markErrorAsHandled(promise) {
      var i = unhandledErrors.length;
      while (i)
        if (unhandledErrors[--i]._value === promise._value) {
          unhandledErrors.splice(i, 1);
          return;
        }
    }
    function PromiseReject(reason) {
      return new DexiePromise(INTERNAL, false, reason);
    }
    function wrap(fn, errorCatcher) {
      var psd = PSD;
      return function() {
        var wasRootExec = beginMicroTickScope(), outerScope = PSD;
        try {
          switchToZone(psd, true);
          return fn.apply(this, arguments);
        } catch (e2) {
          errorCatcher && errorCatcher(e2);
        } finally {
          switchToZone(outerScope, false);
          if (wasRootExec)
            endMicroTickScope();
        }
      };
    }
    var task = { awaits: 0, echoes: 0, id: 0 };
    var taskCounter = 0;
    var zoneStack = [];
    var zoneEchoes = 0;
    var totalEchoes = 0;
    var zone_id_counter = 0;
    function newScope(fn, props2, a1, a2) {
      var parent = PSD, psd = Object.create(parent);
      psd.parent = parent;
      psd.ref = 0;
      psd.global = false;
      psd.id = ++zone_id_counter;
      var globalEnv = globalPSD.env;
      psd.env = patchGlobalPromise ? {
        Promise: DexiePromise,
        PromiseProp: { value: DexiePromise, configurable: true, writable: true },
        all: DexiePromise.all,
        race: DexiePromise.race,
        allSettled: DexiePromise.allSettled,
        any: DexiePromise.any,
        resolve: DexiePromise.resolve,
        reject: DexiePromise.reject,
        nthen: getPatchedPromiseThen(globalEnv.nthen, psd),
        gthen: getPatchedPromiseThen(globalEnv.gthen, psd)
      } : {};
      if (props2)
        extend$1(psd, props2);
      ++parent.ref;
      psd.finalize = function() {
        --this.parent.ref || this.parent.finalize();
      };
      var rv = usePSD(psd, fn, a1, a2);
      if (psd.ref === 0)
        psd.finalize();
      return rv;
    }
    function incrementExpectedAwaits() {
      if (!task.id)
        task.id = ++taskCounter;
      ++task.awaits;
      task.echoes += ZONE_ECHO_LIMIT;
      return task.id;
    }
    function decrementExpectedAwaits() {
      if (!task.awaits)
        return false;
      if (--task.awaits === 0)
        task.id = 0;
      task.echoes = task.awaits * ZONE_ECHO_LIMIT;
      return true;
    }
    if (("" + nativePromiseThen).indexOf("[native code]") === -1) {
      incrementExpectedAwaits = decrementExpectedAwaits = nop;
    }
    function onPossibleParallellAsync(possiblePromise) {
      if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {
        incrementExpectedAwaits();
        return possiblePromise.then(function(x2) {
          decrementExpectedAwaits();
          return x2;
        }, function(e2) {
          decrementExpectedAwaits();
          return rejection(e2);
        });
      }
      return possiblePromise;
    }
    function zoneEnterEcho(targetZone) {
      ++totalEchoes;
      if (!task.echoes || --task.echoes === 0) {
        task.echoes = task.id = 0;
      }
      zoneStack.push(PSD);
      switchToZone(targetZone, true);
    }
    function zoneLeaveEcho() {
      var zone = zoneStack[zoneStack.length - 1];
      zoneStack.pop();
      switchToZone(zone, false);
    }
    function switchToZone(targetZone, bEnteringZone) {
      var currentZone = PSD;
      if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {
        enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);
      }
      if (targetZone === PSD)
        return;
      PSD = targetZone;
      if (currentZone === globalPSD)
        globalPSD.env = snapShot();
      if (patchGlobalPromise) {
        var GlobalPromise_1 = globalPSD.env.Promise;
        var targetEnv = targetZone.env;
        nativePromiseProto.then = targetEnv.nthen;
        GlobalPromise_1.prototype.then = targetEnv.gthen;
        if (currentZone.global || targetZone.global) {
          Object.defineProperty(_global, "Promise", targetEnv.PromiseProp);
          GlobalPromise_1.all = targetEnv.all;
          GlobalPromise_1.race = targetEnv.race;
          GlobalPromise_1.resolve = targetEnv.resolve;
          GlobalPromise_1.reject = targetEnv.reject;
          if (targetEnv.allSettled)
            GlobalPromise_1.allSettled = targetEnv.allSettled;
          if (targetEnv.any)
            GlobalPromise_1.any = targetEnv.any;
        }
      }
    }
    function snapShot() {
      var GlobalPromise = _global.Promise;
      return patchGlobalPromise ? {
        Promise: GlobalPromise,
        PromiseProp: Object.getOwnPropertyDescriptor(_global, "Promise"),
        all: GlobalPromise.all,
        race: GlobalPromise.race,
        allSettled: GlobalPromise.allSettled,
        any: GlobalPromise.any,
        resolve: GlobalPromise.resolve,
        reject: GlobalPromise.reject,
        nthen: nativePromiseProto.then,
        gthen: GlobalPromise.prototype.then
      } : {};
    }
    function usePSD(psd, fn, a1, a2, a3) {
      var outerScope = PSD;
      try {
        switchToZone(psd, true);
        return fn(a1, a2, a3);
      } finally {
        switchToZone(outerScope, false);
      }
    }
    function enqueueNativeMicroTask(job) {
      nativePromiseThen.call(resolvedNativePromise, job);
    }
    function nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {
      return typeof fn !== "function" ? fn : function() {
        var outerZone = PSD;
        if (possibleAwait)
          incrementExpectedAwaits();
        switchToZone(zone, true);
        try {
          return fn.apply(this, arguments);
        } finally {
          switchToZone(outerZone, false);
          if (cleanup)
            enqueueNativeMicroTask(decrementExpectedAwaits);
        }
      };
    }
    function getPatchedPromiseThen(origThen, zone) {
      return function(onResolved, onRejected) {
        return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone), nativeAwaitCompatibleWrap(onRejected, zone));
      };
    }
    var UNHANDLEDREJECTION = "unhandledrejection";
    function globalError(err, promise) {
      var rv;
      try {
        rv = promise.onuncatched(err);
      } catch (e2) {
      }
      if (rv !== false)
        try {
          var event, eventData = { promise, reason: err };
          if (_global.document && document.createEvent) {
            event = document.createEvent("Event");
            event.initEvent(UNHANDLEDREJECTION, true, true);
            extend$1(event, eventData);
          } else if (_global.CustomEvent) {
            event = new CustomEvent(UNHANDLEDREJECTION, { detail: eventData });
            extend$1(event, eventData);
          }
          if (event && _global.dispatchEvent) {
            dispatchEvent(event);
            if (!_global.PromiseRejectionEvent && _global.onunhandledrejection)
              try {
                _global.onunhandledrejection(event);
              } catch (_2) {
              }
          }
          if (debug && event && !event.defaultPrevented) {
            console.warn("Unhandled rejection: " + (err.stack || err));
          }
        } catch (e2) {
        }
    }
    var rejection = DexiePromise.reject;
    function tempTransaction(db2, mode, storeNames, fn) {
      if (!db2.idbdb || !db2._state.openComplete && (!PSD.letThrough && !db2._vip)) {
        if (db2._state.openComplete) {
          return rejection(new exceptions.DatabaseClosed(db2._state.dbOpenError));
        }
        if (!db2._state.isBeingOpened) {
          if (!db2._options.autoOpen)
            return rejection(new exceptions.DatabaseClosed());
          db2.open().catch(nop);
        }
        return db2._state.dbReadyPromise.then(function() {
          return tempTransaction(db2, mode, storeNames, fn);
        });
      } else {
        var trans = db2._createTransaction(mode, storeNames, db2._dbSchema);
        try {
          trans.create();
          db2._state.PR1398_maxLoop = 3;
        } catch (ex) {
          if (ex.name === errnames.InvalidState && db2.isOpen() && --db2._state.PR1398_maxLoop > 0) {
            console.warn("Dexie: Need to reopen db");
            db2._close();
            return db2.open().then(function() {
              return tempTransaction(db2, mode, storeNames, fn);
            });
          }
          return rejection(ex);
        }
        return trans._promise(mode, function(resolve, reject) {
          return newScope(function() {
            PSD.trans = trans;
            return fn(resolve, reject, trans);
          });
        }).then(function(result) {
          return trans._completion.then(function() {
            return result;
          });
        });
      }
    }
    var DEXIE_VERSION = "3.2.2";
    var maxString = String.fromCharCode(65535);
    var minKey = -Infinity;
    var INVALID_KEY_ARGUMENT = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.";
    var STRING_EXPECTED = "String expected.";
    var connections = [];
    var isIEOrEdge = typeof navigator !== "undefined" && /(MSIE|Trident|Edge)/.test(navigator.userAgent);
    var hasIEDeleteObjectStoreBug = isIEOrEdge;
    var hangsOnDeleteLargeKeyRange = isIEOrEdge;
    var dexieStackFrameFilter = function(frame) {
      return !/(dexie\.js|dexie\.min\.js)/.test(frame);
    };
    var DBNAMES_DB = "__dbnames";
    var READONLY = "readonly";
    var READWRITE = "readwrite";
    function combine(filter1, filter2) {
      return filter1 ? filter2 ? function() {
        return filter1.apply(this, arguments) && filter2.apply(this, arguments);
      } : filter1 : filter2;
    }
    var AnyRange = {
      type: 3,
      lower: -Infinity,
      lowerOpen: false,
      upper: [[]],
      upperOpen: false
    };
    function workaroundForUndefinedPrimKey(keyPath) {
      return typeof keyPath === "string" && !/\./.test(keyPath) ? function(obj) {
        if (obj[keyPath] === void 0 && keyPath in obj) {
          obj = deepClone(obj);
          delete obj[keyPath];
        }
        return obj;
      } : function(obj) {
        return obj;
      };
    }
    var Table = function() {
      function Table2() {
      }
      Table2.prototype._trans = function(mode, fn, writeLocked) {
        var trans = this._tx || PSD.trans;
        var tableName = this.name;
        function checkTableInTransaction(resolve, reject, trans2) {
          if (!trans2.schema[tableName])
            throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
          return fn(trans2.idbtrans, trans2);
        }
        var wasRootExec = beginMicroTickScope();
        try {
          return trans && trans.db === this.db ? trans === PSD.trans ? trans._promise(mode, checkTableInTransaction, writeLocked) : newScope(function() {
            return trans._promise(mode, checkTableInTransaction, writeLocked);
          }, { trans, transless: PSD.transless || PSD }) : tempTransaction(this.db, mode, [this.name], checkTableInTransaction);
        } finally {
          if (wasRootExec)
            endMicroTickScope();
        }
      };
      Table2.prototype.get = function(keyOrCrit, cb2) {
        var _this = this;
        if (keyOrCrit && keyOrCrit.constructor === Object)
          return this.where(keyOrCrit).first(cb2);
        return this._trans("readonly", function(trans) {
          return _this.core.get({ trans, key: keyOrCrit }).then(function(res) {
            return _this.hook.reading.fire(res);
          });
        }).then(cb2);
      };
      Table2.prototype.where = function(indexOrCrit) {
        if (typeof indexOrCrit === "string")
          return new this.db.WhereClause(this, indexOrCrit);
        if (isArray$1(indexOrCrit))
          return new this.db.WhereClause(this, "[" + indexOrCrit.join("+") + "]");
        var keyPaths = keys$1(indexOrCrit);
        if (keyPaths.length === 1)
          return this.where(keyPaths[0]).equals(indexOrCrit[keyPaths[0]]);
        var compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(function(ix) {
          return ix.compound && keyPaths.every(function(keyPath) {
            return ix.keyPath.indexOf(keyPath) >= 0;
          }) && ix.keyPath.every(function(keyPath) {
            return keyPaths.indexOf(keyPath) >= 0;
          });
        })[0];
        if (compoundIndex && this.db._maxKey !== maxString)
          return this.where(compoundIndex.name).equals(compoundIndex.keyPath.map(function(kp) {
            return indexOrCrit[kp];
          }));
        if (!compoundIndex && debug)
          console.warn("The query " + JSON.stringify(indexOrCrit) + " on " + this.name + " would benefit of a " + ("compound index [" + keyPaths.join("+") + "]"));
        var idxByName = this.schema.idxByName;
        var idb = this.db._deps.indexedDB;
        function equals(a, b2) {
          try {
            return idb.cmp(a, b2) === 0;
          } catch (e2) {
            return false;
          }
        }
        var _a2 = keyPaths.reduce(function(_a3, keyPath) {
          var prevIndex = _a3[0], prevFilterFn = _a3[1];
          var index2 = idxByName[keyPath];
          var value = indexOrCrit[keyPath];
          return [
            prevIndex || index2,
            prevIndex || !index2 ? combine(prevFilterFn, index2 && index2.multi ? function(x2) {
              var prop = getByKeyPath(x2, keyPath);
              return isArray$1(prop) && prop.some(function(item) {
                return equals(value, item);
              });
            } : function(x2) {
              return equals(value, getByKeyPath(x2, keyPath));
            }) : prevFilterFn
          ];
        }, [null, null]), idx = _a2[0], filterFunction = _a2[1];
        return idx ? this.where(idx.name).equals(indexOrCrit[idx.keyPath]).filter(filterFunction) : compoundIndex ? this.filter(filterFunction) : this.where(keyPaths).equals("");
      };
      Table2.prototype.filter = function(filterFunction) {
        return this.toCollection().and(filterFunction);
      };
      Table2.prototype.count = function(thenShortcut) {
        return this.toCollection().count(thenShortcut);
      };
      Table2.prototype.offset = function(offset2) {
        return this.toCollection().offset(offset2);
      };
      Table2.prototype.limit = function(numRows) {
        return this.toCollection().limit(numRows);
      };
      Table2.prototype.each = function(callback) {
        return this.toCollection().each(callback);
      };
      Table2.prototype.toArray = function(thenShortcut) {
        return this.toCollection().toArray(thenShortcut);
      };
      Table2.prototype.toCollection = function() {
        return new this.db.Collection(new this.db.WhereClause(this));
      };
      Table2.prototype.orderBy = function(index2) {
        return new this.db.Collection(new this.db.WhereClause(this, isArray$1(index2) ? "[" + index2.join("+") + "]" : index2));
      };
      Table2.prototype.reverse = function() {
        return this.toCollection().reverse();
      };
      Table2.prototype.mapToClass = function(constructor) {
        this.schema.mappedClass = constructor;
        var readHook = function(obj) {
          if (!obj)
            return obj;
          var res = Object.create(constructor.prototype);
          for (var m2 in obj)
            if (hasOwn(obj, m2))
              try {
                res[m2] = obj[m2];
              } catch (_2) {
              }
          return res;
        };
        if (this.schema.readHook) {
          this.hook.reading.unsubscribe(this.schema.readHook);
        }
        this.schema.readHook = readHook;
        this.hook("reading", readHook);
        return constructor;
      };
      Table2.prototype.defineClass = function() {
        function Class(content) {
          extend$1(this, content);
        }
        return this.mapToClass(Class);
      };
      Table2.prototype.add = function(obj, key) {
        var _this = this;
        var _a2 = this.schema.primKey, auto2 = _a2.auto, keyPath = _a2.keyPath;
        var objToAdd = obj;
        if (keyPath && auto2) {
          objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
        }
        return this._trans("readwrite", function(trans) {
          return _this.core.mutate({ trans, type: "add", keys: key != null ? [key] : null, values: [objToAdd] });
        }).then(function(res) {
          return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult;
        }).then(function(lastResult) {
          if (keyPath) {
            try {
              setByKeyPath(obj, keyPath, lastResult);
            } catch (_2) {
            }
          }
          return lastResult;
        });
      };
      Table2.prototype.update = function(keyOrObject, modifications) {
        if (typeof keyOrObject === "object" && !isArray$1(keyOrObject)) {
          var key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);
          if (key === void 0)
            return rejection(new exceptions.InvalidArgument("Given object does not contain its primary key"));
          try {
            if (typeof modifications !== "function") {
              keys$1(modifications).forEach(function(keyPath) {
                setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);
              });
            } else {
              modifications(keyOrObject, { value: keyOrObject, primKey: key });
            }
          } catch (_a2) {
          }
          return this.where(":id").equals(key).modify(modifications);
        } else {
          return this.where(":id").equals(keyOrObject).modify(modifications);
        }
      };
      Table2.prototype.put = function(obj, key) {
        var _this = this;
        var _a2 = this.schema.primKey, auto2 = _a2.auto, keyPath = _a2.keyPath;
        var objToAdd = obj;
        if (keyPath && auto2) {
          objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
        }
        return this._trans("readwrite", function(trans) {
          return _this.core.mutate({ trans, type: "put", values: [objToAdd], keys: key != null ? [key] : null });
        }).then(function(res) {
          return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult;
        }).then(function(lastResult) {
          if (keyPath) {
            try {
              setByKeyPath(obj, keyPath, lastResult);
            } catch (_2) {
            }
          }
          return lastResult;
        });
      };
      Table2.prototype.delete = function(key) {
        var _this = this;
        return this._trans("readwrite", function(trans) {
          return _this.core.mutate({ trans, type: "delete", keys: [key] });
        }).then(function(res) {
          return res.numFailures ? DexiePromise.reject(res.failures[0]) : void 0;
        });
      };
      Table2.prototype.clear = function() {
        var _this = this;
        return this._trans("readwrite", function(trans) {
          return _this.core.mutate({ trans, type: "deleteRange", range: AnyRange });
        }).then(function(res) {
          return res.numFailures ? DexiePromise.reject(res.failures[0]) : void 0;
        });
      };
      Table2.prototype.bulkGet = function(keys2) {
        var _this = this;
        return this._trans("readonly", function(trans) {
          return _this.core.getMany({
            keys: keys2,
            trans
          }).then(function(result) {
            return result.map(function(res) {
              return _this.hook.reading.fire(res);
            });
          });
        });
      };
      Table2.prototype.bulkAdd = function(objects, keysOrOptions, options) {
        var _this = this;
        var keys2 = Array.isArray(keysOrOptions) ? keysOrOptions : void 0;
        options = options || (keys2 ? void 0 : keysOrOptions);
        var wantResults = options ? options.allKeys : void 0;
        return this._trans("readwrite", function(trans) {
          var _a2 = _this.schema.primKey, auto2 = _a2.auto, keyPath = _a2.keyPath;
          if (keyPath && keys2)
            throw new exceptions.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
          if (keys2 && keys2.length !== objects.length)
            throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
          var numObjects = objects.length;
          var objectsToAdd = keyPath && auto2 ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;
          return _this.core.mutate({ trans, type: "add", keys: keys2, values: objectsToAdd, wantResults }).then(function(_a3) {
            var numFailures = _a3.numFailures, results = _a3.results, lastResult = _a3.lastResult, failures = _a3.failures;
            var result = wantResults ? results : lastResult;
            if (numFailures === 0)
              return result;
            throw new BulkError(_this.name + ".bulkAdd(): " + numFailures + " of " + numObjects + " operations failed", failures);
          });
        });
      };
      Table2.prototype.bulkPut = function(objects, keysOrOptions, options) {
        var _this = this;
        var keys2 = Array.isArray(keysOrOptions) ? keysOrOptions : void 0;
        options = options || (keys2 ? void 0 : keysOrOptions);
        var wantResults = options ? options.allKeys : void 0;
        return this._trans("readwrite", function(trans) {
          var _a2 = _this.schema.primKey, auto2 = _a2.auto, keyPath = _a2.keyPath;
          if (keyPath && keys2)
            throw new exceptions.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
          if (keys2 && keys2.length !== objects.length)
            throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
          var numObjects = objects.length;
          var objectsToPut = keyPath && auto2 ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;
          return _this.core.mutate({ trans, type: "put", keys: keys2, values: objectsToPut, wantResults }).then(function(_a3) {
            var numFailures = _a3.numFailures, results = _a3.results, lastResult = _a3.lastResult, failures = _a3.failures;
            var result = wantResults ? results : lastResult;
            if (numFailures === 0)
              return result;
            throw new BulkError(_this.name + ".bulkPut(): " + numFailures + " of " + numObjects + " operations failed", failures);
          });
        });
      };
      Table2.prototype.bulkDelete = function(keys2) {
        var _this = this;
        var numKeys = keys2.length;
        return this._trans("readwrite", function(trans) {
          return _this.core.mutate({ trans, type: "delete", keys: keys2 });
        }).then(function(_a2) {
          var numFailures = _a2.numFailures, lastResult = _a2.lastResult, failures = _a2.failures;
          if (numFailures === 0)
            return lastResult;
          throw new BulkError(_this.name + ".bulkDelete(): " + numFailures + " of " + numKeys + " operations failed", failures);
        });
      };
      return Table2;
    }();
    function Events(ctx) {
      var evs = {};
      var rv = function(eventName, subscriber) {
        if (subscriber) {
          var i2 = arguments.length, args = new Array(i2 - 1);
          while (--i2)
            args[i2 - 1] = arguments[i2];
          evs[eventName].subscribe.apply(null, args);
          return ctx;
        } else if (typeof eventName === "string") {
          return evs[eventName];
        }
      };
      rv.addEventType = add2;
      for (var i = 1, l2 = arguments.length; i < l2; ++i) {
        add2(arguments[i]);
      }
      return rv;
      function add2(eventName, chainFunction, defaultFunction) {
        if (typeof eventName === "object")
          return addConfiguredEvents(eventName);
        if (!chainFunction)
          chainFunction = reverseStoppableEventChain;
        if (!defaultFunction)
          defaultFunction = nop;
        var context = {
          subscribers: [],
          fire: defaultFunction,
          subscribe: function(cb2) {
            if (context.subscribers.indexOf(cb2) === -1) {
              context.subscribers.push(cb2);
              context.fire = chainFunction(context.fire, cb2);
            }
          },
          unsubscribe: function(cb2) {
            context.subscribers = context.subscribers.filter(function(fn) {
              return fn !== cb2;
            });
            context.fire = context.subscribers.reduce(chainFunction, defaultFunction);
          }
        };
        evs[eventName] = rv[eventName] = context;
        return context;
      }
      function addConfiguredEvents(cfg) {
        keys$1(cfg).forEach(function(eventName) {
          var args = cfg[eventName];
          if (isArray$1(args)) {
            add2(eventName, cfg[eventName][0], cfg[eventName][1]);
          } else if (args === "asap") {
            var context = add2(eventName, mirror, function fire() {
              var i2 = arguments.length, args2 = new Array(i2);
              while (i2--)
                args2[i2] = arguments[i2];
              context.subscribers.forEach(function(fn) {
                asap$1(function fireEvent() {
                  fn.apply(null, args2);
                });
              });
            });
          } else
            throw new exceptions.InvalidArgument("Invalid event config");
        });
      }
    }
    function makeClassConstructor(prototype, constructor) {
      derive(constructor).from({ prototype });
      return constructor;
    }
    function createTableConstructor(db2) {
      return makeClassConstructor(Table.prototype, function Table2(name, tableSchema, trans) {
        this.db = db2;
        this._tx = trans;
        this.name = name;
        this.schema = tableSchema;
        this.hook = db2._allTables[name] ? db2._allTables[name].hook : Events(null, {
          "creating": [hookCreatingChain, nop],
          "reading": [pureFunctionChain, mirror],
          "updating": [hookUpdatingChain, nop],
          "deleting": [hookDeletingChain, nop]
        });
      });
    }
    function isPlainKeyRange(ctx, ignoreLimitFilter) {
      return !(ctx.filter || ctx.algorithm || ctx.or) && (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);
    }
    function addFilter(ctx, fn) {
      ctx.filter = combine(ctx.filter, fn);
    }
    function addReplayFilter(ctx, factory, isLimitFilter) {
      var curr = ctx.replayFilter;
      ctx.replayFilter = curr ? function() {
        return combine(curr(), factory());
      } : factory;
      ctx.justLimit = isLimitFilter && !curr;
    }
    function addMatchFilter(ctx, fn) {
      ctx.isMatch = combine(ctx.isMatch, fn);
    }
    function getIndexOrStore(ctx, coreSchema) {
      if (ctx.isPrimKey)
        return coreSchema.primaryKey;
      var index2 = coreSchema.getIndexByKeyPath(ctx.index);
      if (!index2)
        throw new exceptions.Schema("KeyPath " + ctx.index + " on object store " + coreSchema.name + " is not indexed");
      return index2;
    }
    function openCursor(ctx, coreTable, trans) {
      var index2 = getIndexOrStore(ctx, coreTable.schema);
      return coreTable.openCursor({
        trans,
        values: !ctx.keysOnly,
        reverse: ctx.dir === "prev",
        unique: !!ctx.unique,
        query: {
          index: index2,
          range: ctx.range
        }
      });
    }
    function iter(ctx, fn, coreTrans, coreTable) {
      var filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;
      if (!ctx.or) {
        return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);
      } else {
        var set_1 = {};
        var union = function(item, cursor2, advance) {
          if (!filter || filter(cursor2, advance, function(result) {
            return cursor2.stop(result);
          }, function(err) {
            return cursor2.fail(err);
          })) {
            var primaryKey = cursor2.primaryKey;
            var key = "" + primaryKey;
            if (key === "[object ArrayBuffer]")
              key = "" + new Uint8Array(primaryKey);
            if (!hasOwn(set_1, key)) {
              set_1[key] = true;
              fn(item, cursor2, advance);
            }
          }
        };
        return Promise.all([
          ctx.or._iterate(union, coreTrans),
          iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)
        ]);
      }
    }
    function iterate(cursorPromise, filter, fn, valueMapper) {
      var mappedFn = valueMapper ? function(x2, c2, a) {
        return fn(valueMapper(x2), c2, a);
      } : fn;
      var wrappedFn = wrap(mappedFn);
      return cursorPromise.then(function(cursor2) {
        if (cursor2) {
          return cursor2.start(function() {
            var c2 = function() {
              return cursor2.continue();
            };
            if (!filter || filter(cursor2, function(advancer) {
              return c2 = advancer;
            }, function(val) {
              cursor2.stop(val);
              c2 = nop;
            }, function(e2) {
              cursor2.fail(e2);
              c2 = nop;
            }))
              wrappedFn(cursor2.value, cursor2, function(advancer) {
                return c2 = advancer;
              });
            c2();
          });
        }
      });
    }
    function cmp(a, b2) {
      try {
        var ta2 = type(a);
        var tb2 = type(b2);
        if (ta2 !== tb2) {
          if (ta2 === "Array")
            return 1;
          if (tb2 === "Array")
            return -1;
          if (ta2 === "binary")
            return 1;
          if (tb2 === "binary")
            return -1;
          if (ta2 === "string")
            return 1;
          if (tb2 === "string")
            return -1;
          if (ta2 === "Date")
            return 1;
          if (tb2 !== "Date")
            return NaN;
          return -1;
        }
        switch (ta2) {
          case "number":
          case "Date":
          case "string":
            return a > b2 ? 1 : a < b2 ? -1 : 0;
          case "binary": {
            return compareUint8Arrays(getUint8Array(a), getUint8Array(b2));
          }
          case "Array":
            return compareArrays$1(a, b2);
        }
      } catch (_a2) {
      }
      return NaN;
    }
    function compareArrays$1(a, b2) {
      var al2 = a.length;
      var bl2 = b2.length;
      var l2 = al2 < bl2 ? al2 : bl2;
      for (var i = 0; i < l2; ++i) {
        var res = cmp(a[i], b2[i]);
        if (res !== 0)
          return res;
      }
      return al2 === bl2 ? 0 : al2 < bl2 ? -1 : 1;
    }
    function compareUint8Arrays(a, b2) {
      var al2 = a.length;
      var bl2 = b2.length;
      var l2 = al2 < bl2 ? al2 : bl2;
      for (var i = 0; i < l2; ++i) {
        if (a[i] !== b2[i])
          return a[i] < b2[i] ? -1 : 1;
      }
      return al2 === bl2 ? 0 : al2 < bl2 ? -1 : 1;
    }
    function type(x2) {
      var t2 = typeof x2;
      if (t2 !== "object")
        return t2;
      if (ArrayBuffer.isView(x2))
        return "binary";
      var tsTag = toStringTag(x2);
      return tsTag === "ArrayBuffer" ? "binary" : tsTag;
    }
    function getUint8Array(a) {
      if (a instanceof Uint8Array)
        return a;
      if (ArrayBuffer.isView(a))
        return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
      return new Uint8Array(a);
    }
    var Collection = function() {
      function Collection2() {
      }
      Collection2.prototype._read = function(fn, cb2) {
        var ctx = this._ctx;
        return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans("readonly", fn).then(cb2);
      };
      Collection2.prototype._write = function(fn) {
        var ctx = this._ctx;
        return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans("readwrite", fn, "locked");
      };
      Collection2.prototype._addAlgorithm = function(fn) {
        var ctx = this._ctx;
        ctx.algorithm = combine(ctx.algorithm, fn);
      };
      Collection2.prototype._iterate = function(fn, coreTrans) {
        return iter(this._ctx, fn, coreTrans, this._ctx.table.core);
      };
      Collection2.prototype.clone = function(props2) {
        var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);
        if (props2)
          extend$1(ctx, props2);
        rv._ctx = ctx;
        return rv;
      };
      Collection2.prototype.raw = function() {
        this._ctx.valueMapper = null;
        return this;
      };
      Collection2.prototype.each = function(fn) {
        var ctx = this._ctx;
        return this._read(function(trans) {
          return iter(ctx, fn, trans, ctx.table.core);
        });
      };
      Collection2.prototype.count = function(cb2) {
        var _this = this;
        return this._read(function(trans) {
          var ctx = _this._ctx;
          var coreTable = ctx.table.core;
          if (isPlainKeyRange(ctx, true)) {
            return coreTable.count({
              trans,
              query: {
                index: getIndexOrStore(ctx, coreTable.schema),
                range: ctx.range
              }
            }).then(function(count2) {
              return Math.min(count2, ctx.limit);
            });
          } else {
            var count = 0;
            return iter(ctx, function() {
              ++count;
              return false;
            }, trans, coreTable).then(function() {
              return count;
            });
          }
        }).then(cb2);
      };
      Collection2.prototype.sortBy = function(keyPath, cb2) {
        var parts = keyPath.split(".").reverse(), lastPart = parts[0], lastIndex = parts.length - 1;
        function getval(obj, i) {
          if (i)
            return getval(obj[parts[i]], i - 1);
          return obj[lastPart];
        }
        var order2 = this._ctx.dir === "next" ? 1 : -1;
        function sorter(a, b2) {
          var aVal = getval(a, lastIndex), bVal = getval(b2, lastIndex);
          return aVal < bVal ? -order2 : aVal > bVal ? order2 : 0;
        }
        return this.toArray(function(a) {
          return a.sort(sorter);
        }).then(cb2);
      };
      Collection2.prototype.toArray = function(cb2) {
        var _this = this;
        return this._read(function(trans) {
          var ctx = _this._ctx;
          if (ctx.dir === "next" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
            var valueMapper_1 = ctx.valueMapper;
            var index2 = getIndexOrStore(ctx, ctx.table.core.schema);
            return ctx.table.core.query({
              trans,
              limit: ctx.limit,
              values: true,
              query: {
                index: index2,
                range: ctx.range
              }
            }).then(function(_a2) {
              var result = _a2.result;
              return valueMapper_1 ? result.map(valueMapper_1) : result;
            });
          } else {
            var a_1 = [];
            return iter(ctx, function(item) {
              return a_1.push(item);
            }, trans, ctx.table.core).then(function() {
              return a_1;
            });
          }
        }, cb2);
      };
      Collection2.prototype.offset = function(offset2) {
        var ctx = this._ctx;
        if (offset2 <= 0)
          return this;
        ctx.offset += offset2;
        if (isPlainKeyRange(ctx)) {
          addReplayFilter(ctx, function() {
            var offsetLeft = offset2;
            return function(cursor2, advance) {
              if (offsetLeft === 0)
                return true;
              if (offsetLeft === 1) {
                --offsetLeft;
                return false;
              }
              advance(function() {
                cursor2.advance(offsetLeft);
                offsetLeft = 0;
              });
              return false;
            };
          });
        } else {
          addReplayFilter(ctx, function() {
            var offsetLeft = offset2;
            return function() {
              return --offsetLeft < 0;
            };
          });
        }
        return this;
      };
      Collection2.prototype.limit = function(numRows) {
        this._ctx.limit = Math.min(this._ctx.limit, numRows);
        addReplayFilter(this._ctx, function() {
          var rowsLeft = numRows;
          return function(cursor2, advance, resolve) {
            if (--rowsLeft <= 0)
              advance(resolve);
            return rowsLeft >= 0;
          };
        }, true);
        return this;
      };
      Collection2.prototype.until = function(filterFunction, bIncludeStopEntry) {
        addFilter(this._ctx, function(cursor2, advance, resolve) {
          if (filterFunction(cursor2.value)) {
            advance(resolve);
            return bIncludeStopEntry;
          } else {
            return true;
          }
        });
        return this;
      };
      Collection2.prototype.first = function(cb2) {
        return this.limit(1).toArray(function(a) {
          return a[0];
        }).then(cb2);
      };
      Collection2.prototype.last = function(cb2) {
        return this.reverse().first(cb2);
      };
      Collection2.prototype.filter = function(filterFunction) {
        addFilter(this._ctx, function(cursor2) {
          return filterFunction(cursor2.value);
        });
        addMatchFilter(this._ctx, filterFunction);
        return this;
      };
      Collection2.prototype.and = function(filter) {
        return this.filter(filter);
      };
      Collection2.prototype.or = function(indexName) {
        return new this.db.WhereClause(this._ctx.table, indexName, this);
      };
      Collection2.prototype.reverse = function() {
        this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev";
        if (this._ondirectionchange)
          this._ondirectionchange(this._ctx.dir);
        return this;
      };
      Collection2.prototype.desc = function() {
        return this.reverse();
      };
      Collection2.prototype.eachKey = function(cb2) {
        var ctx = this._ctx;
        ctx.keysOnly = !ctx.isMatch;
        return this.each(function(val, cursor2) {
          cb2(cursor2.key, cursor2);
        });
      };
      Collection2.prototype.eachUniqueKey = function(cb2) {
        this._ctx.unique = "unique";
        return this.eachKey(cb2);
      };
      Collection2.prototype.eachPrimaryKey = function(cb2) {
        var ctx = this._ctx;
        ctx.keysOnly = !ctx.isMatch;
        return this.each(function(val, cursor2) {
          cb2(cursor2.primaryKey, cursor2);
        });
      };
      Collection2.prototype.keys = function(cb2) {
        var ctx = this._ctx;
        ctx.keysOnly = !ctx.isMatch;
        var a = [];
        return this.each(function(item, cursor2) {
          a.push(cursor2.key);
        }).then(function() {
          return a;
        }).then(cb2);
      };
      Collection2.prototype.primaryKeys = function(cb2) {
        var ctx = this._ctx;
        if (ctx.dir === "next" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
          return this._read(function(trans) {
            var index2 = getIndexOrStore(ctx, ctx.table.core.schema);
            return ctx.table.core.query({
              trans,
              values: false,
              limit: ctx.limit,
              query: {
                index: index2,
                range: ctx.range
              }
            });
          }).then(function(_a2) {
            var result = _a2.result;
            return result;
          }).then(cb2);
        }
        ctx.keysOnly = !ctx.isMatch;
        var a = [];
        return this.each(function(item, cursor2) {
          a.push(cursor2.primaryKey);
        }).then(function() {
          return a;
        }).then(cb2);
      };
      Collection2.prototype.uniqueKeys = function(cb2) {
        this._ctx.unique = "unique";
        return this.keys(cb2);
      };
      Collection2.prototype.firstKey = function(cb2) {
        return this.limit(1).keys(function(a) {
          return a[0];
        }).then(cb2);
      };
      Collection2.prototype.lastKey = function(cb2) {
        return this.reverse().firstKey(cb2);
      };
      Collection2.prototype.distinct = function() {
        var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];
        if (!idx || !idx.multi)
          return this;
        var set2 = {};
        addFilter(this._ctx, function(cursor2) {
          var strKey = cursor2.primaryKey.toString();
          var found = hasOwn(set2, strKey);
          set2[strKey] = true;
          return !found;
        });
        return this;
      };
      Collection2.prototype.modify = function(changes) {
        var _this = this;
        var ctx = this._ctx;
        return this._write(function(trans) {
          var modifyer;
          if (typeof changes === "function") {
            modifyer = changes;
          } else {
            var keyPaths = keys$1(changes);
            var numKeys = keyPaths.length;
            modifyer = function(item) {
              var anythingModified = false;
              for (var i = 0; i < numKeys; ++i) {
                var keyPath = keyPaths[i], val = changes[keyPath];
                if (getByKeyPath(item, keyPath) !== val) {
                  setByKeyPath(item, keyPath, val);
                  anythingModified = true;
                }
              }
              return anythingModified;
            };
          }
          var coreTable = ctx.table.core;
          var _a2 = coreTable.schema.primaryKey, outbound = _a2.outbound, extractKey = _a2.extractKey;
          var limit = _this.db._options.modifyChunkSize || 200;
          var totalFailures = [];
          var successCount = 0;
          var failedKeys = [];
          var applyMutateResult = function(expectedCount, res) {
            var failures = res.failures, numFailures = res.numFailures;
            successCount += expectedCount - numFailures;
            for (var _i = 0, _a3 = keys$1(failures); _i < _a3.length; _i++) {
              var pos = _a3[_i];
              totalFailures.push(failures[pos]);
            }
          };
          return _this.clone().primaryKeys().then(function(keys2) {
            var nextChunk = function(offset2) {
              var count = Math.min(limit, keys2.length - offset2);
              return coreTable.getMany({
                trans,
                keys: keys2.slice(offset2, offset2 + count),
                cache: "immutable"
              }).then(function(values2) {
                var addValues = [];
                var putValues = [];
                var putKeys = outbound ? [] : null;
                var deleteKeys = [];
                for (var i = 0; i < count; ++i) {
                  var origValue = values2[i];
                  var ctx_1 = {
                    value: deepClone(origValue),
                    primKey: keys2[offset2 + i]
                  };
                  if (modifyer.call(ctx_1, ctx_1.value, ctx_1) !== false) {
                    if (ctx_1.value == null) {
                      deleteKeys.push(keys2[offset2 + i]);
                    } else if (!outbound && cmp(extractKey(origValue), extractKey(ctx_1.value)) !== 0) {
                      deleteKeys.push(keys2[offset2 + i]);
                      addValues.push(ctx_1.value);
                    } else {
                      putValues.push(ctx_1.value);
                      if (outbound)
                        putKeys.push(keys2[offset2 + i]);
                    }
                  }
                }
                var criteria = isPlainKeyRange(ctx) && ctx.limit === Infinity && (typeof changes !== "function" || changes === deleteCallback) && {
                  index: ctx.index,
                  range: ctx.range
                };
                return Promise.resolve(addValues.length > 0 && coreTable.mutate({ trans, type: "add", values: addValues }).then(function(res) {
                  for (var pos in res.failures) {
                    deleteKeys.splice(parseInt(pos), 1);
                  }
                  applyMutateResult(addValues.length, res);
                })).then(function() {
                  return (putValues.length > 0 || criteria && typeof changes === "object") && coreTable.mutate({
                    trans,
                    type: "put",
                    keys: putKeys,
                    values: putValues,
                    criteria,
                    changeSpec: typeof changes !== "function" && changes
                  }).then(function(res) {
                    return applyMutateResult(putValues.length, res);
                  });
                }).then(function() {
                  return (deleteKeys.length > 0 || criteria && changes === deleteCallback) && coreTable.mutate({
                    trans,
                    type: "delete",
                    keys: deleteKeys,
                    criteria
                  }).then(function(res) {
                    return applyMutateResult(deleteKeys.length, res);
                  });
                }).then(function() {
                  return keys2.length > offset2 + count && nextChunk(offset2 + limit);
                });
              });
            };
            return nextChunk(0).then(function() {
              if (totalFailures.length > 0)
                throw new ModifyError("Error modifying one or more objects", totalFailures, successCount, failedKeys);
              return keys2.length;
            });
          });
        });
      };
      Collection2.prototype.delete = function() {
        var ctx = this._ctx, range = ctx.range;
        if (isPlainKeyRange(ctx) && (ctx.isPrimKey && !hangsOnDeleteLargeKeyRange || range.type === 3)) {
          return this._write(function(trans) {
            var primaryKey = ctx.table.core.schema.primaryKey;
            var coreRange = range;
            return ctx.table.core.count({ trans, query: { index: primaryKey, range: coreRange } }).then(function(count) {
              return ctx.table.core.mutate({ trans, type: "deleteRange", range: coreRange }).then(function(_a2) {
                var failures = _a2.failures;
                _a2.lastResult;
                _a2.results;
                var numFailures = _a2.numFailures;
                if (numFailures)
                  throw new ModifyError("Could not delete some values", Object.keys(failures).map(function(pos) {
                    return failures[pos];
                  }), count - numFailures);
                return count - numFailures;
              });
            });
          });
        }
        return this.modify(deleteCallback);
      };
      return Collection2;
    }();
    var deleteCallback = function(value, ctx) {
      return ctx.value = null;
    };
    function createCollectionConstructor(db2) {
      return makeClassConstructor(Collection.prototype, function Collection2(whereClause, keyRangeGenerator) {
        this.db = db2;
        var keyRange = AnyRange, error = null;
        if (keyRangeGenerator)
          try {
            keyRange = keyRangeGenerator();
          } catch (ex) {
            error = ex;
          }
        var whereCtx = whereClause._ctx;
        var table = whereCtx.table;
        var readingHook = table.hook.reading.fire;
        this._ctx = {
          table,
          index: whereCtx.index,
          isPrimKey: !whereCtx.index || table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name,
          range: keyRange,
          keysOnly: false,
          dir: "next",
          unique: "",
          algorithm: null,
          filter: null,
          replayFilter: null,
          justLimit: true,
          isMatch: null,
          offset: 0,
          limit: Infinity,
          error,
          or: whereCtx.or,
          valueMapper: readingHook !== mirror ? readingHook : null
        };
      });
    }
    function simpleCompare(a, b2) {
      return a < b2 ? -1 : a === b2 ? 0 : 1;
    }
    function simpleCompareReverse(a, b2) {
      return a > b2 ? -1 : a === b2 ? 0 : 1;
    }
    function fail(collectionOrWhereClause, err, T2) {
      var collection = collectionOrWhereClause instanceof WhereClause ? new collectionOrWhereClause.Collection(collectionOrWhereClause) : collectionOrWhereClause;
      collection._ctx.error = T2 ? new T2(err) : new TypeError(err);
      return collection;
    }
    function emptyCollection(whereClause) {
      return new whereClause.Collection(whereClause, function() {
        return rangeEqual("");
      }).limit(0);
    }
    function upperFactory(dir) {
      return dir === "next" ? function(s) {
        return s.toUpperCase();
      } : function(s) {
        return s.toLowerCase();
      };
    }
    function lowerFactory(dir) {
      return dir === "next" ? function(s) {
        return s.toLowerCase();
      } : function(s) {
        return s.toUpperCase();
      };
    }
    function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp2, dir) {
      var length2 = Math.min(key.length, lowerNeedle.length);
      var llp = -1;
      for (var i = 0; i < length2; ++i) {
        var lwrKeyChar = lowerKey[i];
        if (lwrKeyChar !== lowerNeedle[i]) {
          if (cmp2(key[i], upperNeedle[i]) < 0)
            return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);
          if (cmp2(key[i], lowerNeedle[i]) < 0)
            return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);
          if (llp >= 0)
            return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);
          return null;
        }
        if (cmp2(key[i], lwrKeyChar) < 0)
          llp = i;
      }
      if (length2 < lowerNeedle.length && dir === "next")
        return key + upperNeedle.substr(key.length);
      if (length2 < key.length && dir === "prev")
        return key.substr(0, upperNeedle.length);
      return llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1);
    }
    function addIgnoreCaseAlgorithm(whereClause, match5, needles, suffix) {
      var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;
      if (!needles.every(function(s) {
        return typeof s === "string";
      })) {
        return fail(whereClause, STRING_EXPECTED);
      }
      function initDirection(dir) {
        upper = upperFactory(dir);
        lower = lowerFactory(dir);
        compare = dir === "next" ? simpleCompare : simpleCompareReverse;
        var needleBounds = needles.map(function(needle) {
          return { lower: lower(needle), upper: upper(needle) };
        }).sort(function(a, b2) {
          return compare(a.lower, b2.lower);
        });
        upperNeedles = needleBounds.map(function(nb2) {
          return nb2.upper;
        });
        lowerNeedles = needleBounds.map(function(nb2) {
          return nb2.lower;
        });
        direction = dir;
        nextKeySuffix = dir === "next" ? "" : suffix;
      }
      initDirection("next");
      var c2 = new whereClause.Collection(whereClause, function() {
        return createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix);
      });
      c2._ondirectionchange = function(direction2) {
        initDirection(direction2);
      };
      var firstPossibleNeedle = 0;
      c2._addAlgorithm(function(cursor2, advance, resolve) {
        var key = cursor2.key;
        if (typeof key !== "string")
          return false;
        var lowerKey = lower(key);
        if (match5(lowerKey, lowerNeedles, firstPossibleNeedle)) {
          return true;
        } else {
          var lowestPossibleCasing = null;
          for (var i = firstPossibleNeedle; i < needlesLen; ++i) {
            var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);
            if (casing === null && lowestPossibleCasing === null)
              firstPossibleNeedle = i + 1;
            else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {
              lowestPossibleCasing = casing;
            }
          }
          if (lowestPossibleCasing !== null) {
            advance(function() {
              cursor2.continue(lowestPossibleCasing + nextKeySuffix);
            });
          } else {
            advance(resolve);
          }
          return false;
        }
      });
      return c2;
    }
    function createRange(lower, upper, lowerOpen, upperOpen) {
      return {
        type: 2,
        lower,
        upper,
        lowerOpen,
        upperOpen
      };
    }
    function rangeEqual(value) {
      return {
        type: 1,
        lower: value,
        upper: value
      };
    }
    var WhereClause = function() {
      function WhereClause2() {
      }
      Object.defineProperty(WhereClause2.prototype, "Collection", {
        get: function() {
          return this._ctx.table.db.Collection;
        },
        enumerable: false,
        configurable: true
      });
      WhereClause2.prototype.between = function(lower, upper, includeLower, includeUpper) {
        includeLower = includeLower !== false;
        includeUpper = includeUpper === true;
        try {
          if (this._cmp(lower, upper) > 0 || this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper))
            return emptyCollection(this);
          return new this.Collection(this, function() {
            return createRange(lower, upper, !includeLower, !includeUpper);
          });
        } catch (e2) {
          return fail(this, INVALID_KEY_ARGUMENT);
        }
      };
      WhereClause2.prototype.equals = function(value) {
        if (value == null)
          return fail(this, INVALID_KEY_ARGUMENT);
        return new this.Collection(this, function() {
          return rangeEqual(value);
        });
      };
      WhereClause2.prototype.above = function(value) {
        if (value == null)
          return fail(this, INVALID_KEY_ARGUMENT);
        return new this.Collection(this, function() {
          return createRange(value, void 0, true);
        });
      };
      WhereClause2.prototype.aboveOrEqual = function(value) {
        if (value == null)
          return fail(this, INVALID_KEY_ARGUMENT);
        return new this.Collection(this, function() {
          return createRange(value, void 0, false);
        });
      };
      WhereClause2.prototype.below = function(value) {
        if (value == null)
          return fail(this, INVALID_KEY_ARGUMENT);
        return new this.Collection(this, function() {
          return createRange(void 0, value, false, true);
        });
      };
      WhereClause2.prototype.belowOrEqual = function(value) {
        if (value == null)
          return fail(this, INVALID_KEY_ARGUMENT);
        return new this.Collection(this, function() {
          return createRange(void 0, value);
        });
      };
      WhereClause2.prototype.startsWith = function(str) {
        if (typeof str !== "string")
          return fail(this, STRING_EXPECTED);
        return this.between(str, str + maxString, true, true);
      };
      WhereClause2.prototype.startsWithIgnoreCase = function(str) {
        if (str === "")
          return this.startsWith(str);
        return addIgnoreCaseAlgorithm(this, function(x2, a) {
          return x2.indexOf(a[0]) === 0;
        }, [str], maxString);
      };
      WhereClause2.prototype.equalsIgnoreCase = function(str) {
        return addIgnoreCaseAlgorithm(this, function(x2, a) {
          return x2 === a[0];
        }, [str], "");
      };
      WhereClause2.prototype.anyOfIgnoreCase = function() {
        var set2 = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
        if (set2.length === 0)
          return emptyCollection(this);
        return addIgnoreCaseAlgorithm(this, function(x2, a) {
          return a.indexOf(x2) !== -1;
        }, set2, "");
      };
      WhereClause2.prototype.startsWithAnyOfIgnoreCase = function() {
        var set2 = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
        if (set2.length === 0)
          return emptyCollection(this);
        return addIgnoreCaseAlgorithm(this, function(x2, a) {
          return a.some(function(n2) {
            return x2.indexOf(n2) === 0;
          });
        }, set2, maxString);
      };
      WhereClause2.prototype.anyOf = function() {
        var _this = this;
        var set2 = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
        var compare = this._cmp;
        try {
          set2.sort(compare);
        } catch (e2) {
          return fail(this, INVALID_KEY_ARGUMENT);
        }
        if (set2.length === 0)
          return emptyCollection(this);
        var c2 = new this.Collection(this, function() {
          return createRange(set2[0], set2[set2.length - 1]);
        });
        c2._ondirectionchange = function(direction) {
          compare = direction === "next" ? _this._ascending : _this._descending;
          set2.sort(compare);
        };
        var i = 0;
        c2._addAlgorithm(function(cursor2, advance, resolve) {
          var key = cursor2.key;
          while (compare(key, set2[i]) > 0) {
            ++i;
            if (i === set2.length) {
              advance(resolve);
              return false;
            }
          }
          if (compare(key, set2[i]) === 0) {
            return true;
          } else {
            advance(function() {
              cursor2.continue(set2[i]);
            });
            return false;
          }
        });
        return c2;
      };
      WhereClause2.prototype.notEqual = function(value) {
        return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });
      };
      WhereClause2.prototype.noneOf = function() {
        var set2 = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
        if (set2.length === 0)
          return new this.Collection(this);
        try {
          set2.sort(this._ascending);
        } catch (e2) {
          return fail(this, INVALID_KEY_ARGUMENT);
        }
        var ranges = set2.reduce(function(res, val) {
          return res ? res.concat([[res[res.length - 1][1], val]]) : [[minKey, val]];
        }, null);
        ranges.push([set2[set2.length - 1], this.db._maxKey]);
        return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });
      };
      WhereClause2.prototype.inAnyRange = function(ranges, options) {
        var _this = this;
        var cmp2 = this._cmp, ascending = this._ascending, descending = this._descending, min2 = this._min, max2 = this._max;
        if (ranges.length === 0)
          return emptyCollection(this);
        if (!ranges.every(function(range) {
          return range[0] !== void 0 && range[1] !== void 0 && ascending(range[0], range[1]) <= 0;
        })) {
          return fail(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", exceptions.InvalidArgument);
        }
        var includeLowers = !options || options.includeLowers !== false;
        var includeUppers = options && options.includeUppers === true;
        function addRange2(ranges2, newRange) {
          var i = 0, l2 = ranges2.length;
          for (; i < l2; ++i) {
            var range = ranges2[i];
            if (cmp2(newRange[0], range[1]) < 0 && cmp2(newRange[1], range[0]) > 0) {
              range[0] = min2(range[0], newRange[0]);
              range[1] = max2(range[1], newRange[1]);
              break;
            }
          }
          if (i === l2)
            ranges2.push(newRange);
          return ranges2;
        }
        var sortDirection = ascending;
        function rangeSorter(a, b2) {
          return sortDirection(a[0], b2[0]);
        }
        var set2;
        try {
          set2 = ranges.reduce(addRange2, []);
          set2.sort(rangeSorter);
        } catch (ex) {
          return fail(this, INVALID_KEY_ARGUMENT);
        }
        var rangePos = 0;
        var keyIsBeyondCurrentEntry = includeUppers ? function(key) {
          return ascending(key, set2[rangePos][1]) > 0;
        } : function(key) {
          return ascending(key, set2[rangePos][1]) >= 0;
        };
        var keyIsBeforeCurrentEntry = includeLowers ? function(key) {
          return descending(key, set2[rangePos][0]) > 0;
        } : function(key) {
          return descending(key, set2[rangePos][0]) >= 0;
        };
        function keyWithinCurrentRange(key) {
          return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);
        }
        var checkKey = keyIsBeyondCurrentEntry;
        var c2 = new this.Collection(this, function() {
          return createRange(set2[0][0], set2[set2.length - 1][1], !includeLowers, !includeUppers);
        });
        c2._ondirectionchange = function(direction) {
          if (direction === "next") {
            checkKey = keyIsBeyondCurrentEntry;
            sortDirection = ascending;
          } else {
            checkKey = keyIsBeforeCurrentEntry;
            sortDirection = descending;
          }
          set2.sort(rangeSorter);
        };
        c2._addAlgorithm(function(cursor2, advance, resolve) {
          var key = cursor2.key;
          while (checkKey(key)) {
            ++rangePos;
            if (rangePos === set2.length) {
              advance(resolve);
              return false;
            }
          }
          if (keyWithinCurrentRange(key)) {
            return true;
          } else if (_this._cmp(key, set2[rangePos][1]) === 0 || _this._cmp(key, set2[rangePos][0]) === 0) {
            return false;
          } else {
            advance(function() {
              if (sortDirection === ascending)
                cursor2.continue(set2[rangePos][0]);
              else
                cursor2.continue(set2[rangePos][1]);
            });
            return false;
          }
        });
        return c2;
      };
      WhereClause2.prototype.startsWithAnyOf = function() {
        var set2 = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
        if (!set2.every(function(s) {
          return typeof s === "string";
        })) {
          return fail(this, "startsWithAnyOf() only works with strings");
        }
        if (set2.length === 0)
          return emptyCollection(this);
        return this.inAnyRange(set2.map(function(str) {
          return [str, str + maxString];
        }));
      };
      return WhereClause2;
    }();
    function createWhereClauseConstructor(db2) {
      return makeClassConstructor(WhereClause.prototype, function WhereClause2(table, index2, orCollection) {
        this.db = db2;
        this._ctx = {
          table,
          index: index2 === ":id" ? null : index2,
          or: orCollection
        };
        var indexedDB2 = db2._deps.indexedDB;
        if (!indexedDB2)
          throw new exceptions.MissingAPI();
        this._cmp = this._ascending = indexedDB2.cmp.bind(indexedDB2);
        this._descending = function(a, b2) {
          return indexedDB2.cmp(b2, a);
        };
        this._max = function(a, b2) {
          return indexedDB2.cmp(a, b2) > 0 ? a : b2;
        };
        this._min = function(a, b2) {
          return indexedDB2.cmp(a, b2) < 0 ? a : b2;
        };
        this._IDBKeyRange = db2._deps.IDBKeyRange;
      });
    }
    function eventRejectHandler(reject) {
      return wrap(function(event) {
        preventDefault(event);
        reject(event.target.error);
        return false;
      });
    }
    function preventDefault(event) {
      if (event.stopPropagation)
        event.stopPropagation();
      if (event.preventDefault)
        event.preventDefault();
    }
    var DEXIE_STORAGE_MUTATED_EVENT_NAME = "storagemutated";
    var STORAGE_MUTATED_DOM_EVENT_NAME = "x-storagemutated-1";
    var globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);
    var Transaction = function() {
      function Transaction2() {
      }
      Transaction2.prototype._lock = function() {
        assert(!PSD.global);
        ++this._reculock;
        if (this._reculock === 1 && !PSD.global)
          PSD.lockOwnerFor = this;
        return this;
      };
      Transaction2.prototype._unlock = function() {
        assert(!PSD.global);
        if (--this._reculock === 0) {
          if (!PSD.global)
            PSD.lockOwnerFor = null;
          while (this._blockedFuncs.length > 0 && !this._locked()) {
            var fnAndPSD = this._blockedFuncs.shift();
            try {
              usePSD(fnAndPSD[1], fnAndPSD[0]);
            } catch (e2) {
            }
          }
        }
        return this;
      };
      Transaction2.prototype._locked = function() {
        return this._reculock && PSD.lockOwnerFor !== this;
      };
      Transaction2.prototype.create = function(idbtrans) {
        var _this = this;
        if (!this.mode)
          return this;
        var idbdb = this.db.idbdb;
        var dbOpenError = this.db._state.dbOpenError;
        assert(!this.idbtrans);
        if (!idbtrans && !idbdb) {
          switch (dbOpenError && dbOpenError.name) {
            case "DatabaseClosedError":
              throw new exceptions.DatabaseClosed(dbOpenError);
            case "MissingAPIError":
              throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);
            default:
              throw new exceptions.OpenFailed(dbOpenError);
          }
        }
        if (!this.active)
          throw new exceptions.TransactionInactive();
        assert(this._completion._state === null);
        idbtrans = this.idbtrans = idbtrans || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }) : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));
        idbtrans.onerror = wrap(function(ev) {
          preventDefault(ev);
          _this._reject(idbtrans.error);
        });
        idbtrans.onabort = wrap(function(ev) {
          preventDefault(ev);
          _this.active && _this._reject(new exceptions.Abort(idbtrans.error));
          _this.active = false;
          _this.on("abort").fire(ev);
        });
        idbtrans.oncomplete = wrap(function() {
          _this.active = false;
          _this._resolve();
          if ("mutatedParts" in idbtrans) {
            globalEvents.storagemutated.fire(idbtrans["mutatedParts"]);
          }
        });
        return this;
      };
      Transaction2.prototype._promise = function(mode, fn, bWriteLock) {
        var _this = this;
        if (mode === "readwrite" && this.mode !== "readwrite")
          return rejection(new exceptions.ReadOnly("Transaction is readonly"));
        if (!this.active)
          return rejection(new exceptions.TransactionInactive());
        if (this._locked()) {
          return new DexiePromise(function(resolve, reject) {
            _this._blockedFuncs.push([function() {
              _this._promise(mode, fn, bWriteLock).then(resolve, reject);
            }, PSD]);
          });
        } else if (bWriteLock) {
          return newScope(function() {
            var p3 = new DexiePromise(function(resolve, reject) {
              _this._lock();
              var rv = fn(resolve, reject, _this);
              if (rv && rv.then)
                rv.then(resolve, reject);
            });
            p3.finally(function() {
              return _this._unlock();
            });
            p3._lib = true;
            return p3;
          });
        } else {
          var p2 = new DexiePromise(function(resolve, reject) {
            var rv = fn(resolve, reject, _this);
            if (rv && rv.then)
              rv.then(resolve, reject);
          });
          p2._lib = true;
          return p2;
        }
      };
      Transaction2.prototype._root = function() {
        return this.parent ? this.parent._root() : this;
      };
      Transaction2.prototype.waitFor = function(promiseLike) {
        var root2 = this._root();
        var promise = DexiePromise.resolve(promiseLike);
        if (root2._waitingFor) {
          root2._waitingFor = root2._waitingFor.then(function() {
            return promise;
          });
        } else {
          root2._waitingFor = promise;
          root2._waitingQueue = [];
          var store = root2.idbtrans.objectStore(root2.storeNames[0]);
          (function spin() {
            ++root2._spinCount;
            while (root2._waitingQueue.length)
              root2._waitingQueue.shift()();
            if (root2._waitingFor)
              store.get(-Infinity).onsuccess = spin;
          })();
        }
        var currentWaitPromise = root2._waitingFor;
        return new DexiePromise(function(resolve, reject) {
          promise.then(function(res) {
            return root2._waitingQueue.push(wrap(resolve.bind(null, res)));
          }, function(err) {
            return root2._waitingQueue.push(wrap(reject.bind(null, err)));
          }).finally(function() {
            if (root2._waitingFor === currentWaitPromise) {
              root2._waitingFor = null;
            }
          });
        });
      };
      Transaction2.prototype.abort = function() {
        if (this.active) {
          this.active = false;
          if (this.idbtrans)
            this.idbtrans.abort();
          this._reject(new exceptions.Abort());
        }
      };
      Transaction2.prototype.table = function(tableName) {
        var memoizedTables = this._memoizedTables || (this._memoizedTables = {});
        if (hasOwn(memoizedTables, tableName))
          return memoizedTables[tableName];
        var tableSchema = this.schema[tableName];
        if (!tableSchema) {
          throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
        }
        var transactionBoundTable = new this.db.Table(tableName, tableSchema, this);
        transactionBoundTable.core = this.db.core.table(tableName);
        memoizedTables[tableName] = transactionBoundTable;
        return transactionBoundTable;
      };
      return Transaction2;
    }();
    function createTransactionConstructor(db2) {
      return makeClassConstructor(Transaction.prototype, function Transaction2(mode, storeNames, dbschema, chromeTransactionDurability, parent) {
        var _this = this;
        this.db = db2;
        this.mode = mode;
        this.storeNames = storeNames;
        this.schema = dbschema;
        this.chromeTransactionDurability = chromeTransactionDurability;
        this.idbtrans = null;
        this.on = Events(this, "complete", "error", "abort");
        this.parent = parent || null;
        this.active = true;
        this._reculock = 0;
        this._blockedFuncs = [];
        this._resolve = null;
        this._reject = null;
        this._waitingFor = null;
        this._waitingQueue = null;
        this._spinCount = 0;
        this._completion = new DexiePromise(function(resolve, reject) {
          _this._resolve = resolve;
          _this._reject = reject;
        });
        this._completion.then(function() {
          _this.active = false;
          _this.on.complete.fire();
        }, function(e2) {
          var wasActive = _this.active;
          _this.active = false;
          _this.on.error.fire(e2);
          _this.parent ? _this.parent._reject(e2) : wasActive && _this.idbtrans && _this.idbtrans.abort();
          return rejection(e2);
        });
      });
    }
    function createIndexSpec(name, keyPath, unique, multi, auto2, compound, isPrimKey) {
      return {
        name,
        keyPath,
        unique,
        multi,
        auto: auto2,
        compound,
        src: (unique && !isPrimKey ? "&" : "") + (multi ? "*" : "") + (auto2 ? "++" : "") + nameFromKeyPath(keyPath)
      };
    }
    function nameFromKeyPath(keyPath) {
      return typeof keyPath === "string" ? keyPath : keyPath ? "[" + [].join.call(keyPath, "+") + "]" : "";
    }
    function createTableSchema(name, primKey, indexes) {
      return {
        name,
        primKey,
        indexes,
        mappedClass: null,
        idxByName: arrayToObject(indexes, function(index2) {
          return [index2.name, index2];
        })
      };
    }
    function safariMultiStoreFix(storeNames) {
      return storeNames.length === 1 ? storeNames[0] : storeNames;
    }
    var getMaxKey = function(IdbKeyRange) {
      try {
        IdbKeyRange.only([[]]);
        getMaxKey = function() {
          return [[]];
        };
        return [[]];
      } catch (e2) {
        getMaxKey = function() {
          return maxString;
        };
        return maxString;
      }
    };
    function getKeyExtractor(keyPath) {
      if (keyPath == null) {
        return function() {
          return void 0;
        };
      } else if (typeof keyPath === "string") {
        return getSinglePathKeyExtractor(keyPath);
      } else {
        return function(obj) {
          return getByKeyPath(obj, keyPath);
        };
      }
    }
    function getSinglePathKeyExtractor(keyPath) {
      var split = keyPath.split(".");
      if (split.length === 1) {
        return function(obj) {
          return obj[keyPath];
        };
      } else {
        return function(obj) {
          return getByKeyPath(obj, keyPath);
        };
      }
    }
    function arrayify(arrayLike) {
      return [].slice.call(arrayLike);
    }
    var _id_counter = 0;
    function getKeyPathAlias(keyPath) {
      return keyPath == null ? ":id" : typeof keyPath === "string" ? keyPath : "[" + keyPath.join("+") + "]";
    }
    function createDBCore(db2, IdbKeyRange, tmpTrans) {
      function extractSchema(db3, trans) {
        var tables2 = arrayify(db3.objectStoreNames);
        return {
          schema: {
            name: db3.name,
            tables: tables2.map(function(table) {
              return trans.objectStore(table);
            }).map(function(store) {
              var keyPath = store.keyPath, autoIncrement = store.autoIncrement;
              var compound = isArray$1(keyPath);
              var outbound = keyPath == null;
              var indexByKeyPath = {};
              var result = {
                name: store.name,
                primaryKey: {
                  name: null,
                  isPrimaryKey: true,
                  outbound,
                  compound,
                  keyPath,
                  autoIncrement,
                  unique: true,
                  extractKey: getKeyExtractor(keyPath)
                },
                indexes: arrayify(store.indexNames).map(function(indexName) {
                  return store.index(indexName);
                }).map(function(index2) {
                  var name = index2.name, unique = index2.unique, multiEntry = index2.multiEntry, keyPath2 = index2.keyPath;
                  var compound2 = isArray$1(keyPath2);
                  var result2 = {
                    name,
                    compound: compound2,
                    keyPath: keyPath2,
                    unique,
                    multiEntry,
                    extractKey: getKeyExtractor(keyPath2)
                  };
                  indexByKeyPath[getKeyPathAlias(keyPath2)] = result2;
                  return result2;
                }),
                getIndexByKeyPath: function(keyPath2) {
                  return indexByKeyPath[getKeyPathAlias(keyPath2)];
                }
              };
              indexByKeyPath[":id"] = result.primaryKey;
              if (keyPath != null) {
                indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;
              }
              return result;
            })
          },
          hasGetAll: tables2.length > 0 && "getAll" in trans.objectStore(tables2[0]) && !(typeof navigator !== "undefined" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604)
        };
      }
      function makeIDBKeyRange(range) {
        if (range.type === 3)
          return null;
        if (range.type === 4)
          throw new Error("Cannot convert never type to IDBKeyRange");
        var lower = range.lower, upper = range.upper, lowerOpen = range.lowerOpen, upperOpen = range.upperOpen;
        var idbRange = lower === void 0 ? upper === void 0 ? null : IdbKeyRange.upperBound(upper, !!upperOpen) : upper === void 0 ? IdbKeyRange.lowerBound(lower, !!lowerOpen) : IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);
        return idbRange;
      }
      function createDbCoreTable(tableSchema) {
        var tableName = tableSchema.name;
        function mutate(_a3) {
          var trans = _a3.trans, type2 = _a3.type, keys2 = _a3.keys, values2 = _a3.values, range = _a3.range;
          return new Promise(function(resolve, reject) {
            resolve = wrap(resolve);
            var store = trans.objectStore(tableName);
            var outbound = store.keyPath == null;
            var isAddOrPut = type2 === "put" || type2 === "add";
            if (!isAddOrPut && type2 !== "delete" && type2 !== "deleteRange")
              throw new Error("Invalid operation type: " + type2);
            var length2 = (keys2 || values2 || { length: 1 }).length;
            if (keys2 && values2 && keys2.length !== values2.length) {
              throw new Error("Given keys array must have same length as given values array.");
            }
            if (length2 === 0)
              return resolve({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
            var req;
            var reqs = [];
            var failures = [];
            var numFailures = 0;
            var errorHandler = function(event) {
              ++numFailures;
              preventDefault(event);
            };
            if (type2 === "deleteRange") {
              if (range.type === 4)
                return resolve({ numFailures, failures, results: [], lastResult: void 0 });
              if (range.type === 3)
                reqs.push(req = store.clear());
              else
                reqs.push(req = store.delete(makeIDBKeyRange(range)));
            } else {
              var _a4 = isAddOrPut ? outbound ? [values2, keys2] : [values2, null] : [keys2, null], args1 = _a4[0], args2 = _a4[1];
              if (isAddOrPut) {
                for (var i = 0; i < length2; ++i) {
                  reqs.push(req = args2 && args2[i] !== void 0 ? store[type2](args1[i], args2[i]) : store[type2](args1[i]));
                  req.onerror = errorHandler;
                }
              } else {
                for (var i = 0; i < length2; ++i) {
                  reqs.push(req = store[type2](args1[i]));
                  req.onerror = errorHandler;
                }
              }
            }
            var done = function(event) {
              var lastResult = event.target.result;
              reqs.forEach(function(req2, i2) {
                return req2.error != null && (failures[i2] = req2.error);
              });
              resolve({
                numFailures,
                failures,
                results: type2 === "delete" ? keys2 : reqs.map(function(req2) {
                  return req2.result;
                }),
                lastResult
              });
            };
            req.onerror = function(event) {
              errorHandler(event);
              done(event);
            };
            req.onsuccess = done;
          });
        }
        function openCursor2(_a3) {
          var trans = _a3.trans, values2 = _a3.values, query2 = _a3.query, reverse = _a3.reverse, unique = _a3.unique;
          return new Promise(function(resolve, reject) {
            resolve = wrap(resolve);
            var index2 = query2.index, range = query2.range;
            var store = trans.objectStore(tableName);
            var source = index2.isPrimaryKey ? store : store.index(index2.name);
            var direction = reverse ? unique ? "prevunique" : "prev" : unique ? "nextunique" : "next";
            var req = values2 || !("openKeyCursor" in source) ? source.openCursor(makeIDBKeyRange(range), direction) : source.openKeyCursor(makeIDBKeyRange(range), direction);
            req.onerror = eventRejectHandler(reject);
            req.onsuccess = wrap(function(ev) {
              var cursor2 = req.result;
              if (!cursor2) {
                resolve(null);
                return;
              }
              cursor2.___id = ++_id_counter;
              cursor2.done = false;
              var _cursorContinue = cursor2.continue.bind(cursor2);
              var _cursorContinuePrimaryKey = cursor2.continuePrimaryKey;
              if (_cursorContinuePrimaryKey)
                _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor2);
              var _cursorAdvance = cursor2.advance.bind(cursor2);
              var doThrowCursorIsNotStarted = function() {
                throw new Error("Cursor not started");
              };
              var doThrowCursorIsStopped = function() {
                throw new Error("Cursor not stopped");
              };
              cursor2.trans = trans;
              cursor2.stop = cursor2.continue = cursor2.continuePrimaryKey = cursor2.advance = doThrowCursorIsNotStarted;
              cursor2.fail = wrap(reject);
              cursor2.next = function() {
                var _this = this;
                var gotOne = 1;
                return this.start(function() {
                  return gotOne-- ? _this.continue() : _this.stop();
                }).then(function() {
                  return _this;
                });
              };
              cursor2.start = function(callback) {
                var iterationPromise = new Promise(function(resolveIteration, rejectIteration) {
                  resolveIteration = wrap(resolveIteration);
                  req.onerror = eventRejectHandler(rejectIteration);
                  cursor2.fail = rejectIteration;
                  cursor2.stop = function(value) {
                    cursor2.stop = cursor2.continue = cursor2.continuePrimaryKey = cursor2.advance = doThrowCursorIsStopped;
                    resolveIteration(value);
                  };
                });
                var guardedCallback = function() {
                  if (req.result) {
                    try {
                      callback();
                    } catch (err) {
                      cursor2.fail(err);
                    }
                  } else {
                    cursor2.done = true;
                    cursor2.start = function() {
                      throw new Error("Cursor behind last entry");
                    };
                    cursor2.stop();
                  }
                };
                req.onsuccess = wrap(function(ev2) {
                  req.onsuccess = guardedCallback;
                  guardedCallback();
                });
                cursor2.continue = _cursorContinue;
                cursor2.continuePrimaryKey = _cursorContinuePrimaryKey;
                cursor2.advance = _cursorAdvance;
                guardedCallback();
                return iterationPromise;
              };
              resolve(cursor2);
            }, reject);
          });
        }
        function query(hasGetAll2) {
          return function(request) {
            return new Promise(function(resolve, reject) {
              resolve = wrap(resolve);
              var trans = request.trans, values2 = request.values, limit = request.limit, query2 = request.query;
              var nonInfinitLimit = limit === Infinity ? void 0 : limit;
              var index2 = query2.index, range = query2.range;
              var store = trans.objectStore(tableName);
              var source = index2.isPrimaryKey ? store : store.index(index2.name);
              var idbKeyRange = makeIDBKeyRange(range);
              if (limit === 0)
                return resolve({ result: [] });
              if (hasGetAll2) {
                var req = values2 ? source.getAll(idbKeyRange, nonInfinitLimit) : source.getAllKeys(idbKeyRange, nonInfinitLimit);
                req.onsuccess = function(event) {
                  return resolve({ result: event.target.result });
                };
                req.onerror = eventRejectHandler(reject);
              } else {
                var count_1 = 0;
                var req_1 = values2 || !("openKeyCursor" in source) ? source.openCursor(idbKeyRange) : source.openKeyCursor(idbKeyRange);
                var result_1 = [];
                req_1.onsuccess = function(event) {
                  var cursor2 = req_1.result;
                  if (!cursor2)
                    return resolve({ result: result_1 });
                  result_1.push(values2 ? cursor2.value : cursor2.primaryKey);
                  if (++count_1 === limit)
                    return resolve({ result: result_1 });
                  cursor2.continue();
                };
                req_1.onerror = eventRejectHandler(reject);
              }
            });
          };
        }
        return {
          name: tableName,
          schema: tableSchema,
          mutate,
          getMany: function(_a3) {
            var trans = _a3.trans, keys2 = _a3.keys;
            return new Promise(function(resolve, reject) {
              resolve = wrap(resolve);
              var store = trans.objectStore(tableName);
              var length2 = keys2.length;
              var result = new Array(length2);
              var keyCount = 0;
              var callbackCount = 0;
              var req;
              var successHandler = function(event) {
                var req2 = event.target;
                if ((result[req2._pos] = req2.result) != null)
                  ;
                if (++callbackCount === keyCount)
                  resolve(result);
              };
              var errorHandler = eventRejectHandler(reject);
              for (var i = 0; i < length2; ++i) {
                var key = keys2[i];
                if (key != null) {
                  req = store.get(keys2[i]);
                  req._pos = i;
                  req.onsuccess = successHandler;
                  req.onerror = errorHandler;
                  ++keyCount;
                }
              }
              if (keyCount === 0)
                resolve(result);
            });
          },
          get: function(_a3) {
            var trans = _a3.trans, key = _a3.key;
            return new Promise(function(resolve, reject) {
              resolve = wrap(resolve);
              var store = trans.objectStore(tableName);
              var req = store.get(key);
              req.onsuccess = function(event) {
                return resolve(event.target.result);
              };
              req.onerror = eventRejectHandler(reject);
            });
          },
          query: query(hasGetAll),
          openCursor: openCursor2,
          count: function(_a3) {
            var query2 = _a3.query, trans = _a3.trans;
            var index2 = query2.index, range = query2.range;
            return new Promise(function(resolve, reject) {
              var store = trans.objectStore(tableName);
              var source = index2.isPrimaryKey ? store : store.index(index2.name);
              var idbKeyRange = makeIDBKeyRange(range);
              var req = idbKeyRange ? source.count(idbKeyRange) : source.count();
              req.onsuccess = wrap(function(ev) {
                return resolve(ev.target.result);
              });
              req.onerror = eventRejectHandler(reject);
            });
          }
        };
      }
      var _a2 = extractSchema(db2, tmpTrans), schema = _a2.schema, hasGetAll = _a2.hasGetAll;
      var tables = schema.tables.map(function(tableSchema) {
        return createDbCoreTable(tableSchema);
      });
      var tableMap = {};
      tables.forEach(function(table) {
        return tableMap[table.name] = table;
      });
      return {
        stack: "dbcore",
        transaction: db2.transaction.bind(db2),
        table: function(name) {
          var result = tableMap[name];
          if (!result)
            throw new Error("Table '" + name + "' not found");
          return tableMap[name];
        },
        MIN_KEY: -Infinity,
        MAX_KEY: getMaxKey(IdbKeyRange),
        schema
      };
    }
    function createMiddlewareStack(stackImpl, middlewares) {
      return middlewares.reduce(function(down, _a2) {
        var create = _a2.create;
        return __assign(__assign({}, down), create(down));
      }, stackImpl);
    }
    function createMiddlewareStacks(middlewares, idbdb, _a2, tmpTrans) {
      var IDBKeyRange = _a2.IDBKeyRange;
      _a2.indexedDB;
      var dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);
      return {
        dbcore
      };
    }
    function generateMiddlewareStacks(_a2, tmpTrans) {
      var db2 = _a2._novip;
      var idbdb = tmpTrans.db;
      var stacks = createMiddlewareStacks(db2._middlewares, idbdb, db2._deps, tmpTrans);
      db2.core = stacks.dbcore;
      db2.tables.forEach(function(table) {
        var tableName = table.name;
        if (db2.core.schema.tables.some(function(tbl) {
          return tbl.name === tableName;
        })) {
          table.core = db2.core.table(tableName);
          if (db2[tableName] instanceof db2.Table) {
            db2[tableName].core = table.core;
          }
        }
      });
    }
    function setApiOnPlace(_a2, objs, tableNames, dbschema) {
      var db2 = _a2._novip;
      tableNames.forEach(function(tableName) {
        var schema = dbschema[tableName];
        objs.forEach(function(obj) {
          var propDesc = getPropertyDescriptor(obj, tableName);
          if (!propDesc || "value" in propDesc && propDesc.value === void 0) {
            if (obj === db2.Transaction.prototype || obj instanceof db2.Transaction) {
              setProp(obj, tableName, {
                get: function() {
                  return this.table(tableName);
                },
                set: function(value) {
                  defineProperty(this, tableName, { value, writable: true, configurable: true, enumerable: true });
                }
              });
            } else {
              obj[tableName] = new db2.Table(tableName, schema);
            }
          }
        });
      });
    }
    function removeTablesApi(_a2, objs) {
      var db2 = _a2._novip;
      objs.forEach(function(obj) {
        for (var key in obj) {
          if (obj[key] instanceof db2.Table)
            delete obj[key];
        }
      });
    }
    function lowerVersionFirst(a, b2) {
      return a._cfg.version - b2._cfg.version;
    }
    function runUpgraders(db2, oldVersion, idbUpgradeTrans, reject) {
      var globalSchema = db2._dbSchema;
      var trans = db2._createTransaction("readwrite", db2._storeNames, globalSchema);
      trans.create(idbUpgradeTrans);
      trans._completion.catch(reject);
      var rejectTransaction = trans._reject.bind(trans);
      var transless = PSD.transless || PSD;
      newScope(function() {
        PSD.trans = trans;
        PSD.transless = transless;
        if (oldVersion === 0) {
          keys$1(globalSchema).forEach(function(tableName) {
            createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);
          });
          generateMiddlewareStacks(db2, idbUpgradeTrans);
          DexiePromise.follow(function() {
            return db2.on.populate.fire(trans);
          }).catch(rejectTransaction);
        } else
          updateTablesAndIndexes(db2, oldVersion, trans, idbUpgradeTrans).catch(rejectTransaction);
      });
    }
    function updateTablesAndIndexes(_a2, oldVersion, trans, idbUpgradeTrans) {
      var db2 = _a2._novip;
      var queue = [];
      var versions = db2._versions;
      var globalSchema = db2._dbSchema = buildGlobalSchema(db2, db2.idbdb, idbUpgradeTrans);
      var anyContentUpgraderHasRun = false;
      var versToRun = versions.filter(function(v2) {
        return v2._cfg.version >= oldVersion;
      });
      versToRun.forEach(function(version) {
        queue.push(function() {
          var oldSchema = globalSchema;
          var newSchema = version._cfg.dbschema;
          adjustToExistingIndexNames(db2, oldSchema, idbUpgradeTrans);
          adjustToExistingIndexNames(db2, newSchema, idbUpgradeTrans);
          globalSchema = db2._dbSchema = newSchema;
          var diff2 = getSchemaDiff(oldSchema, newSchema);
          diff2.add.forEach(function(tuple) {
            createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);
          });
          diff2.change.forEach(function(change) {
            if (change.recreate) {
              throw new exceptions.Upgrade("Not yet support for changing primary key");
            } else {
              var store_1 = idbUpgradeTrans.objectStore(change.name);
              change.add.forEach(function(idx) {
                return addIndex(store_1, idx);
              });
              change.change.forEach(function(idx) {
                store_1.deleteIndex(idx.name);
                addIndex(store_1, idx);
              });
              change.del.forEach(function(idxName) {
                return store_1.deleteIndex(idxName);
              });
            }
          });
          var contentUpgrade = version._cfg.contentUpgrade;
          if (contentUpgrade && version._cfg.version > oldVersion) {
            generateMiddlewareStacks(db2, idbUpgradeTrans);
            trans._memoizedTables = {};
            anyContentUpgraderHasRun = true;
            var upgradeSchema_1 = shallowClone(newSchema);
            diff2.del.forEach(function(table) {
              upgradeSchema_1[table] = oldSchema[table];
            });
            removeTablesApi(db2, [db2.Transaction.prototype]);
            setApiOnPlace(db2, [db2.Transaction.prototype], keys$1(upgradeSchema_1), upgradeSchema_1);
            trans.schema = upgradeSchema_1;
            var contentUpgradeIsAsync_1 = isAsyncFunction(contentUpgrade);
            if (contentUpgradeIsAsync_1) {
              incrementExpectedAwaits();
            }
            var returnValue_1;
            var promiseFollowed = DexiePromise.follow(function() {
              returnValue_1 = contentUpgrade(trans);
              if (returnValue_1) {
                if (contentUpgradeIsAsync_1) {
                  var decrementor = decrementExpectedAwaits.bind(null, null);
                  returnValue_1.then(decrementor, decrementor);
                }
              }
            });
            return returnValue_1 && typeof returnValue_1.then === "function" ? DexiePromise.resolve(returnValue_1) : promiseFollowed.then(function() {
              return returnValue_1;
            });
          }
        });
        queue.push(function(idbtrans) {
          if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {
            var newSchema = version._cfg.dbschema;
            deleteRemovedTables(newSchema, idbtrans);
          }
          removeTablesApi(db2, [db2.Transaction.prototype]);
          setApiOnPlace(db2, [db2.Transaction.prototype], db2._storeNames, db2._dbSchema);
          trans.schema = db2._dbSchema;
        });
      });
      function runQueue() {
        return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) : DexiePromise.resolve();
      }
      return runQueue().then(function() {
        createMissingTables(globalSchema, idbUpgradeTrans);
      });
    }
    function getSchemaDiff(oldSchema, newSchema) {
      var diff2 = {
        del: [],
        add: [],
        change: []
      };
      var table;
      for (table in oldSchema) {
        if (!newSchema[table])
          diff2.del.push(table);
      }
      for (table in newSchema) {
        var oldDef = oldSchema[table], newDef = newSchema[table];
        if (!oldDef) {
          diff2.add.push([table, newDef]);
        } else {
          var change = {
            name: table,
            def: newDef,
            recreate: false,
            del: [],
            add: [],
            change: []
          };
          if ("" + (oldDef.primKey.keyPath || "") !== "" + (newDef.primKey.keyPath || "") || oldDef.primKey.auto !== newDef.primKey.auto && !isIEOrEdge) {
            change.recreate = true;
            diff2.change.push(change);
          } else {
            var oldIndexes = oldDef.idxByName;
            var newIndexes = newDef.idxByName;
            var idxName = void 0;
            for (idxName in oldIndexes) {
              if (!newIndexes[idxName])
                change.del.push(idxName);
            }
            for (idxName in newIndexes) {
              var oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];
              if (!oldIdx)
                change.add.push(newIdx);
              else if (oldIdx.src !== newIdx.src)
                change.change.push(newIdx);
            }
            if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {
              diff2.change.push(change);
            }
          }
        }
      }
      return diff2;
    }
    function createTable(idbtrans, tableName, primKey, indexes) {
      var store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ? { keyPath: primKey.keyPath, autoIncrement: primKey.auto } : { autoIncrement: primKey.auto });
      indexes.forEach(function(idx) {
        return addIndex(store, idx);
      });
      return store;
    }
    function createMissingTables(newSchema, idbtrans) {
      keys$1(newSchema).forEach(function(tableName) {
        if (!idbtrans.db.objectStoreNames.contains(tableName)) {
          createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);
        }
      });
    }
    function deleteRemovedTables(newSchema, idbtrans) {
      [].slice.call(idbtrans.db.objectStoreNames).forEach(function(storeName) {
        return newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName);
      });
    }
    function addIndex(store, idx) {
      store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });
    }
    function buildGlobalSchema(db2, idbdb, tmpTrans) {
      var globalSchema = {};
      var dbStoreNames = slice(idbdb.objectStoreNames, 0);
      dbStoreNames.forEach(function(storeName) {
        var store = tmpTrans.objectStore(storeName);
        var keyPath = store.keyPath;
        var primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || "", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== "string", true);
        var indexes = [];
        for (var j = 0; j < store.indexNames.length; ++j) {
          var idbindex = store.index(store.indexNames[j]);
          keyPath = idbindex.keyPath;
          var index2 = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== "string", false);
          indexes.push(index2);
        }
        globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);
      });
      return globalSchema;
    }
    function readGlobalSchema(_a2, idbdb, tmpTrans) {
      var db2 = _a2._novip;
      db2.verno = idbdb.version / 10;
      var globalSchema = db2._dbSchema = buildGlobalSchema(db2, idbdb, tmpTrans);
      db2._storeNames = slice(idbdb.objectStoreNames, 0);
      setApiOnPlace(db2, [db2._allTables], keys$1(globalSchema), globalSchema);
    }
    function verifyInstalledSchema(db2, tmpTrans) {
      var installedSchema = buildGlobalSchema(db2, db2.idbdb, tmpTrans);
      var diff2 = getSchemaDiff(installedSchema, db2._dbSchema);
      return !(diff2.add.length || diff2.change.some(function(ch2) {
        return ch2.add.length || ch2.change.length;
      }));
    }
    function adjustToExistingIndexNames(_a2, schema, idbtrans) {
      var db2 = _a2._novip;
      var storeNames = idbtrans.db.objectStoreNames;
      for (var i = 0; i < storeNames.length; ++i) {
        var storeName = storeNames[i];
        var store = idbtrans.objectStore(storeName);
        db2._hasGetAll = "getAll" in store;
        for (var j = 0; j < store.indexNames.length; ++j) {
          var indexName = store.indexNames[j];
          var keyPath = store.index(indexName).keyPath;
          var dexieName = typeof keyPath === "string" ? keyPath : "[" + slice(keyPath).join("+") + "]";
          if (schema[storeName]) {
            var indexSpec = schema[storeName].idxByName[dexieName];
            if (indexSpec) {
              indexSpec.name = indexName;
              delete schema[storeName].idxByName[dexieName];
              schema[storeName].idxByName[indexName] = indexSpec;
            }
          }
        }
      }
      if (typeof navigator !== "undefined" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) {
        db2._hasGetAll = false;
      }
    }
    function parseIndexSyntax(primKeyAndIndexes) {
      return primKeyAndIndexes.split(",").map(function(index2, indexNum) {
        index2 = index2.trim();
        var name = index2.replace(/([&*]|\+\+)/g, "");
        var keyPath = /^\[/.test(name) ? name.match(/^\[(.*)\]$/)[1].split("+") : name;
        return createIndexSpec(name, keyPath || null, /\&/.test(index2), /\*/.test(index2), /\+\+/.test(index2), isArray$1(keyPath), indexNum === 0);
      });
    }
    var Version = function() {
      function Version2() {
      }
      Version2.prototype._parseStoresSpec = function(stores2, outSchema) {
        keys$1(stores2).forEach(function(tableName) {
          if (stores2[tableName] !== null) {
            var indexes = parseIndexSyntax(stores2[tableName]);
            var primKey = indexes.shift();
            if (primKey.multi)
              throw new exceptions.Schema("Primary key cannot be multi-valued");
            indexes.forEach(function(idx) {
              if (idx.auto)
                throw new exceptions.Schema("Only primary key can be marked as autoIncrement (++)");
              if (!idx.keyPath)
                throw new exceptions.Schema("Index must have a name and cannot be an empty string");
            });
            outSchema[tableName] = createTableSchema(tableName, primKey, indexes);
          }
        });
      };
      Version2.prototype.stores = function(stores2) {
        var db2 = this.db;
        this._cfg.storesSource = this._cfg.storesSource ? extend$1(this._cfg.storesSource, stores2) : stores2;
        var versions = db2._versions;
        var storesSpec = {};
        var dbschema = {};
        versions.forEach(function(version) {
          extend$1(storesSpec, version._cfg.storesSource);
          dbschema = version._cfg.dbschema = {};
          version._parseStoresSpec(storesSpec, dbschema);
        });
        db2._dbSchema = dbschema;
        removeTablesApi(db2, [db2._allTables, db2, db2.Transaction.prototype]);
        setApiOnPlace(db2, [db2._allTables, db2, db2.Transaction.prototype, this._cfg.tables], keys$1(dbschema), dbschema);
        db2._storeNames = keys$1(dbschema);
        return this;
      };
      Version2.prototype.upgrade = function(upgradeFunction) {
        this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);
        return this;
      };
      return Version2;
    }();
    function createVersionConstructor(db2) {
      return makeClassConstructor(Version.prototype, function Version2(versionNumber) {
        this.db = db2;
        this._cfg = {
          version: versionNumber,
          storesSource: null,
          dbschema: {},
          tables: {},
          contentUpgrade: null
        };
      });
    }
    function getDbNamesTable(indexedDB2, IDBKeyRange) {
      var dbNamesDB = indexedDB2["_dbNamesDB"];
      if (!dbNamesDB) {
        dbNamesDB = indexedDB2["_dbNamesDB"] = new Dexie$1(DBNAMES_DB, {
          addons: [],
          indexedDB: indexedDB2,
          IDBKeyRange
        });
        dbNamesDB.version(1).stores({ dbnames: "name" });
      }
      return dbNamesDB.table("dbnames");
    }
    function hasDatabasesNative(indexedDB2) {
      return indexedDB2 && typeof indexedDB2.databases === "function";
    }
    function getDatabaseNames(_a2) {
      var indexedDB2 = _a2.indexedDB, IDBKeyRange = _a2.IDBKeyRange;
      return hasDatabasesNative(indexedDB2) ? Promise.resolve(indexedDB2.databases()).then(function(infos) {
        return infos.map(function(info) {
          return info.name;
        }).filter(function(name) {
          return name !== DBNAMES_DB;
        });
      }) : getDbNamesTable(indexedDB2, IDBKeyRange).toCollection().primaryKeys();
    }
    function _onDatabaseCreated(_a2, name) {
      var indexedDB2 = _a2.indexedDB, IDBKeyRange = _a2.IDBKeyRange;
      !hasDatabasesNative(indexedDB2) && name !== DBNAMES_DB && getDbNamesTable(indexedDB2, IDBKeyRange).put({ name }).catch(nop);
    }
    function _onDatabaseDeleted(_a2, name) {
      var indexedDB2 = _a2.indexedDB, IDBKeyRange = _a2.IDBKeyRange;
      !hasDatabasesNative(indexedDB2) && name !== DBNAMES_DB && getDbNamesTable(indexedDB2, IDBKeyRange).delete(name).catch(nop);
    }
    function vip(fn) {
      return newScope(function() {
        PSD.letThrough = true;
        return fn();
      });
    }
    function idbReady() {
      var isSafari = !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent);
      if (!isSafari || !indexedDB.databases)
        return Promise.resolve();
      var intervalId;
      return new Promise(function(resolve) {
        var tryIdb = function() {
          return indexedDB.databases().finally(resolve);
        };
        intervalId = setInterval(tryIdb, 100);
        tryIdb();
      }).finally(function() {
        return clearInterval(intervalId);
      });
    }
    function dexieOpen(db2) {
      var state = db2._state;
      var indexedDB2 = db2._deps.indexedDB;
      if (state.isBeingOpened || db2.idbdb)
        return state.dbReadyPromise.then(function() {
          return state.dbOpenError ? rejection(state.dbOpenError) : db2;
        });
      debug && (state.openCanceller._stackHolder = getErrorWithStack());
      state.isBeingOpened = true;
      state.dbOpenError = null;
      state.openComplete = false;
      var openCanceller = state.openCanceller;
      function throwIfCancelled() {
        if (state.openCanceller !== openCanceller)
          throw new exceptions.DatabaseClosed("db.open() was cancelled");
      }
      var resolveDbReady = state.dbReadyResolve, upgradeTransaction = null, wasCreated = false;
      return DexiePromise.race([openCanceller, (typeof navigator === "undefined" ? DexiePromise.resolve() : idbReady()).then(function() {
        return new DexiePromise(function(resolve, reject) {
          throwIfCancelled();
          if (!indexedDB2)
            throw new exceptions.MissingAPI();
          var dbName = db2.name;
          var req = state.autoSchema ? indexedDB2.open(dbName) : indexedDB2.open(dbName, Math.round(db2.verno * 10));
          if (!req)
            throw new exceptions.MissingAPI();
          req.onerror = eventRejectHandler(reject);
          req.onblocked = wrap(db2._fireOnBlocked);
          req.onupgradeneeded = wrap(function(e2) {
            upgradeTransaction = req.transaction;
            if (state.autoSchema && !db2._options.allowEmptyDB) {
              req.onerror = preventDefault;
              upgradeTransaction.abort();
              req.result.close();
              var delreq = indexedDB2.deleteDatabase(dbName);
              delreq.onsuccess = delreq.onerror = wrap(function() {
                reject(new exceptions.NoSuchDatabase("Database " + dbName + " doesnt exist"));
              });
            } else {
              upgradeTransaction.onerror = eventRejectHandler(reject);
              var oldVer = e2.oldVersion > Math.pow(2, 62) ? 0 : e2.oldVersion;
              wasCreated = oldVer < 1;
              db2._novip.idbdb = req.result;
              runUpgraders(db2, oldVer / 10, upgradeTransaction, reject);
            }
          }, reject);
          req.onsuccess = wrap(function() {
            upgradeTransaction = null;
            var idbdb = db2._novip.idbdb = req.result;
            var objectStoreNames = slice(idbdb.objectStoreNames);
            if (objectStoreNames.length > 0)
              try {
                var tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), "readonly");
                if (state.autoSchema)
                  readGlobalSchema(db2, idbdb, tmpTrans);
                else {
                  adjustToExistingIndexNames(db2, db2._dbSchema, tmpTrans);
                  if (!verifyInstalledSchema(db2, tmpTrans)) {
                    console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.");
                  }
                }
                generateMiddlewareStacks(db2, tmpTrans);
              } catch (e2) {
              }
            connections.push(db2);
            idbdb.onversionchange = wrap(function(ev) {
              state.vcFired = true;
              db2.on("versionchange").fire(ev);
            });
            idbdb.onclose = wrap(function(ev) {
              db2.on("close").fire(ev);
            });
            if (wasCreated)
              _onDatabaseCreated(db2._deps, dbName);
            resolve();
          }, reject);
        });
      })]).then(function() {
        throwIfCancelled();
        state.onReadyBeingFired = [];
        return DexiePromise.resolve(vip(function() {
          return db2.on.ready.fire(db2.vip);
        })).then(function fireRemainders() {
          if (state.onReadyBeingFired.length > 0) {
            var remainders_1 = state.onReadyBeingFired.reduce(promisableChain, nop);
            state.onReadyBeingFired = [];
            return DexiePromise.resolve(vip(function() {
              return remainders_1(db2.vip);
            })).then(fireRemainders);
          }
        });
      }).finally(function() {
        state.onReadyBeingFired = null;
        state.isBeingOpened = false;
      }).then(function() {
        return db2;
      }).catch(function(err) {
        state.dbOpenError = err;
        try {
          upgradeTransaction && upgradeTransaction.abort();
        } catch (_a2) {
        }
        if (openCanceller === state.openCanceller) {
          db2._close();
        }
        return rejection(err);
      }).finally(function() {
        state.openComplete = true;
        resolveDbReady();
      });
    }
    function awaitIterator(iterator) {
      var callNext = function(result) {
        return iterator.next(result);
      }, doThrow = function(error) {
        return iterator.throw(error);
      }, onSuccess = step(callNext), onError = step(doThrow);
      function step(getNext) {
        return function(val) {
          var next2 = getNext(val), value = next2.value;
          return next2.done ? value : !value || typeof value.then !== "function" ? isArray$1(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) : value.then(onSuccess, onError);
        };
      }
      return step(callNext)();
    }
    function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {
      var i = arguments.length;
      if (i < 2)
        throw new exceptions.InvalidArgument("Too few arguments");
      var args = new Array(i - 1);
      while (--i)
        args[i - 1] = arguments[i];
      scopeFunc = args.pop();
      var tables = flatten(args);
      return [mode, tables, scopeFunc];
    }
    function enterTransactionScope(db2, mode, storeNames, parentTransaction, scopeFunc) {
      return DexiePromise.resolve().then(function() {
        var transless = PSD.transless || PSD;
        var trans = db2._createTransaction(mode, storeNames, db2._dbSchema, parentTransaction);
        var zoneProps = {
          trans,
          transless
        };
        if (parentTransaction) {
          trans.idbtrans = parentTransaction.idbtrans;
        } else {
          try {
            trans.create();
            db2._state.PR1398_maxLoop = 3;
          } catch (ex) {
            if (ex.name === errnames.InvalidState && db2.isOpen() && --db2._state.PR1398_maxLoop > 0) {
              console.warn("Dexie: Need to reopen db");
              db2._close();
              return db2.open().then(function() {
                return enterTransactionScope(db2, mode, storeNames, null, scopeFunc);
              });
            }
            return rejection(ex);
          }
        }
        var scopeFuncIsAsync = isAsyncFunction(scopeFunc);
        if (scopeFuncIsAsync) {
          incrementExpectedAwaits();
        }
        var returnValue;
        var promiseFollowed = DexiePromise.follow(function() {
          returnValue = scopeFunc.call(trans, trans);
          if (returnValue) {
            if (scopeFuncIsAsync) {
              var decrementor = decrementExpectedAwaits.bind(null, null);
              returnValue.then(decrementor, decrementor);
            } else if (typeof returnValue.next === "function" && typeof returnValue.throw === "function") {
              returnValue = awaitIterator(returnValue);
            }
          }
        }, zoneProps);
        return (returnValue && typeof returnValue.then === "function" ? DexiePromise.resolve(returnValue).then(function(x2) {
          return trans.active ? x2 : rejection(new exceptions.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
        }) : promiseFollowed.then(function() {
          return returnValue;
        })).then(function(x2) {
          if (parentTransaction)
            trans._resolve();
          return trans._completion.then(function() {
            return x2;
          });
        }).catch(function(e2) {
          trans._reject(e2);
          return rejection(e2);
        });
      });
    }
    function pad$1(a, value, count) {
      var result = isArray$1(a) ? a.slice() : [a];
      for (var i = 0; i < count; ++i)
        result.push(value);
      return result;
    }
    function createVirtualIndexMiddleware(down) {
      return __assign(__assign({}, down), { table: function(tableName) {
        var table = down.table(tableName);
        var schema = table.schema;
        var indexLookup = {};
        var allVirtualIndexes = [];
        function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {
          var keyPathAlias = getKeyPathAlias(keyPath);
          var indexList = indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || [];
          var keyLength = keyPath == null ? 0 : typeof keyPath === "string" ? 1 : keyPath.length;
          var isVirtual = keyTail > 0;
          var virtualIndex = __assign(__assign({}, lowLevelIndex), { isVirtual, keyTail, keyLength, extractKey: getKeyExtractor(keyPath), unique: !isVirtual && lowLevelIndex.unique });
          indexList.push(virtualIndex);
          if (!virtualIndex.isPrimaryKey) {
            allVirtualIndexes.push(virtualIndex);
          }
          if (keyLength > 1) {
            var virtualKeyPath = keyLength === 2 ? keyPath[0] : keyPath.slice(0, keyLength - 1);
            addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);
          }
          indexList.sort(function(a, b2) {
            return a.keyTail - b2.keyTail;
          });
          return virtualIndex;
        }
        var primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);
        indexLookup[":id"] = [primaryKey];
        for (var _i = 0, _a2 = schema.indexes; _i < _a2.length; _i++) {
          var index2 = _a2[_i];
          addVirtualIndexes(index2.keyPath, 0, index2);
        }
        function findBestIndex(keyPath) {
          var result2 = indexLookup[getKeyPathAlias(keyPath)];
          return result2 && result2[0];
        }
        function translateRange(range, keyTail) {
          return {
            type: range.type === 1 ? 2 : range.type,
            lower: pad$1(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),
            lowerOpen: true,
            upper: pad$1(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),
            upperOpen: true
          };
        }
        function translateRequest(req) {
          var index3 = req.query.index;
          return index3.isVirtual ? __assign(__assign({}, req), { query: {
            index: index3,
            range: translateRange(req.query.range, index3.keyTail)
          } }) : req;
        }
        var result = __assign(__assign({}, table), { schema: __assign(__assign({}, schema), { primaryKey, indexes: allVirtualIndexes, getIndexByKeyPath: findBestIndex }), count: function(req) {
          return table.count(translateRequest(req));
        }, query: function(req) {
          return table.query(translateRequest(req));
        }, openCursor: function(req) {
          var _a3 = req.query.index, keyTail = _a3.keyTail, isVirtual = _a3.isVirtual, keyLength = _a3.keyLength;
          if (!isVirtual)
            return table.openCursor(req);
          function createVirtualCursor(cursor2) {
            function _continue(key) {
              key != null ? cursor2.continue(pad$1(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) : req.unique ? cursor2.continue(cursor2.key.slice(0, keyLength).concat(req.reverse ? down.MIN_KEY : down.MAX_KEY, keyTail)) : cursor2.continue();
            }
            var virtualCursor = Object.create(cursor2, {
              continue: { value: _continue },
              continuePrimaryKey: {
                value: function(key, primaryKey2) {
                  cursor2.continuePrimaryKey(pad$1(key, down.MAX_KEY, keyTail), primaryKey2);
                }
              },
              primaryKey: {
                get: function() {
                  return cursor2.primaryKey;
                }
              },
              key: {
                get: function() {
                  var key = cursor2.key;
                  return keyLength === 1 ? key[0] : key.slice(0, keyLength);
                }
              },
              value: {
                get: function() {
                  return cursor2.value;
                }
              }
            });
            return virtualCursor;
          }
          return table.openCursor(translateRequest(req)).then(function(cursor2) {
            return cursor2 && createVirtualCursor(cursor2);
          });
        } });
        return result;
      } });
    }
    var virtualIndexMiddleware = {
      stack: "dbcore",
      name: "VirtualIndexMiddleware",
      level: 1,
      create: createVirtualIndexMiddleware
    };
    function getObjectDiff(a, b2, rv, prfx) {
      rv = rv || {};
      prfx = prfx || "";
      keys$1(a).forEach(function(prop) {
        if (!hasOwn(b2, prop)) {
          rv[prfx + prop] = void 0;
        } else {
          var ap = a[prop], bp = b2[prop];
          if (typeof ap === "object" && typeof bp === "object" && ap && bp) {
            var apTypeName = toStringTag(ap);
            var bpTypeName = toStringTag(bp);
            if (apTypeName !== bpTypeName) {
              rv[prfx + prop] = b2[prop];
            } else if (apTypeName === "Object") {
              getObjectDiff(ap, bp, rv, prfx + prop + ".");
            } else if (ap !== bp) {
              rv[prfx + prop] = b2[prop];
            }
          } else if (ap !== bp)
            rv[prfx + prop] = b2[prop];
        }
      });
      keys$1(b2).forEach(function(prop) {
        if (!hasOwn(a, prop)) {
          rv[prfx + prop] = b2[prop];
        }
      });
      return rv;
    }
    function getEffectiveKeys(primaryKey, req) {
      if (req.type === "delete")
        return req.keys;
      return req.keys || req.values.map(primaryKey.extractKey);
    }
    var hooksMiddleware = {
      stack: "dbcore",
      name: "HooksMiddleware",
      level: 2,
      create: function(downCore) {
        return __assign(__assign({}, downCore), { table: function(tableName) {
          var downTable = downCore.table(tableName);
          var primaryKey = downTable.schema.primaryKey;
          var tableMiddleware = __assign(__assign({}, downTable), { mutate: function(req) {
            var dxTrans = PSD.trans;
            var _a2 = dxTrans.table(tableName).hook, deleting = _a2.deleting, creating = _a2.creating, updating = _a2.updating;
            switch (req.type) {
              case "add":
                if (creating.fire === nop)
                  break;
                return dxTrans._promise("readwrite", function() {
                  return addPutOrDelete(req);
                }, true);
              case "put":
                if (creating.fire === nop && updating.fire === nop)
                  break;
                return dxTrans._promise("readwrite", function() {
                  return addPutOrDelete(req);
                }, true);
              case "delete":
                if (deleting.fire === nop)
                  break;
                return dxTrans._promise("readwrite", function() {
                  return addPutOrDelete(req);
                }, true);
              case "deleteRange":
                if (deleting.fire === nop)
                  break;
                return dxTrans._promise("readwrite", function() {
                  return deleteRange(req);
                }, true);
            }
            return downTable.mutate(req);
            function addPutOrDelete(req2) {
              var dxTrans2 = PSD.trans;
              var keys2 = req2.keys || getEffectiveKeys(primaryKey, req2);
              if (!keys2)
                throw new Error("Keys missing");
              req2 = req2.type === "add" || req2.type === "put" ? __assign(__assign({}, req2), { keys: keys2 }) : __assign({}, req2);
              if (req2.type !== "delete")
                req2.values = __spreadArray([], req2.values, true);
              if (req2.keys)
                req2.keys = __spreadArray([], req2.keys, true);
              return getExistingValues(downTable, req2, keys2).then(function(existingValues) {
                var contexts = keys2.map(function(key, i) {
                  var existingValue = existingValues[i];
                  var ctx = { onerror: null, onsuccess: null };
                  if (req2.type === "delete") {
                    deleting.fire.call(ctx, key, existingValue, dxTrans2);
                  } else if (req2.type === "add" || existingValue === void 0) {
                    var generatedPrimaryKey = creating.fire.call(ctx, key, req2.values[i], dxTrans2);
                    if (key == null && generatedPrimaryKey != null) {
                      key = generatedPrimaryKey;
                      req2.keys[i] = key;
                      if (!primaryKey.outbound) {
                        setByKeyPath(req2.values[i], primaryKey.keyPath, key);
                      }
                    }
                  } else {
                    var objectDiff = getObjectDiff(existingValue, req2.values[i]);
                    var additionalChanges_1 = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans2);
                    if (additionalChanges_1) {
                      var requestedValue_1 = req2.values[i];
                      Object.keys(additionalChanges_1).forEach(function(keyPath) {
                        if (hasOwn(requestedValue_1, keyPath)) {
                          requestedValue_1[keyPath] = additionalChanges_1[keyPath];
                        } else {
                          setByKeyPath(requestedValue_1, keyPath, additionalChanges_1[keyPath]);
                        }
                      });
                    }
                  }
                  return ctx;
                });
                return downTable.mutate(req2).then(function(_a3) {
                  var failures = _a3.failures, results = _a3.results, numFailures = _a3.numFailures, lastResult = _a3.lastResult;
                  for (var i = 0; i < keys2.length; ++i) {
                    var primKey = results ? results[i] : keys2[i];
                    var ctx = contexts[i];
                    if (primKey == null) {
                      ctx.onerror && ctx.onerror(failures[i]);
                    } else {
                      ctx.onsuccess && ctx.onsuccess(
                        req2.type === "put" && existingValues[i] ? req2.values[i] : primKey
                      );
                    }
                  }
                  return { failures, results, numFailures, lastResult };
                }).catch(function(error) {
                  contexts.forEach(function(ctx) {
                    return ctx.onerror && ctx.onerror(error);
                  });
                  return Promise.reject(error);
                });
              });
            }
            function deleteRange(req2) {
              return deleteNextChunk(req2.trans, req2.range, 1e4);
            }
            function deleteNextChunk(trans, range, limit) {
              return downTable.query({ trans, values: false, query: { index: primaryKey, range }, limit }).then(function(_a3) {
                var result = _a3.result;
                return addPutOrDelete({ type: "delete", keys: result, trans }).then(function(res) {
                  if (res.numFailures > 0)
                    return Promise.reject(res.failures[0]);
                  if (result.length < limit) {
                    return { failures: [], numFailures: 0, lastResult: void 0 };
                  } else {
                    return deleteNextChunk(trans, __assign(__assign({}, range), { lower: result[result.length - 1], lowerOpen: true }), limit);
                  }
                });
              });
            }
          } });
          return tableMiddleware;
        } });
      }
    };
    function getExistingValues(table, req, effectiveKeys) {
      return req.type === "add" ? Promise.resolve([]) : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: "immutable" });
    }
    function getFromTransactionCache(keys2, cache, clone2) {
      try {
        if (!cache)
          return null;
        if (cache.keys.length < keys2.length)
          return null;
        var result = [];
        for (var i = 0, j = 0; i < cache.keys.length && j < keys2.length; ++i) {
          if (cmp(cache.keys[i], keys2[j]) !== 0)
            continue;
          result.push(clone2 ? deepClone(cache.values[i]) : cache.values[i]);
          ++j;
        }
        return result.length === keys2.length ? result : null;
      } catch (_a2) {
        return null;
      }
    }
    var cacheExistingValuesMiddleware = {
      stack: "dbcore",
      level: -1,
      create: function(core) {
        return {
          table: function(tableName) {
            var table = core.table(tableName);
            return __assign(__assign({}, table), { getMany: function(req) {
              if (!req.cache) {
                return table.getMany(req);
              }
              var cachedResult = getFromTransactionCache(req.keys, req.trans["_cache"], req.cache === "clone");
              if (cachedResult) {
                return DexiePromise.resolve(cachedResult);
              }
              return table.getMany(req).then(function(res) {
                req.trans["_cache"] = {
                  keys: req.keys,
                  values: req.cache === "clone" ? deepClone(res) : res
                };
                return res;
              });
            }, mutate: function(req) {
              if (req.type !== "add")
                req.trans["_cache"] = null;
              return table.mutate(req);
            } });
          }
        };
      }
    };
    var _a;
    function isEmptyRange(node2) {
      return !("from" in node2);
    }
    var RangeSet = function(fromOrTree, to2) {
      if (this) {
        extend$1(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to2 : fromOrTree } : { d: 0 });
      } else {
        var rv = new RangeSet();
        if (fromOrTree && "d" in fromOrTree) {
          extend$1(rv, fromOrTree);
        }
        return rv;
      }
    };
    props(RangeSet.prototype, (_a = {
      add: function(rangeSet) {
        mergeRanges(this, rangeSet);
        return this;
      },
      addKey: function(key) {
        addRange(this, key, key);
        return this;
      },
      addKeys: function(keys2) {
        var _this = this;
        keys2.forEach(function(key) {
          return addRange(_this, key, key);
        });
        return this;
      }
    }, _a[iteratorSymbol] = function() {
      return getRangeSetIterator(this);
    }, _a));
    function addRange(target, from2, to2) {
      var diff2 = cmp(from2, to2);
      if (isNaN(diff2))
        return;
      if (diff2 > 0)
        throw RangeError();
      if (isEmptyRange(target))
        return extend$1(target, { from: from2, to: to2, d: 1 });
      var left2 = target.l;
      var right2 = target.r;
      if (cmp(to2, target.from) < 0) {
        left2 ? addRange(left2, from2, to2) : target.l = { from: from2, to: to2, d: 1, l: null, r: null };
        return rebalance(target);
      }
      if (cmp(from2, target.to) > 0) {
        right2 ? addRange(right2, from2, to2) : target.r = { from: from2, to: to2, d: 1, l: null, r: null };
        return rebalance(target);
      }
      if (cmp(from2, target.from) < 0) {
        target.from = from2;
        target.l = null;
        target.d = right2 ? right2.d + 1 : 1;
      }
      if (cmp(to2, target.to) > 0) {
        target.to = to2;
        target.r = null;
        target.d = target.l ? target.l.d + 1 : 1;
      }
      var rightWasCutOff = !target.r;
      if (left2 && !target.l) {
        mergeRanges(target, left2);
      }
      if (right2 && rightWasCutOff) {
        mergeRanges(target, right2);
      }
    }
    function mergeRanges(target, newSet) {
      function _addRangeSet(target2, _a2) {
        var from2 = _a2.from, to2 = _a2.to, l2 = _a2.l, r2 = _a2.r;
        addRange(target2, from2, to2);
        if (l2)
          _addRangeSet(target2, l2);
        if (r2)
          _addRangeSet(target2, r2);
      }
      if (!isEmptyRange(newSet))
        _addRangeSet(target, newSet);
    }
    function rangesOverlap(rangeSet1, rangeSet2) {
      var i1 = getRangeSetIterator(rangeSet2);
      var nextResult1 = i1.next();
      if (nextResult1.done)
        return false;
      var a = nextResult1.value;
      var i2 = getRangeSetIterator(rangeSet1);
      var nextResult2 = i2.next(a.from);
      var b2 = nextResult2.value;
      while (!nextResult1.done && !nextResult2.done) {
        if (cmp(b2.from, a.to) <= 0 && cmp(b2.to, a.from) >= 0)
          return true;
        cmp(a.from, b2.from) < 0 ? a = (nextResult1 = i1.next(b2.from)).value : b2 = (nextResult2 = i2.next(a.from)).value;
      }
      return false;
    }
    function getRangeSetIterator(node2) {
      var state = isEmptyRange(node2) ? null : { s: 0, n: node2 };
      return {
        next: function(key) {
          var keyProvided = arguments.length > 0;
          while (state) {
            switch (state.s) {
              case 0:
                state.s = 1;
                if (keyProvided) {
                  while (state.n.l && cmp(key, state.n.from) < 0)
                    state = { up: state, n: state.n.l, s: 1 };
                } else {
                  while (state.n.l)
                    state = { up: state, n: state.n.l, s: 1 };
                }
              case 1:
                state.s = 2;
                if (!keyProvided || cmp(key, state.n.to) <= 0)
                  return { value: state.n, done: false };
              case 2:
                if (state.n.r) {
                  state.s = 3;
                  state = { up: state, n: state.n.r, s: 0 };
                  continue;
                }
              case 3:
                state = state.up;
            }
          }
          return { done: true };
        }
      };
    }
    function rebalance(target) {
      var _a2, _b;
      var diff2 = (((_a2 = target.r) === null || _a2 === void 0 ? void 0 : _a2.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);
      var r2 = diff2 > 1 ? "r" : diff2 < -1 ? "l" : "";
      if (r2) {
        var l2 = r2 === "r" ? "l" : "r";
        var rootClone = __assign({}, target);
        var oldRootRight = target[r2];
        target.from = oldRootRight.from;
        target.to = oldRootRight.to;
        target[r2] = oldRootRight[r2];
        rootClone[r2] = oldRootRight[l2];
        target[l2] = rootClone;
        rootClone.d = computeDepth(rootClone);
      }
      target.d = computeDepth(target);
    }
    function computeDepth(_a2) {
      var r2 = _a2.r, l2 = _a2.l;
      return (r2 ? l2 ? Math.max(r2.d, l2.d) : r2.d : l2 ? l2.d : 0) + 1;
    }
    var observabilityMiddleware = {
      stack: "dbcore",
      level: 0,
      create: function(core) {
        var dbName = core.schema.name;
        var FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);
        return __assign(__assign({}, core), { table: function(tableName) {
          var table = core.table(tableName);
          var schema = table.schema;
          var primaryKey = schema.primaryKey;
          var extractKey = primaryKey.extractKey, outbound = primaryKey.outbound;
          var tableClone = __assign(__assign({}, table), { mutate: function(req) {
            var trans = req.trans;
            var mutatedParts = trans.mutatedParts || (trans.mutatedParts = {});
            var getRangeSet = function(indexName) {
              var part = "idb://" + dbName + "/" + tableName + "/" + indexName;
              return mutatedParts[part] || (mutatedParts[part] = new RangeSet());
            };
            var pkRangeSet = getRangeSet("");
            var delsRangeSet = getRangeSet(":dels");
            var type2 = req.type;
            var _a2 = req.type === "deleteRange" ? [req.range] : req.type === "delete" ? [req.keys] : req.values.length < 50 ? [[], req.values] : [], keys2 = _a2[0], newObjs = _a2[1];
            var oldCache = req.trans["_cache"];
            return table.mutate(req).then(function(res) {
              if (isArray$1(keys2)) {
                if (type2 !== "delete")
                  keys2 = res.results;
                pkRangeSet.addKeys(keys2);
                var oldObjs = getFromTransactionCache(keys2, oldCache);
                if (!oldObjs && type2 !== "add") {
                  delsRangeSet.addKeys(keys2);
                }
                if (oldObjs || newObjs) {
                  trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);
                }
              } else if (keys2) {
                var range = { from: keys2.lower, to: keys2.upper };
                delsRangeSet.add(range);
                pkRangeSet.add(range);
              } else {
                pkRangeSet.add(FULL_RANGE);
                delsRangeSet.add(FULL_RANGE);
                schema.indexes.forEach(function(idx) {
                  return getRangeSet(idx.name).add(FULL_RANGE);
                });
              }
              return res;
            });
          } });
          var getRange = function(_a2) {
            var _b, _c;
            var _d = _a2.query, index2 = _d.index, range = _d.range;
            return [
              index2,
              new RangeSet((_b = range.lower) !== null && _b !== void 0 ? _b : core.MIN_KEY, (_c = range.upper) !== null && _c !== void 0 ? _c : core.MAX_KEY)
            ];
          };
          var readSubscribers = {
            get: function(req) {
              return [primaryKey, new RangeSet(req.key)];
            },
            getMany: function(req) {
              return [primaryKey, new RangeSet().addKeys(req.keys)];
            },
            count: getRange,
            query: getRange,
            openCursor: getRange
          };
          keys$1(readSubscribers).forEach(function(method2) {
            tableClone[method2] = function(req) {
              var subscr = PSD.subscr;
              if (subscr) {
                var getRangeSet = function(indexName) {
                  var part = "idb://" + dbName + "/" + tableName + "/" + indexName;
                  return subscr[part] || (subscr[part] = new RangeSet());
                };
                var pkRangeSet_1 = getRangeSet("");
                var delsRangeSet_1 = getRangeSet(":dels");
                var _a2 = readSubscribers[method2](req), queriedIndex = _a2[0], queriedRanges = _a2[1];
                getRangeSet(queriedIndex.name || "").add(queriedRanges);
                if (!queriedIndex.isPrimaryKey) {
                  if (method2 === "count") {
                    delsRangeSet_1.add(FULL_RANGE);
                  } else {
                    var keysPromise_1 = method2 === "query" && outbound && req.values && table.query(__assign(__assign({}, req), { values: false }));
                    return table[method2].apply(this, arguments).then(function(res) {
                      if (method2 === "query") {
                        if (outbound && req.values) {
                          return keysPromise_1.then(function(_a3) {
                            var resultingKeys = _a3.result;
                            pkRangeSet_1.addKeys(resultingKeys);
                            return res;
                          });
                        }
                        var pKeys = req.values ? res.result.map(extractKey) : res.result;
                        if (req.values) {
                          pkRangeSet_1.addKeys(pKeys);
                        } else {
                          delsRangeSet_1.addKeys(pKeys);
                        }
                      } else if (method2 === "openCursor") {
                        var cursor_1 = res;
                        var wantValues_1 = req.values;
                        return cursor_1 && Object.create(cursor_1, {
                          key: {
                            get: function() {
                              delsRangeSet_1.addKey(cursor_1.primaryKey);
                              return cursor_1.key;
                            }
                          },
                          primaryKey: {
                            get: function() {
                              var pkey = cursor_1.primaryKey;
                              delsRangeSet_1.addKey(pkey);
                              return pkey;
                            }
                          },
                          value: {
                            get: function() {
                              wantValues_1 && pkRangeSet_1.addKey(cursor_1.primaryKey);
                              return cursor_1.value;
                            }
                          }
                        });
                      }
                      return res;
                    });
                  }
                }
              }
              return table[method2].apply(this, arguments);
            };
          });
          return tableClone;
        } });
      }
    };
    function trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {
      function addAffectedIndex(ix) {
        var rangeSet = getRangeSet(ix.name || "");
        function extractKey(obj) {
          return obj != null ? ix.extractKey(obj) : null;
        }
        var addKeyOrKeys = function(key) {
          return ix.multiEntry && isArray$1(key) ? key.forEach(function(key2) {
            return rangeSet.addKey(key2);
          }) : rangeSet.addKey(key);
        };
        (oldObjs || newObjs).forEach(function(_2, i) {
          var oldKey = oldObjs && extractKey(oldObjs[i]);
          var newKey = newObjs && extractKey(newObjs[i]);
          if (cmp(oldKey, newKey) !== 0) {
            if (oldKey != null)
              addKeyOrKeys(oldKey);
            if (newKey != null)
              addKeyOrKeys(newKey);
          }
        });
      }
      schema.indexes.forEach(addAffectedIndex);
    }
    var Dexie$1 = function() {
      function Dexie2(name, options) {
        var _this = this;
        this._middlewares = {};
        this.verno = 0;
        var deps = Dexie2.dependencies;
        this._options = options = __assign({
          addons: Dexie2.addons,
          autoOpen: true,
          indexedDB: deps.indexedDB,
          IDBKeyRange: deps.IDBKeyRange
        }, options);
        this._deps = {
          indexedDB: options.indexedDB,
          IDBKeyRange: options.IDBKeyRange
        };
        var addons = options.addons;
        this._dbSchema = {};
        this._versions = [];
        this._storeNames = [];
        this._allTables = {};
        this.idbdb = null;
        this._novip = this;
        var state = {
          dbOpenError: null,
          isBeingOpened: false,
          onReadyBeingFired: null,
          openComplete: false,
          dbReadyResolve: nop,
          dbReadyPromise: null,
          cancelOpen: nop,
          openCanceller: null,
          autoSchema: true,
          PR1398_maxLoop: 3
        };
        state.dbReadyPromise = new DexiePromise(function(resolve) {
          state.dbReadyResolve = resolve;
        });
        state.openCanceller = new DexiePromise(function(_2, reject) {
          state.cancelOpen = reject;
        });
        this._state = state;
        this.name = name;
        this.on = Events(this, "populate", "blocked", "versionchange", "close", { ready: [promisableChain, nop] });
        this.on.ready.subscribe = override(this.on.ready.subscribe, function(subscribe) {
          return function(subscriber, bSticky) {
            Dexie2.vip(function() {
              var state2 = _this._state;
              if (state2.openComplete) {
                if (!state2.dbOpenError)
                  DexiePromise.resolve().then(subscriber);
                if (bSticky)
                  subscribe(subscriber);
              } else if (state2.onReadyBeingFired) {
                state2.onReadyBeingFired.push(subscriber);
                if (bSticky)
                  subscribe(subscriber);
              } else {
                subscribe(subscriber);
                var db_1 = _this;
                if (!bSticky)
                  subscribe(function unsubscribe() {
                    db_1.on.ready.unsubscribe(subscriber);
                    db_1.on.ready.unsubscribe(unsubscribe);
                  });
              }
            });
          };
        });
        this.Collection = createCollectionConstructor(this);
        this.Table = createTableConstructor(this);
        this.Transaction = createTransactionConstructor(this);
        this.Version = createVersionConstructor(this);
        this.WhereClause = createWhereClauseConstructor(this);
        this.on("versionchange", function(ev) {
          if (ev.newVersion > 0)
            console.warn("Another connection wants to upgrade database '" + _this.name + "'. Closing db now to resume the upgrade.");
          else
            console.warn("Another connection wants to delete database '" + _this.name + "'. Closing db now to resume the delete request.");
          _this.close();
        });
        this.on("blocked", function(ev) {
          if (!ev.newVersion || ev.newVersion < ev.oldVersion)
            console.warn("Dexie.delete('" + _this.name + "') was blocked");
          else
            console.warn("Upgrade '" + _this.name + "' blocked by other connection holding version " + ev.oldVersion / 10);
        });
        this._maxKey = getMaxKey(options.IDBKeyRange);
        this._createTransaction = function(mode, storeNames, dbschema, parentTransaction) {
          return new _this.Transaction(mode, storeNames, dbschema, _this._options.chromeTransactionDurability, parentTransaction);
        };
        this._fireOnBlocked = function(ev) {
          _this.on("blocked").fire(ev);
          connections.filter(function(c2) {
            return c2.name === _this.name && c2 !== _this && !c2._state.vcFired;
          }).map(function(c2) {
            return c2.on("versionchange").fire(ev);
          });
        };
        this.use(virtualIndexMiddleware);
        this.use(hooksMiddleware);
        this.use(observabilityMiddleware);
        this.use(cacheExistingValuesMiddleware);
        this.vip = Object.create(this, { _vip: { value: true } });
        addons.forEach(function(addon) {
          return addon(_this);
        });
      }
      Dexie2.prototype.version = function(versionNumber) {
        if (isNaN(versionNumber) || versionNumber < 0.1)
          throw new exceptions.Type("Given version is not a positive number");
        versionNumber = Math.round(versionNumber * 10) / 10;
        if (this.idbdb || this._state.isBeingOpened)
          throw new exceptions.Schema("Cannot add version when database is open");
        this.verno = Math.max(this.verno, versionNumber);
        var versions = this._versions;
        var versionInstance = versions.filter(function(v2) {
          return v2._cfg.version === versionNumber;
        })[0];
        if (versionInstance)
          return versionInstance;
        versionInstance = new this.Version(versionNumber);
        versions.push(versionInstance);
        versions.sort(lowerVersionFirst);
        versionInstance.stores({});
        this._state.autoSchema = false;
        return versionInstance;
      };
      Dexie2.prototype._whenReady = function(fn) {
        var _this = this;
        return this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip) ? fn() : new DexiePromise(function(resolve, reject) {
          if (_this._state.openComplete) {
            return reject(new exceptions.DatabaseClosed(_this._state.dbOpenError));
          }
          if (!_this._state.isBeingOpened) {
            if (!_this._options.autoOpen) {
              reject(new exceptions.DatabaseClosed());
              return;
            }
            _this.open().catch(nop);
          }
          _this._state.dbReadyPromise.then(resolve, reject);
        }).then(fn);
      };
      Dexie2.prototype.use = function(_a2) {
        var stack = _a2.stack, create = _a2.create, level = _a2.level, name = _a2.name;
        if (name)
          this.unuse({ stack, name });
        var middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);
        middlewares.push({ stack, create, level: level == null ? 10 : level, name });
        middlewares.sort(function(a, b2) {
          return a.level - b2.level;
        });
        return this;
      };
      Dexie2.prototype.unuse = function(_a2) {
        var stack = _a2.stack, name = _a2.name, create = _a2.create;
        if (stack && this._middlewares[stack]) {
          this._middlewares[stack] = this._middlewares[stack].filter(function(mw) {
            return create ? mw.create !== create : name ? mw.name !== name : false;
          });
        }
        return this;
      };
      Dexie2.prototype.open = function() {
        return dexieOpen(this);
      };
      Dexie2.prototype._close = function() {
        var state = this._state;
        var idx = connections.indexOf(this);
        if (idx >= 0)
          connections.splice(idx, 1);
        if (this.idbdb) {
          try {
            this.idbdb.close();
          } catch (e2) {
          }
          this._novip.idbdb = null;
        }
        state.dbReadyPromise = new DexiePromise(function(resolve) {
          state.dbReadyResolve = resolve;
        });
        state.openCanceller = new DexiePromise(function(_2, reject) {
          state.cancelOpen = reject;
        });
      };
      Dexie2.prototype.close = function() {
        this._close();
        var state = this._state;
        this._options.autoOpen = false;
        state.dbOpenError = new exceptions.DatabaseClosed();
        if (state.isBeingOpened)
          state.cancelOpen(state.dbOpenError);
      };
      Dexie2.prototype.delete = function() {
        var _this = this;
        var hasArguments = arguments.length > 0;
        var state = this._state;
        return new DexiePromise(function(resolve, reject) {
          var doDelete = function() {
            _this.close();
            var req = _this._deps.indexedDB.deleteDatabase(_this.name);
            req.onsuccess = wrap(function() {
              _onDatabaseDeleted(_this._deps, _this.name);
              resolve();
            });
            req.onerror = eventRejectHandler(reject);
            req.onblocked = _this._fireOnBlocked;
          };
          if (hasArguments)
            throw new exceptions.InvalidArgument("Arguments not allowed in db.delete()");
          if (state.isBeingOpened) {
            state.dbReadyPromise.then(doDelete);
          } else {
            doDelete();
          }
        });
      };
      Dexie2.prototype.backendDB = function() {
        return this.idbdb;
      };
      Dexie2.prototype.isOpen = function() {
        return this.idbdb !== null;
      };
      Dexie2.prototype.hasBeenClosed = function() {
        var dbOpenError = this._state.dbOpenError;
        return dbOpenError && dbOpenError.name === "DatabaseClosed";
      };
      Dexie2.prototype.hasFailed = function() {
        return this._state.dbOpenError !== null;
      };
      Dexie2.prototype.dynamicallyOpened = function() {
        return this._state.autoSchema;
      };
      Object.defineProperty(Dexie2.prototype, "tables", {
        get: function() {
          var _this = this;
          return keys$1(this._allTables).map(function(name) {
            return _this._allTables[name];
          });
        },
        enumerable: false,
        configurable: true
      });
      Dexie2.prototype.transaction = function() {
        var args = extractTransactionArgs.apply(this, arguments);
        return this._transaction.apply(this, args);
      };
      Dexie2.prototype._transaction = function(mode, tables, scopeFunc) {
        var _this = this;
        var parentTransaction = PSD.trans;
        if (!parentTransaction || parentTransaction.db !== this || mode.indexOf("!") !== -1)
          parentTransaction = null;
        var onlyIfCompatible = mode.indexOf("?") !== -1;
        mode = mode.replace("!", "").replace("?", "");
        var idbMode, storeNames;
        try {
          storeNames = tables.map(function(table) {
            var storeName = table instanceof _this.Table ? table.name : table;
            if (typeof storeName !== "string")
              throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
            return storeName;
          });
          if (mode == "r" || mode === READONLY)
            idbMode = READONLY;
          else if (mode == "rw" || mode == READWRITE)
            idbMode = READWRITE;
          else
            throw new exceptions.InvalidArgument("Invalid transaction mode: " + mode);
          if (parentTransaction) {
            if (parentTransaction.mode === READONLY && idbMode === READWRITE) {
              if (onlyIfCompatible) {
                parentTransaction = null;
              } else
                throw new exceptions.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
            }
            if (parentTransaction) {
              storeNames.forEach(function(storeName) {
                if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {
                  if (onlyIfCompatible) {
                    parentTransaction = null;
                  } else
                    throw new exceptions.SubTransaction("Table " + storeName + " not included in parent transaction.");
                }
              });
            }
            if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {
              parentTransaction = null;
            }
          }
        } catch (e2) {
          return parentTransaction ? parentTransaction._promise(null, function(_2, reject) {
            reject(e2);
          }) : rejection(e2);
        }
        var enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);
        return parentTransaction ? parentTransaction._promise(idbMode, enterTransaction, "lock") : PSD.trans ? usePSD(PSD.transless, function() {
          return _this._whenReady(enterTransaction);
        }) : this._whenReady(enterTransaction);
      };
      Dexie2.prototype.table = function(tableName) {
        if (!hasOwn(this._allTables, tableName)) {
          throw new exceptions.InvalidTable("Table " + tableName + " does not exist");
        }
        return this._allTables[tableName];
      };
      return Dexie2;
    }();
    var symbolObservable = typeof Symbol !== "undefined" && "observable" in Symbol ? Symbol.observable : "@@observable";
    var Observable = function() {
      function Observable2(subscribe) {
        this._subscribe = subscribe;
      }
      Observable2.prototype.subscribe = function(x2, error, complete) {
        return this._subscribe(!x2 || typeof x2 === "function" ? { next: x2, error, complete } : x2);
      };
      Observable2.prototype[symbolObservable] = function() {
        return this;
      };
      return Observable2;
    }();
    function extendObservabilitySet(target, newSet) {
      keys$1(newSet).forEach(function(part) {
        var rangeSet = target[part] || (target[part] = new RangeSet());
        mergeRanges(rangeSet, newSet[part]);
      });
      return target;
    }
    function liveQuery(querier) {
      return new Observable(function(observer) {
        var scopeFuncIsAsync = isAsyncFunction(querier);
        function execute(subscr) {
          if (scopeFuncIsAsync) {
            incrementExpectedAwaits();
          }
          var exec = function() {
            return newScope(querier, { subscr, trans: null });
          };
          var rv = PSD.trans ? usePSD(PSD.transless, exec) : exec();
          if (scopeFuncIsAsync) {
            rv.then(decrementExpectedAwaits, decrementExpectedAwaits);
          }
          return rv;
        }
        var closed = false;
        var accumMuts = {};
        var currentObs = {};
        var subscription = {
          get closed() {
            return closed;
          },
          unsubscribe: function() {
            closed = true;
            globalEvents.storagemutated.unsubscribe(mutationListener);
          }
        };
        observer.start && observer.start(subscription);
        var querying = false, startedListening = false;
        function shouldNotify() {
          return keys$1(currentObs).some(function(key) {
            return accumMuts[key] && rangesOverlap(accumMuts[key], currentObs[key]);
          });
        }
        var mutationListener = function(parts) {
          extendObservabilitySet(accumMuts, parts);
          if (shouldNotify()) {
            doQuery();
          }
        };
        var doQuery = function() {
          if (querying || closed)
            return;
          accumMuts = {};
          var subscr = {};
          var ret = execute(subscr);
          if (!startedListening) {
            globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);
            startedListening = true;
          }
          querying = true;
          Promise.resolve(ret).then(function(result) {
            querying = false;
            if (closed)
              return;
            if (shouldNotify()) {
              doQuery();
            } else {
              accumMuts = {};
              currentObs = subscr;
              observer.next && observer.next(result);
            }
          }, function(err) {
            querying = false;
            observer.error && observer.error(err);
            subscription.unsubscribe();
          });
        };
        doQuery();
        return subscription;
      });
    }
    var domDeps;
    try {
      domDeps = {
        indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,
        IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange
      };
    } catch (e2) {
      domDeps = { indexedDB: null, IDBKeyRange: null };
    }
    var Dexie = Dexie$1;
    props(Dexie, __assign(__assign({}, fullNameExceptions), {
      delete: function(databaseName) {
        var db2 = new Dexie(databaseName, { addons: [] });
        return db2.delete();
      },
      exists: function(name) {
        return new Dexie(name, { addons: [] }).open().then(function(db2) {
          db2.close();
          return true;
        }).catch("NoSuchDatabaseError", function() {
          return false;
        });
      },
      getDatabaseNames: function(cb2) {
        try {
          return getDatabaseNames(Dexie.dependencies).then(cb2);
        } catch (_a2) {
          return rejection(new exceptions.MissingAPI());
        }
      },
      defineClass: function() {
        function Class(content) {
          extend$1(this, content);
        }
        return Class;
      },
      ignoreTransaction: function(scopeFunc) {
        return PSD.trans ? usePSD(PSD.transless, scopeFunc) : scopeFunc();
      },
      vip,
      async: function(generatorFn) {
        return function() {
          try {
            var rv = awaitIterator(generatorFn.apply(this, arguments));
            if (!rv || typeof rv.then !== "function")
              return DexiePromise.resolve(rv);
            return rv;
          } catch (e2) {
            return rejection(e2);
          }
        };
      },
      spawn: function(generatorFn, args, thiz) {
        try {
          var rv = awaitIterator(generatorFn.apply(thiz, args || []));
          if (!rv || typeof rv.then !== "function")
            return DexiePromise.resolve(rv);
          return rv;
        } catch (e2) {
          return rejection(e2);
        }
      },
      currentTransaction: {
        get: function() {
          return PSD.trans || null;
        }
      },
      waitFor: function(promiseOrFunction, optionalTimeout) {
        var promise = DexiePromise.resolve(typeof promiseOrFunction === "function" ? Dexie.ignoreTransaction(promiseOrFunction) : promiseOrFunction).timeout(optionalTimeout || 6e4);
        return PSD.trans ? PSD.trans.waitFor(promise) : promise;
      },
      Promise: DexiePromise,
      debug: {
        get: function() {
          return debug;
        },
        set: function(value) {
          setDebug(value, value === "dexie" ? function() {
            return true;
          } : dexieStackFrameFilter);
        }
      },
      derive,
      extend: extend$1,
      props,
      override,
      Events,
      on: globalEvents,
      liveQuery,
      extendObservabilitySet,
      getByKeyPath,
      setByKeyPath,
      delByKeyPath,
      shallowClone,
      deepClone,
      getObjectDiff,
      cmp,
      asap: asap$1,
      minKey,
      addons: [],
      connections,
      errnames,
      dependencies: domDeps,
      semVer: DEXIE_VERSION,
      version: DEXIE_VERSION.split(".").map(function(n2) {
        return parseInt(n2);
      }).reduce(function(p2, c2, i) {
        return p2 + c2 / Math.pow(10, i * 2);
      })
    }));
    Dexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);
    if (typeof dispatchEvent !== "undefined" && typeof addEventListener !== "undefined") {
      globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function(updatedParts) {
        if (!propagatingLocally) {
          var event_1;
          if (isIEOrEdge) {
            event_1 = document.createEvent("CustomEvent");
            event_1.initCustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, true, true, updatedParts);
          } else {
            event_1 = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {
              detail: updatedParts
            });
          }
          propagatingLocally = true;
          dispatchEvent(event_1);
          propagatingLocally = false;
        }
      });
      addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, function(_a2) {
        var detail = _a2.detail;
        if (!propagatingLocally) {
          propagateLocally(detail);
        }
      });
    }
    function propagateLocally(updateParts) {
      var wasMe = propagatingLocally;
      try {
        propagatingLocally = true;
        globalEvents.storagemutated.fire(updateParts);
      } finally {
        propagatingLocally = wasMe;
      }
    }
    var propagatingLocally = false;
    if (typeof BroadcastChannel !== "undefined") {
      var bc_1 = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);
      globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function(changedParts) {
        if (!propagatingLocally) {
          bc_1.postMessage(changedParts);
        }
      });
      bc_1.onmessage = function(ev) {
        if (ev.data)
          propagateLocally(ev.data);
      };
    } else if (typeof self !== "undefined" && typeof navigator !== "undefined") {
      globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function(changedParts) {
        try {
          if (!propagatingLocally) {
            if (typeof localStorage !== "undefined") {
              localStorage.setItem(STORAGE_MUTATED_DOM_EVENT_NAME, JSON.stringify({
                trig: Math.random(),
                changedParts
              }));
            }
            if (typeof self["clients"] === "object") {
              __spreadArray([], self["clients"].matchAll({ includeUncontrolled: true }), true).forEach(function(client2) {
                return client2.postMessage({
                  type: STORAGE_MUTATED_DOM_EVENT_NAME,
                  changedParts
                });
              });
            }
          }
        } catch (_a2) {
        }
      });
      if (typeof addEventListener !== "undefined") {
        addEventListener("storage", function(ev) {
          if (ev.key === STORAGE_MUTATED_DOM_EVENT_NAME) {
            var data = JSON.parse(ev.newValue);
            if (data)
              propagateLocally(data.changedParts);
          }
        });
      }
      var swContainer = self.document && navigator.serviceWorker;
      if (swContainer) {
        swContainer.addEventListener("message", propagateMessageLocally);
      }
    }
    function propagateMessageLocally(_a2) {
      var data = _a2.data;
      if (data && data.type === STORAGE_MUTATED_DOM_EVENT_NAME) {
        propagateLocally(data.changedParts);
      }
    }
    DexiePromise.rejectionMapper = mapError;
    setDebug(debug, dexieStackFrameFilter);
    const stores = [
      { storeName: "Personal", sincronizeAsk: true, definition: "++id,dni,nombres_apellidos,rol,idplanilla,idempresa" },
      { storeName: "PuntoAcceso", sincronizeAsk: true, definition: "++id,id_idpuntoacceso,descripcion" },
      { storeName: "Usuario", sincronizeAsk: true, definition: "++id,dni,nombres_apellidos,usuario,clave,idresponsable,idempresa" },
      { storeName: "Turno", sincronizeAsk: true, definition: "++id,id_turno,descripcion" },
      { storeName: "consumidoresMaquinaria", sincronizeAsk: true, definition: "++cod,id,descripcion,idempresa", indexes: ["[idempresa]"] },
      { storeName: "Maquinarias", sincronizeAsk: true, definition: "++cod,id,descripcion,costoha_mof,costo_mof,idempresa" },
      { storeName: "Jirones", sincronizeAsk: true, definition: "++cod,id,descripcion" },
      { storeName: "Cuarteles", sincronizeAsk: true, definition: "++cod,id,descripcion" },
      { storeName: "Proveedores", sincronizeAsk: true, definition: "++cod,ID,DESCRIPCION", indexes: ["[DESCRIPCION]"] },
      { storeName: "Actividades", sincronizeAsk: true, definition: "++cod,id,descripcion" },
      { storeName: "Labores", sincronizeAsk: true, definition: "++cod,ID,DESCRIPCION,IDACTIVIDAD" },
      { storeName: "Areas", sincronizeAsk: true, definition: "++cod,id,descripcion" },
      { storeName: "Operarios", sincronizeAsk: true, definition: "++cod,id,descripcion,idempresa" },
      { storeName: "Implementos", sincronizeAsk: true, definition: "++cod,id,descripcion,idempresa" },
      { storeName: "Combustibles", sincronizeAsk: true, definition: "++cod,id,descripcion,idmedida,idempresa" },
      {
        storeName: "AC_PARTEMAQUINARIA",
        sincronizeAsk: false,
        definition: "++cod,IDPARTEMAQ,IDCLIEPROV,PROVEEDOR,IDDOCUMENTO,IDCONSUMIDORMAQUINARIA,MAQUINA,OPERARIO,IDOPERARIO,HORAS_TRAB,HORAS_TRAB1,TURNO,IDTURNOTRABAJO,TOTAL_COSTO,FORMAPAGO,TOTALAREA_TRAB,AREA,IDAREA,COSTO_HORA,IDUSUARIO,ESTADO,FECHA,HORAINICIO,HORAFINAL,HOROMETROINICIAL,HOROMETROFINAL,GLOSA,IDCONSUMIDORIMPLEMENTO,DESCIMPLEMENTO,DESCCONSUMIDOR,idempresa",
        indexes: [
          "[FECHA+IDCONSUMIDORMAQUINARIA+ESTADO+idempresa]",
          "[FECHA+ESTADO+idempresa]"
        ]
      },
      {
        storeName: "AC_DPARTEMAQUINARIA",
        sincronizeAsk: false,
        definition: "++cod,IDPARTEMAQ,ITEM,IDCONSUMIDOR,DESCRIPCION,AREA_TRAB,HORAINICIO,HORAFINAL,HOROMETROINICIAL,HOROMETROFINAL,HORAS_TRAB,HORAS_TRAB1,COSTO_HORA,IDACTIVIDAD,IDLABOR,HOROMETRO_DIFERENCIA,DSC_LABOR,COSTO_TOTAL,IDCUARTEL,IDJIRON,DESCJIRON,DESCCUARTEL",
        indexes: ["[IDPARTEMAQ]"]
      },
      {
        storeName: "AC_COMBUSTIBLE",
        sincronizeAsk: false,
        definition: "++cod,IDPARTEMAQ,ITEM,IDCOMBUSTIBLE,DESCRIPCION,CANTIDAD,IDMEDIDA",
        indexes: ["[IDPARTEMAQ]"]
      }
    ];
    const localDataBaseName = "MaquinariaDatabase";
    const localDataBase = new Dexie$1(localDataBaseName);
    let storesCreated = {};
    stores.forEach((o, i) => {
      var _a2;
      let definition = o.definition;
      if (Boolean(((_a2 = o.indexes) == null ? void 0 : _a2.length) > 0)) {
        definition = `${definition},${o.indexes.toString()}`;
      }
      storesCreated[o.storeName] = definition;
    });
    localDataBase.version(1).stores(storesCreated);
    localDataBase.version(2).stores({
      Implementos: "++cod,id,descripcion"
    });
    localDataBase.version(4).stores({
      AC_PARTEMAQUINARIA: "++cod,IDPARTEMAQ,IDCLIEPROV,PROVEEDOR,IDDOCUMENTO,IDCONSUMIDORMAQUINARIA,MAQUINA,OPERARIO,IDOPERARIO,HORAS_TRAB,HORAS_TRAB1,TURNO,IDTURNOTRABAJO,TOTAL_COSTO,FORMAPAGO,TOTALAREA_TRABAREA,IDAREA,COSTO_HORA,IDUSUARIO,ESTADO,FECHA,HORAINICIO,HORAFINAL,HOROMETROINICIAL,HOROMETROFINAL,GLOSA,IDCONSUMIDORIMPLEMENTO,DESCIMPLEMENTO,DESCCONSUMIDOR,[FECHA+ESTADO],[FECHA+IDCONSUMIDORMAQUINARIA+ESTADO]"
    });
    localDataBase.version(11).stores({
      AC_PARTEMAQUINARIA: "++cod,IDPARTEMAQ,IDCLIEPROV,PROVEEDOR,IDDOCUMENTO,IDCONSUMIDORMAQUINARIA,MAQUINA,OPERARIO,IDOPERARIO,HORAS_TRAB,HORAS_TRAB1,TURNO,IDTURNOTRABAJO,TOTAL_COSTO,FORMAPAGO,TOTALAREA_TRABAREA,IDAREA,COSTO_HORA,IDUSUARIO,ESTADO,FECHA,HORAINICIO,HORAFINAL,HOROMETROINICIAL,HOROMETROFINAL,GLOSA,IDCONSUMIDORIMPLEMENTO,DESCIMPLEMENTO,DESCCONSUMIDOR,idmepresa,[FECHA+ESTADO+idempresa],[FECHA+IDCONSUMIDORMAQUINARIA+ESTADO+idempresa]",
      Combustibles: "++cod,id,descripcion,idmedida,idempresa"
    });
    const logIn = async ({ username }) => {
      const data = await localDataBase.Usuario.where("usuario").equals(username).toArray();
      return data;
    };
    function useAuth() {
      const SESSION_NAME = `${"usuario"}`;
      const CACHE_CULTIVO = `${"ussanidadcultivo"}`;
      const CACHE_EMPRESA = `${"empresa"}`;
      const CACHE_ETAPAFENOLOGICA = `${"ussanidadetapafenologica"}`;
      const { auth, setAuth, empresa, setEmpresa, cultivo, setCultivo, aplicativo, setAplicativo, etapaFenologica, setEtapaFenologica } = react.exports.useContext(Context$1);
      const [stateLoading, setStateLoading] = react.exports.useState({
        isLoading: false,
        error: ""
      });
      react.exports.useEffect(() => {
        if (stateLoading.error !== "") {
          setTimeout(() => {
            setStateLoading({
              ...stateLoading,
              error: ""
            });
          }, 4e3);
        }
      }, [stateLoading.error]);
      const logIn$1 = react.exports.useCallback(({
        username,
        password
      }) => {
        setStateLoading({
          isLoading: true,
          error: ""
        });
        const usernameCase = username.toUpperCase();
        const passwordCoded = md5(password);
        logIn({ username: usernameCase }).then((response) => {
          if (!response.length) {
            setStateLoading({
              isLoading: false,
              error: "No existe este usuario."
            });
            return;
          }
          console.log(response[0]);
          console.log(passwordCoded);
          const usuarioFound = response[0];
          if (usuarioFound.clave !== passwordCoded.toUpperCase()) {
            setStateLoading({
              isLoading: false,
              error: "Clave incorrecta."
            });
            return;
          }
          setStateLoading({
            isLoading: false,
            error: ""
          });
          const usuario = {
            dni_usuario: usuarioFound.dni_usuario,
            usuario: usuarioFound.usuario,
            nombres_apellidos: usuarioFound.nombres_apellidos
          };
          window.localStorage.setItem(SESSION_NAME, JSON.stringify(usuario));
          setAuth(usuario);
        }).catch((err) => {
          if (err) {
            window.localStorage.removeItem(SESSION_NAME);
            setStateLoading({
              isLoading: false,
              error: err.message
            });
            setAuth(null);
          }
        });
      }, [setAuth]);
      const logOut = react.exports.useCallback(() => {
        window.localStorage.removeItem(SESSION_NAME);
        setAuth(null);
      }, [setAuth]);
      const asignarEmpresa = (localEmpresa) => {
        window.localStorage.setItem(CACHE_EMPRESA, localEmpresa);
        setEmpresa(localEmpresa);
      };
      const asignarCultivo = (localCultivo) => {
        window.localStorage.setItem(CACHE_CULTIVO, localCultivo);
        setCultivo(localCultivo);
      };
      const asignarEtapaFenologica = (localEtapaFenologica) => {
        window.localStorage.setItem(CACHE_ETAPAFENOLOGICA, localEtapaFenologica);
        setEtapaFenologica(localEtapaFenologica);
      };
      return {
        empresa,
        asignarEmpresa,
        cultivo,
        asignarCultivo,
        aplicativo,
        setAplicativo,
        isLoggedIn: Boolean(auth),
        user: auth,
        isLoginLoading: stateLoading.isLoading,
        errorLogin: stateLoading.error,
        logIn: logIn$1,
        logOut,
        etapaFenologica,
        asignarEtapaFenologica
      };
    }
    const url_api = "https://69.64.95.68:6061/cayaltiservernisira/controlador/index.php";
    const sincronizeMaquinaria = async () => {
      const formData = new FormData();
      formData.append("empresa", "001");
      formData.append("modelo", "Maquinaria");
      formData.append("metodo", "sincronizarDatos");
      return fetch(url_api, {
        body: formData,
        method: "POST"
      }).then((res) => res.json()).catch((e2) => {
        console.log(e2);
      });
    };
    const registrarMasivo = async ({ data, storeName }) => {
      const res = await localDataBase[storeName].bulkAdd(data);
      return res;
    };
    const clearMasivo = async ({ storeName }) => {
      const res = await localDataBase[storeName].clear();
      return res;
    };
    function useSincronize() {
      const [isLoadingSincroAsk, setIsLoadingSincroAsk] = react.exports.useState(false);
      const [registrosTotales, setRegistrosTotales] = react.exports.useState(0);
      const [registrosActuales, setRegistrosActuales] = react.exports.useState(0);
      const [isOpenDialog, setIsOpenDialog] = react.exports.useState(false);
      const TIEMPO_TRAS_COMPLETAR = 2;
      react.exports.useEffect(() => {
        let timer;
        if (registrosTotales === registrosActuales) {
          timer = setTimeout(() => {
            setIsOpenDialog(false);
          }, TIEMPO_TRAS_COMPLETAR * 1e3);
        }
        return () => {
          clearInterval(timer);
        };
      }, [registrosTotales, registrosActuales]);
      const sincronizeAsk = () => {
        setRegistrosTotales(0);
        setRegistrosActuales(0);
        setIsOpenDialog(true);
        setIsLoadingSincroAsk(true);
        sincronizeMaquinaria().then((respuesta) => {
          var response = respuesta.data;
          setRegistrosTotales(response == null ? void 0 : response.contador_registros);
          stores.forEach((o, i) => {
            if (o.sincronizeAsk === false) {
              return;
            }
            const data = response[o.storeName];
            console.log(data);
            clearMasivo({ storeName: o.storeName }).then(function() {
              if (data && data.length) {
                const cantidadRegistros = data.length;
                registrarMasivo({ data, storeName: o.storeName }).then(function() {
                  setRegistrosActuales((prev2) => {
                    setIsOpenDialog(false);
                    return prev2 + cantidadRegistros;
                  });
                }).catch(Dexie$1.BulkError, function(e2) {
                  console.error(e2.failures);
                });
              }
            }).catch(Dexie$1.DexieError, function(e2) {
              console.error("Error al limpiar store. ", e2);
            });
          });
        }).catch((err) => {
          alert("No se puede conectar con el servidor");
          setIsOpenDialog(false);
        }).finally(() => {
          setIsLoadingSincroAsk(false);
        });
      };
      return {
        isLoadingSincroAsk,
        isOpenDialog,
        registrosTotales,
        registrosActuales,
        sincronizeAsk
      };
    }
    var Sync = {};
    var _interopRequireDefault$d = interopRequireDefault.exports;
    Object.defineProperty(Sync, "__esModule", {
      value: true
    });
    var default_1$d = Sync.default = void 0;
    var _createSvgIcon$d = _interopRequireDefault$d(requireCreateSvgIcon());
    var _jsxRuntime$d = require$$2;
    var _default$d = (0, _createSvgIcon$d.default)(/* @__PURE__ */ (0, _jsxRuntime$d.jsx)("path", {
      d: "M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"
    }), "Sync");
    default_1$d = Sync.default = _default$d;
    const Visibility = createSvgIcon$1(/* @__PURE__ */ jsx("path", {
      d: "M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"
    }), "Visibility");
    const VisibilityOff = createSvgIcon$1(/* @__PURE__ */ jsx("path", {
      d: "M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78 3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"
    }), "VisibilityOff");
    const nameApp$1 = "AppMaquinaria";
    function Login() {
      var _a2, _b;
      const [username, setUsername] = react.exports.useState("");
      const [password, setPassword] = react.exports.useState("");
      const [showPassword, setShowPassword] = react.exports.useState(false);
      const [presionar, setPresionar] = react.exports.useState(false);
      const navigate = useNavigate();
      const location2 = useLocation();
      const from2 = ((_b = (_a2 = location2.state) == null ? void 0 : _a2.from) == null ? void 0 : _b.pathname) || "/home";
      const {
        empresa,
        asignarEmpresa,
        isLoggedIn,
        isLoginLoading,
        errorLogin,
        logIn: logIn2
      } = useAuth();
      const {
        isOpenDialog,
        isLoadingSincroAsk,
        registrosTotales,
        registrosActuales,
        sincronizeAsk
      } = useSincronize();
      react.exports.useEffect(() => {
        if (isLoggedIn) {
          navigate(from2, {
            replace: true
          });
        }
      }, [isLoggedIn]);
      const verContrase\u00F1a = () => {
        setShowPassword(!showPassword);
      };
      const handleSubmit = (e2) => {
        e2.preventDefault();
        logIn2({
          username: username.trim(),
          password: password.trim()
        });
        window.localStorage.setItem("empresa", empresa);
        console.log(empresa);
      };
      const handleMouseDown = (e2) => {
        e2.preventDefault();
      };
      const sincronizar = (e2) => {
        e2.preventDefault();
        sincronizeAsk();
      };
      react.exports.useEffect(() => {
      }, []);
      return /* @__PURE__ */ jsxs(Container$1, {
        maxWidth: "xs",
        children: [/* @__PURE__ */ jsxs(Button$1, {
          variant: "contained",
          size: "small",
          color: "success",
          sx: {
            position: "absolute",
            top: "12px",
            right: "12px",
            fontWeight: "bold"
          },
          onClick: sincronizar,
          children: [/* @__PURE__ */ jsx(default_1$d, {}), "SINCRONIZAR"]
        }), /* @__PURE__ */ jsxs(Box$1, {
          sx: {
            marginTop: 3,
            padding: 4,
            display: "flex",
            flexDirection: "column",
            alignItems: "center"
          },
          children: [/* @__PURE__ */ jsx(Typography$1, {
            component: "h1",
            variant: "h5",
            children: /* @__PURE__ */ jsxs("strong", {
              children: [" ", nameApp$1]
            })
          }), /* @__PURE__ */ jsx(Avatar$1, {
            sx: {
              m: 1,
              width: 192,
              height: 192
            },
            src: empresa === "1" ? LogoCayalti : LogoYarabamba
          }), /* @__PURE__ */ jsxs(Box$1, {
            component: "form",
            onSubmit: handleSubmit,
            noValidate: true,
            sx: {
              mt: 1
            },
            children: [/* @__PURE__ */ jsx(Select$1, {
              id: "select-empresa",
              value: empresa,
              label: "Empresa",
              name: "select-empresa",
              size: "small",
              fullWidth: true,
              onChange: (e2) => {
                asignarEmpresa(e2.target.value);
              },
              children: EMPRESAS.map((empresa2) => {
                return /* @__PURE__ */ jsx(MenuItem$1, {
                  value: empresa2.id,
                  children: empresa2.name
                }, empresa2.id);
              })
            }), /* @__PURE__ */ jsx(TextField$1, {
              margin: "normal",
              required: true,
              fullWidth: true,
              value: username,
              id: "username",
              label: "Usuario",
              name: "username",
              autoComplete: "username",
              autoFocus: true,
              size: "small",
              color: "success",
              onFocus: () => setPresionar(false),
              onChange: (e2) => {
                setUsername(e2.currentTarget.value);
              }
            }), /* @__PURE__ */ jsx(TextField$1, {
              margin: "normal",
              value: password,
              required: true,
              inputProps: {
                pattern: "[0-9]*",
                inputMode: "numeric"
              },
              focused: presionar,
              error: password.length < 8 && presionar == true ? true : false,
              helperText: password.length < 8 && presionar == true ? "Clave debe tener 6 d\xEDgitos" : "",
              fullWidth: true,
              label: "Clave",
              type: showPassword ? "number" : "password",
              id: "password",
              size: "small",
              color: "success",
              onFocus: () => setPresionar(true),
              onChange: (e2) => {
                if (e2.target.value.length >= 0 && e2.target.value.length <= 8) {
                  setPassword(e2.target.value);
                }
              },
              InputProps: {
                endAdornment: /* @__PURE__ */ jsx(InputAdornment$1, {
                  position: "end",
                  children: /* @__PURE__ */ jsx(IconButton$1, {
                    onClick: verContrase\u00F1a,
                    onMouseDown: handleMouseDown,
                    children: showPassword ? /* @__PURE__ */ jsx(VisibilityOff, {
                      color: "white"
                    }) : /* @__PURE__ */ jsx(Visibility, {
                      color: "white"
                    })
                  })
                })
              }
            }), errorLogin !== "" ? /* @__PURE__ */ jsx(Alert$1, {
              variant: "filled",
              severity: "error",
              children: errorLogin
            }) : /* @__PURE__ */ jsx(LoadingButton$1, {
              loading: isLoginLoading,
              text: "INICIANDO...",
              fullWidth: true,
              type: "submit",
              loadingPosition: "start",
              startIcon: /* @__PURE__ */ jsx(default_1$e, {}),
              variant: "contained",
              sx: {
                mt: 3,
                mb: 2,
                background: "#2e7d32"
              },
              children: "INGRESAR"
            })]
          })]
        }), /* @__PURE__ */ jsx(DialogSincronize, {
          isOpen: isOpenDialog,
          isLoadingServer: isLoadingSincroAsk,
          progress: registrosActuales / registrosTotales * 100
        })]
      });
    }
    var Menu = {};
    var _interopRequireDefault$c = interopRequireDefault.exports;
    Object.defineProperty(Menu, "__esModule", {
      value: true
    });
    var default_1$c = Menu.default = void 0;
    var _createSvgIcon$c = _interopRequireDefault$c(requireCreateSvgIcon());
    var _jsxRuntime$c = require$$2;
    var _default$c = (0, _createSvgIcon$c.default)(/* @__PURE__ */ (0, _jsxRuntime$c.jsx)("path", {
      d: "M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"
    }), "Menu");
    default_1$c = Menu.default = _default$c;
    var Agriculture = {};
    var _interopRequireDefault$b = interopRequireDefault.exports;
    Object.defineProperty(Agriculture, "__esModule", {
      value: true
    });
    var default_1$b = Agriculture.default = void 0;
    var _createSvgIcon$b = _interopRequireDefault$b(requireCreateSvgIcon());
    var _jsxRuntime$b = require$$2;
    var _default$b = (0, _createSvgIcon$b.default)([/* @__PURE__ */ (0, _jsxRuntime$b.jsx)("path", {
      d: "M19.5 12c.93 0 1.78.28 2.5.76V8c0-1.1-.9-2-2-2h-6.29l-1.06-1.06 1.41-1.41-.71-.71-3.53 3.53.71.71 1.41-1.41L13 6.71V9c0 1.1-.9 2-2 2h-.54c.95 1.06 1.54 2.46 1.54 4 0 .34-.04.67-.09 1h3.14c.25-2.25 2.14-4 4.45-4z"
    }, "0"), /* @__PURE__ */ (0, _jsxRuntime$b.jsx)("path", {
      d: "M19.5 13c-1.93 0-3.5 1.57-3.5 3.5s1.57 3.5 3.5 3.5 3.5-1.57 3.5-3.5-1.57-3.5-3.5-3.5zm0 5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zM4 9h5c0-1.1-.9-2-2-2H4c-.55 0-1 .45-1 1s.45 1 1 1zm5.83 4.82-.18-.47.93-.35c-.46-1.06-1.28-1.91-2.31-2.43l-.4.89-.46-.21.4-.9C7.26 10.13 6.64 10 6 10c-.53 0-1.04.11-1.52.26l.34.91-.47.18-.35-.93c-1.06.46-1.91 1.28-2.43 2.31l.89.4-.21.46-.9-.4C1.13 13.74 1 14.36 1 15c0 .53.11 1.04.26 1.52l.91-.34.18.47-.93.35c.46 1.06 1.28 1.91 2.31 2.43l.4-.89.46.21-.4.9c.55.22 1.17.35 1.81.35.53 0 1.04-.11 1.52-.26l-.34-.91.47-.18.35.93c1.06-.46 1.91-1.28 2.43-2.31l-.89-.4.21-.46.9.4c.22-.55.35-1.17.35-1.81 0-.53-.11-1.04-.26-1.52l-.91.34zm-2.68 3.95c-1.53.63-3.29-.09-3.92-1.62-.63-1.53.09-3.29 1.62-3.92 1.53-.63 3.29.09 3.92 1.62.64 1.53-.09 3.29-1.62 3.92z"
    }, "1")], "Agriculture");
    default_1$b = Agriculture.default = _default$b;
    var NoteAlt = {};
    var _interopRequireDefault$a = interopRequireDefault.exports;
    Object.defineProperty(NoteAlt, "__esModule", {
      value: true
    });
    var default_1$a = NoteAlt.default = void 0;
    var _createSvgIcon$a = _interopRequireDefault$a(requireCreateSvgIcon());
    var _jsxRuntime$a = require$$2;
    var _default$a = (0, _createSvgIcon$a.default)(/* @__PURE__ */ (0, _jsxRuntime$a.jsx)("path", {
      d: "M19 3h-4.18C14.4 1.84 13.3 1 12 1s-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7-.25c.41 0 .75.34.75.75s-.34.75-.75.75-.75-.34-.75-.75.34-.75.75-.75zM9.1 17H7v-2.14l5.96-5.96 2.12 2.12L9.1 17zm7.75-7.73-1.06 1.06-2.12-2.12 1.06-1.06c.2-.2.51-.2.71 0l1.41 1.41c.2.2.2.51 0 .71z"
    }), "NoteAlt");
    default_1$a = NoteAlt.default = _default$a;
    const Navbar = (props2) => {
      const theme = useTheme();
      const navigate = useNavigate();
      const irMaqPropia = () => {
        navigate("/home");
      };
      const listarEnviados = () => {
        navigate("/listarEnviados");
      };
      return /* @__PURE__ */ jsx(Drawer$1, {
        color: "success",
        open: props2.state,
        onClose: props2.close,
        children: /* @__PURE__ */ jsxs(Box$1, {
          width: theme.spacing(45),
          height: "100%",
          flexDirection: "column",
          children: [/* @__PURE__ */ jsx(List$1, {
            sx: {
              background: "#2e7d32"
            },
            children: /* @__PURE__ */ jsxs(ListItemButton$1, {
              onClick: () => "hola",
              sx: {
                background: "#2e7d32"
              },
              children: [/* @__PURE__ */ jsx(ListItemAvatar$1, {
                children: /* @__PURE__ */ jsx(Avatar$1, {})
              }), /* @__PURE__ */ jsx(ListItemText$1, {
                primary: "APP MAQUINARIA",
                sx: {
                  color: "white"
                }
              })]
            })
          }), /* @__PURE__ */ jsxs(List$1, {
            children: [/* @__PURE__ */ jsxs(ListItemButton$1, {
              onClick: () => irMaqPropia(),
              children: [/* @__PURE__ */ jsx(ListItemIcon$1, {
                children: /* @__PURE__ */ jsx(default_1$b, {})
              }), /* @__PURE__ */ jsx(ListItemText$1, {
                primary: /* @__PURE__ */ jsx(Typography$1, {
                  type: "body2",
                  sx: {
                    fontWeight: "bold"
                  },
                  children: "Parte de Maquinaria"
                })
              })]
            }), /* @__PURE__ */ jsxs(ListItemButton$1, {
              onClick: () => listarEnviados(),
              children: [/* @__PURE__ */ jsx(ListItemIcon$1, {
                children: /* @__PURE__ */ jsx(default_1$a, {})
              }), /* @__PURE__ */ jsx(ListItemText$1, {
                primary: /* @__PURE__ */ jsx(Typography$1, {
                  type: "body2",
                  sx: {
                    fontWeight: "bold"
                  },
                  children: "Partes enviados"
                })
              })]
            })]
          })]
        })
      });
    };
    var ExitToApp = {};
    var _interopRequireDefault$9 = interopRequireDefault.exports;
    Object.defineProperty(ExitToApp, "__esModule", {
      value: true
    });
    var default_1$9 = ExitToApp.default = void 0;
    var _createSvgIcon$9 = _interopRequireDefault$9(requireCreateSvgIcon());
    var _jsxRuntime$9 = require$$2;
    var _default$9 = (0, _createSvgIcon$9.default)(/* @__PURE__ */ (0, _jsxRuntime$9.jsx)("path", {
      d: "M10.09 15.59 11.5 17l5-5-5-5-1.41 1.41L12.67 11H3v2h9.67l-2.58 2.59zM19 3H5c-1.11 0-2 .9-2 2v4h2V5h14v14H5v-4H3v4c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"
    }), "ExitToApp");
    default_1$9 = ExitToApp.default = _default$9;
    var Send = {};
    var _interopRequireDefault$8 = interopRequireDefault.exports;
    Object.defineProperty(Send, "__esModule", {
      value: true
    });
    var default_1$8 = Send.default = void 0;
    var _createSvgIcon$8 = _interopRequireDefault$8(requireCreateSvgIcon());
    var _jsxRuntime$8 = require$$2;
    var _default$8 = (0, _createSvgIcon$8.default)(/* @__PURE__ */ (0, _jsxRuntime$8.jsx)("path", {
      d: "M2.01 21 23 12 2.01 3 2 10l15 2-15 2z"
    }), "Send");
    default_1$8 = Send.default = _default$8;
    var Save = {};
    var _interopRequireDefault$7 = interopRequireDefault.exports;
    Object.defineProperty(Save, "__esModule", {
      value: true
    });
    var default_1$7 = Save.default = void 0;
    var _createSvgIcon$7 = _interopRequireDefault$7(requireCreateSvgIcon());
    var _jsxRuntime$7 = require$$2;
    var _default$7 = (0, _createSvgIcon$7.default)(/* @__PURE__ */ (0, _jsxRuntime$7.jsx)("path", {
      d: "M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"
    }), "Save");
    default_1$7 = Save.default = _default$7;
    const Appbar = (props2) => {
      const [state, setState] = react.exports.useState(false);
      function ElevationScroll(props22) {
        const {
          children,
          window: window2
        } = props22;
        const trigger = useScrollTrigger({
          disableHysteresis: true,
          threshold: 0,
          target: window2 ? window2() : void 0
        });
        return react.exports.cloneElement(children, {
          elevation: trigger ? 4 : 0
        });
      }
      const toggleDrawer = (open) => (event) => {
        if (event.type === "keydown" && (event.key === "Tab" || event.key === "Shift")) {
          return;
        }
        setState(open);
      };
      return /* @__PURE__ */ jsxs(react.exports.Fragment, {
        children: [/* @__PURE__ */ jsx(CssBaseline, {}), /* @__PURE__ */ jsx(ElevationScroll, {
          ...props2,
          children: /* @__PURE__ */ jsx(AppBar$1, {
            sx: {
              flexGrow: 1,
              display: props2.header,
              background: "#2e7d32"
            },
            children: /* @__PURE__ */ jsxs(Toolbar$1, {
              children: [/* @__PURE__ */ jsx(IconButton$1, {
                size: "large",
                edge: "start",
                color: "inherit",
                "aria-label": "menu",
                sx: {
                  mr: 2
                },
                onClick: toggleDrawer(true),
                children: /* @__PURE__ */ jsx(default_1$c, {})
              }), /* @__PURE__ */ jsx(Typography$1, {
                variant: "h6",
                component: "div",
                sx: {
                  flexGrow: 1
                },
                children: props2.nombre
              }), /* @__PURE__ */ jsx(Button$1, {
                color: "inherit",
                endIcon: /* @__PURE__ */ jsx(default_1$9, {}),
                onClick: props2.salir,
                sx: {
                  display: props2.mostrarSalir
                },
                children: "Salir"
              }), /* @__PURE__ */ jsx(Button$1, {
                variant: "contained",
                color: "warning",
                startIcon: /* @__PURE__ */ jsx(default_1$8, {}),
                onClick: props2.enviar,
                sx: {
                  display: props2.mostrarEnviar,
                  borderRadius: 4
                },
                children: "Enviar"
              }), /* @__PURE__ */ jsx(Button$1, {
                sx: {
                  display: props2.mostrarGuardar,
                  borderRadius: 4
                },
                variant: "contained",
                color: "warning",
                onClick: props2.guardar,
                disabled: props2.deshabilitar,
                startIcon: /* @__PURE__ */ jsx(default_1$7, {}),
                children: "Guardar"
              })]
            })
          })
        }), /* @__PURE__ */ jsx(Navbar, {
          state,
          close: toggleDrawer(false)
        })]
      });
    };
    var Add = {};
    var _interopRequireDefault$6 = interopRequireDefault.exports;
    Object.defineProperty(Add, "__esModule", {
      value: true
    });
    var default_1$6 = Add.default = void 0;
    var _createSvgIcon$6 = _interopRequireDefault$6(requireCreateSvgIcon());
    var _jsxRuntime$6 = require$$2;
    var _default$6 = (0, _createSvgIcon$6.default)(/* @__PURE__ */ (0, _jsxRuntime$6.jsx)("path", {
      d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"
    }), "Add");
    default_1$6 = Add.default = _default$6;
    const Loading = (props2) => {
      return /* @__PURE__ */ jsxs(Backdrop$1, {
        open: props2.open,
        sx: {
          zIndex: (theme) => theme.zIndex.modal + 1
        },
        children: [/* @__PURE__ */ jsx(CircularProgress$1, {
          sx: {
            color: "white"
          }
        }), /* @__PURE__ */ jsx("p", {}), /* @__PURE__ */ jsx(Typography$1, {
          sx: {
            color: "white"
          },
          children: props2.label
        })]
      });
    };
    const Autocompletar = (props2) => {
      return /* @__PURE__ */ jsx(Autocomplete$1, {
        sx: {
          display: props2.esconder
        },
        id: "txtAutocomplete",
        getOptionLabel: (option) => option.DESCRIPCION ? option.DESCRIPCION : "",
        options: props2.options,
        value: props2.value,
        disabled: props2.disabled,
        renderInput: (params) => /* @__PURE__ */ jsx(TextField$1, {
          ...params,
          label: props2.label,
          error: props2.error === "",
          size: "small",
          helperText: props2.error === "" ? "Seleccione campo" : ""
        }),
        isOptionEqualToValue: (option, val) => option.DESCRIPCION === val.DESCRIPCION,
        onChange: (event, newValue) => props2.cambiar(event, newValue),
        noOptionsText: "Sin resultado",
        renderOption: (props22, item) => /* @__PURE__ */ react.exports.createElement(Box$1, {
          ...props22,
          key: Math.random(9999)
        }, item.ID + "-" + item.DESCRIPCION)
      });
    };
    var DeleteForever = {};
    var _interopRequireDefault$5 = interopRequireDefault.exports;
    Object.defineProperty(DeleteForever, "__esModule", {
      value: true
    });
    var default_1$5 = DeleteForever.default = void 0;
    var _createSvgIcon$5 = _interopRequireDefault$5(requireCreateSvgIcon());
    var _jsxRuntime$5 = require$$2;
    var _default$5 = (0, _createSvgIcon$5.default)(/* @__PURE__ */ (0, _jsxRuntime$5.jsx)("path", {
      d: "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zm2.46-7.12 1.41-1.41L12 12.59l2.12-2.12 1.41 1.41L13.41 14l2.12 2.12-1.41 1.41L12 15.41l-2.12 2.12-1.41-1.41L10.59 14l-2.13-2.12zM15.5 4l-1-1h-5l-1 1H5v2h14V4z"
    }), "DeleteForever");
    default_1$5 = DeleteForever.default = _default$5;
    var SendToMobile = {};
    var _interopRequireDefault$4 = interopRequireDefault.exports;
    Object.defineProperty(SendToMobile, "__esModule", {
      value: true
    });
    var default_1$4 = SendToMobile.default = void 0;
    var _createSvgIcon$4 = _interopRequireDefault$4(requireCreateSvgIcon());
    var _jsxRuntime$4 = require$$2;
    var _default$4 = (0, _createSvgIcon$4.default)(/* @__PURE__ */ (0, _jsxRuntime$4.jsx)("path", {
      d: "M17 17h2v4c0 1.1-.9 2-2 2H7c-1.1 0-2-.9-2-2V3c0-1.1.9-1.99 2-1.99L17 1c1.1 0 2 .9 2 2v4h-2V6H7v12h10v-1zm5-5-4-4v3h-5v2h5v3l4-4z"
    }), "SendToMobile");
    default_1$4 = SendToMobile.default = _default$4;
    const Dialogs = (props2) => {
      return /* @__PURE__ */ jsxs(Dialog$1, {
        open: props2.open,
        onClose: props2.cerraDialog,
        "aria-labelledby": "alert-dialog-title",
        "aria-describedby": "alert-dialog-description",
        children: [/* @__PURE__ */ jsxs(DialogTitle$1, {
          id: "alert-dialog-title",
          children: [props2.mensaje, /* @__PURE__ */ jsx("p", {}), /* @__PURE__ */ jsxs(TextField$1, {
            id: "txtturno",
            select: true,
            label: "Implemento de terceros",
            size: "small",
            value: props2.implemento,
            sx: {
              width: "100%",
              display: props2.esconder
            },
            onChange: (event, newvalue) => props2.cambiarImplemento(event, newvalue),
            children: [/* @__PURE__ */ jsx(MenuItem$1, {
              value: "1",
              children: /* @__PURE__ */ jsx(Typography$1, {
                fontSize: 12,
                children: "Si"
              })
            }, "1"), /* @__PURE__ */ jsx(MenuItem$1, {
              value: "0",
              children: /* @__PURE__ */ jsx(Typography$1, {
                fontSize: 12,
                children: "No"
              })
            }, "0")]
          }), /* @__PURE__ */ jsx("p", {}), /* @__PURE__ */ jsx(Autocompletar, {
            esconder: props2.esconder,
            label: "Responsable",
            options: props2.responsbles,
            cambiar: (event, newValue) => props2.cambiarResponsable(newValue)
          })]
        }), /* @__PURE__ */ jsxs(DialogActions$1, {
          children: [/* @__PURE__ */ jsx(Button$1, {
            sx: {
              display: props2.display
            },
            onClick: props2.cerrar,
            children: "Cancelar"
          }), /* @__PURE__ */ jsx(Button$1, {
            onClick: props2.aceptar,
            disabled: props2.disabled,
            autoFocus: true,
            children: "Aceptar"
          })]
        })]
      });
    };
    const ListaParteMaq = (props2) => {
      const navigate = useNavigate();
      function itemSeleccionado(cod, cabecera) {
        navigate("/editarParte/" + cod, {
          state: {
            cabecera,
            deshabilitar: false
          }
        });
      }
      return props2.datos != null ? props2.datos.map((item, i) => /* @__PURE__ */ jsxs(Box$1, {
        children: [/* @__PURE__ */ jsxs(ListItem$1, {
          secondaryAction: /* @__PURE__ */ jsx(IconButton$1, {
            edge: "end",
            "aria-label": "delete",
            onClick: () => props2.abrirDialogBorrar(item.cod),
            children: /* @__PURE__ */ jsx(default_1$5, {
              color: "primary",
              sx: {
                color: "red"
              }
            })
          }),
          children: [/* @__PURE__ */ jsx(ListItemAvatar$1, {
            onClick: () => {
              itemSeleccionado(item.cod, item), console.log(item);
            },
            children: /* @__PURE__ */ jsx(default_1$4, {
              color: "warning"
            })
          }, `avatar-${i}`), /* @__PURE__ */ jsx(ListItemText$1, {
            primary: /* @__PURE__ */ jsx(Typography$1, {
              variant: "h1",
              color: "green",
              fontSize: 14,
              children: item.IDDOCUMENTO == "PMA" ? "PARTE DE MAQUINARIA ALQUILADA" : "PARTE DE MAQUINARIA PROPIA"
            }),
            secondary: /* @__PURE__ */ jsxs(React.Fragment, {
              children: [/* @__PURE__ */ jsx(Typography$1, {
                component: "span",
                variant: "body2",
                fontWeight: "bold",
                fontSize: 12,
                children: item.MAQUINA
              }), /* @__PURE__ */ jsx("br", {}), /* @__PURE__ */ jsxs(Typography$1, {
                component: "span",
                variant: "body2",
                fontWeight: "bold",
                fontSize: 12,
                children: ["OPERARIO: ", item.OPERARIO, " || FECHA: ", " " + item.FECHA]
              }), /* @__PURE__ */ jsx("br", {}), /* @__PURE__ */ jsx(Typography$1, {
                component: "span",
                variant: "body2",
                fontWeight: "bold"
              })]
            })
          }, `txt-${i}`)]
        }, `item-${i}`), /* @__PURE__ */ jsx(Divider$1, {
          color: "green"
        })]
      }, i)) : "sin registros";
    };
    function arrayIncludes(array, itemOrItems) {
      if (Array.isArray(itemOrItems)) {
        return itemOrItems.every((item) => array.indexOf(item) !== -1);
      }
      return array.indexOf(itemOrItems) !== -1;
    }
    const onSpaceOrEnter = (innerFn, onFocus) => (event) => {
      if (event.key === "Enter" || event.key === " ") {
        innerFn();
        event.preventDefault();
        event.stopPropagation();
      }
      if (onFocus) {
        onFocus(event);
      }
    };
    function getPickersMonthUtilityClass(slot) {
      return generateUtilityClass("PrivatePickersMonth", slot);
    }
    const pickersMonthClasses = generateUtilityClasses(
      "PrivatePickersMonth",
      ["root", "selected"]
    );
    const _excluded$g = ["disabled", "onSelect", "selected", "value", "tabIndex", "hasFocus", "onFocus", "onBlur"];
    const useUtilityClasses$i = (ownerState) => {
      const {
        classes,
        selected
      } = ownerState;
      const slots = {
        root: ["root", selected && "selected"]
      };
      return composeClasses(slots, getPickersMonthUtilityClass, classes);
    };
    const PickersMonthRoot = styled$1(Typography$1, {
      name: "PrivatePickersMonth",
      slot: "Root",
      overridesResolver: (_2, styles2) => [styles2.root, {
        [`&.${pickersMonthClasses.selected}`]: styles2.selected
      }]
    })(({
      theme
    }) => _extends({
      flex: "1 0 33.33%",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      color: "unset",
      backgroundColor: "transparent",
      border: 0,
      outline: 0
    }, theme.typography.subtitle1, {
      margin: "8px 0",
      height: 36,
      borderRadius: 18,
      cursor: "pointer",
      "&:focus, &:hover": {
        backgroundColor: alpha(theme.palette.action.active, theme.palette.action.hoverOpacity)
      },
      "&:disabled": {
        pointerEvents: "none",
        color: theme.palette.text.secondary
      },
      [`&.${pickersMonthClasses.selected}`]: {
        color: theme.palette.primary.contrastText,
        backgroundColor: theme.palette.primary.main,
        "&:focus, &:hover": {
          backgroundColor: theme.palette.primary.dark
        }
      }
    }));
    const noop$2 = () => {
    };
    const PickersMonth = (props2) => {
      const {
        disabled,
        onSelect,
        selected,
        value,
        tabIndex,
        hasFocus,
        onFocus = noop$2,
        onBlur = noop$2
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$g);
      const classes = useUtilityClasses$i(props2);
      const handleSelection = () => {
        onSelect(value);
      };
      const ref = react.exports.useRef(null);
      useEnhancedEffect$1(() => {
        if (hasFocus) {
          var _ref$current;
          (_ref$current = ref.current) == null ? void 0 : _ref$current.focus();
        }
      }, [hasFocus]);
      return /* @__PURE__ */ jsx(PickersMonthRoot, _extends({
        ref,
        component: "button",
        type: "button",
        className: classes.root,
        tabIndex,
        onClick: handleSelection,
        onKeyDown: onSpaceOrEnter(handleSelection),
        color: selected ? "primary" : void 0,
        variant: selected ? "h5" : "subtitle1",
        disabled,
        onFocus: (event) => onFocus(event, value),
        onBlur: (event) => onBlur(event, value)
      }, other));
    };
    const getPickersLocalization = (pickersTranslations) => {
      return {
        components: {
          MuiLocalizationProvider: {
            defaultProps: {
              localeText: _extends({}, pickersTranslations)
            }
          }
        }
      };
    };
    const enUSPickers = {
      previousMonth: "Previous month",
      nextMonth: "Next month",
      openPreviousView: "open previous view",
      openNextView: "open next view",
      calendarViewSwitchingButtonAriaLabel: (view) => view === "year" ? "year view is open, switch to calendar view" : "calendar view is open, switch to year view",
      inputModeToggleButtonAriaLabel: (isKeyboardInputOpen, viewType) => isKeyboardInputOpen ? `text input view is open, go to ${viewType} view` : `${viewType} view is open, go to text input view`,
      start: "Start",
      end: "End",
      cancelButtonLabel: "Cancel",
      clearButtonLabel: "Clear",
      okButtonLabel: "OK",
      todayButtonLabel: "Today",
      datePickerDefaultToolbarTitle: "Select date",
      dateTimePickerDefaultToolbarTitle: "Select date & time",
      timePickerDefaultToolbarTitle: "Select time",
      dateRangePickerDefaultToolbarTitle: "Select date range",
      clockLabelText: (view, time, adapter) => `Select ${view}. ${time === null ? "No time selected" : `Selected time is ${adapter.format(time, "fullTime")}`}`,
      hoursClockNumberText: (hours2) => `${hours2} hours`,
      minutesClockNumberText: (minutes2) => `${minutes2} minutes`,
      secondsClockNumberText: (seconds2) => `${seconds2} seconds`,
      openDatePickerDialogue: (rawValue, utils2) => rawValue && utils2.isValid(utils2.date(rawValue)) ? `Choose date, selected date is ${utils2.format(utils2.date(rawValue), "fullDate")}` : "Choose date",
      openTimePickerDialogue: (rawValue, utils2) => rawValue && utils2.isValid(utils2.date(rawValue)) ? `Choose time, selected time is ${utils2.format(utils2.date(rawValue), "fullTime")}` : "Choose time",
      timeTableLabel: "pick time",
      dateTableLabel: "pick date"
    };
    const DEFAULT_LOCALE = enUSPickers;
    getPickersLocalization(enUSPickers);
    const MuiPickersAdapterContext = /* @__PURE__ */ react.exports.createContext(null);
    function LocalizationProvider(inProps) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiLocalizationProvider"
      });
      const {
        children,
        dateAdapter: Utils,
        dateFormats,
        dateLibInstance,
        locale: locale2,
        adapterLocale,
        localeText
      } = props2;
      const utils2 = react.exports.useMemo(() => new Utils({
        locale: adapterLocale != null ? adapterLocale : locale2,
        formats: dateFormats,
        instance: dateLibInstance
      }), [Utils, locale2, adapterLocale, dateFormats, dateLibInstance]);
      const defaultDates = react.exports.useMemo(() => {
        return {
          minDate: utils2.date("1900-01-01T00:00:00.000"),
          maxDate: utils2.date("2099-12-31T00:00:00.000")
        };
      }, [utils2]);
      const contextValue = react.exports.useMemo(() => {
        return {
          utils: utils2,
          defaultDates,
          localeText: _extends({}, DEFAULT_LOCALE, localeText != null ? localeText : {})
        };
      }, [defaultDates, utils2, localeText]);
      return /* @__PURE__ */ jsx(MuiPickersAdapterContext.Provider, {
        value: contextValue,
        children
      });
    }
    const useLocalizationContext = () => {
      const localization = react.exports.useContext(MuiPickersAdapterContext);
      if (localization === null) {
        throw new Error("MUI: Can not find utils in context. It looks like you forgot to wrap your component in LocalizationProvider, or pass dateAdapter prop directly.");
      }
      return localization;
    };
    const useUtils = () => useLocalizationContext().utils;
    const useDefaultDates = () => useLocalizationContext().defaultDates;
    const useLocaleText = () => useLocalizationContext().localeText;
    const useNow = () => {
      const utils2 = useUtils();
      const now2 = react.exports.useRef(utils2.date());
      return now2.current;
    };
    function getMonthPickerUtilityClass(slot) {
      return generateUtilityClass("MuiMonthPicker", slot);
    }
    generateUtilityClasses("MuiMonthPicker", ["root"]);
    const findClosestEnabledDate = ({
      date,
      disableFuture,
      disablePast,
      maxDate,
      minDate,
      isDateDisabled,
      utils: utils2
    }) => {
      const today = utils2.startOfDay(utils2.date());
      if (disablePast && utils2.isBefore(minDate, today)) {
        minDate = today;
      }
      if (disableFuture && utils2.isAfter(maxDate, today)) {
        maxDate = today;
      }
      let forward = date;
      let backward = date;
      if (utils2.isBefore(date, minDate)) {
        forward = utils2.date(minDate);
        backward = null;
      }
      if (utils2.isAfter(date, maxDate)) {
        if (backward) {
          backward = utils2.date(maxDate);
        }
        forward = null;
      }
      while (forward || backward) {
        if (forward && utils2.isAfter(forward, maxDate)) {
          forward = null;
        }
        if (backward && utils2.isBefore(backward, minDate)) {
          backward = null;
        }
        if (forward) {
          if (!isDateDisabled(forward)) {
            return forward;
          }
          forward = utils2.addDays(forward, 1);
        }
        if (backward) {
          if (!isDateDisabled(backward)) {
            return backward;
          }
          backward = utils2.addDays(backward, -1);
        }
      }
      return null;
    };
    const parsePickerInputValue = (utils2, value) => {
      const parsedValue = utils2.date(value);
      return utils2.isValid(parsedValue) ? parsedValue : null;
    };
    const parseNonNullablePickerDate = (utils2, value, defaultValue) => {
      if (value == null) {
        return defaultValue;
      }
      const parsedValue = utils2.date(value);
      const isDateValid = utils2.isValid(parsedValue);
      if (isDateValid) {
        return parsedValue;
      }
      return defaultValue;
    };
    const _excluded$f = ["className", "date", "disabled", "disableFuture", "disablePast", "maxDate", "minDate", "onChange", "shouldDisableMonth", "readOnly", "disableHighlightToday", "autoFocus", "onMonthFocus", "hasFocus", "onFocusedViewChange"];
    const useUtilityClasses$h = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"]
      };
      return composeClasses(slots, getMonthPickerUtilityClass, classes);
    };
    function useMonthPickerDefaultizedProps(props2, name) {
      const utils2 = useUtils();
      const defaultDates = useDefaultDates();
      const themeProps = useThemeProps({
        props: props2,
        name
      });
      return _extends({
        disableFuture: false,
        disablePast: false
      }, themeProps, {
        minDate: parseNonNullablePickerDate(utils2, themeProps.minDate, defaultDates.minDate),
        maxDate: parseNonNullablePickerDate(utils2, themeProps.maxDate, defaultDates.maxDate)
      });
    }
    const MonthPickerRoot = styled$1("div", {
      name: "MuiMonthPicker",
      slot: "Root",
      overridesResolver: (props2, styles2) => styles2.root
    })({
      width: 310,
      display: "flex",
      flexWrap: "wrap",
      alignContent: "stretch",
      margin: "0 4px"
    });
    const MonthPicker = /* @__PURE__ */ react.exports.forwardRef(function MonthPicker2(inProps, ref) {
      const utils2 = useUtils();
      const now2 = useNow();
      const props2 = useMonthPickerDefaultizedProps(inProps, "MuiMonthPicker");
      const {
        className,
        date,
        disabled,
        disableFuture,
        disablePast,
        maxDate,
        minDate,
        onChange,
        shouldDisableMonth,
        readOnly,
        disableHighlightToday,
        autoFocus = false,
        onMonthFocus,
        hasFocus,
        onFocusedViewChange
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$f);
      const ownerState = props2;
      const classes = useUtilityClasses$h(ownerState);
      const theme = useTheme$1();
      const selectedDateOrToday = date != null ? date : now2;
      const selectedMonth = react.exports.useMemo(() => {
        if (date != null) {
          return utils2.getMonth(date);
        }
        if (disableHighlightToday) {
          return null;
        }
        return utils2.getMonth(now2);
      }, [now2, date, utils2, disableHighlightToday]);
      const [focusedMonth, setFocusedMonth] = react.exports.useState(() => selectedMonth || utils2.getMonth(now2));
      const isMonthDisabled = react.exports.useCallback((month) => {
        const firstEnabledMonth = utils2.startOfMonth(disablePast && utils2.isAfter(now2, minDate) ? now2 : minDate);
        const lastEnabledMonth = utils2.startOfMonth(disableFuture && utils2.isBefore(now2, maxDate) ? now2 : maxDate);
        if (utils2.isBefore(month, firstEnabledMonth)) {
          return true;
        }
        if (utils2.isAfter(month, lastEnabledMonth)) {
          return true;
        }
        if (!shouldDisableMonth) {
          return false;
        }
        return shouldDisableMonth(month);
      }, [disableFuture, disablePast, maxDate, minDate, now2, shouldDisableMonth, utils2]);
      const onMonthSelect = (month) => {
        if (readOnly) {
          return;
        }
        const newDate = utils2.setMonth(selectedDateOrToday, month);
        onChange(newDate, "finish");
      };
      const [internalHasFocus, setInternalHasFocus] = useControlled({
        name: "MonthPicker",
        state: "hasFocus",
        controlled: hasFocus,
        default: autoFocus
      });
      const changeHasFocus = react.exports.useCallback((newHasFocus) => {
        setInternalHasFocus(newHasFocus);
        if (onFocusedViewChange) {
          onFocusedViewChange(newHasFocus);
        }
      }, [setInternalHasFocus, onFocusedViewChange]);
      const focusMonth = react.exports.useCallback((month) => {
        if (!isMonthDisabled(utils2.setMonth(selectedDateOrToday, month))) {
          setFocusedMonth(month);
          changeHasFocus(true);
          if (onMonthFocus) {
            onMonthFocus(month);
          }
        }
      }, [selectedDateOrToday, isMonthDisabled, utils2, onMonthFocus, changeHasFocus]);
      react.exports.useEffect(() => {
        setFocusedMonth((prevFocusedMonth) => selectedMonth !== null && prevFocusedMonth !== selectedMonth ? selectedMonth : prevFocusedMonth);
      }, [selectedMonth]);
      const handleKeyDown2 = useEventCallback((event) => {
        const monthsInYear = 12;
        const monthsInRow = 3;
        switch (event.key) {
          case "ArrowUp":
            focusMonth((monthsInYear + focusedMonth - monthsInRow) % monthsInYear);
            event.preventDefault();
            break;
          case "ArrowDown":
            focusMonth((monthsInYear + focusedMonth + monthsInRow) % monthsInYear);
            event.preventDefault();
            break;
          case "ArrowLeft":
            focusMonth((monthsInYear + focusedMonth + (theme.direction === "ltr" ? -1 : 1)) % monthsInYear);
            event.preventDefault();
            break;
          case "ArrowRight":
            focusMonth((monthsInYear + focusedMonth + (theme.direction === "ltr" ? 1 : -1)) % monthsInYear);
            event.preventDefault();
            break;
        }
      });
      const handleMonthFocus = react.exports.useCallback((event, month) => {
        focusMonth(month);
      }, [focusMonth]);
      const handleMonthBlur = react.exports.useCallback(() => {
        changeHasFocus(false);
      }, [changeHasFocus]);
      const currentMonthNumber = utils2.getMonth(now2);
      return /* @__PURE__ */ jsx(MonthPickerRoot, _extends({
        ref,
        className: clsx(classes.root, className),
        ownerState,
        onKeyDown: handleKeyDown2
      }, other, {
        children: utils2.getMonthArray(selectedDateOrToday).map((month) => {
          const monthNumber = utils2.getMonth(month);
          const monthText = utils2.format(month, "monthShort");
          const isDisabled = disabled || isMonthDisabled(month);
          return /* @__PURE__ */ jsx(PickersMonth, {
            value: monthNumber,
            selected: monthNumber === selectedMonth,
            tabIndex: monthNumber === focusedMonth && !isDisabled ? 0 : -1,
            hasFocus: internalHasFocus && monthNumber === focusedMonth,
            onSelect: onMonthSelect,
            onFocus: handleMonthFocus,
            onBlur: handleMonthBlur,
            disabled: isDisabled,
            "aria-current": currentMonthNumber === monthNumber ? "date" : void 0,
            children: monthText
          }, monthText);
        })
      }));
    });
    function useValidation(props2, validate, isSameError) {
      const {
        value,
        onError
      } = props2;
      const adapter = useLocalizationContext();
      const previousValidationErrorRef = react.exports.useRef(null);
      const validationError = validate({
        adapter,
        value,
        props: props2
      });
      react.exports.useEffect(() => {
        if (onError && !isSameError(validationError, previousValidationErrorRef.current)) {
          onError(validationError, value);
        }
        previousValidationErrorRef.current = validationError;
      }, [isSameError, onError, previousValidationErrorRef, validationError, value]);
      return validationError;
    }
    const validateDate = ({
      props: props2,
      value,
      adapter
    }) => {
      const now2 = adapter.utils.date();
      const date = adapter.utils.date(value);
      const minDate = parseNonNullablePickerDate(adapter.utils, props2.minDate, adapter.defaultDates.minDate);
      const maxDate = parseNonNullablePickerDate(adapter.utils, props2.maxDate, adapter.defaultDates.maxDate);
      if (date === null) {
        return null;
      }
      switch (true) {
        case !adapter.utils.isValid(value):
          return "invalidDate";
        case Boolean(props2.shouldDisableDate && props2.shouldDisableDate(date)):
          return "shouldDisableDate";
        case Boolean(props2.disableFuture && adapter.utils.isAfterDay(date, now2)):
          return "disableFuture";
        case Boolean(props2.disablePast && adapter.utils.isBeforeDay(date, now2)):
          return "disablePast";
        case Boolean(minDate && adapter.utils.isBeforeDay(date, minDate)):
          return "minDate";
        case Boolean(maxDate && adapter.utils.isAfterDay(date, maxDate)):
          return "maxDate";
        default:
          return null;
      }
    };
    const useIsDayDisabled = ({
      shouldDisableDate,
      minDate,
      maxDate,
      disableFuture,
      disablePast
    }) => {
      const adapter = useLocalizationContext();
      return react.exports.useCallback((day) => validateDate({
        adapter,
        value: day,
        props: {
          shouldDisableDate,
          minDate,
          maxDate,
          disableFuture,
          disablePast
        }
      }) !== null, [adapter, shouldDisableDate, minDate, maxDate, disableFuture, disablePast]);
    };
    const isSameDateError = (a, b2) => a === b2;
    const useDateValidation = (props2) => useValidation(props2, validateDate, isSameDateError);
    const createCalendarStateReducer = (reduceAnimations, disableSwitchToMonthOnDayFocus, utils2) => (state, action) => {
      switch (action.type) {
        case "changeMonth":
          return _extends({}, state, {
            slideDirection: action.direction,
            currentMonth: action.newMonth,
            isMonthSwitchingAnimating: !reduceAnimations
          });
        case "finishMonthSwitchingAnimation":
          return _extends({}, state, {
            isMonthSwitchingAnimating: false
          });
        case "changeFocusedDay": {
          if (state.focusedDay != null && action.focusedDay != null && utils2.isSameDay(action.focusedDay, state.focusedDay)) {
            return state;
          }
          const needMonthSwitch = action.focusedDay != null && !disableSwitchToMonthOnDayFocus && !utils2.isSameMonth(state.currentMonth, action.focusedDay);
          return _extends({}, state, {
            focusedDay: action.focusedDay,
            isMonthSwitchingAnimating: needMonthSwitch && !reduceAnimations && !action.withoutMonthSwitchingAnimation,
            currentMonth: needMonthSwitch ? utils2.startOfMonth(action.focusedDay) : state.currentMonth,
            slideDirection: action.focusedDay != null && utils2.isAfterDay(action.focusedDay, state.currentMonth) ? "left" : "right"
          });
        }
        default:
          throw new Error("missing support");
      }
    };
    const useCalendarState = ({
      date,
      defaultCalendarMonth,
      disableFuture,
      disablePast,
      disableSwitchToMonthOnDayFocus = false,
      maxDate,
      minDate,
      onMonthChange,
      reduceAnimations,
      shouldDisableDate
    }) => {
      var _ref;
      const now2 = useNow();
      const utils2 = useUtils();
      const reducerFn = react.exports.useRef(createCalendarStateReducer(Boolean(reduceAnimations), disableSwitchToMonthOnDayFocus, utils2)).current;
      const [calendarState, dispatch] = react.exports.useReducer(reducerFn, {
        isMonthSwitchingAnimating: false,
        focusedDay: date || now2,
        currentMonth: utils2.startOfMonth((_ref = date != null ? date : defaultCalendarMonth) != null ? _ref : now2),
        slideDirection: "left"
      });
      const handleChangeMonth = react.exports.useCallback((payload) => {
        dispatch(_extends({
          type: "changeMonth"
        }, payload));
        if (onMonthChange) {
          onMonthChange(payload.newMonth);
        }
      }, [onMonthChange]);
      const changeMonth = react.exports.useCallback((newDate) => {
        const newDateRequested = newDate != null ? newDate : now2;
        if (utils2.isSameMonth(newDateRequested, calendarState.currentMonth)) {
          return;
        }
        handleChangeMonth({
          newMonth: utils2.startOfMonth(newDateRequested),
          direction: utils2.isAfterDay(newDateRequested, calendarState.currentMonth) ? "left" : "right"
        });
      }, [calendarState.currentMonth, handleChangeMonth, now2, utils2]);
      const isDateDisabled = useIsDayDisabled({
        shouldDisableDate,
        minDate,
        maxDate,
        disableFuture,
        disablePast
      });
      const onMonthSwitchingAnimationEnd = react.exports.useCallback(() => {
        dispatch({
          type: "finishMonthSwitchingAnimation"
        });
      }, []);
      const changeFocusedDay = react.exports.useCallback((newFocusedDate, withoutMonthSwitchingAnimation) => {
        if (!isDateDisabled(newFocusedDate)) {
          dispatch({
            type: "changeFocusedDay",
            focusedDay: newFocusedDate,
            withoutMonthSwitchingAnimation
          });
        }
      }, [isDateDisabled]);
      return {
        calendarState,
        changeMonth,
        changeFocusedDay,
        isDateDisabled,
        onMonthSwitchingAnimationEnd,
        handleChangeMonth
      };
    };
    const getPickersFadeTransitionGroupUtilityClass = (slot) => generateUtilityClass("MuiPickersFadeTransitionGroup", slot);
    generateUtilityClasses("MuiPickersFadeTransitionGroup", ["root"]);
    const useUtilityClasses$g = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"]
      };
      return composeClasses(slots, getPickersFadeTransitionGroupUtilityClass, classes);
    };
    const animationDuration = 500;
    const PickersFadeTransitionGroupRoot = styled$1(TransitionGroup$1, {
      name: "MuiPickersFadeTransitionGroup",
      slot: "Root",
      overridesResolver: (_2, styles2) => styles2.root
    })({
      display: "block",
      position: "relative"
    });
    function PickersFadeTransitionGroup(inProps) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiPickersFadeTransitionGroup"
      });
      const {
        children,
        className,
        reduceAnimations,
        transKey
      } = props2;
      const classes = useUtilityClasses$g(props2);
      if (reduceAnimations) {
        return children;
      }
      return /* @__PURE__ */ jsx(PickersFadeTransitionGroupRoot, {
        className: clsx(classes.root, className),
        children: /* @__PURE__ */ jsx(Fade$1, {
          appear: false,
          mountOnEnter: true,
          unmountOnExit: true,
          timeout: {
            appear: animationDuration,
            enter: animationDuration / 2,
            exit: 0
          },
          children
        }, transKey)
      });
    }
    const DAY_SIZE = 36;
    const DAY_MARGIN = 2;
    const DIALOG_WIDTH = 320;
    const VIEW_HEIGHT = 358;
    function getPickersDayUtilityClass(slot) {
      return generateUtilityClass("MuiPickersDay", slot);
    }
    const pickersDayClasses = generateUtilityClasses("MuiPickersDay", ["root", "dayWithMargin", "dayOutsideMonth", "hiddenDaySpacingFiller", "today", "selected", "disabled"]);
    const _excluded$e = ["autoFocus", "className", "day", "disabled", "disableHighlightToday", "disableMargin", "hidden", "isAnimating", "onClick", "onDaySelect", "onFocus", "onBlur", "onKeyDown", "onMouseDown", "outsideCurrentMonth", "selected", "showDaysOutsideCurrentMonth", "children", "today"];
    const useUtilityClasses$f = (ownerState) => {
      const {
        selected,
        disableMargin,
        disableHighlightToday,
        today,
        disabled,
        outsideCurrentMonth,
        showDaysOutsideCurrentMonth,
        classes
      } = ownerState;
      const slots = {
        root: ["root", selected && "selected", disabled && "disabled", !disableMargin && "dayWithMargin", !disableHighlightToday && today && "today", outsideCurrentMonth && showDaysOutsideCurrentMonth && "dayOutsideMonth", outsideCurrentMonth && !showDaysOutsideCurrentMonth && "hiddenDaySpacingFiller"],
        hiddenDaySpacingFiller: ["hiddenDaySpacingFiller"]
      };
      return composeClasses(slots, getPickersDayUtilityClass, classes);
    };
    const styleArg = ({
      theme,
      ownerState
    }) => _extends({}, theme.typography.caption, {
      width: DAY_SIZE,
      height: DAY_SIZE,
      borderRadius: "50%",
      padding: 0,
      backgroundColor: theme.palette.background.paper,
      color: theme.palette.text.primary,
      "&:hover": {
        backgroundColor: alpha(theme.palette.action.active, theme.palette.action.hoverOpacity)
      },
      "&:focus": {
        backgroundColor: alpha(theme.palette.action.active, theme.palette.action.hoverOpacity),
        [`&.${pickersDayClasses.selected}`]: {
          willChange: "background-color",
          backgroundColor: theme.palette.primary.dark
        }
      },
      [`&.${pickersDayClasses.selected}`]: {
        color: theme.palette.primary.contrastText,
        backgroundColor: theme.palette.primary.main,
        fontWeight: theme.typography.fontWeightMedium,
        transition: theme.transitions.create("background-color", {
          duration: theme.transitions.duration.short
        }),
        "&:hover": {
          willChange: "background-color",
          backgroundColor: theme.palette.primary.dark
        }
      },
      [`&.${pickersDayClasses.disabled}`]: {
        color: theme.palette.text.disabled
      }
    }, !ownerState.disableMargin && {
      margin: `0 ${DAY_MARGIN}px`
    }, ownerState.outsideCurrentMonth && ownerState.showDaysOutsideCurrentMonth && {
      color: theme.palette.text.secondary
    }, !ownerState.disableHighlightToday && ownerState.today && {
      [`&:not(.${pickersDayClasses.selected})`]: {
        border: `1px solid ${theme.palette.text.secondary}`
      }
    });
    const overridesResolver = (props2, styles2) => {
      const {
        ownerState
      } = props2;
      return [styles2.root, !ownerState.disableMargin && styles2.dayWithMargin, !ownerState.disableHighlightToday && ownerState.today && styles2.today, !ownerState.outsideCurrentMonth && ownerState.showDaysOutsideCurrentMonth && styles2.dayOutsideMonth, ownerState.outsideCurrentMonth && !ownerState.showDaysOutsideCurrentMonth && styles2.hiddenDaySpacingFiller];
    };
    const PickersDayRoot = styled$1(ButtonBase$1, {
      name: "MuiPickersDay",
      slot: "Root",
      overridesResolver
    })(styleArg);
    const PickersDayFiller = styled$1("div", {
      name: "MuiPickersDay",
      slot: "Root",
      overridesResolver
    })(({
      theme,
      ownerState
    }) => _extends({}, styleArg({
      theme,
      ownerState
    }), {
      opacity: 0,
      pointerEvents: "none"
    }));
    const noop$1 = () => {
    };
    const PickersDayRaw = /* @__PURE__ */ react.exports.forwardRef(function PickersDay2(inProps, forwardedRef) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiPickersDay"
      });
      const {
        autoFocus = false,
        className,
        day,
        disabled = false,
        disableHighlightToday = false,
        disableMargin = false,
        isAnimating,
        onClick,
        onDaySelect,
        onFocus = noop$1,
        onBlur = noop$1,
        onKeyDown = noop$1,
        onMouseDown,
        outsideCurrentMonth,
        selected = false,
        showDaysOutsideCurrentMonth = false,
        children,
        today: isToday = false
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$e);
      const ownerState = _extends({}, props2, {
        autoFocus,
        disabled,
        disableHighlightToday,
        disableMargin,
        selected,
        showDaysOutsideCurrentMonth,
        today: isToday
      });
      const classes = useUtilityClasses$f(ownerState);
      const utils2 = useUtils();
      const ref = react.exports.useRef(null);
      const handleRef = useForkRef(ref, forwardedRef);
      useEnhancedEffect$1(() => {
        if (autoFocus && !disabled && !isAnimating && !outsideCurrentMonth) {
          ref.current.focus();
        }
      }, [autoFocus, disabled, isAnimating, outsideCurrentMonth]);
      const handleMouseDown = (event) => {
        if (onMouseDown) {
          onMouseDown(event);
        }
        if (outsideCurrentMonth) {
          event.preventDefault();
        }
      };
      const handleClick = (event) => {
        if (!disabled) {
          onDaySelect(day, "finish");
        }
        if (outsideCurrentMonth) {
          event.currentTarget.focus();
        }
        if (onClick) {
          onClick(event);
        }
      };
      if (outsideCurrentMonth && !showDaysOutsideCurrentMonth) {
        return /* @__PURE__ */ jsx(PickersDayFiller, {
          className: clsx(classes.root, classes.hiddenDaySpacingFiller, className),
          ownerState,
          role: other.role
        });
      }
      return /* @__PURE__ */ jsx(PickersDayRoot, _extends({
        className: clsx(classes.root, className),
        ownerState,
        ref: handleRef,
        centerRipple: true,
        disabled,
        tabIndex: selected ? 0 : -1,
        onKeyDown: (event) => onKeyDown(event, day),
        onFocus: (event) => onFocus(event, day),
        onBlur: (event) => onBlur(event, day),
        onClick: handleClick,
        onMouseDown: handleMouseDown
      }, other, {
        children: !children ? utils2.format(day, "dayOfMonth") : children
      }));
    });
    const areDayPropsEqual = (prevProps, nextProps) => {
      return prevProps.autoFocus === nextProps.autoFocus && prevProps.isAnimating === nextProps.isAnimating && prevProps.today === nextProps.today && prevProps.disabled === nextProps.disabled && prevProps.selected === nextProps.selected && prevProps.disableMargin === nextProps.disableMargin && prevProps.showDaysOutsideCurrentMonth === nextProps.showDaysOutsideCurrentMonth && prevProps.disableHighlightToday === nextProps.disableHighlightToday && prevProps.className === nextProps.className && prevProps.sx === nextProps.sx && prevProps.outsideCurrentMonth === nextProps.outsideCurrentMonth && prevProps.onFocus === nextProps.onFocus && prevProps.onBlur === nextProps.onBlur && prevProps.onDaySelect === nextProps.onDaySelect;
    };
    const PickersDay = /* @__PURE__ */ react.exports.memo(PickersDayRaw, areDayPropsEqual);
    const getPickersSlideTransitionUtilityClass = (slot) => generateUtilityClass("PrivatePickersSlideTransition", slot);
    const pickersSlideTransitionClasses = generateUtilityClasses(
      "PrivatePickersSlideTransition",
      ["root", "slideEnter-left", "slideEnter-right", "slideEnterActive", "slideExit", "slideExitActiveLeft-left", "slideExitActiveLeft-right"]
    );
    const _excluded$d = ["children", "className", "reduceAnimations", "slideDirection", "transKey"];
    const useUtilityClasses$e = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"]
      };
      return composeClasses(slots, getPickersSlideTransitionUtilityClass, classes);
    };
    const slideAnimationDuration = 350;
    const PickersSlideTransitionRoot = styled$1(TransitionGroup$1, {
      name: "PrivatePickersSlideTransition",
      slot: "Root",
      overridesResolver: (_2, styles2) => [styles2.root, {
        [`.${pickersSlideTransitionClasses["slideEnter-left"]}`]: styles2["slideEnter-left"]
      }, {
        [`.${pickersSlideTransitionClasses["slideEnter-right"]}`]: styles2["slideEnter-right"]
      }, {
        [`.${pickersSlideTransitionClasses.slideEnterActive}`]: styles2.slideEnterActive
      }, {
        [`.${pickersSlideTransitionClasses.slideExit}`]: styles2.slideExit
      }, {
        [`.${pickersSlideTransitionClasses["slideExitActiveLeft-left"]}`]: styles2["slideExitActiveLeft-left"]
      }, {
        [`.${pickersSlideTransitionClasses["slideExitActiveLeft-right"]}`]: styles2["slideExitActiveLeft-right"]
      }]
    })(({
      theme
    }) => {
      const slideTransition = theme.transitions.create("transform", {
        duration: slideAnimationDuration,
        easing: "cubic-bezier(0.35, 0.8, 0.4, 1)"
      });
      return {
        display: "block",
        position: "relative",
        overflowX: "hidden",
        "& > *": {
          position: "absolute",
          top: 0,
          right: 0,
          left: 0
        },
        [`& .${pickersSlideTransitionClasses["slideEnter-left"]}`]: {
          willChange: "transform",
          transform: "translate(100%)",
          zIndex: 1
        },
        [`& .${pickersSlideTransitionClasses["slideEnter-right"]}`]: {
          willChange: "transform",
          transform: "translate(-100%)",
          zIndex: 1
        },
        [`& .${pickersSlideTransitionClasses.slideEnterActive}`]: {
          transform: "translate(0%)",
          transition: slideTransition
        },
        [`& .${pickersSlideTransitionClasses.slideExit}`]: {
          transform: "translate(0%)"
        },
        [`& .${pickersSlideTransitionClasses["slideExitActiveLeft-left"]}`]: {
          willChange: "transform",
          transform: "translate(-100%)",
          transition: slideTransition,
          zIndex: 0
        },
        [`& .${pickersSlideTransitionClasses["slideExitActiveLeft-right"]}`]: {
          willChange: "transform",
          transform: "translate(100%)",
          transition: slideTransition,
          zIndex: 0
        }
      };
    });
    const PickersSlideTransition = (props2) => {
      const {
        children,
        className,
        reduceAnimations,
        slideDirection,
        transKey
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$d);
      const classes = useUtilityClasses$e(props2);
      if (reduceAnimations) {
        return /* @__PURE__ */ jsx("div", {
          className: clsx(classes.root, className),
          children
        });
      }
      const transitionClasses = {
        exit: pickersSlideTransitionClasses.slideExit,
        enterActive: pickersSlideTransitionClasses.slideEnterActive,
        enter: pickersSlideTransitionClasses[`slideEnter-${slideDirection}`],
        exitActive: pickersSlideTransitionClasses[`slideExitActiveLeft-${slideDirection}`]
      };
      return /* @__PURE__ */ jsx(PickersSlideTransitionRoot, {
        className: clsx(classes.root, className),
        childFactory: (element) => /* @__PURE__ */ react.exports.cloneElement(element, {
          classNames: transitionClasses
        }),
        role: "presentation",
        children: /* @__PURE__ */ jsx(CSSTransition$1, _extends({
          mountOnEnter: true,
          unmountOnExit: true,
          timeout: slideAnimationDuration,
          classNames: transitionClasses
        }, other, {
          children
        }), transKey)
      });
    };
    const getDayPickerUtilityClass = (slot) => generateUtilityClass("MuiDayPicker", slot);
    generateUtilityClasses("MuiDayPicker", ["header", "weekDayLabel", "loadingContainer", "slideTransition", "monthContainer", "weekContainer"]);
    const useUtilityClasses$d = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        header: ["header"],
        weekDayLabel: ["weekDayLabel"],
        loadingContainer: ["loadingContainer"],
        slideTransition: ["slideTransition"],
        monthContainer: ["monthContainer"],
        weekContainer: ["weekContainer"]
      };
      return composeClasses(slots, getDayPickerUtilityClass, classes);
    };
    const defaultDayOfWeekFormatter = (day) => day.charAt(0).toUpperCase();
    const weeksContainerHeight = (DAY_SIZE + DAY_MARGIN * 2) * 6;
    const PickersCalendarDayHeader = styled$1("div", {
      name: "MuiDayPicker",
      slot: "Header",
      overridesResolver: (_2, styles2) => styles2.header
    })({
      display: "flex",
      justifyContent: "center",
      alignItems: "center"
    });
    const PickersCalendarWeekDayLabel = styled$1(Typography$1, {
      name: "MuiDayPicker",
      slot: "WeekDayLabel",
      overridesResolver: (_2, styles2) => styles2.weekDayLabel
    })(({
      theme
    }) => ({
      width: 36,
      height: 40,
      margin: "0 2px",
      textAlign: "center",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      color: theme.palette.text.secondary
    }));
    const PickersCalendarLoadingContainer = styled$1("div", {
      name: "MuiDayPicker",
      slot: "LoadingContainer",
      overridesResolver: (_2, styles2) => styles2.loadingContainer
    })({
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      minHeight: weeksContainerHeight
    });
    const PickersCalendarSlideTransition = styled$1(PickersSlideTransition, {
      name: "MuiDayPicker",
      slot: "SlideTransition",
      overridesResolver: (_2, styles2) => styles2.slideTransition
    })({
      minHeight: weeksContainerHeight
    });
    const PickersCalendarWeekContainer = styled$1("div", {
      name: "MuiDayPicker",
      slot: "MonthContainer",
      overridesResolver: (_2, styles2) => styles2.monthContainer
    })({
      overflow: "hidden"
    });
    const PickersCalendarWeek = styled$1("div", {
      name: "MuiDayPicker",
      slot: "WeekContainer",
      overridesResolver: (_2, styles2) => styles2.weekContainer
    })({
      margin: `${DAY_MARGIN}px 0`,
      display: "flex",
      justifyContent: "center"
    });
    function DayPicker(inProps) {
      const now2 = useNow();
      const utils2 = useUtils();
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiDayPicker"
      });
      const classes = useUtilityClasses$d(props2);
      const {
        onFocusedDayChange,
        className,
        currentMonth,
        selectedDays,
        disabled,
        disableHighlightToday,
        focusedDay,
        isMonthSwitchingAnimating,
        loading,
        onSelectedDaysChange,
        onMonthSwitchingAnimationEnd,
        readOnly,
        reduceAnimations,
        renderDay,
        renderLoading = () => /* @__PURE__ */ jsx("span", {
          children: "..."
        }),
        showDaysOutsideCurrentMonth,
        slideDirection,
        TransitionProps,
        disablePast,
        disableFuture,
        minDate,
        maxDate,
        shouldDisableDate,
        dayOfWeekFormatter = defaultDayOfWeekFormatter,
        hasFocus,
        onFocusedViewChange,
        gridLabelId
      } = props2;
      const isDateDisabled = useIsDayDisabled({
        shouldDisableDate,
        minDate,
        maxDate,
        disablePast,
        disableFuture
      });
      const [internalFocusedDay, setInternalFocusedDay] = react.exports.useState(() => focusedDay || now2);
      const changeHasFocus = react.exports.useCallback((newHasFocus) => {
        if (onFocusedViewChange) {
          onFocusedViewChange(newHasFocus);
        }
      }, [onFocusedViewChange]);
      const handleDaySelect = react.exports.useCallback((day, isFinish = "finish") => {
        if (readOnly) {
          return;
        }
        onSelectedDaysChange(day, isFinish);
      }, [onSelectedDaysChange, readOnly]);
      const focusDay = react.exports.useCallback((day) => {
        if (!isDateDisabled(day)) {
          onFocusedDayChange(day);
          setInternalFocusedDay(day);
          changeHasFocus(true);
        }
      }, [isDateDisabled, onFocusedDayChange, changeHasFocus]);
      const theme = useTheme();
      function handleKeyDown2(event, day) {
        switch (event.key) {
          case "ArrowUp":
            focusDay(utils2.addDays(day, -7));
            event.preventDefault();
            break;
          case "ArrowDown":
            focusDay(utils2.addDays(day, 7));
            event.preventDefault();
            break;
          case "ArrowLeft": {
            const newFocusedDayDefault = utils2.addDays(day, theme.direction === "ltr" ? -1 : 1);
            const nextAvailableMonth = theme.direction === "ltr" ? utils2.getPreviousMonth(day) : utils2.getNextMonth(day);
            const closestDayToFocus = findClosestEnabledDate({
              utils: utils2,
              date: newFocusedDayDefault,
              minDate: theme.direction === "ltr" ? utils2.startOfMonth(nextAvailableMonth) : newFocusedDayDefault,
              maxDate: theme.direction === "ltr" ? newFocusedDayDefault : utils2.endOfMonth(nextAvailableMonth),
              isDateDisabled
            });
            focusDay(closestDayToFocus || newFocusedDayDefault);
            event.preventDefault();
            break;
          }
          case "ArrowRight": {
            const newFocusedDayDefault = utils2.addDays(day, theme.direction === "ltr" ? 1 : -1);
            const nextAvailableMonth = theme.direction === "ltr" ? utils2.getNextMonth(day) : utils2.getPreviousMonth(day);
            const closestDayToFocus = findClosestEnabledDate({
              utils: utils2,
              date: newFocusedDayDefault,
              minDate: theme.direction === "ltr" ? newFocusedDayDefault : utils2.startOfMonth(nextAvailableMonth),
              maxDate: theme.direction === "ltr" ? utils2.endOfMonth(nextAvailableMonth) : newFocusedDayDefault,
              isDateDisabled
            });
            focusDay(closestDayToFocus || newFocusedDayDefault);
            event.preventDefault();
            break;
          }
          case "Home":
            focusDay(utils2.startOfWeek(day));
            event.preventDefault();
            break;
          case "End":
            focusDay(utils2.endOfWeek(day));
            event.preventDefault();
            break;
          case "PageUp":
            focusDay(utils2.getNextMonth(day));
            event.preventDefault();
            break;
          case "PageDown":
            focusDay(utils2.getPreviousMonth(day));
            event.preventDefault();
            break;
        }
      }
      function handleFocus(event, day) {
        focusDay(day);
      }
      function handleBlur(event, day) {
        if (hasFocus && utils2.isSameDay(internalFocusedDay, day)) {
          changeHasFocus(false);
        }
      }
      const currentMonthNumber = utils2.getMonth(currentMonth);
      const validSelectedDays = selectedDays.filter((day) => !!day).map((day) => utils2.startOfDay(day));
      const transitionKey = currentMonthNumber;
      const slideNodeRef = react.exports.useMemo(() => /* @__PURE__ */ react.exports.createRef(), [transitionKey]);
      const startOfCurrentWeek = utils2.startOfWeek(now2);
      const focusableDay = react.exports.useMemo(() => {
        const startOfMonth = utils2.startOfMonth(currentMonth);
        const endOfMonth = utils2.endOfMonth(currentMonth);
        if (isDateDisabled(internalFocusedDay) || utils2.isAfterDay(internalFocusedDay, endOfMonth) || utils2.isBeforeDay(internalFocusedDay, startOfMonth)) {
          return findClosestEnabledDate({
            utils: utils2,
            date: internalFocusedDay,
            minDate: startOfMonth,
            maxDate: endOfMonth,
            disablePast,
            disableFuture,
            isDateDisabled
          });
        }
        return internalFocusedDay;
      }, [currentMonth, disableFuture, disablePast, internalFocusedDay, isDateDisabled, utils2]);
      return /* @__PURE__ */ jsxs("div", {
        role: "grid",
        "aria-labelledby": gridLabelId,
        children: [/* @__PURE__ */ jsx(PickersCalendarDayHeader, {
          role: "row",
          className: classes.header,
          children: utils2.getWeekdays().map((day, i) => {
            var _dayOfWeekFormatter;
            return /* @__PURE__ */ jsx(PickersCalendarWeekDayLabel, {
              variant: "caption",
              role: "columnheader",
              "aria-label": utils2.format(utils2.addDays(startOfCurrentWeek, i), "weekday"),
              className: classes.weekDayLabel,
              children: (_dayOfWeekFormatter = dayOfWeekFormatter == null ? void 0 : dayOfWeekFormatter(day)) != null ? _dayOfWeekFormatter : day
            }, day + i.toString());
          })
        }), loading ? /* @__PURE__ */ jsx(PickersCalendarLoadingContainer, {
          className: classes.loadingContainer,
          children: renderLoading()
        }) : /* @__PURE__ */ jsx(PickersCalendarSlideTransition, _extends({
          transKey: transitionKey,
          onExited: onMonthSwitchingAnimationEnd,
          reduceAnimations,
          slideDirection,
          className: clsx(className, classes.slideTransition)
        }, TransitionProps, {
          nodeRef: slideNodeRef,
          children: /* @__PURE__ */ jsx(PickersCalendarWeekContainer, {
            ref: slideNodeRef,
            role: "rowgroup",
            className: classes.monthContainer,
            children: utils2.getWeekArray(currentMonth).map((week) => /* @__PURE__ */ jsx(PickersCalendarWeek, {
              role: "row",
              className: classes.weekContainer,
              children: week.map((day) => {
                const isFocusableDay = focusableDay !== null && utils2.isSameDay(day, focusableDay);
                const isSelected = validSelectedDays.some((selectedDay) => utils2.isSameDay(selectedDay, day));
                const isToday = utils2.isSameDay(day, now2);
                const pickersDayProps = {
                  key: day == null ? void 0 : day.toString(),
                  day,
                  isAnimating: isMonthSwitchingAnimating,
                  disabled: disabled || isDateDisabled(day),
                  autoFocus: hasFocus && isFocusableDay,
                  today: isToday,
                  outsideCurrentMonth: utils2.getMonth(day) !== currentMonthNumber,
                  selected: isSelected,
                  disableHighlightToday,
                  showDaysOutsideCurrentMonth,
                  onKeyDown: handleKeyDown2,
                  onFocus: handleFocus,
                  onBlur: handleBlur,
                  onDaySelect: handleDaySelect,
                  tabIndex: isFocusableDay ? 0 : -1,
                  role: "gridcell",
                  "aria-selected": isSelected
                };
                if (isToday) {
                  pickersDayProps["aria-current"] = "date";
                }
                return renderDay ? renderDay(day, validSelectedDays, pickersDayProps) : /* @__PURE__ */ jsx(PickersDay, _extends({}, pickersDayProps), pickersDayProps.key);
              })
            }, `week-${week[0]}`))
          })
        }))]
      });
    }
    function useViews({
      onChange,
      onViewChange,
      openTo,
      view,
      views
    }) {
      var _views, _views2;
      const [openView, setOpenView] = useControlled({
        name: "Picker",
        state: "view",
        controlled: view,
        default: openTo && arrayIncludes(views, openTo) ? openTo : views[0]
      });
      const previousView = (_views = views[views.indexOf(openView) - 1]) != null ? _views : null;
      const nextView = (_views2 = views[views.indexOf(openView) + 1]) != null ? _views2 : null;
      const changeView = react.exports.useCallback((newView) => {
        setOpenView(newView);
        if (onViewChange) {
          onViewChange(newView);
        }
      }, [setOpenView, onViewChange]);
      const openNext = react.exports.useCallback(() => {
        if (nextView) {
          changeView(nextView);
        }
      }, [nextView, changeView]);
      const handleChangeAndOpenNext = react.exports.useCallback((date, currentViewSelectionState) => {
        const isSelectionFinishedOnCurrentView = currentViewSelectionState === "finish";
        const globalSelectionState = isSelectionFinishedOnCurrentView && Boolean(nextView) ? "partial" : currentViewSelectionState;
        onChange(date, globalSelectionState);
        if (isSelectionFinishedOnCurrentView) {
          openNext();
        }
      }, [nextView, onChange, openNext]);
      return {
        handleChangeAndOpenNext,
        nextView,
        previousView,
        openNext,
        openView,
        setOpenView: changeView
      };
    }
    const ArrowDropDown = createSvgIcon$1(/* @__PURE__ */ jsx("path", {
      d: "M7 10l5 5 5-5z"
    }), "ArrowDropDown");
    const ArrowLeft = createSvgIcon$1(/* @__PURE__ */ jsx("path", {
      d: "M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z"
    }), "ArrowLeft");
    const ArrowRight = createSvgIcon$1(/* @__PURE__ */ jsx("path", {
      d: "M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"
    }), "ArrowRight");
    const Calendar = createSvgIcon$1(/* @__PURE__ */ jsx("path", {
      d: "M17 12h-5v5h5v-5zM16 1v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2h-1V1h-2zm3 18H5V8h14v11z"
    }), "Calendar");
    const Clock$1 = createSvgIcon$1(/* @__PURE__ */ jsxs(react.exports.Fragment, {
      children: [/* @__PURE__ */ jsx("path", {
        d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
      }), /* @__PURE__ */ jsx("path", {
        d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"
      })]
    }), "Clock");
    createSvgIcon$1(/* @__PURE__ */ jsx("path", {
      d: "M9 11H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2zm2-7h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V9h14v11z"
    }), "DateRange");
    const Pen = createSvgIcon$1(/* @__PURE__ */ jsx("path", {
      d: "M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34a.9959.9959 0 00-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"
    }), "Pen");
    createSvgIcon$1(/* @__PURE__ */ jsxs(react.exports.Fragment, {
      children: [/* @__PURE__ */ jsx("path", {
        d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
      }), /* @__PURE__ */ jsx("path", {
        d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"
      })]
    }), "Time");
    function getPickersArrowSwitcherUtilityClass(slot) {
      return generateUtilityClass("MuiPickersArrowSwitcher", slot);
    }
    generateUtilityClasses("MuiPickersArrowSwitcher", ["root", "spacer", "button"]);
    const _excluded$c = ["children", "className", "components", "componentsProps", "isLeftDisabled", "isLeftHidden", "isRightDisabled", "isRightHidden", "leftArrowButtonText", "onLeftClick", "onRightClick", "rightArrowButtonText"];
    const useUtilityClasses$c = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        spacer: ["spacer"],
        button: ["button"]
      };
      return composeClasses(slots, getPickersArrowSwitcherUtilityClass, classes);
    };
    const PickersArrowSwitcherRoot = styled$1("div", {
      name: "MuiPickersArrowSwitcher",
      slot: "Root",
      overridesResolver: (props2, styles2) => styles2.root
    })({
      display: "flex"
    });
    const PickersArrowSwitcherSpacer = styled$1("div", {
      name: "MuiPickersArrowSwitcher",
      slot: "Spacer",
      overridesResolver: (props2, styles2) => styles2.spacer
    })(({
      theme
    }) => ({
      width: theme.spacing(3)
    }));
    const PickersArrowSwitcherButton = styled$1(IconButton$1, {
      name: "MuiPickersArrowSwitcher",
      slot: "Button",
      overridesResolver: (props2, styles2) => styles2.button
    })(({
      ownerState
    }) => _extends({}, ownerState.hidden && {
      visibility: "hidden"
    }));
    const PickersArrowSwitcher = /* @__PURE__ */ react.exports.forwardRef(function PickersArrowSwitcher2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiPickersArrowSwitcher"
      });
      const {
        children,
        className,
        components,
        componentsProps,
        isLeftDisabled,
        isLeftHidden,
        isRightDisabled,
        isRightHidden,
        leftArrowButtonText,
        onLeftClick,
        onRightClick,
        rightArrowButtonText
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$c);
      const theme = useTheme();
      const isRtl = theme.direction === "rtl";
      const leftArrowButtonProps = (componentsProps == null ? void 0 : componentsProps.leftArrowButton) || {};
      const LeftArrowIcon = (components == null ? void 0 : components.LeftArrowIcon) || ArrowLeft;
      const rightArrowButtonProps = (componentsProps == null ? void 0 : componentsProps.rightArrowButton) || {};
      const RightArrowIcon = (components == null ? void 0 : components.RightArrowIcon) || ArrowRight;
      const ownerState = props2;
      const classes = useUtilityClasses$c(ownerState);
      return /* @__PURE__ */ jsxs(PickersArrowSwitcherRoot, _extends({
        ref,
        className: clsx(classes.root, className),
        ownerState
      }, other, {
        children: [/* @__PURE__ */ jsx(PickersArrowSwitcherButton, _extends({
          as: components == null ? void 0 : components.LeftArrowButton,
          size: "small",
          "aria-label": leftArrowButtonText,
          title: leftArrowButtonText,
          disabled: isLeftDisabled,
          edge: "end",
          onClick: onLeftClick
        }, leftArrowButtonProps, {
          className: clsx(classes.button, leftArrowButtonProps.className),
          ownerState: _extends({}, ownerState, leftArrowButtonProps, {
            hidden: isLeftHidden
          }),
          children: isRtl ? /* @__PURE__ */ jsx(RightArrowIcon, {}) : /* @__PURE__ */ jsx(LeftArrowIcon, {})
        })), children ? /* @__PURE__ */ jsx(Typography$1, {
          variant: "subtitle1",
          component: "span",
          children
        }) : /* @__PURE__ */ jsx(PickersArrowSwitcherSpacer, {
          className: classes.spacer,
          ownerState
        }), /* @__PURE__ */ jsx(PickersArrowSwitcherButton, _extends({
          as: components == null ? void 0 : components.RightArrowButton,
          size: "small",
          "aria-label": rightArrowButtonText,
          title: rightArrowButtonText,
          edge: "start",
          disabled: isRightDisabled,
          onClick: onRightClick
        }, rightArrowButtonProps, {
          className: clsx(classes.button, rightArrowButtonProps.className),
          ownerState: _extends({}, ownerState, rightArrowButtonProps, {
            hidden: isRightHidden
          }),
          children: isRtl ? /* @__PURE__ */ jsx(LeftArrowIcon, {}) : /* @__PURE__ */ jsx(RightArrowIcon, {})
        }))]
      }));
    });
    const getMeridiem = (date, utils2) => {
      if (!date) {
        return null;
      }
      return utils2.getHours(date) >= 12 ? "pm" : "am";
    };
    const convertValueToMeridiem = (value, meridiem2, ampm) => {
      if (ampm) {
        const currentMeridiem = value >= 12 ? "pm" : "am";
        if (currentMeridiem !== meridiem2) {
          return meridiem2 === "am" ? value - 12 : value + 12;
        }
      }
      return value;
    };
    const convertToMeridiem = (time, meridiem2, ampm, utils2) => {
      const newHoursAmount = convertValueToMeridiem(utils2.getHours(time), meridiem2, ampm);
      return utils2.setHours(time, newHoursAmount);
    };
    const getSecondsInDay = (date, utils2) => {
      return utils2.getHours(date) * 3600 + utils2.getMinutes(date) * 60 + utils2.getSeconds(date);
    };
    const createIsAfterIgnoreDatePart = (disableIgnoringDatePartForTimeValidation = false, utils2) => (dateLeft, dateRight) => {
      if (disableIgnoringDatePartForTimeValidation) {
        return utils2.isAfter(dateLeft, dateRight);
      }
      return getSecondsInDay(dateLeft, utils2) > getSecondsInDay(dateRight, utils2);
    };
    function useNextMonthDisabled(month, {
      disableFuture,
      maxDate
    }) {
      const utils2 = useUtils();
      return react.exports.useMemo(() => {
        const now2 = utils2.date();
        const lastEnabledMonth = utils2.startOfMonth(disableFuture && utils2.isBefore(now2, maxDate) ? now2 : maxDate);
        return !utils2.isAfter(lastEnabledMonth, month);
      }, [disableFuture, maxDate, month, utils2]);
    }
    function usePreviousMonthDisabled(month, {
      disablePast,
      minDate
    }) {
      const utils2 = useUtils();
      return react.exports.useMemo(() => {
        const now2 = utils2.date();
        const firstEnabledMonth = utils2.startOfMonth(disablePast && utils2.isAfter(now2, minDate) ? now2 : minDate);
        return !utils2.isBefore(firstEnabledMonth, month);
      }, [disablePast, minDate, month, utils2]);
    }
    function useMeridiemMode(date, ampm, onChange) {
      const utils2 = useUtils();
      const meridiemMode = getMeridiem(date, utils2);
      const handleMeridiemChange = react.exports.useCallback((mode) => {
        const timeWithMeridiem = date == null ? null : convertToMeridiem(date, mode, Boolean(ampm), utils2);
        onChange(timeWithMeridiem, "partial");
      }, [ampm, date, onChange, utils2]);
      return {
        meridiemMode,
        handleMeridiemChange
      };
    }
    const buildDeprecatedPropsWarning = (message) => {
      {
        return () => {
        };
      }
    };
    const getPickersCalendarHeaderUtilityClass = (slot) => generateUtilityClass("MuiPickersCalendarHeader", slot);
    generateUtilityClasses("MuiPickersCalendarHeader", ["root", "labelContainer", "label", "switchViewButton", "switchViewIcon"]);
    const useUtilityClasses$b = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        labelContainer: ["labelContainer"],
        label: ["label"],
        switchViewButton: ["switchViewButton"],
        switchViewIcon: ["switchViewIcon"]
      };
      return composeClasses(slots, getPickersCalendarHeaderUtilityClass, classes);
    };
    const PickersCalendarHeaderRoot = styled$1("div", {
      name: "MuiPickersCalendarHeader",
      slot: "Root",
      overridesResolver: (_2, styles2) => styles2.root
    })({
      display: "flex",
      alignItems: "center",
      marginTop: 16,
      marginBottom: 8,
      paddingLeft: 24,
      paddingRight: 12,
      maxHeight: 30,
      minHeight: 30
    });
    const PickersCalendarHeaderLabelContainer = styled$1("div", {
      name: "MuiPickersCalendarHeader",
      slot: "LabelContainer",
      overridesResolver: (_2, styles2) => styles2.labelContainer
    })(({
      theme
    }) => _extends({
      display: "flex",
      maxHeight: 30,
      overflow: "hidden",
      alignItems: "center",
      cursor: "pointer",
      marginRight: "auto"
    }, theme.typography.body1, {
      fontWeight: theme.typography.fontWeightMedium
    }));
    const PickersCalendarHeaderLabel = styled$1("div", {
      name: "MuiPickersCalendarHeader",
      slot: "Label",
      overridesResolver: (_2, styles2) => styles2.label
    })({
      marginRight: 6
    });
    const PickersCalendarHeaderSwitchViewButton = styled$1(IconButton$1, {
      name: "MuiPickersCalendarHeader",
      slot: "SwitchViewButton",
      overridesResolver: (_2, styles2) => styles2.switchViewButton
    })({
      marginRight: "auto"
    });
    const PickersCalendarHeaderSwitchViewIcon = styled$1(ArrowDropDown, {
      name: "MuiPickersCalendarHeader",
      slot: "SwitchViewIcon",
      overridesResolver: (_2, styles2) => styles2.switchViewIcon
    })(({
      theme,
      ownerState
    }) => _extends({
      willChange: "transform",
      transition: theme.transitions.create("transform"),
      transform: "rotate(0deg)"
    }, ownerState.openView === "year" && {
      transform: "rotate(180deg)"
    }));
    const deprecatedPropsWarning$1 = buildDeprecatedPropsWarning();
    function PickersCalendarHeader(inProps) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiPickersCalendarHeader"
      });
      const {
        components = {},
        componentsProps = {},
        currentMonth: month,
        disabled,
        disableFuture,
        disablePast,
        getViewSwitchingButtonText: getViewSwitchingButtonTextProp,
        leftArrowButtonText: leftArrowButtonTextProp,
        maxDate,
        minDate,
        onMonthChange,
        onViewChange,
        openView: currentView,
        reduceAnimations,
        rightArrowButtonText: rightArrowButtonTextProp,
        views,
        labelId
      } = props2;
      deprecatedPropsWarning$1({
        leftArrowButtonText: leftArrowButtonTextProp,
        rightArrowButtonText: rightArrowButtonTextProp,
        getViewSwitchingButtonText: getViewSwitchingButtonTextProp
      });
      const localeText = useLocaleText();
      const leftArrowButtonText = leftArrowButtonTextProp != null ? leftArrowButtonTextProp : localeText.previousMonth;
      const rightArrowButtonText = rightArrowButtonTextProp != null ? rightArrowButtonTextProp : localeText.nextMonth;
      const getViewSwitchingButtonText = getViewSwitchingButtonTextProp != null ? getViewSwitchingButtonTextProp : localeText.calendarViewSwitchingButtonAriaLabel;
      const utils2 = useUtils();
      const classes = useUtilityClasses$b(props2);
      const switchViewButtonProps = componentsProps.switchViewButton || {};
      const selectNextMonth = () => onMonthChange(utils2.getNextMonth(month), "left");
      const selectPreviousMonth = () => onMonthChange(utils2.getPreviousMonth(month), "right");
      const isNextMonthDisabled = useNextMonthDisabled(month, {
        disableFuture,
        maxDate
      });
      const isPreviousMonthDisabled = usePreviousMonthDisabled(month, {
        disablePast,
        minDate
      });
      const handleToggleView = () => {
        if (views.length === 1 || !onViewChange || disabled) {
          return;
        }
        if (views.length === 2) {
          onViewChange(views.find((view) => view !== currentView) || views[0]);
        } else {
          const nextIndexToOpen = views.indexOf(currentView) !== 0 ? 0 : 1;
          onViewChange(views[nextIndexToOpen]);
        }
      };
      if (views.length === 1 && views[0] === "year") {
        return null;
      }
      const ownerState = props2;
      return /* @__PURE__ */ jsxs(PickersCalendarHeaderRoot, {
        ownerState,
        className: classes.root,
        children: [/* @__PURE__ */ jsxs(PickersCalendarHeaderLabelContainer, {
          role: "presentation",
          onClick: handleToggleView,
          ownerState,
          "aria-live": "polite",
          className: classes.labelContainer,
          children: [/* @__PURE__ */ jsx(PickersFadeTransitionGroup, {
            reduceAnimations,
            transKey: utils2.format(month, "monthAndYear"),
            children: /* @__PURE__ */ jsx(PickersCalendarHeaderLabel, {
              id: labelId,
              ownerState,
              className: classes.label,
              children: utils2.format(month, "monthAndYear")
            })
          }), views.length > 1 && !disabled && /* @__PURE__ */ jsx(PickersCalendarHeaderSwitchViewButton, _extends({
            size: "small",
            as: components.SwitchViewButton,
            "aria-label": getViewSwitchingButtonText(currentView),
            className: classes.switchViewButton
          }, switchViewButtonProps, {
            children: /* @__PURE__ */ jsx(PickersCalendarHeaderSwitchViewIcon, {
              as: components.SwitchViewIcon,
              ownerState,
              className: classes.switchViewIcon
            })
          }))]
        }), /* @__PURE__ */ jsx(Fade$1, {
          in: currentView === "day",
          children: /* @__PURE__ */ jsx(PickersArrowSwitcher, {
            leftArrowButtonText,
            rightArrowButtonText,
            components,
            componentsProps,
            onLeftClick: selectPreviousMonth,
            onRightClick: selectNextMonth,
            isLeftDisabled: isPreviousMonthDisabled,
            isRightDisabled: isNextMonthDisabled
          })
        })]
      });
    }
    const WrapperVariantContext = /* @__PURE__ */ react.exports.createContext(null);
    function getPickersYearUtilityClass(slot) {
      return generateUtilityClass("PrivatePickersYear", slot);
    }
    const pickersYearClasses = generateUtilityClasses("PrivatePickersYear", ["root", "modeDesktop", "modeMobile", "yearButton", "selected", "disabled"]);
    const _excluded$b = ["autoFocus", "className", "children", "disabled", "onClick", "onKeyDown", "value", "tabIndex", "onFocus", "onBlur"];
    const useUtilityClasses$a = (ownerState) => {
      const {
        wrapperVariant,
        disabled,
        selected,
        classes
      } = ownerState;
      const slots = {
        root: ["root", wrapperVariant && `mode${capitalize(wrapperVariant)}`],
        yearButton: ["yearButton", disabled && "disabled", selected && "selected"]
      };
      return composeClasses(slots, getPickersYearUtilityClass, classes);
    };
    const PickersYearRoot = styled$1("div", {
      name: "PrivatePickersYear",
      slot: "Root",
      overridesResolver: (_2, styles2) => [styles2.root, {
        [`&.${pickersYearClasses.modeDesktop}`]: styles2.modeDesktop
      }, {
        [`&.${pickersYearClasses.modeMobile}`]: styles2.modeMobile
      }]
    })(({
      ownerState
    }) => _extends({
      flexBasis: "33.3%",
      display: "flex",
      alignItems: "center",
      justifyContent: "center"
    }, (ownerState == null ? void 0 : ownerState.wrapperVariant) === "desktop" && {
      flexBasis: "25%"
    }));
    const PickersYearButton = styled$1("button", {
      name: "PrivatePickersYear",
      slot: "Button",
      overridesResolver: (_2, styles2) => [styles2.button, {
        [`&.${pickersYearClasses.disabled}`]: styles2.disabled
      }, {
        [`&.${pickersYearClasses.selected}`]: styles2.selected
      }]
    })(({
      theme
    }) => _extends({
      color: "unset",
      backgroundColor: "transparent",
      border: 0,
      outline: 0
    }, theme.typography.subtitle1, {
      margin: "8px 0",
      height: 36,
      width: 72,
      borderRadius: 18,
      cursor: "pointer",
      "&:focus, &:hover": {
        backgroundColor: alpha(theme.palette.action.active, theme.palette.action.hoverOpacity)
      },
      [`&.${pickersYearClasses.disabled}`]: {
        color: theme.palette.text.secondary
      },
      [`&.${pickersYearClasses.selected}`]: {
        color: theme.palette.primary.contrastText,
        backgroundColor: theme.palette.primary.main,
        "&:focus, &:hover": {
          backgroundColor: theme.palette.primary.dark
        }
      }
    }));
    const noop = () => {
    };
    const PickersYear = /* @__PURE__ */ react.exports.forwardRef(function PickersYear2(props2, forwardedRef) {
      const {
        autoFocus,
        className,
        children,
        disabled,
        onClick,
        onKeyDown,
        value,
        tabIndex,
        onFocus = noop,
        onBlur = noop
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$b);
      const ref = react.exports.useRef(null);
      const refHandle = useForkRef(ref, forwardedRef);
      const wrapperVariant = react.exports.useContext(WrapperVariantContext);
      const ownerState = _extends({}, props2, {
        wrapperVariant
      });
      const classes = useUtilityClasses$a(ownerState);
      react.exports.useEffect(() => {
        if (autoFocus) {
          ref.current.focus();
        }
      }, [autoFocus]);
      return /* @__PURE__ */ jsx(PickersYearRoot, {
        className: clsx(classes.root, className),
        ownerState,
        children: /* @__PURE__ */ jsx(PickersYearButton, _extends({
          ref: refHandle,
          disabled,
          type: "button",
          tabIndex: disabled ? -1 : tabIndex,
          onClick: (event) => onClick(event, value),
          onKeyDown: (event) => onKeyDown(event, value),
          onFocus: (event) => onFocus(event, value),
          onBlur: (event) => onBlur(event, value),
          className: classes.yearButton,
          ownerState
        }, other, {
          children
        }))
      });
    });
    function getYearPickerUtilityClass(slot) {
      return generateUtilityClass("MuiYearPicker", slot);
    }
    generateUtilityClasses("MuiYearPicker", ["root"]);
    const useUtilityClasses$9 = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"]
      };
      return composeClasses(slots, getYearPickerUtilityClass, classes);
    };
    function useYearPickerDefaultizedProps(props2, name) {
      const utils2 = useUtils();
      const defaultDates = useDefaultDates();
      const themeProps = useThemeProps({
        props: props2,
        name
      });
      return _extends({
        disablePast: false,
        disableFuture: false
      }, themeProps, {
        minDate: parseNonNullablePickerDate(utils2, themeProps.minDate, defaultDates.minDate),
        maxDate: parseNonNullablePickerDate(utils2, themeProps.maxDate, defaultDates.maxDate)
      });
    }
    const YearPickerRoot = styled$1("div", {
      name: "MuiYearPicker",
      slot: "Root",
      overridesResolver: (props2, styles2) => styles2.root
    })({
      display: "flex",
      flexDirection: "row",
      flexWrap: "wrap",
      overflowY: "auto",
      height: "100%",
      padding: "0 4px",
      maxHeight: "304px"
    });
    const YearPicker = /* @__PURE__ */ react.exports.forwardRef(function YearPicker2(inProps, ref) {
      const now2 = useNow();
      const theme = useTheme();
      const utils2 = useUtils();
      const props2 = useYearPickerDefaultizedProps(inProps, "MuiYearPicker");
      const {
        autoFocus,
        className,
        date,
        disabled,
        disableFuture,
        disablePast,
        maxDate,
        minDate,
        onChange,
        readOnly,
        shouldDisableYear,
        disableHighlightToday,
        onYearFocus,
        hasFocus,
        onFocusedViewChange
      } = props2;
      const ownerState = props2;
      const classes = useUtilityClasses$9(ownerState);
      const selectedDateOrToday = date != null ? date : now2;
      const currentYear = react.exports.useMemo(() => {
        if (date != null) {
          return utils2.getYear(date);
        }
        if (disableHighlightToday) {
          return null;
        }
        return utils2.getYear(now2);
      }, [now2, date, utils2, disableHighlightToday]);
      const wrapperVariant = react.exports.useContext(WrapperVariantContext);
      const selectedYearRef = react.exports.useRef(null);
      const [focusedYear, setFocusedYear] = react.exports.useState(() => currentYear || utils2.getYear(now2));
      const [internalHasFocus, setInternalHasFocus] = useControlled({
        name: "YearPicker",
        state: "hasFocus",
        controlled: hasFocus,
        default: autoFocus
      });
      const changeHasFocus = react.exports.useCallback((newHasFocus) => {
        setInternalHasFocus(newHasFocus);
        if (onFocusedViewChange) {
          onFocusedViewChange(newHasFocus);
        }
      }, [setInternalHasFocus, onFocusedViewChange]);
      const isYearDisabled = react.exports.useCallback((dateToValidate) => {
        if (disablePast && utils2.isBeforeYear(dateToValidate, now2)) {
          return true;
        }
        if (disableFuture && utils2.isAfterYear(dateToValidate, now2)) {
          return true;
        }
        if (minDate && utils2.isBeforeYear(dateToValidate, minDate)) {
          return true;
        }
        if (maxDate && utils2.isAfterYear(dateToValidate, maxDate)) {
          return true;
        }
        if (shouldDisableYear && shouldDisableYear(dateToValidate)) {
          return true;
        }
        return false;
      }, [disableFuture, disablePast, maxDate, minDate, now2, shouldDisableYear, utils2]);
      const handleYearSelection = (event, year, isFinish = "finish") => {
        if (readOnly) {
          return;
        }
        const newDate = utils2.setYear(selectedDateOrToday, year);
        onChange(newDate, isFinish);
      };
      const focusYear = react.exports.useCallback((year) => {
        if (!isYearDisabled(utils2.setYear(selectedDateOrToday, year))) {
          setFocusedYear(year);
          changeHasFocus(true);
          onYearFocus == null ? void 0 : onYearFocus(year);
        }
      }, [isYearDisabled, utils2, selectedDateOrToday, changeHasFocus, onYearFocus]);
      react.exports.useEffect(() => {
        setFocusedYear((prevFocusedYear) => currentYear !== null && prevFocusedYear !== currentYear ? currentYear : prevFocusedYear);
      }, [currentYear]);
      const yearsInRow = wrapperVariant === "desktop" ? 4 : 3;
      const handleKeyDown2 = react.exports.useCallback((event, year) => {
        switch (event.key) {
          case "ArrowUp":
            focusYear(year - yearsInRow);
            event.preventDefault();
            break;
          case "ArrowDown":
            focusYear(year + yearsInRow);
            event.preventDefault();
            break;
          case "ArrowLeft":
            focusYear(year + (theme.direction === "ltr" ? -1 : 1));
            event.preventDefault();
            break;
          case "ArrowRight":
            focusYear(year + (theme.direction === "ltr" ? 1 : -1));
            event.preventDefault();
            break;
        }
      }, [focusYear, theme.direction, yearsInRow]);
      const handleFocus = react.exports.useCallback((event, year) => {
        focusYear(year);
      }, [focusYear]);
      const handleBlur = react.exports.useCallback((event, year) => {
        if (focusedYear === year) {
          changeHasFocus(false);
        }
      }, [focusedYear, changeHasFocus]);
      const nowYear = utils2.getYear(now2);
      const scrollerRef = react.exports.useRef(null);
      const handleRef = useForkRef(ref, scrollerRef);
      react.exports.useEffect(() => {
        if (autoFocus || scrollerRef.current === null) {
          return;
        }
        const tabbableButton = scrollerRef.current.querySelector('[tabindex="0"]');
        if (!tabbableButton) {
          return;
        }
        const offsetHeight = tabbableButton.offsetHeight;
        const offsetTop = tabbableButton.offsetTop;
        const clientHeight = scrollerRef.current.clientHeight;
        const scrollTop = scrollerRef.current.scrollTop;
        const elementBottom = offsetTop + offsetHeight;
        if (offsetHeight > clientHeight || offsetTop < scrollTop) {
          return;
        }
        scrollerRef.current.scrollTop = elementBottom - clientHeight / 2 - offsetHeight / 2;
      }, [autoFocus]);
      return /* @__PURE__ */ jsx(YearPickerRoot, {
        ref: handleRef,
        className: clsx(classes.root, className),
        ownerState,
        children: utils2.getYearRange(minDate, maxDate).map((year) => {
          const yearNumber = utils2.getYear(year);
          const selected = yearNumber === currentYear;
          return /* @__PURE__ */ jsx(PickersYear, {
            selected,
            value: yearNumber,
            onClick: handleYearSelection,
            onKeyDown: handleKeyDown2,
            autoFocus: internalHasFocus && yearNumber === focusedYear,
            ref: selected ? selectedYearRef : void 0,
            disabled: disabled || isYearDisabled(year),
            tabIndex: yearNumber === focusedYear ? 0 : -1,
            onFocus: handleFocus,
            onBlur: handleBlur,
            "aria-current": nowYear === yearNumber ? "date" : void 0,
            children: utils2.format(year, "year")
          }, utils2.format(year, "year"));
        })
      });
    });
    const PickerViewRoot = styled$1("div")({
      overflowX: "hidden",
      width: DIALOG_WIDTH,
      maxHeight: VIEW_HEIGHT,
      display: "flex",
      flexDirection: "column",
      margin: "0 auto"
    });
    const defaultReduceAnimations = typeof navigator !== "undefined" && /(android)/i.test(navigator.userAgent);
    const getCalendarPickerUtilityClass = (slot) => generateUtilityClass("MuiCalendarPicker", slot);
    generateUtilityClasses("MuiCalendarPicker", ["root", "viewTransitionContainer"]);
    const _excluded$a = ["autoFocus", "onViewChange", "date", "disableFuture", "disablePast", "defaultCalendarMonth", "onChange", "onYearChange", "onMonthChange", "reduceAnimations", "shouldDisableDate", "shouldDisableMonth", "shouldDisableYear", "view", "views", "openTo", "className", "disabled", "readOnly", "minDate", "maxDate", "disableHighlightToday", "focusedView", "onFocusedViewChange", "classes"];
    const useUtilityClasses$8 = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        viewTransitionContainer: ["viewTransitionContainer"]
      };
      return composeClasses(slots, getCalendarPickerUtilityClass, classes);
    };
    function useCalendarPickerDefaultizedProps(props2, name) {
      const utils2 = useUtils();
      const defaultDates = useDefaultDates();
      const themeProps = useThemeProps({
        props: props2,
        name
      });
      return _extends({
        loading: false,
        disablePast: false,
        disableFuture: false,
        openTo: "day",
        views: ["year", "day"],
        reduceAnimations: defaultReduceAnimations,
        renderLoading: () => /* @__PURE__ */ jsx("span", {
          children: "..."
        })
      }, themeProps, {
        minDate: parseNonNullablePickerDate(utils2, themeProps.minDate, defaultDates.minDate),
        maxDate: parseNonNullablePickerDate(utils2, themeProps.maxDate, defaultDates.maxDate)
      });
    }
    const CalendarPickerRoot = styled$1(PickerViewRoot, {
      name: "MuiCalendarPicker",
      slot: "Root",
      overridesResolver: (props2, styles2) => styles2.root
    })({
      display: "flex",
      flexDirection: "column"
    });
    const CalendarPickerViewTransitionContainer = styled$1(PickersFadeTransitionGroup, {
      name: "MuiCalendarPicker",
      slot: "ViewTransitionContainer",
      overridesResolver: (props2, styles2) => styles2.viewTransitionContainer
    })({});
    const CalendarPicker = /* @__PURE__ */ react.exports.forwardRef(function CalendarPicker2(inProps, ref) {
      const utils2 = useUtils();
      const id2 = useId();
      const props2 = useCalendarPickerDefaultizedProps(inProps, "MuiCalendarPicker");
      const {
        autoFocus,
        onViewChange,
        date,
        disableFuture,
        disablePast,
        defaultCalendarMonth,
        onChange,
        onYearChange,
        onMonthChange,
        reduceAnimations,
        shouldDisableDate,
        shouldDisableMonth,
        shouldDisableYear,
        view,
        views,
        openTo,
        className,
        disabled,
        readOnly,
        minDate,
        maxDate,
        disableHighlightToday,
        focusedView,
        onFocusedViewChange
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$a);
      const {
        openView,
        setOpenView,
        openNext
      } = useViews({
        view,
        views,
        openTo,
        onChange,
        onViewChange
      });
      const {
        calendarState,
        changeFocusedDay,
        changeMonth,
        handleChangeMonth,
        isDateDisabled,
        onMonthSwitchingAnimationEnd
      } = useCalendarState({
        date,
        defaultCalendarMonth,
        reduceAnimations,
        onMonthChange,
        minDate,
        maxDate,
        shouldDisableDate,
        disablePast,
        disableFuture
      });
      const handleDateMonthChange = react.exports.useCallback((newDate, selectionState) => {
        const startOfMonth = utils2.startOfMonth(newDate);
        const endOfMonth = utils2.endOfMonth(newDate);
        const closestEnabledDate = isDateDisabled(newDate) ? findClosestEnabledDate({
          utils: utils2,
          date: newDate,
          minDate: utils2.isBefore(minDate, startOfMonth) ? startOfMonth : minDate,
          maxDate: utils2.isAfter(maxDate, endOfMonth) ? endOfMonth : maxDate,
          disablePast,
          disableFuture,
          isDateDisabled
        }) : newDate;
        if (closestEnabledDate) {
          onChange(closestEnabledDate, selectionState);
          onMonthChange == null ? void 0 : onMonthChange(startOfMonth);
        } else {
          openNext();
          changeMonth(startOfMonth);
        }
        changeFocusedDay(closestEnabledDate, true);
      }, [changeFocusedDay, disableFuture, disablePast, isDateDisabled, maxDate, minDate, onChange, onMonthChange, changeMonth, openNext, utils2]);
      const handleDateYearChange = react.exports.useCallback((newDate, selectionState) => {
        const startOfYear = utils2.startOfYear(newDate);
        const endOfYear = utils2.endOfYear(newDate);
        const closestEnabledDate = isDateDisabled(newDate) ? findClosestEnabledDate({
          utils: utils2,
          date: newDate,
          minDate: utils2.isBefore(minDate, startOfYear) ? startOfYear : minDate,
          maxDate: utils2.isAfter(maxDate, endOfYear) ? endOfYear : maxDate,
          disablePast,
          disableFuture,
          isDateDisabled
        }) : newDate;
        if (closestEnabledDate) {
          onChange(closestEnabledDate, selectionState);
          onYearChange == null ? void 0 : onYearChange(closestEnabledDate);
        } else {
          openNext();
          changeMonth(startOfYear);
        }
        changeFocusedDay(closestEnabledDate, true);
      }, [changeFocusedDay, disableFuture, disablePast, isDateDisabled, maxDate, minDate, onChange, onYearChange, openNext, utils2, changeMonth]);
      const onSelectedDayChange = react.exports.useCallback((day, isFinish) => {
        if (date && day) {
          return onChange(utils2.mergeDateAndTime(day, date), isFinish);
        }
        return onChange(day, isFinish);
      }, [utils2, date, onChange]);
      react.exports.useEffect(() => {
        if (date) {
          changeMonth(date);
        }
      }, [date]);
      const ownerState = props2;
      const classes = useUtilityClasses$8(ownerState);
      const baseDateValidationProps = {
        disablePast,
        disableFuture,
        maxDate,
        minDate
      };
      const minDateWithDisabled = disabled && date || minDate;
      const maxDateWithDisabled = disabled && date || maxDate;
      const commonViewProps = {
        disableHighlightToday,
        readOnly,
        disabled
      };
      const gridLabelId = `${id2}-grid-label`;
      const [internalFocusedView, setInternalFocusedView] = useControlled({
        name: "DayPicker",
        state: "focusedView",
        controlled: focusedView,
        default: autoFocus ? openView : null
      });
      const hasFocus = internalFocusedView !== null;
      const handleFocusedViewChange = useEventCallback((eventView) => (newHasFocus) => {
        if (onFocusedViewChange) {
          onFocusedViewChange(eventView)(newHasFocus);
          return;
        }
        if (newHasFocus) {
          setInternalFocusedView(eventView);
        } else {
          setInternalFocusedView((prevView) => prevView === eventView ? null : prevView);
        }
      });
      const prevOpenViewRef = react.exports.useRef(openView);
      react.exports.useEffect(() => {
        if (prevOpenViewRef.current === openView) {
          return;
        }
        prevOpenViewRef.current = openView;
        handleFocusedViewChange(openView)(true);
      }, [openView, handleFocusedViewChange]);
      return /* @__PURE__ */ jsxs(CalendarPickerRoot, {
        ref,
        className: clsx(classes.root, className),
        ownerState,
        children: [/* @__PURE__ */ jsx(PickersCalendarHeader, _extends({}, other, {
          views,
          openView,
          currentMonth: calendarState.currentMonth,
          onViewChange: setOpenView,
          onMonthChange: (newMonth, direction) => handleChangeMonth({
            newMonth,
            direction
          }),
          minDate: minDateWithDisabled,
          maxDate: maxDateWithDisabled,
          disabled,
          disablePast,
          disableFuture,
          reduceAnimations,
          labelId: gridLabelId
        })), /* @__PURE__ */ jsx(CalendarPickerViewTransitionContainer, {
          reduceAnimations,
          className: classes.viewTransitionContainer,
          transKey: openView,
          ownerState,
          children: /* @__PURE__ */ jsxs("div", {
            children: [openView === "year" && /* @__PURE__ */ jsx(YearPicker, _extends({}, other, baseDateValidationProps, commonViewProps, {
              autoFocus,
              date,
              onChange: handleDateYearChange,
              shouldDisableYear,
              hasFocus,
              onFocusedViewChange: handleFocusedViewChange("year")
            })), openView === "month" && /* @__PURE__ */ jsx(MonthPicker, _extends({}, baseDateValidationProps, commonViewProps, {
              autoFocus,
              hasFocus,
              className,
              date,
              onChange: handleDateMonthChange,
              shouldDisableMonth,
              onFocusedViewChange: handleFocusedViewChange("month")
            })), openView === "day" && /* @__PURE__ */ jsx(DayPicker, _extends({}, other, calendarState, baseDateValidationProps, commonViewProps, {
              autoFocus,
              onMonthSwitchingAnimationEnd,
              onFocusedDayChange: changeFocusedDay,
              reduceAnimations,
              selectedDays: [date],
              onSelectedDaysChange: onSelectedDayChange,
              shouldDisableDate,
              hasFocus,
              onFocusedViewChange: handleFocusedViewChange("day"),
              gridLabelId
            }))]
          })
        })]
      });
    });
    const CLOCK_WIDTH = 220;
    const CLOCK_HOUR_WIDTH = 36;
    const clockCenter = {
      x: CLOCK_WIDTH / 2,
      y: CLOCK_WIDTH / 2
    };
    const baseClockPoint = {
      x: clockCenter.x,
      y: 0
    };
    const cx = baseClockPoint.x - clockCenter.x;
    const cy = baseClockPoint.y - clockCenter.y;
    const rad2deg = (rad) => rad * (180 / Math.PI);
    const getAngleValue = (step, offsetX, offsetY) => {
      const x2 = offsetX - clockCenter.x;
      const y2 = offsetY - clockCenter.y;
      const atan = Math.atan2(cx, cy) - Math.atan2(x2, y2);
      let deg = rad2deg(atan);
      deg = Math.round(deg / step) * step;
      deg %= 360;
      const value = Math.floor(deg / step) || 0;
      const delta = x2 ** 2 + y2 ** 2;
      const distance = Math.sqrt(delta);
      return {
        value,
        distance
      };
    };
    const getMinutes = (offsetX, offsetY, step = 1) => {
      const angleStep = step * 6;
      let {
        value
      } = getAngleValue(angleStep, offsetX, offsetY);
      value = value * step % 60;
      return value;
    };
    const getHours = (offsetX, offsetY, ampm) => {
      const {
        value,
        distance
      } = getAngleValue(30, offsetX, offsetY);
      let hour = value || 12;
      if (!ampm) {
        if (distance < CLOCK_WIDTH / 2 - CLOCK_HOUR_WIDTH) {
          hour += 12;
          hour %= 24;
        }
      } else {
        hour %= 12;
      }
      return hour;
    };
    function getClockPointerUtilityClass(slot) {
      return generateUtilityClass("MuiClockPointer", slot);
    }
    generateUtilityClasses("MuiClockPointer", ["root", "thumb"]);
    const _excluded$9 = ["className", "hasSelected", "isInner", "type", "value"];
    const useUtilityClasses$7 = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        thumb: ["thumb"]
      };
      return composeClasses(slots, getClockPointerUtilityClass, classes);
    };
    const ClockPointerRoot = styled$1("div", {
      name: "MuiClockPointer",
      slot: "Root",
      overridesResolver: (_2, styles2) => styles2.root
    })(({
      theme,
      ownerState
    }) => _extends({
      width: 2,
      backgroundColor: theme.palette.primary.main,
      position: "absolute",
      left: "calc(50% - 1px)",
      bottom: "50%",
      transformOrigin: "center bottom 0px"
    }, ownerState.shouldAnimate && {
      transition: theme.transitions.create(["transform", "height"])
    }));
    const ClockPointerThumb = styled$1("div", {
      name: "MuiClockPointer",
      slot: "Thumb",
      overridesResolver: (_2, styles2) => styles2.thumb
    })(({
      theme,
      ownerState
    }) => _extends({
      width: 4,
      height: 4,
      backgroundColor: theme.palette.primary.contrastText,
      borderRadius: "50%",
      position: "absolute",
      top: -21,
      left: `calc(50% - ${CLOCK_HOUR_WIDTH / 2}px)`,
      border: `${(CLOCK_HOUR_WIDTH - 4) / 2}px solid ${theme.palette.primary.main}`,
      boxSizing: "content-box"
    }, ownerState.hasSelected && {
      backgroundColor: theme.palette.primary.main
    }));
    function ClockPointer(inProps) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiClockPointer"
      });
      const {
        className,
        isInner,
        type: type2,
        value
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$9);
      const previousType = react.exports.useRef(type2);
      react.exports.useEffect(() => {
        previousType.current = type2;
      }, [type2]);
      const ownerState = _extends({}, props2, {
        shouldAnimate: previousType.current !== type2
      });
      const classes = useUtilityClasses$7(ownerState);
      const getAngleStyle = () => {
        const max2 = type2 === "hours" ? 12 : 60;
        let angle = 360 / max2 * value;
        if (type2 === "hours" && value > 12) {
          angle -= 360;
        }
        return {
          height: Math.round((isInner ? 0.26 : 0.4) * CLOCK_WIDTH),
          transform: `rotateZ(${angle}deg)`
        };
      };
      return /* @__PURE__ */ jsx(ClockPointerRoot, _extends({
        style: getAngleStyle(),
        className: clsx(className, classes.root),
        ownerState
      }, other, {
        children: /* @__PURE__ */ jsx(ClockPointerThumb, {
          ownerState,
          className: classes.thumb
        })
      }));
    }
    function getClockUtilityClass(slot) {
      return generateUtilityClass("MuiClock", slot);
    }
    generateUtilityClasses("MuiClock", ["root", "clock", "wrapper", "squareMask", "pin", "amButton", "pmButton"]);
    const useUtilityClasses$6 = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        clock: ["clock"],
        wrapper: ["wrapper"],
        squareMask: ["squareMask"],
        pin: ["pin"],
        amButton: ["amButton"],
        pmButton: ["pmButton"]
      };
      return composeClasses(slots, getClockUtilityClass, classes);
    };
    const ClockRoot = styled$1("div", {
      name: "MuiClock",
      slot: "Root",
      overridesResolver: (_2, styles2) => styles2.root
    })(({
      theme
    }) => ({
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      margin: theme.spacing(2)
    }));
    const ClockClock = styled$1("div", {
      name: "MuiClock",
      slot: "Clock",
      overridesResolver: (_2, styles2) => styles2.clock
    })({
      backgroundColor: "rgba(0,0,0,.07)",
      borderRadius: "50%",
      height: 220,
      width: 220,
      flexShrink: 0,
      position: "relative",
      pointerEvents: "none"
    });
    const ClockWrapper = styled$1("div", {
      name: "MuiClock",
      slot: "Wrapper",
      overridesResolver: (_2, styles2) => styles2.wrapper
    })({
      "&:focus": {
        outline: "none"
      }
    });
    const ClockSquareMask = styled$1("div", {
      name: "MuiClock",
      slot: "SquareMask",
      overridesResolver: (_2, styles2) => styles2.squareMask
    })(({
      ownerState
    }) => _extends({
      width: "100%",
      height: "100%",
      position: "absolute",
      pointerEvents: "auto",
      outline: 0,
      touchAction: "none",
      userSelect: "none"
    }, ownerState.disabled ? {} : {
      "@media (pointer: fine)": {
        cursor: "pointer",
        borderRadius: "50%"
      },
      "&:active": {
        cursor: "move"
      }
    }));
    const ClockPin = styled$1("div", {
      name: "MuiClock",
      slot: "Pin",
      overridesResolver: (_2, styles2) => styles2.pin
    })(({
      theme
    }) => ({
      width: 6,
      height: 6,
      borderRadius: "50%",
      backgroundColor: theme.palette.primary.main,
      position: "absolute",
      top: "50%",
      left: "50%",
      transform: "translate(-50%, -50%)"
    }));
    const ClockAmButton = styled$1(IconButton$1, {
      name: "MuiClock",
      slot: "AmButton",
      overridesResolver: (_2, styles2) => styles2.amButton
    })(({
      theme,
      ownerState
    }) => _extends({
      zIndex: 1,
      position: "absolute",
      bottom: ownerState.ampmInClock ? 64 : 8,
      left: 8
    }, ownerState.meridiemMode === "am" && {
      backgroundColor: theme.palette.primary.main,
      color: theme.palette.primary.contrastText,
      "&:hover": {
        backgroundColor: theme.palette.primary.light
      }
    }));
    const ClockPmButton = styled$1(IconButton$1, {
      name: "MuiClock",
      slot: "PmButton",
      overridesResolver: (_2, styles2) => styles2.pmButton
    })(({
      theme,
      ownerState
    }) => _extends({
      zIndex: 1,
      position: "absolute",
      bottom: ownerState.ampmInClock ? 64 : 8,
      right: 8
    }, ownerState.meridiemMode === "pm" && {
      backgroundColor: theme.palette.primary.main,
      color: theme.palette.primary.contrastText,
      "&:hover": {
        backgroundColor: theme.palette.primary.light
      }
    }));
    function Clock(inProps) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiClock"
      });
      const {
        ampm,
        ampmInClock,
        autoFocus,
        children,
        date,
        getClockLabelText,
        handleMeridiemChange,
        isTimeDisabled,
        meridiemMode,
        minutesStep = 1,
        onChange,
        selectedId,
        type: type2,
        value,
        disabled,
        readOnly,
        className
      } = props2;
      const ownerState = props2;
      const utils2 = useUtils();
      const wrapperVariant = react.exports.useContext(WrapperVariantContext);
      const isMoving = react.exports.useRef(false);
      const classes = useUtilityClasses$6(ownerState);
      const isSelectedTimeDisabled = isTimeDisabled(value, type2);
      const isPointerInner = !ampm && type2 === "hours" && (value < 1 || value > 12);
      const handleValueChange = (newValue, isFinish) => {
        if (disabled || readOnly) {
          return;
        }
        if (isTimeDisabled(newValue, type2)) {
          return;
        }
        onChange(newValue, isFinish);
      };
      const setTime = (event, isFinish) => {
        let {
          offsetX,
          offsetY
        } = event;
        if (offsetX === void 0) {
          const rect = event.target.getBoundingClientRect();
          offsetX = event.changedTouches[0].clientX - rect.left;
          offsetY = event.changedTouches[0].clientY - rect.top;
        }
        const newSelectedValue = type2 === "seconds" || type2 === "minutes" ? getMinutes(offsetX, offsetY, minutesStep) : getHours(offsetX, offsetY, Boolean(ampm));
        handleValueChange(newSelectedValue, isFinish);
      };
      const handleTouchMove = (event) => {
        isMoving.current = true;
        setTime(event, "shallow");
      };
      const handleTouchEnd = (event) => {
        if (isMoving.current) {
          setTime(event, "finish");
          isMoving.current = false;
        }
      };
      const handleMouseMove = (event) => {
        if (event.buttons > 0) {
          setTime(event.nativeEvent, "shallow");
        }
      };
      const handleMouseUp = (event) => {
        if (isMoving.current) {
          isMoving.current = false;
        }
        setTime(event.nativeEvent, "finish");
      };
      const hasSelected = react.exports.useMemo(() => {
        if (type2 === "hours") {
          return true;
        }
        return value % 5 === 0;
      }, [type2, value]);
      const keyboardControlStep = type2 === "minutes" ? minutesStep : 1;
      const listboxRef = react.exports.useRef(null);
      useEnhancedEffect$1(() => {
        if (autoFocus) {
          listboxRef.current.focus();
        }
      }, [autoFocus]);
      const handleKeyDown2 = (event) => {
        if (isMoving.current) {
          return;
        }
        switch (event.key) {
          case "Home":
            handleValueChange(0, "partial");
            event.preventDefault();
            break;
          case "End":
            handleValueChange(type2 === "minutes" ? 59 : 23, "partial");
            event.preventDefault();
            break;
          case "ArrowUp":
            handleValueChange(value + keyboardControlStep, "partial");
            event.preventDefault();
            break;
          case "ArrowDown":
            handleValueChange(value - keyboardControlStep, "partial");
            event.preventDefault();
            break;
        }
      };
      return /* @__PURE__ */ jsxs(ClockRoot, {
        className: clsx(className, classes.root),
        children: [/* @__PURE__ */ jsxs(ClockClock, {
          className: classes.clock,
          children: [/* @__PURE__ */ jsx(ClockSquareMask, {
            onTouchMove: handleTouchMove,
            onTouchEnd: handleTouchEnd,
            onMouseUp: handleMouseUp,
            onMouseMove: handleMouseMove,
            ownerState: {
              disabled
            },
            className: classes.squareMask
          }), !isSelectedTimeDisabled && /* @__PURE__ */ jsxs(react.exports.Fragment, {
            children: [/* @__PURE__ */ jsx(ClockPin, {
              className: classes.pin
            }), date && /* @__PURE__ */ jsx(ClockPointer, {
              type: type2,
              value,
              isInner: isPointerInner,
              hasSelected
            })]
          }), /* @__PURE__ */ jsx(ClockWrapper, {
            "aria-activedescendant": selectedId,
            "aria-label": getClockLabelText(type2, date, utils2),
            ref: listboxRef,
            role: "listbox",
            onKeyDown: handleKeyDown2,
            tabIndex: 0,
            className: classes.wrapper,
            children
          })]
        }), ampm && (wrapperVariant === "desktop" || ampmInClock) && /* @__PURE__ */ jsxs(react.exports.Fragment, {
          children: [/* @__PURE__ */ jsx(ClockAmButton, {
            onClick: readOnly ? void 0 : () => handleMeridiemChange("am"),
            disabled: disabled || meridiemMode === null,
            ownerState,
            className: classes.amButton,
            children: /* @__PURE__ */ jsx(Typography$1, {
              variant: "caption",
              children: "AM"
            })
          }), /* @__PURE__ */ jsx(ClockPmButton, {
            disabled: disabled || meridiemMode === null,
            onClick: readOnly ? void 0 : () => handleMeridiemChange("pm"),
            ownerState,
            className: classes.pmButton,
            children: /* @__PURE__ */ jsx(Typography$1, {
              variant: "caption",
              children: "PM"
            })
          })]
        })]
      });
    }
    function getClockNumberUtilityClass(slot) {
      return generateUtilityClass("MuiClockNumber", slot);
    }
    const clockNumberClasses = generateUtilityClasses("MuiClockNumber", ["root", "selected", "disabled"]);
    const _excluded$8 = ["className", "disabled", "index", "inner", "label", "selected"];
    const useUtilityClasses$5 = (ownerState) => {
      const {
        classes,
        selected,
        disabled
      } = ownerState;
      const slots = {
        root: ["root", selected && "selected", disabled && "disabled"]
      };
      return composeClasses(slots, getClockNumberUtilityClass, classes);
    };
    const ClockNumberRoot = styled$1("span", {
      name: "MuiClockNumber",
      slot: "Root",
      overridesResolver: (_2, styles2) => [styles2.root, {
        [`&.${clockNumberClasses.disabled}`]: styles2.disabled
      }, {
        [`&.${clockNumberClasses.selected}`]: styles2.selected
      }]
    })(({
      theme,
      ownerState
    }) => _extends({
      height: CLOCK_HOUR_WIDTH,
      width: CLOCK_HOUR_WIDTH,
      position: "absolute",
      left: `calc((100% - ${CLOCK_HOUR_WIDTH}px) / 2)`,
      display: "inline-flex",
      justifyContent: "center",
      alignItems: "center",
      borderRadius: "50%",
      color: theme.palette.text.primary,
      fontFamily: theme.typography.fontFamily,
      "&:focused": {
        backgroundColor: theme.palette.background.paper
      },
      [`&.${clockNumberClasses.selected}`]: {
        color: theme.palette.primary.contrastText
      },
      [`&.${clockNumberClasses.disabled}`]: {
        pointerEvents: "none",
        color: theme.palette.text.disabled
      }
    }, ownerState.inner && _extends({}, theme.typography.body2, {
      color: theme.palette.text.secondary
    })));
    function ClockNumber(inProps) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiClockNumber"
      });
      const {
        className,
        disabled,
        index: index2,
        inner,
        label,
        selected
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$8);
      const ownerState = props2;
      const classes = useUtilityClasses$5(ownerState);
      const angle = index2 % 12 / 12 * Math.PI * 2 - Math.PI / 2;
      const length2 = (CLOCK_WIDTH - CLOCK_HOUR_WIDTH - 2) / 2 * (inner ? 0.65 : 1);
      const x2 = Math.round(Math.cos(angle) * length2);
      const y2 = Math.round(Math.sin(angle) * length2);
      return /* @__PURE__ */ jsx(ClockNumberRoot, _extends({
        className: clsx(className, classes.root),
        "aria-disabled": disabled ? true : void 0,
        "aria-selected": selected ? true : void 0,
        role: "option",
        style: {
          transform: `translate(${x2}px, ${y2 + (CLOCK_WIDTH - CLOCK_HOUR_WIDTH) / 2}px`
        },
        ownerState
      }, other, {
        children: label
      }));
    }
    const getHourNumbers = ({
      ampm,
      date,
      getClockNumberText,
      isDisabled,
      selectedId,
      utils: utils2
    }) => {
      const currentHours = date ? utils2.getHours(date) : null;
      const hourNumbers = [];
      const startHour = ampm ? 1 : 0;
      const endHour = ampm ? 12 : 23;
      const isSelected = (hour) => {
        if (currentHours === null) {
          return false;
        }
        if (ampm) {
          if (hour === 12) {
            return currentHours === 12 || currentHours === 0;
          }
          return currentHours === hour || currentHours - 12 === hour;
        }
        return currentHours === hour;
      };
      for (let hour = startHour; hour <= endHour; hour += 1) {
        let label = hour.toString();
        if (hour === 0) {
          label = "00";
        }
        const inner = !ampm && (hour === 0 || hour > 12);
        label = utils2.formatNumber(label);
        const selected = isSelected(hour);
        hourNumbers.push(/* @__PURE__ */ jsx(ClockNumber, {
          id: selected ? selectedId : void 0,
          index: hour,
          inner,
          selected,
          disabled: isDisabled(hour),
          label,
          "aria-label": getClockNumberText(label)
        }, hour));
      }
      return hourNumbers;
    };
    const getMinutesNumbers = ({
      utils: utils2,
      value,
      isDisabled,
      getClockNumberText,
      selectedId
    }) => {
      const f2 = utils2.formatNumber;
      return [[5, f2("05")], [10, f2("10")], [15, f2("15")], [20, f2("20")], [25, f2("25")], [30, f2("30")], [35, f2("35")], [40, f2("40")], [45, f2("45")], [50, f2("50")], [55, f2("55")], [0, f2("00")]].map(([numberValue, label], index2) => {
        const selected = numberValue === value;
        return /* @__PURE__ */ jsx(ClockNumber, {
          label,
          id: selected ? selectedId : void 0,
          index: index2 + 1,
          inner: false,
          disabled: isDisabled(numberValue),
          selected,
          "aria-label": getClockNumberText(label)
        }, numberValue);
      });
    };
    function getClockPickerUtilityClass(slot) {
      return generateUtilityClass("MuiClockPicker", slot);
    }
    generateUtilityClasses("MuiClockPicker", ["root", "arrowSwitcher"]);
    const useUtilityClasses$4 = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        arrowSwitcher: ["arrowSwitcher"]
      };
      return composeClasses(slots, getClockPickerUtilityClass, classes);
    };
    const ClockPickerRoot = styled$1(PickerViewRoot, {
      name: "MuiClockPicker",
      slot: "Root",
      overridesResolver: (props2, styles2) => styles2.root
    })({
      display: "flex",
      flexDirection: "column"
    });
    const ClockPickerArrowSwitcher = styled$1(PickersArrowSwitcher, {
      name: "MuiClockPicker",
      slot: "ArrowSwitcher",
      overridesResolver: (props2, styles2) => styles2.arrowSwitcher
    })({
      position: "absolute",
      right: 12,
      top: 15
    });
    const deprecatedPropsWarning = buildDeprecatedPropsWarning();
    const ClockPicker = /* @__PURE__ */ react.exports.forwardRef(function ClockPicker2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiClockPicker"
      });
      const {
        ampm = false,
        ampmInClock = false,
        autoFocus,
        components,
        componentsProps,
        date,
        disableIgnoringDatePartForTimeValidation,
        getClockLabelText: getClockLabelTextProp,
        getHoursClockNumberText: getHoursClockNumberTextProp,
        getMinutesClockNumberText: getMinutesClockNumberTextProp,
        getSecondsClockNumberText: getSecondsClockNumberTextProp,
        leftArrowButtonText: leftArrowButtonTextProp,
        maxTime,
        minTime,
        minutesStep = 1,
        rightArrowButtonText: rightArrowButtonTextProp,
        shouldDisableTime,
        showViewSwitcher,
        onChange,
        view,
        views = ["hours", "minutes"],
        openTo,
        onViewChange,
        className,
        disabled,
        readOnly
      } = props2;
      deprecatedPropsWarning({
        leftArrowButtonText: leftArrowButtonTextProp,
        rightArrowButtonText: rightArrowButtonTextProp,
        getClockLabelText: getClockLabelTextProp,
        getHoursClockNumberText: getHoursClockNumberTextProp,
        getMinutesClockNumberText: getMinutesClockNumberTextProp,
        getSecondsClockNumberText: getSecondsClockNumberTextProp
      });
      const localeText = useLocaleText();
      const leftArrowButtonText = leftArrowButtonTextProp != null ? leftArrowButtonTextProp : localeText.openPreviousView;
      const rightArrowButtonText = rightArrowButtonTextProp != null ? rightArrowButtonTextProp : localeText.openNextView;
      const getClockLabelText = getClockLabelTextProp != null ? getClockLabelTextProp : localeText.clockLabelText;
      const getHoursClockNumberText = getHoursClockNumberTextProp != null ? getHoursClockNumberTextProp : localeText.hoursClockNumberText;
      const getMinutesClockNumberText = getMinutesClockNumberTextProp != null ? getMinutesClockNumberTextProp : localeText.minutesClockNumberText;
      const getSecondsClockNumberText = getSecondsClockNumberTextProp != null ? getSecondsClockNumberTextProp : localeText.secondsClockNumberText;
      const {
        openView,
        setOpenView,
        nextView,
        previousView,
        handleChangeAndOpenNext
      } = useViews({
        view,
        views,
        openTo,
        onViewChange,
        onChange
      });
      const now2 = useNow();
      const utils2 = useUtils();
      const dateOrMidnight = react.exports.useMemo(() => date || utils2.setSeconds(utils2.setMinutes(utils2.setHours(now2, 0), 0), 0), [date, now2, utils2]);
      const {
        meridiemMode,
        handleMeridiemChange
      } = useMeridiemMode(dateOrMidnight, ampm, handleChangeAndOpenNext);
      const isTimeDisabled = react.exports.useCallback((rawValue, viewType) => {
        const isAfter2 = createIsAfterIgnoreDatePart(disableIgnoringDatePartForTimeValidation, utils2);
        const containsValidTime = ({
          start: start2,
          end: end2
        }) => {
          if (minTime && isAfter2(minTime, end2)) {
            return false;
          }
          if (maxTime && isAfter2(start2, maxTime)) {
            return false;
          }
          return true;
        };
        const isValidValue = (value, step = 1) => {
          if (value % step !== 0) {
            return false;
          }
          if (shouldDisableTime) {
            return !shouldDisableTime(value, viewType);
          }
          return true;
        };
        switch (viewType) {
          case "hours": {
            const value = convertValueToMeridiem(rawValue, meridiemMode, ampm);
            const dateWithNewHours = utils2.setHours(dateOrMidnight, value);
            const start2 = utils2.setSeconds(utils2.setMinutes(dateWithNewHours, 0), 0);
            const end2 = utils2.setSeconds(utils2.setMinutes(dateWithNewHours, 59), 59);
            return !containsValidTime({
              start: start2,
              end: end2
            }) || !isValidValue(value);
          }
          case "minutes": {
            const dateWithNewMinutes = utils2.setMinutes(dateOrMidnight, rawValue);
            const start2 = utils2.setSeconds(dateWithNewMinutes, 0);
            const end2 = utils2.setSeconds(dateWithNewMinutes, 59);
            return !containsValidTime({
              start: start2,
              end: end2
            }) || !isValidValue(rawValue, minutesStep);
          }
          case "seconds": {
            const dateWithNewSeconds = utils2.setSeconds(dateOrMidnight, rawValue);
            const start2 = dateWithNewSeconds;
            const end2 = dateWithNewSeconds;
            return !containsValidTime({
              start: start2,
              end: end2
            }) || !isValidValue(rawValue);
          }
          default:
            throw new Error("not supported");
        }
      }, [ampm, dateOrMidnight, disableIgnoringDatePartForTimeValidation, maxTime, meridiemMode, minTime, minutesStep, shouldDisableTime, utils2]);
      const selectedId = useId();
      const viewProps = react.exports.useMemo(() => {
        switch (openView) {
          case "hours": {
            const handleHoursChange = (value, isFinish) => {
              const valueWithMeridiem = convertValueToMeridiem(value, meridiemMode, ampm);
              handleChangeAndOpenNext(utils2.setHours(dateOrMidnight, valueWithMeridiem), isFinish);
            };
            return {
              onChange: handleHoursChange,
              value: utils2.getHours(dateOrMidnight),
              children: getHourNumbers({
                date,
                utils: utils2,
                ampm,
                onChange: handleHoursChange,
                getClockNumberText: getHoursClockNumberText,
                isDisabled: (value) => disabled || isTimeDisabled(value, "hours"),
                selectedId
              })
            };
          }
          case "minutes": {
            const minutesValue = utils2.getMinutes(dateOrMidnight);
            const handleMinutesChange = (value, isFinish) => {
              handleChangeAndOpenNext(utils2.setMinutes(dateOrMidnight, value), isFinish);
            };
            return {
              value: minutesValue,
              onChange: handleMinutesChange,
              children: getMinutesNumbers({
                utils: utils2,
                value: minutesValue,
                onChange: handleMinutesChange,
                getClockNumberText: getMinutesClockNumberText,
                isDisabled: (value) => disabled || isTimeDisabled(value, "minutes"),
                selectedId
              })
            };
          }
          case "seconds": {
            const secondsValue = utils2.getSeconds(dateOrMidnight);
            const handleSecondsChange = (value, isFinish) => {
              handleChangeAndOpenNext(utils2.setSeconds(dateOrMidnight, value), isFinish);
            };
            return {
              value: secondsValue,
              onChange: handleSecondsChange,
              children: getMinutesNumbers({
                utils: utils2,
                value: secondsValue,
                onChange: handleSecondsChange,
                getClockNumberText: getSecondsClockNumberText,
                isDisabled: (value) => disabled || isTimeDisabled(value, "seconds"),
                selectedId
              })
            };
          }
          default:
            throw new Error("You must provide the type for ClockView");
        }
      }, [openView, utils2, date, ampm, getHoursClockNumberText, getMinutesClockNumberText, getSecondsClockNumberText, meridiemMode, handleChangeAndOpenNext, dateOrMidnight, isTimeDisabled, selectedId, disabled]);
      const ownerState = props2;
      const classes = useUtilityClasses$4(ownerState);
      return /* @__PURE__ */ jsxs(ClockPickerRoot, {
        ref,
        className: clsx(classes.root, className),
        ownerState,
        children: [showViewSwitcher && /* @__PURE__ */ jsx(ClockPickerArrowSwitcher, {
          className: classes.arrowSwitcher,
          leftArrowButtonText,
          rightArrowButtonText,
          components,
          componentsProps,
          onLeftClick: () => setOpenView(previousView),
          onRightClick: () => setOpenView(nextView),
          isLeftDisabled: !previousView,
          isRightDisabled: !nextView,
          ownerState
        }), /* @__PURE__ */ jsx(Clock, _extends({
          autoFocus,
          date,
          ampmInClock,
          type: openView,
          ampm,
          getClockLabelText,
          minutesStep,
          isTimeDisabled,
          meridiemMode,
          handleMeridiemChange,
          selectedId,
          disabled,
          readOnly
        }, viewProps))]
      });
    });
    const isYearOnlyView = (views) => views.length === 1 && views[0] === "year";
    const isYearAndMonthViews = (views) => views.length === 2 && views.indexOf("month") !== -1 && views.indexOf("year") !== -1;
    const getFormatAndMaskByViews = (views, utils2) => {
      if (isYearOnlyView(views)) {
        return {
          inputFormat: utils2.formats.year
        };
      }
      if (isYearAndMonthViews(views)) {
        return {
          disableMaskedInput: true,
          inputFormat: utils2.formats.monthAndYear
        };
      }
      return {
        inputFormat: utils2.formats.keyboardDate
      };
    };
    function useDatePickerDefaultizedProps(props2, name) {
      var _themeProps$views;
      const utils2 = useUtils();
      const defaultDates = useDefaultDates();
      const themeProps = useThemeProps({
        props: props2,
        name
      });
      const views = (_themeProps$views = themeProps.views) != null ? _themeProps$views : ["year", "day"];
      return _extends({
        openTo: "day",
        disableFuture: false,
        disablePast: false
      }, getFormatAndMaskByViews(views, utils2), themeProps, {
        views,
        minDate: parseNonNullablePickerDate(utils2, themeProps.minDate, defaultDates.minDate),
        maxDate: parseNonNullablePickerDate(utils2, themeProps.maxDate, defaultDates.maxDate)
      });
    }
    const datePickerValueManager = {
      emptyValue: null,
      getTodayValue: (utils2) => utils2.date(),
      parseInput: parsePickerInputValue,
      areValuesEqual: (utils2, a, b2) => utils2.isEqual(a, b2)
    };
    function getPickersToolbarUtilityClass(slot) {
      return generateUtilityClass("MuiPickersToolbar", slot);
    }
    const pickersToolbarClasses = generateUtilityClasses("MuiPickersToolbar", ["root", "content", "penIconButton", "penIconButtonLandscape"]);
    const useUtilityClasses$3 = (ownerState) => {
      const {
        classes,
        isLandscape
      } = ownerState;
      const slots = {
        root: ["root"],
        content: ["content"],
        penIconButton: ["penIconButton", isLandscape && "penIconButtonLandscape"]
      };
      return composeClasses(slots, getPickersToolbarUtilityClass, classes);
    };
    const PickersToolbarRoot = styled$1("div", {
      name: "MuiPickersToolbar",
      slot: "Root",
      overridesResolver: (props2, styles2) => styles2.root
    })(({
      theme,
      ownerState
    }) => _extends({
      display: "flex",
      flexDirection: "column",
      alignItems: "flex-start",
      justifyContent: "space-between",
      padding: theme.spacing(2, 3)
    }, ownerState.isLandscape && {
      height: "auto",
      maxWidth: 160,
      padding: 16,
      justifyContent: "flex-start",
      flexWrap: "wrap"
    }));
    const PickersToolbarContent = styled$1(Grid$1, {
      name: "MuiPickersToolbar",
      slot: "Content",
      overridesResolver: (props2, styles2) => styles2.content
    })({
      flex: 1
    });
    const PickersToolbarPenIconButton = styled$1(IconButton$1, {
      name: "MuiPickersToolbar",
      slot: "PenIconButton",
      overridesResolver: (props2, styles2) => [{
        [`&.${pickersToolbarClasses.penIconButtonLandscape}`]: styles2.penIconButtonLandscape
      }, styles2.penIconButton]
    })({});
    const getViewTypeIcon = (viewType) => viewType === "clock" ? /* @__PURE__ */ jsx(Clock$1, {
      color: "inherit"
    }) : /* @__PURE__ */ jsx(Calendar, {
      color: "inherit"
    });
    const PickersToolbar = /* @__PURE__ */ react.exports.forwardRef(function PickersToolbar2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiPickersToolbar"
      });
      const {
        children,
        className,
        getMobileKeyboardInputViewButtonText,
        isLandscape,
        isMobileKeyboardViewOpen,
        landscapeDirection = "column",
        toggleMobileKeyboardView,
        toolbarTitle,
        viewType = "calendar"
      } = props2;
      const ownerState = props2;
      const localeText = useLocaleText();
      const classes = useUtilityClasses$3(ownerState);
      return /* @__PURE__ */ jsxs(PickersToolbarRoot, {
        ref,
        className: clsx(classes.root, className),
        ownerState,
        children: [/* @__PURE__ */ jsx(Typography$1, {
          color: "text.secondary",
          variant: "overline",
          children: toolbarTitle
        }), /* @__PURE__ */ jsxs(PickersToolbarContent, {
          container: true,
          justifyContent: "space-between",
          className: classes.content,
          ownerState,
          direction: isLandscape ? landscapeDirection : "row",
          alignItems: isLandscape ? "flex-start" : "flex-end",
          children: [children, /* @__PURE__ */ jsx(PickersToolbarPenIconButton, {
            onClick: toggleMobileKeyboardView,
            className: classes.penIconButton,
            ownerState,
            color: "inherit",
            "aria-label": getMobileKeyboardInputViewButtonText ? getMobileKeyboardInputViewButtonText(isMobileKeyboardViewOpen, viewType) : localeText.inputModeToggleButtonAriaLabel(isMobileKeyboardViewOpen, viewType),
            children: isMobileKeyboardViewOpen ? getViewTypeIcon(viewType) : /* @__PURE__ */ jsx(Pen, {
              color: "inherit"
            })
          })]
        })]
      });
    });
    function getDatePickerToolbarUtilityClass(slot) {
      return generateUtilityClass("MuiDatePickerToolbar", slot);
    }
    generateUtilityClasses("MuiDatePickerToolbar", ["root", "title"]);
    const _excluded$7 = ["parsedValue", "isLandscape", "isMobileKeyboardViewOpen", "onChange", "toggleMobileKeyboardView", "toolbarFormat", "toolbarPlaceholder", "toolbarTitle", "views"];
    const useUtilityClasses$2 = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        title: ["title"]
      };
      return composeClasses(slots, getDatePickerToolbarUtilityClass, classes);
    };
    const DatePickerToolbarRoot = styled$1(PickersToolbar, {
      name: "MuiDatePickerToolbar",
      slot: "Root",
      overridesResolver: (_2, styles2) => styles2.root
    })({
      [`& .${pickersToolbarClasses.penIconButton}`]: {
        position: "relative",
        top: 4
      }
    });
    const DatePickerToolbarTitle = styled$1(Typography$1, {
      name: "MuiDatePickerToolbar",
      slot: "Title",
      overridesResolver: (_2, styles2) => styles2.title
    })(({
      ownerState
    }) => _extends({}, ownerState.isLandscape && {
      margin: "auto 16px auto auto"
    }));
    const DatePickerToolbar = /* @__PURE__ */ react.exports.forwardRef(function DatePickerToolbar2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiDatePickerToolbar"
      });
      const {
        parsedValue,
        isLandscape,
        isMobileKeyboardViewOpen,
        toggleMobileKeyboardView,
        toolbarFormat,
        toolbarPlaceholder = "\u2013\u2013",
        toolbarTitle: toolbarTitleProp,
        views
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$7);
      const utils2 = useUtils();
      const localeText = useLocaleText();
      const classes = useUtilityClasses$2(props2);
      const toolbarTitle = toolbarTitleProp != null ? toolbarTitleProp : localeText.datePickerDefaultToolbarTitle;
      const dateText = react.exports.useMemo(() => {
        if (!parsedValue) {
          return toolbarPlaceholder;
        }
        if (toolbarFormat) {
          return utils2.formatByString(parsedValue, toolbarFormat);
        }
        if (isYearOnlyView(views)) {
          return utils2.format(parsedValue, "year");
        }
        if (isYearAndMonthViews(views)) {
          return utils2.format(parsedValue, "month");
        }
        return /en/.test(utils2.getCurrentLocaleCode()) ? utils2.format(parsedValue, "normalDateWithWeekday") : utils2.format(parsedValue, "normalDate");
      }, [parsedValue, toolbarFormat, toolbarPlaceholder, utils2, views]);
      const ownerState = props2;
      return /* @__PURE__ */ jsx(DatePickerToolbarRoot, _extends({
        ref,
        toolbarTitle,
        isMobileKeyboardViewOpen,
        toggleMobileKeyboardView,
        isLandscape,
        ownerState,
        className: classes.root
      }, other, {
        children: /* @__PURE__ */ jsx(DatePickerToolbarTitle, {
          variant: "h4",
          align: isLandscape ? "left" : "center",
          ownerState,
          className: classes.title,
          children: dateText
        })
      }));
    });
    const _excluded$6 = ["onAccept", "onClear", "onCancel", "onSetToday", "actions"];
    const PickersActionBar = (props2) => {
      const {
        onAccept,
        onClear,
        onCancel,
        onSetToday,
        actions
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$6);
      const wrapperVariant = react.exports.useContext(WrapperVariantContext);
      const localeText = useLocaleText();
      const actionsArray = typeof actions === "function" ? actions(wrapperVariant) : actions;
      if (actionsArray == null || actionsArray.length === 0) {
        return null;
      }
      const buttons = actionsArray == null ? void 0 : actionsArray.map((actionType) => {
        switch (actionType) {
          case "clear":
            return /* @__PURE__ */ jsx(Button$1, {
              onClick: onClear,
              children: localeText.clearButtonLabel
            }, actionType);
          case "cancel":
            return /* @__PURE__ */ jsx(Button$1, {
              onClick: onCancel,
              children: localeText.cancelButtonLabel
            }, actionType);
          case "accept":
            return /* @__PURE__ */ jsx(Button$1, {
              onClick: onAccept,
              children: localeText.okButtonLabel
            }, actionType);
          case "today":
            return /* @__PURE__ */ jsx(Button$1, {
              onClick: onSetToday,
              children: localeText.todayButtonLabel
            }, actionType);
          default:
            return null;
        }
      });
      return /* @__PURE__ */ jsx(DialogActions$1, _extends({}, other, {
        children: buttons
      }));
    };
    const useRifm = (props2) => {
      const [, refresh] = react.exports.useReducer((c2) => c2 + 1, 0);
      const valueRef = react.exports.useRef(null);
      const {
        replace: replace2,
        append: append2
      } = props2;
      const userValue = replace2 ? replace2(props2.format(props2.value)) : props2.format(props2.value);
      const isDeleleteButtonDownRef = react.exports.useRef(false);
      const onChange = (evt) => {
        const eventValue = evt.target.value;
        valueRef.current = [
          eventValue,
          evt.target,
          eventValue.length > userValue.length,
          isDeleleteButtonDownRef.current,
          userValue === props2.format(eventValue)
        ];
        refresh();
      };
      {
        react.exports.useLayoutEffect(() => {
          if (valueRef.current == null)
            return;
          let [
            eventValue,
            input,
            isSizeIncreaseOperation,
            isDeleleteButtonDown,
            isNoOperation
          ] = valueRef.current;
          valueRef.current = null;
          const deleteWasNoOp = isDeleleteButtonDown && isNoOperation;
          const valueAfterSelectionStart = eventValue.slice(input.selectionStart);
          const acceptedCharIndexAfterDelete = valueAfterSelectionStart.search(props2.accept || /\d/g);
          const charsToSkipAfterDelete = acceptedCharIndexAfterDelete !== -1 ? acceptedCharIndexAfterDelete : 0;
          const clean = (str) => (str.match(props2.accept || /\d/g) || []).join("");
          const valueBeforeSelectionStart = clean(eventValue.substr(0, input.selectionStart));
          const getCursorPosition = (val) => {
            let start2 = 0;
            let cleanPos = 0;
            for (let i = 0; i !== valueBeforeSelectionStart.length; ++i) {
              let newPos = val.indexOf(valueBeforeSelectionStart[i], start2) + 1;
              let newCleanPos = clean(val).indexOf(valueBeforeSelectionStart[i], cleanPos) + 1;
              if (newCleanPos - cleanPos > 1) {
                newPos = start2;
                newCleanPos = cleanPos;
              }
              cleanPos = Math.max(newCleanPos, cleanPos);
              start2 = Math.max(start2, newPos);
            }
            return start2;
          };
          if (props2.mask === true && isSizeIncreaseOperation && !isNoOperation) {
            let start2 = getCursorPosition(eventValue);
            const c2 = clean(eventValue.substr(start2))[0];
            start2 = eventValue.indexOf(c2, start2);
            eventValue = `${eventValue.substr(0, start2)}${eventValue.substr(start2 + 1)}`;
          }
          let formattedValue = props2.format(eventValue);
          if (append2 != null && input.selectionStart === eventValue.length && !isNoOperation) {
            if (isSizeIncreaseOperation) {
              formattedValue = append2(formattedValue);
            } else {
              if (clean(formattedValue.slice(-1)) === "") {
                formattedValue = formattedValue.slice(0, -1);
              }
            }
          }
          const replacedValue = replace2 ? replace2(formattedValue) : formattedValue;
          if (userValue === replacedValue) {
            refresh();
          } else {
            props2.onChange(replacedValue);
          }
          return () => {
            let start2 = getCursorPosition(formattedValue);
            if (props2.mask != null && (isSizeIncreaseOperation || isDeleleteButtonDown && !deleteWasNoOp)) {
              while (formattedValue[start2] && clean(formattedValue[start2]) === "") {
                start2 += 1;
              }
            }
            input.selectionStart = input.selectionEnd = start2 + (deleteWasNoOp ? 1 + charsToSkipAfterDelete : 0);
          };
        });
      }
      react.exports.useEffect(() => {
        const handleKeyDown2 = (evt) => {
          if (evt.code === "Delete") {
            isDeleleteButtonDownRef.current = true;
          }
        };
        const handleKeyUp = (evt) => {
          if (evt.code === "Delete") {
            isDeleleteButtonDownRef.current = false;
          }
        };
        document.addEventListener("keydown", handleKeyDown2);
        document.addEventListener("keyup", handleKeyUp);
        return () => {
          document.removeEventListener("keydown", handleKeyDown2);
          document.removeEventListener("keyup", handleKeyUp);
        };
      }, []);
      return {
        value: valueRef.current != null ? valueRef.current[0] : userValue,
        onChange
      };
    };
    const getDisplayDate = (utils2, rawValue, inputFormat) => {
      const date = utils2.date(rawValue);
      const isEmpty2 = rawValue === null;
      if (isEmpty2) {
        return "";
      }
      return utils2.isValid(date) ? utils2.formatByString(
        date,
        inputFormat
      ) : "";
    };
    const MASK_USER_INPUT_SYMBOL = "_";
    const staticDateWith2DigitTokens = "2019-11-21T22:30:00.000";
    const staticDateWith1DigitTokens = "2019-01-01T09:00:00.000";
    function getMaskFromCurrentFormat(mask, format2, acceptRegex, utils2) {
      if (mask) {
        return mask;
      }
      const formattedDateWith1Digit = utils2.formatByString(utils2.date(staticDateWith1DigitTokens), format2);
      const inferredFormatPatternWith1Digits = formattedDateWith1Digit.replace(acceptRegex, MASK_USER_INPUT_SYMBOL);
      const inferredFormatPatternWith2Digits = utils2.formatByString(utils2.date(staticDateWith2DigitTokens), format2).replace(acceptRegex, "_");
      if (inferredFormatPatternWith1Digits === inferredFormatPatternWith2Digits) {
        return inferredFormatPatternWith1Digits;
      }
      return "";
    }
    function checkMaskIsValidForCurrentFormat(mask, format2, acceptRegex, utils2) {
      if (!mask) {
        return false;
      }
      const formattedDateWith1Digit = utils2.formatByString(utils2.date(staticDateWith1DigitTokens), format2);
      const inferredFormatPatternWith1Digits = formattedDateWith1Digit.replace(acceptRegex, MASK_USER_INPUT_SYMBOL);
      const inferredFormatPatternWith2Digits = utils2.formatByString(utils2.date(staticDateWith2DigitTokens), format2).replace(acceptRegex, "_");
      const isMaskValid = inferredFormatPatternWith2Digits === inferredFormatPatternWith1Digits && mask === inferredFormatPatternWith2Digits;
      if (!isMaskValid && utils2.lib !== "luxon" && false) {
        if (format2.includes("MMM")) {
          console.warn([`Mask does not support literals such as 'MMM'.`, `Either use numbers with fix length or disable mask feature with 'disableMaskedInput' prop`, `Falling down to uncontrolled no-mask input.`].join("\n"));
        } else if (inferredFormatPatternWith2Digits && inferredFormatPatternWith2Digits !== inferredFormatPatternWith1Digits) {
          console.warn([`Mask does not support numbers with variable length such as 'M'.`, `Either use numbers with fix length or disable mask feature with 'disableMaskedInput' prop`, `Falling down to uncontrolled no-mask input.`].join("\n"));
        } else if (mask) {
          console.warn([`The mask "${mask}" you passed is not valid for the format used ${format2}.`, `Falling down to uncontrolled no-mask input.`].join("\n"));
        }
      }
      return isMaskValid;
    }
    const maskedDateFormatter = (mask, acceptRegexp) => (value) => {
      let outputCharIndex = 0;
      return value.split("").map((char2, inputCharIndex) => {
        acceptRegexp.lastIndex = 0;
        if (outputCharIndex > mask.length - 1) {
          return "";
        }
        const maskChar = mask[outputCharIndex];
        const nextMaskChar = mask[outputCharIndex + 1];
        const acceptedChar = acceptRegexp.test(char2) ? char2 : "";
        const formattedChar = maskChar === MASK_USER_INPUT_SYMBOL ? acceptedChar : maskChar + acceptedChar;
        outputCharIndex += formattedChar.length;
        const isLastCharacter = inputCharIndex === value.length - 1;
        if (isLastCharacter && nextMaskChar && nextMaskChar !== MASK_USER_INPUT_SYMBOL) {
          return formattedChar ? formattedChar + nextMaskChar : "";
        }
        return formattedChar;
      }).join("");
    };
    const useMaskedInput = ({
      acceptRegex = /[\d]/gi,
      disabled,
      disableMaskedInput,
      ignoreInvalidInputs,
      inputFormat,
      inputProps,
      label,
      mask,
      onChange,
      rawValue,
      readOnly,
      rifmFormatter,
      TextFieldProps,
      validationError
    }) => {
      const utils2 = useUtils();
      const formatHelperText = utils2.getFormatHelperText(inputFormat);
      const {
        shouldUseMaskedInput,
        maskToUse
      } = react.exports.useMemo(() => {
        if (disableMaskedInput) {
          return {
            shouldUseMaskedInput: false,
            maskToUse: ""
          };
        }
        const computedMaskToUse = getMaskFromCurrentFormat(mask, inputFormat, acceptRegex, utils2);
        return {
          shouldUseMaskedInput: checkMaskIsValidForCurrentFormat(computedMaskToUse, inputFormat, acceptRegex, utils2),
          maskToUse: computedMaskToUse
        };
      }, [acceptRegex, disableMaskedInput, inputFormat, mask, utils2]);
      const formatter = react.exports.useMemo(() => shouldUseMaskedInput && maskToUse ? maskedDateFormatter(maskToUse, acceptRegex) : (st) => st, [acceptRegex, maskToUse, shouldUseMaskedInput]);
      const parsedValue = rawValue === null ? null : utils2.date(rawValue);
      const [innerInputValue, setInnerInputValue] = react.exports.useState(parsedValue);
      const [innerDisplayedInputValue, setInnerDisplayedInputValue] = react.exports.useState(getDisplayDate(utils2, rawValue, inputFormat));
      const prevRawValue = react.exports.useRef();
      const prevLocale = react.exports.useRef(utils2.locale);
      react.exports.useEffect(() => {
        const rawValueHasChanged = rawValue !== prevRawValue.current;
        const localeHasChanged = utils2.locale !== prevLocale.current;
        prevRawValue.current = rawValue;
        prevLocale.current = utils2.locale;
        if (!rawValueHasChanged && !localeHasChanged) {
          return;
        }
        const newParsedValue = rawValue === null ? null : utils2.date(rawValue);
        const isAcceptedValue = rawValue === null || utils2.isValid(newParsedValue);
        if (!localeHasChanged && (!isAcceptedValue || utils2.isEqual(innerInputValue, newParsedValue))) {
          return;
        }
        const newDisplayDate = getDisplayDate(utils2, rawValue, inputFormat);
        setInnerInputValue(newParsedValue);
        setInnerDisplayedInputValue(newDisplayDate);
      }, [utils2, rawValue, inputFormat, innerInputValue]);
      const handleChange = (text) => {
        const finalString = text === "" || text === mask ? "" : text;
        setInnerDisplayedInputValue(finalString);
        const date = finalString === null ? null : utils2.parse(finalString, inputFormat);
        if (ignoreInvalidInputs && !utils2.isValid(date)) {
          return;
        }
        setInnerInputValue(date);
        onChange(date, finalString || void 0);
      };
      const rifmProps = useRifm({
        value: innerDisplayedInputValue,
        onChange: handleChange,
        format: rifmFormatter || formatter
      });
      const inputStateArgs = shouldUseMaskedInput ? rifmProps : {
        value: innerDisplayedInputValue,
        onChange: (event) => {
          handleChange(event.currentTarget.value);
        }
      };
      return _extends({
        label,
        disabled,
        error: validationError,
        inputProps: _extends({}, inputStateArgs, {
          disabled,
          placeholder: formatHelperText,
          readOnly,
          type: shouldUseMaskedInput ? "tel" : "text"
        }, inputProps)
      }, TextFieldProps);
    };
    const _excluded$5 = ["className", "components", "disableOpenPicker", "getOpenDialogAriaText", "InputAdornmentProps", "InputProps", "inputRef", "openPicker", "OpenPickerButtonProps", "renderInput"];
    const KeyboardDateInput = /* @__PURE__ */ react.exports.forwardRef(function KeyboardDateInput2(props2, ref) {
      const {
        className,
        components = {},
        disableOpenPicker,
        getOpenDialogAriaText: getOpenDialogAriaTextProp,
        InputAdornmentProps,
        InputProps,
        inputRef,
        openPicker,
        OpenPickerButtonProps,
        renderInput
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$5);
      const localeText = useLocaleText();
      const getOpenDialogAriaText = getOpenDialogAriaTextProp != null ? getOpenDialogAriaTextProp : localeText.openDatePickerDialogue;
      const utils2 = useUtils();
      const textFieldProps = useMaskedInput(other);
      const adornmentPosition = (InputAdornmentProps == null ? void 0 : InputAdornmentProps.position) || "end";
      const OpenPickerIcon = components.OpenPickerIcon || Calendar;
      return renderInput(_extends({
        ref,
        inputRef,
        className
      }, textFieldProps, {
        InputProps: _extends({}, InputProps, {
          [`${adornmentPosition}Adornment`]: disableOpenPicker ? void 0 : /* @__PURE__ */ jsx(InputAdornment$1, _extends({
            position: adornmentPosition
          }, InputAdornmentProps, {
            children: /* @__PURE__ */ jsx(IconButton$1, _extends({
              edge: adornmentPosition,
              disabled: other.disabled || other.readOnly,
              "aria-label": getOpenDialogAriaText(other.rawValue, utils2)
            }, OpenPickerButtonProps, {
              onClick: openPicker,
              children: /* @__PURE__ */ jsx(OpenPickerIcon, {})
            }))
          }))
        })
      }));
    });
    function getOrientation() {
      if (typeof window === "undefined") {
        return "portrait";
      }
      if (window.screen && window.screen.orientation && window.screen.orientation.angle) {
        return Math.abs(window.screen.orientation.angle) === 90 ? "landscape" : "portrait";
      }
      if (window.orientation) {
        return Math.abs(Number(window.orientation)) === 90 ? "landscape" : "portrait";
      }
      return "portrait";
    }
    const useIsLandscape = (views, customOrientation) => {
      const [orientation, setOrientation] = react.exports.useState(getOrientation);
      useEnhancedEffect$1(() => {
        const eventHandler = () => {
          setOrientation(getOrientation());
        };
        window.addEventListener("orientationchange", eventHandler);
        return () => {
          window.removeEventListener("orientationchange", eventHandler);
        };
      }, []);
      if (arrayIncludes(views, ["hours", "minutes", "seconds"])) {
        return false;
      }
      const orientationToUse = customOrientation || orientation;
      return orientationToUse === "landscape";
    };
    const useFocusManagement = ({
      autoFocus,
      openView
    }) => {
      const [focusedView, setFocusedView] = react.exports.useState(autoFocus ? openView : null);
      const setFocusedViewCallback = react.exports.useCallback((view) => (newHasFocus) => {
        if (newHasFocus) {
          setFocusedView(view);
        } else {
          setFocusedView((prevFocusedView) => view === prevFocusedView ? null : prevFocusedView);
        }
      }, []);
      return {
        focusedView,
        setFocusedView: setFocusedViewCallback
      };
    };
    function getCalendarOrClockPickerUtilityClass(slot) {
      return generateUtilityClass("MuiCalendarOrClockPicker", slot);
    }
    generateUtilityClasses("MuiCalendarOrClockPicker", ["root", "mobileKeyboardInputView"]);
    const _excluded$4 = ["autoFocus", "className", "parsedValue", "DateInputProps", "isMobileKeyboardViewOpen", "onDateChange", "onViewChange", "openTo", "orientation", "showToolbar", "toggleMobileKeyboardView", "ToolbarComponent", "toolbarFormat", "toolbarPlaceholder", "toolbarTitle", "views", "dateRangeIcon", "timeIcon", "hideTabs", "classes"];
    const useUtilityClasses$1 = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        mobileKeyboardInputView: ["mobileKeyboardInputView"]
      };
      return composeClasses(slots, getCalendarOrClockPickerUtilityClass, classes);
    };
    const MobileKeyboardInputView = styled$1("div", {
      name: "MuiCalendarOrClockPicker",
      slot: "MobileKeyboardInputView",
      overridesResolver: (_2, styles2) => styles2.mobileKeyboardInputView
    })({
      padding: "16px 24px"
    });
    const PickerRoot = styled$1("div", {
      name: "MuiCalendarOrClockPicker",
      slot: "Root",
      overridesResolver: (_2, styles2) => styles2.root
    })(({
      ownerState
    }) => _extends({
      display: "flex",
      flexDirection: "column"
    }, ownerState.isLandscape && {
      flexDirection: "row"
    }));
    const MobileKeyboardTextFieldProps = {
      fullWidth: true
    };
    const isDatePickerView = (view) => view === "year" || view === "month" || view === "day";
    const isTimePickerView = (view) => view === "hours" || view === "minutes" || view === "seconds";
    function CalendarOrClockPicker(inProps) {
      var _other$components, _other$componentsProp;
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiCalendarOrClockPicker"
      });
      const {
        autoFocus,
        parsedValue,
        DateInputProps,
        isMobileKeyboardViewOpen,
        onDateChange,
        onViewChange,
        openTo,
        orientation,
        showToolbar,
        toggleMobileKeyboardView,
        ToolbarComponent = () => null,
        toolbarFormat,
        toolbarPlaceholder,
        toolbarTitle,
        views,
        dateRangeIcon,
        timeIcon,
        hideTabs
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$4);
      const TabsComponent = (_other$components = other.components) == null ? void 0 : _other$components.Tabs;
      const isLandscape = useIsLandscape(views, orientation);
      const wrapperVariant = react.exports.useContext(WrapperVariantContext);
      const classes = useUtilityClasses$1(props2);
      const toShowToolbar = showToolbar != null ? showToolbar : wrapperVariant !== "desktop";
      const showTabs = !hideTabs && typeof window !== "undefined" && window.innerHeight > 667;
      const handleDateChange = react.exports.useCallback((newDate, selectionState) => {
        onDateChange(newDate, wrapperVariant, selectionState);
      }, [onDateChange, wrapperVariant]);
      const handleViewChange = react.exports.useCallback((newView) => {
        if (isMobileKeyboardViewOpen) {
          toggleMobileKeyboardView();
        }
        if (onViewChange) {
          onViewChange(newView);
        }
      }, [isMobileKeyboardViewOpen, onViewChange, toggleMobileKeyboardView]);
      const {
        openView,
        setOpenView,
        handleChangeAndOpenNext
      } = useViews({
        view: void 0,
        views,
        openTo,
        onChange: handleDateChange,
        onViewChange: handleViewChange
      });
      const {
        focusedView,
        setFocusedView
      } = useFocusManagement({
        autoFocus,
        openView
      });
      return /* @__PURE__ */ jsxs(PickerRoot, {
        ownerState: {
          isLandscape
        },
        className: classes.root,
        children: [toShowToolbar && /* @__PURE__ */ jsx(ToolbarComponent, _extends({}, other, {
          views,
          isLandscape,
          parsedValue,
          onChange: handleDateChange,
          setOpenView,
          openView,
          toolbarTitle,
          toolbarFormat,
          toolbarPlaceholder,
          isMobileKeyboardViewOpen,
          toggleMobileKeyboardView
        })), showTabs && !!TabsComponent && /* @__PURE__ */ jsx(TabsComponent, _extends({
          dateRangeIcon,
          timeIcon,
          view: openView,
          onChange: setOpenView
        }, (_other$componentsProp = other.componentsProps) == null ? void 0 : _other$componentsProp.tabs)), /* @__PURE__ */ jsx(PickerViewRoot, {
          children: isMobileKeyboardViewOpen ? /* @__PURE__ */ jsx(MobileKeyboardInputView, {
            className: classes.mobileKeyboardInputView,
            children: /* @__PURE__ */ jsx(KeyboardDateInput, _extends({}, DateInputProps, {
              ignoreInvalidInputs: true,
              disableOpenPicker: true,
              TextFieldProps: MobileKeyboardTextFieldProps
            }))
          }) : /* @__PURE__ */ jsxs(react.exports.Fragment, {
            children: [isDatePickerView(openView) && /* @__PURE__ */ jsx(CalendarPicker, _extends({
              autoFocus,
              date: parsedValue,
              onViewChange: setOpenView,
              onChange: handleChangeAndOpenNext,
              view: openView,
              views: views.filter(isDatePickerView),
              focusedView,
              onFocusedViewChange: setFocusedView
            }, other)), isTimePickerView(openView) && /* @__PURE__ */ jsx(ClockPicker, _extends({}, other, {
              autoFocus,
              date: parsedValue,
              view: openView,
              views: views.filter(isTimePickerView),
              onChange: handleChangeAndOpenNext,
              onViewChange: setOpenView,
              showViewSwitcher: wrapperVariant === "desktop"
            }))]
          })
        })]
      });
    }
    const useOpenState = ({
      open,
      onOpen,
      onClose
    }) => {
      const isControllingOpenProp = react.exports.useRef(typeof open === "boolean").current;
      const [openState, setIsOpenState] = react.exports.useState(false);
      react.exports.useEffect(() => {
        if (isControllingOpenProp) {
          if (typeof open !== "boolean") {
            throw new Error("You must not mix controlling and uncontrolled mode for `open` prop");
          }
          setIsOpenState(open);
        }
      }, [isControllingOpenProp, open]);
      const setIsOpen = react.exports.useCallback((newIsOpen) => {
        if (!isControllingOpenProp) {
          setIsOpenState(newIsOpen);
        }
        if (newIsOpen && onOpen) {
          onOpen();
        }
        if (!newIsOpen && onClose) {
          onClose();
        }
      }, [isControllingOpenProp, onOpen, onClose]);
      return {
        isOpen: openState,
        setIsOpen
      };
    };
    const usePickerState = (props2, valueManager) => {
      const {
        onAccept,
        onChange,
        value,
        closeOnSelect
      } = props2;
      const utils2 = useUtils();
      const {
        isOpen,
        setIsOpen
      } = useOpenState(props2);
      const parsedDateValue = react.exports.useMemo(() => valueManager.parseInput(utils2, value), [valueManager, utils2, value]);
      const [lastValidDateValue, setLastValidDateValue] = react.exports.useState(parsedDateValue);
      const [dateState, setDateState] = react.exports.useState(() => ({
        committed: parsedDateValue,
        draft: parsedDateValue,
        resetFallback: parsedDateValue
      }));
      const setDate = react.exports.useCallback((params) => {
        setDateState((prev2) => {
          switch (params.action) {
            case "setAll":
            case "acceptAndClose": {
              return {
                draft: params.value,
                committed: params.value,
                resetFallback: params.value
              };
            }
            case "setCommitted": {
              return _extends({}, prev2, {
                draft: params.value,
                committed: params.value
              });
            }
            case "setDraft": {
              return _extends({}, prev2, {
                draft: params.value
              });
            }
            default: {
              return prev2;
            }
          }
        });
        if (params.forceOnChangeCall || !params.skipOnChangeCall && !valueManager.areValuesEqual(utils2, dateState.committed, params.value)) {
          onChange(params.value);
        }
        if (params.action === "acceptAndClose") {
          setIsOpen(false);
          if (onAccept && !valueManager.areValuesEqual(utils2, dateState.resetFallback, params.value)) {
            onAccept(params.value);
          }
        }
      }, [onAccept, onChange, setIsOpen, dateState, utils2, valueManager]);
      react.exports.useEffect(() => {
        if (utils2.isValid(parsedDateValue)) {
          setLastValidDateValue(parsedDateValue);
        }
      }, [utils2, parsedDateValue]);
      react.exports.useEffect(() => {
        if (isOpen) {
          setDate({
            action: "setAll",
            value: parsedDateValue,
            skipOnChangeCall: true
          });
        }
      }, [isOpen]);
      if (!valueManager.areValuesEqual(utils2, dateState.committed, parsedDateValue)) {
        setDate({
          action: "setCommitted",
          value: parsedDateValue,
          skipOnChangeCall: true
        });
      }
      const wrapperProps = react.exports.useMemo(() => ({
        open: isOpen,
        onClear: () => {
          setDate({
            value: valueManager.emptyValue,
            action: "acceptAndClose",
            forceOnChangeCall: !valueManager.areValuesEqual(utils2, value, valueManager.emptyValue)
          });
        },
        onAccept: () => {
          setDate({
            value: dateState.draft,
            action: "acceptAndClose",
            forceOnChangeCall: !valueManager.areValuesEqual(utils2, value, parsedDateValue)
          });
        },
        onDismiss: () => {
          setDate({
            value: dateState.committed,
            action: "acceptAndClose"
          });
        },
        onCancel: () => {
          setDate({
            value: dateState.resetFallback,
            action: "acceptAndClose"
          });
        },
        onSetToday: () => {
          setDate({
            value: valueManager.getTodayValue(utils2),
            action: "acceptAndClose"
          });
        }
      }), [setDate, isOpen, utils2, dateState, valueManager, value, parsedDateValue]);
      const [isMobileKeyboardViewOpen, setMobileKeyboardViewOpen] = react.exports.useState(false);
      const pickerProps = react.exports.useMemo(() => ({
        parsedValue: dateState.draft,
        isMobileKeyboardViewOpen,
        toggleMobileKeyboardView: () => setMobileKeyboardViewOpen(!isMobileKeyboardViewOpen),
        onDateChange: (newDate, wrapperVariant, selectionState = "partial") => {
          switch (selectionState) {
            case "shallow": {
              return setDate({
                action: "setDraft",
                value: newDate,
                skipOnChangeCall: true
              });
            }
            case "partial": {
              return setDate({
                action: "setDraft",
                value: newDate
              });
            }
            case "finish": {
              if (closeOnSelect != null ? closeOnSelect : wrapperVariant === "desktop") {
                return setDate({
                  value: newDate,
                  action: "acceptAndClose"
                });
              }
              return setDate({
                value: newDate,
                action: "setCommitted"
              });
            }
            default: {
              throw new Error("MUI: Invalid selectionState passed to `onDateChange`");
            }
          }
        }
      }), [setDate, isMobileKeyboardViewOpen, dateState.draft, closeOnSelect]);
      const handleInputChange = react.exports.useCallback((newParsedValue, keyboardInputValue) => {
        const cleanParsedValue = valueManager.valueReducer ? valueManager.valueReducer(utils2, lastValidDateValue, newParsedValue) : newParsedValue;
        onChange(cleanParsedValue, keyboardInputValue);
      }, [onChange, valueManager, lastValidDateValue, utils2]);
      const inputProps = react.exports.useMemo(() => ({
        onChange: handleInputChange,
        open: isOpen,
        rawValue: value,
        openPicker: () => setIsOpen(true)
      }), [handleInputChange, isOpen, value, setIsOpen]);
      const pickerState = {
        pickerProps,
        inputProps,
        wrapperProps
      };
      react.exports.useDebugValue(pickerState, () => ({
        MuiPickerState: {
          dateState,
          other: pickerState
        }
      }));
      return pickerState;
    };
    const PickersModalDialogRoot = styled$1(Dialog$1)({
      [`& .${dialogClasses$1.container}`]: {
        outline: 0
      },
      [`& .${dialogClasses$1.paper}`]: {
        outline: 0,
        minWidth: DIALOG_WIDTH
      }
    });
    const PickersModalDialogContent = styled$1(DialogContent$1)({
      "&:first-of-type": {
        padding: 0
      }
    });
    const PickersModalDialog = (props2) => {
      var _components$ActionBar;
      const {
        children,
        DialogProps = {},
        onAccept,
        onClear,
        onDismiss,
        onCancel,
        onSetToday,
        open,
        components,
        componentsProps
      } = props2;
      const ActionBar = (_components$ActionBar = components == null ? void 0 : components.ActionBar) != null ? _components$ActionBar : PickersActionBar;
      return /* @__PURE__ */ jsxs(PickersModalDialogRoot, _extends({
        open,
        onClose: onDismiss
      }, DialogProps, {
        children: [/* @__PURE__ */ jsx(PickersModalDialogContent, {
          children
        }), /* @__PURE__ */ jsx(ActionBar, _extends({
          onAccept,
          onClear,
          onCancel,
          onSetToday,
          actions: ["cancel", "accept"]
        }, componentsProps == null ? void 0 : componentsProps.actionBar))]
      }));
    };
    const _excluded$3 = ["children", "DateInputProps", "DialogProps", "onAccept", "onClear", "onDismiss", "onCancel", "onSetToday", "open", "PureDateInputComponent", "components", "componentsProps"];
    function MobileWrapper(props2) {
      const {
        children,
        DateInputProps,
        DialogProps,
        onAccept,
        onClear,
        onDismiss,
        onCancel,
        onSetToday,
        open,
        PureDateInputComponent,
        components,
        componentsProps
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$3);
      return /* @__PURE__ */ jsxs(WrapperVariantContext.Provider, {
        value: "mobile",
        children: [/* @__PURE__ */ jsx(PureDateInputComponent, _extends({
          components
        }, other, DateInputProps)), /* @__PURE__ */ jsx(PickersModalDialog, {
          DialogProps,
          onAccept,
          onClear,
          onDismiss,
          onCancel,
          onSetToday,
          open,
          components,
          componentsProps,
          children
        })]
      });
    }
    const PureDateInput = /* @__PURE__ */ react.exports.forwardRef(function PureDateInput2(props2, ref) {
      const {
        disabled,
        getOpenDialogAriaText: getOpenDialogAriaTextProp,
        inputFormat,
        InputProps,
        inputRef,
        label,
        openPicker: onOpen,
        rawValue,
        renderInput,
        TextFieldProps = {},
        validationError,
        className
      } = props2;
      const localeText = useLocaleText();
      const getOpenDialogAriaText = getOpenDialogAriaTextProp != null ? getOpenDialogAriaTextProp : localeText.openDatePickerDialogue;
      const utils2 = useUtils();
      const PureDateInputProps = react.exports.useMemo(() => _extends({}, InputProps, {
        readOnly: true
      }), [InputProps]);
      const inputValue = getDisplayDate(utils2, rawValue, inputFormat);
      const handleOnClick = useEventCallback((event) => {
        event.stopPropagation();
        onOpen();
      });
      return renderInput(_extends({
        label,
        disabled,
        ref,
        inputRef,
        error: validationError,
        InputProps: PureDateInputProps,
        className
      }, !props2.readOnly && !props2.disabled && {
        onClick: handleOnClick
      }, {
        inputProps: _extends({
          disabled,
          readOnly: true,
          "aria-readonly": true,
          "aria-label": getOpenDialogAriaText(rawValue, utils2),
          value: inputValue
        }, !props2.readOnly && {
          onClick: handleOnClick
        }, {
          onKeyDown: onSpaceOrEnter(onOpen)
        })
      }, TextFieldProps));
    });
    const _excluded$2 = ["ToolbarComponent", "value", "onChange", "components", "componentsProps"];
    const MobileDatePicker = /* @__PURE__ */ react.exports.forwardRef(function MobileDatePicker2(inProps, ref) {
      const props2 = useDatePickerDefaultizedProps(inProps, "MuiMobileDatePicker");
      const validationError = useDateValidation(props2) !== null;
      const {
        pickerProps,
        inputProps,
        wrapperProps
      } = usePickerState(props2, datePickerValueManager);
      const {
        ToolbarComponent = DatePickerToolbar,
        components,
        componentsProps
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$2);
      const DateInputProps = _extends({}, inputProps, other, {
        components,
        componentsProps,
        ref,
        validationError
      });
      return /* @__PURE__ */ jsx(MobileWrapper, _extends({}, other, wrapperProps, {
        DateInputProps,
        PureDateInputComponent: PureDateInput,
        components,
        componentsProps,
        children: /* @__PURE__ */ jsx(CalendarOrClockPicker, _extends({}, pickerProps, {
          autoFocus: true,
          toolbarTitle: props2.label || props2.toolbarTitle,
          ToolbarComponent,
          DateInputProps,
          components,
          componentsProps
        }, other))
      }));
    });
    //! moment.js
    //! version : 2.29.4
    //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
    //! license : MIT
    //! momentjs.com
    var hookCallback;
    function hooks() {
      return hookCallback.apply(null, arguments);
    }
    function setHookCallback(callback) {
      hookCallback = callback;
    }
    function isArray(input) {
      return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
    }
    function isObject(input) {
      return input != null && Object.prototype.toString.call(input) === "[object Object]";
    }
    function hasOwnProp(a, b2) {
      return Object.prototype.hasOwnProperty.call(a, b2);
    }
    function isObjectEmpty(obj) {
      if (Object.getOwnPropertyNames) {
        return Object.getOwnPropertyNames(obj).length === 0;
      } else {
        var k2;
        for (k2 in obj) {
          if (hasOwnProp(obj, k2)) {
            return false;
          }
        }
        return true;
      }
    }
    function isUndefined(input) {
      return input === void 0;
    }
    function isNumber(input) {
      return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
    }
    function isDate(input) {
      return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
    }
    function map(arr, fn) {
      var res = [], i, arrLen = arr.length;
      for (i = 0; i < arrLen; ++i) {
        res.push(fn(arr[i], i));
      }
      return res;
    }
    function extend(a, b2) {
      for (var i in b2) {
        if (hasOwnProp(b2, i)) {
          a[i] = b2[i];
        }
      }
      if (hasOwnProp(b2, "toString")) {
        a.toString = b2.toString;
      }
      if (hasOwnProp(b2, "valueOf")) {
        a.valueOf = b2.valueOf;
      }
      return a;
    }
    function createUTC(input, format2, locale2, strict) {
      return createLocalOrUTC(input, format2, locale2, strict, true).utc();
    }
    function defaultParsingFlags() {
      return {
        empty: false,
        unusedTokens: [],
        unusedInput: [],
        overflow: -2,
        charsLeftOver: 0,
        nullInput: false,
        invalidEra: null,
        invalidMonth: null,
        invalidFormat: false,
        userInvalidated: false,
        iso: false,
        parsedDateParts: [],
        era: null,
        meridiem: null,
        rfc2822: false,
        weekdayMismatch: false
      };
    }
    function getParsingFlags(m2) {
      if (m2._pf == null) {
        m2._pf = defaultParsingFlags();
      }
      return m2._pf;
    }
    var some;
    if (Array.prototype.some) {
      some = Array.prototype.some;
    } else {
      some = function(fun) {
        var t2 = Object(this), len = t2.length >>> 0, i;
        for (i = 0; i < len; i++) {
          if (i in t2 && fun.call(this, t2[i], i, t2)) {
            return true;
          }
        }
        return false;
      };
    }
    function isValid(m2) {
      if (m2._isValid == null) {
        var flags = getParsingFlags(m2), parsedParts = some.call(flags.parsedDateParts, function(i) {
          return i != null;
        }), isNowValid = !isNaN(m2._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
        if (m2._strict) {
          isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
        }
        if (Object.isFrozen == null || !Object.isFrozen(m2)) {
          m2._isValid = isNowValid;
        } else {
          return isNowValid;
        }
      }
      return m2._isValid;
    }
    function createInvalid(flags) {
      var m2 = createUTC(NaN);
      if (flags != null) {
        extend(getParsingFlags(m2), flags);
      } else {
        getParsingFlags(m2).userInvalidated = true;
      }
      return m2;
    }
    var momentProperties = hooks.momentProperties = [], updateInProgress = false;
    function copyConfig(to2, from2) {
      var i, prop, val, momentPropertiesLen = momentProperties.length;
      if (!isUndefined(from2._isAMomentObject)) {
        to2._isAMomentObject = from2._isAMomentObject;
      }
      if (!isUndefined(from2._i)) {
        to2._i = from2._i;
      }
      if (!isUndefined(from2._f)) {
        to2._f = from2._f;
      }
      if (!isUndefined(from2._l)) {
        to2._l = from2._l;
      }
      if (!isUndefined(from2._strict)) {
        to2._strict = from2._strict;
      }
      if (!isUndefined(from2._tzm)) {
        to2._tzm = from2._tzm;
      }
      if (!isUndefined(from2._isUTC)) {
        to2._isUTC = from2._isUTC;
      }
      if (!isUndefined(from2._offset)) {
        to2._offset = from2._offset;
      }
      if (!isUndefined(from2._pf)) {
        to2._pf = getParsingFlags(from2);
      }
      if (!isUndefined(from2._locale)) {
        to2._locale = from2._locale;
      }
      if (momentPropertiesLen > 0) {
        for (i = 0; i < momentPropertiesLen; i++) {
          prop = momentProperties[i];
          val = from2[prop];
          if (!isUndefined(val)) {
            to2[prop] = val;
          }
        }
      }
      return to2;
    }
    function Moment(config2) {
      copyConfig(this, config2);
      this._d = new Date(config2._d != null ? config2._d.getTime() : NaN);
      if (!this.isValid()) {
        this._d = new Date(NaN);
      }
      if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
      }
    }
    function isMoment(obj) {
      return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
    }
    function warn(msg) {
      if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
        console.warn("Deprecation warning: " + msg);
      }
    }
    function deprecate(msg, fn) {
      var firstTime = true;
      return extend(function() {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
          var args = [], arg, i, key, argLen = arguments.length;
          for (i = 0; i < argLen; i++) {
            arg = "";
            if (typeof arguments[i] === "object") {
              arg += "\n[" + i + "] ";
              for (key in arguments[0]) {
                if (hasOwnProp(arguments[0], key)) {
                  arg += key + ": " + arguments[0][key] + ", ";
                }
              }
              arg = arg.slice(0, -2);
            } else {
              arg = arguments[i];
            }
            args.push(arg);
          }
          warn(
            msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
          );
          firstTime = false;
        }
        return fn.apply(this, arguments);
      }, fn);
    }
    var deprecations = {};
    function deprecateSimple(name, msg) {
      if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
      }
      if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
      }
    }
    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;
    function isFunction(input) {
      return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
    }
    function set(config2) {
      var prop, i;
      for (i in config2) {
        if (hasOwnProp(config2, i)) {
          prop = config2[i];
          if (isFunction(prop)) {
            this[i] = prop;
          } else {
            this["_" + i] = prop;
          }
        }
      }
      this._config = config2;
      this._dayOfMonthOrdinalParseLenient = new RegExp(
        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
      );
    }
    function mergeConfigs(parentConfig, childConfig) {
      var res = extend({}, parentConfig), prop;
      for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
          if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
            res[prop] = {};
            extend(res[prop], parentConfig[prop]);
            extend(res[prop], childConfig[prop]);
          } else if (childConfig[prop] != null) {
            res[prop] = childConfig[prop];
          } else {
            delete res[prop];
          }
        }
      }
      for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
          res[prop] = extend({}, res[prop]);
        }
      }
      return res;
    }
    function Locale(config2) {
      if (config2 != null) {
        this.set(config2);
      }
    }
    var keys;
    if (Object.keys) {
      keys = Object.keys;
    } else {
      keys = function(obj) {
        var i, res = [];
        for (i in obj) {
          if (hasOwnProp(obj, i)) {
            res.push(i);
          }
        }
        return res;
      };
    }
    var defaultCalendar = {
      sameDay: "[Today at] LT",
      nextDay: "[Tomorrow at] LT",
      nextWeek: "dddd [at] LT",
      lastDay: "[Yesterday at] LT",
      lastWeek: "[Last] dddd [at] LT",
      sameElse: "L"
    };
    function calendar(key, mom, now2) {
      var output = this._calendar[key] || this._calendar["sameElse"];
      return isFunction(output) ? output.call(mom, now2) : output;
    }
    function zeroFill(number, targetLength, forceSign) {
      var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
      return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }
    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
    function addFormatToken(token2, padded, ordinal2, callback) {
      var func = callback;
      if (typeof callback === "string") {
        func = function() {
          return this[callback]();
        };
      }
      if (token2) {
        formatTokenFunctions[token2] = func;
      }
      if (padded) {
        formatTokenFunctions[padded[0]] = function() {
          return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
      }
      if (ordinal2) {
        formatTokenFunctions[ordinal2] = function() {
          return this.localeData().ordinal(
            func.apply(this, arguments),
            token2
          );
        };
      }
    }
    function removeFormattingTokens(input) {
      if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, "");
      }
      return input.replace(/\\/g, "");
    }
    function makeFormatFunction(format2) {
      var array = format2.match(formattingTokens), i, length2;
      for (i = 0, length2 = array.length; i < length2; i++) {
        if (formatTokenFunctions[array[i]]) {
          array[i] = formatTokenFunctions[array[i]];
        } else {
          array[i] = removeFormattingTokens(array[i]);
        }
      }
      return function(mom) {
        var output = "", i2;
        for (i2 = 0; i2 < length2; i2++) {
          output += isFunction(array[i2]) ? array[i2].call(mom, format2) : array[i2];
        }
        return output;
      };
    }
    function formatMoment(m2, format2) {
      if (!m2.isValid()) {
        return m2.localeData().invalidDate();
      }
      format2 = expandFormat(format2, m2.localeData());
      formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
      return formatFunctions[format2](m2);
    }
    function expandFormat(format2, locale2) {
      var i = 5;
      function replaceLongDateFormatTokens(input) {
        return locale2.longDateFormat(input) || input;
      }
      localFormattingTokens.lastIndex = 0;
      while (i >= 0 && localFormattingTokens.test(format2)) {
        format2 = format2.replace(
          localFormattingTokens,
          replaceLongDateFormatTokens
        );
        localFormattingTokens.lastIndex = 0;
        i -= 1;
      }
      return format2;
    }
    var defaultLongDateFormat = {
      LTS: "h:mm:ss A",
      LT: "h:mm A",
      L: "MM/DD/YYYY",
      LL: "MMMM D, YYYY",
      LLL: "MMMM D, YYYY h:mm A",
      LLLL: "dddd, MMMM D, YYYY h:mm A"
    };
    function longDateFormat(key) {
      var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
      if (format2 || !formatUpper) {
        return format2;
      }
      this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
        if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
          return tok.slice(1);
        }
        return tok;
      }).join("");
      return this._longDateFormat[key];
    }
    var defaultInvalidDate = "Invalid date";
    function invalidDate() {
      return this._invalidDate;
    }
    var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
    function ordinal(number) {
      return this._ordinal.replace("%d", number);
    }
    var defaultRelativeTime = {
      future: "in %s",
      past: "%s ago",
      s: "a few seconds",
      ss: "%d seconds",
      m: "a minute",
      mm: "%d minutes",
      h: "an hour",
      hh: "%d hours",
      d: "a day",
      dd: "%d days",
      w: "a week",
      ww: "%d weeks",
      M: "a month",
      MM: "%d months",
      y: "a year",
      yy: "%d years"
    };
    function relativeTime(number, withoutSuffix, string, isFuture) {
      var output = this._relativeTime[string];
      return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
    }
    function pastFuture(diff2, output) {
      var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
      return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
    }
    var aliases = {};
    function addUnitAlias(unit, shorthand) {
      var lowerCase = unit.toLowerCase();
      aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
    }
    function normalizeUnits(units) {
      return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
    }
    function normalizeObjectUnits(inputObject) {
      var normalizedInput = {}, normalizedProp, prop;
      for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
          normalizedProp = normalizeUnits(prop);
          if (normalizedProp) {
            normalizedInput[normalizedProp] = inputObject[prop];
          }
        }
      }
      return normalizedInput;
    }
    var priorities = {};
    function addUnitPriority(unit, priority) {
      priorities[unit] = priority;
    }
    function getPrioritizedUnits(unitsObj) {
      var units = [], u2;
      for (u2 in unitsObj) {
        if (hasOwnProp(unitsObj, u2)) {
          units.push({ unit: u2, priority: priorities[u2] });
        }
      }
      units.sort(function(a, b2) {
        return a.priority - b2.priority;
      });
      return units;
    }
    function isLeapYear(year) {
      return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }
    function absFloor(number) {
      if (number < 0) {
        return Math.ceil(number) || 0;
      } else {
        return Math.floor(number);
      }
    }
    function toInt(argumentForCoercion) {
      var coercedNumber = +argumentForCoercion, value = 0;
      if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
      }
      return value;
    }
    function makeGetSet(unit, keepTime) {
      return function(value) {
        if (value != null) {
          set$1(this, unit, value);
          hooks.updateOffset(this, keepTime);
          return this;
        } else {
          return get$c(this, unit);
        }
      };
    }
    function get$c(mom, unit) {
      return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
    }
    function set$1(mom, unit, value) {
      if (mom.isValid() && !isNaN(value)) {
        if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
          value = toInt(value);
          mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
            value,
            mom.month(),
            daysInMonth(value, mom.month())
          );
        } else {
          mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
        }
      }
    }
    function stringGet(units) {
      units = normalizeUnits(units);
      if (isFunction(this[units])) {
        return this[units]();
      }
      return this;
    }
    function stringSet(units, value) {
      if (typeof units === "object") {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;
        for (i = 0; i < prioritizedLen; i++) {
          this[prioritized[i].unit](units[prioritized[i].unit]);
        }
      } else {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
          return this[units](value);
        }
      }
      return this;
    }
    var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
    regexes = {};
    function addRegexToken(token2, regex, strictRegex) {
      regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
        return isStrict && strictRegex ? strictRegex : regex;
      };
    }
    function getParseRegexForToken(token2, config2) {
      if (!hasOwnProp(regexes, token2)) {
        return new RegExp(unescapeFormat(token2));
      }
      return regexes[token2](config2._strict, config2._locale);
    }
    function unescapeFormat(s) {
      return regexEscape(
        s.replace("\\", "").replace(
          /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
          function(matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
          }
        )
      );
    }
    function regexEscape(s) {
      return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    var tokens = {};
    function addParseToken(token2, callback) {
      var i, func = callback, tokenLen;
      if (typeof token2 === "string") {
        token2 = [token2];
      }
      if (isNumber(callback)) {
        func = function(input, array) {
          array[callback] = toInt(input);
        };
      }
      tokenLen = token2.length;
      for (i = 0; i < tokenLen; i++) {
        tokens[token2[i]] = func;
      }
    }
    function addWeekParseToken(token2, callback) {
      addParseToken(token2, function(input, array, config2, token3) {
        config2._w = config2._w || {};
        callback(input, config2._w, config2, token3);
      });
    }
    function addTimeToArrayFromToken(token2, input, config2) {
      if (input != null && hasOwnProp(tokens, token2)) {
        tokens[token2](input, config2._a, config2, token2);
      }
    }
    var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
    function mod(n2, x2) {
      return (n2 % x2 + x2) % x2;
    }
    var indexOf;
    if (Array.prototype.indexOf) {
      indexOf = Array.prototype.indexOf;
    } else {
      indexOf = function(o) {
        var i;
        for (i = 0; i < this.length; ++i) {
          if (this[i] === o) {
            return i;
          }
        }
        return -1;
      };
    }
    function daysInMonth(year, month) {
      if (isNaN(year) || isNaN(month)) {
        return NaN;
      }
      var modMonth = mod(month, 12);
      year += (month - modMonth) / 12;
      return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
    }
    addFormatToken("M", ["MM", 2], "Mo", function() {
      return this.month() + 1;
    });
    addFormatToken("MMM", 0, 0, function(format2) {
      return this.localeData().monthsShort(this, format2);
    });
    addFormatToken("MMMM", 0, 0, function(format2) {
      return this.localeData().months(this, format2);
    });
    addUnitAlias("month", "M");
    addUnitPriority("month", 8);
    addRegexToken("M", match1to2);
    addRegexToken("MM", match1to2, match2);
    addRegexToken("MMM", function(isStrict, locale2) {
      return locale2.monthsShortRegex(isStrict);
    });
    addRegexToken("MMMM", function(isStrict, locale2) {
      return locale2.monthsRegex(isStrict);
    });
    addParseToken(["M", "MM"], function(input, array) {
      array[MONTH] = toInt(input) - 1;
    });
    addParseToken(["MMM", "MMMM"], function(input, array, config2, token2) {
      var month = config2._locale.monthsParse(input, token2, config2._strict);
      if (month != null) {
        array[MONTH] = month;
      } else {
        getParsingFlags(config2).invalidMonth = input;
      }
    });
    var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
      "_"
    ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
    function localeMonths(m2, format2) {
      if (!m2) {
        return isArray(this._months) ? this._months : this._months["standalone"];
      }
      return isArray(this._months) ? this._months[m2.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m2.month()];
    }
    function localeMonthsShort(m2, format2) {
      if (!m2) {
        return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
      }
      return isArray(this._monthsShort) ? this._monthsShort[m2.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m2.month()];
    }
    function handleStrictParse(monthName, format2, strict) {
      var i, ii2, mom, llc = monthName.toLocaleLowerCase();
      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0; i < 12; ++i) {
          mom = createUTC([2e3, i]);
          this._shortMonthsParse[i] = this.monthsShort(
            mom,
            ""
          ).toLocaleLowerCase();
          this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
        }
      }
      if (strict) {
        if (format2 === "MMM") {
          ii2 = indexOf.call(this._shortMonthsParse, llc);
          return ii2 !== -1 ? ii2 : null;
        } else {
          ii2 = indexOf.call(this._longMonthsParse, llc);
          return ii2 !== -1 ? ii2 : null;
        }
      } else {
        if (format2 === "MMM") {
          ii2 = indexOf.call(this._shortMonthsParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._longMonthsParse, llc);
          return ii2 !== -1 ? ii2 : null;
        } else {
          ii2 = indexOf.call(this._longMonthsParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._shortMonthsParse, llc);
          return ii2 !== -1 ? ii2 : null;
        }
      }
    }
    function localeMonthsParse(monthName, format2, strict) {
      var i, mom, regex;
      if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format2, strict);
      }
      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
      }
      for (i = 0; i < 12; i++) {
        mom = createUTC([2e3, i]);
        if (strict && !this._longMonthsParse[i]) {
          this._longMonthsParse[i] = new RegExp(
            "^" + this.months(mom, "").replace(".", "") + "$",
            "i"
          );
          this._shortMonthsParse[i] = new RegExp(
            "^" + this.monthsShort(mom, "").replace(".", "") + "$",
            "i"
          );
        }
        if (!strict && !this._monthsParse[i]) {
          regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
          this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
        }
        if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
          return i;
        } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
          return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
          return i;
        }
      }
    }
    function setMonth(mom, value) {
      var dayOfMonth;
      if (!mom.isValid()) {
        return mom;
      }
      if (typeof value === "string") {
        if (/^\d+$/.test(value)) {
          value = toInt(value);
        } else {
          value = mom.localeData().monthsParse(value);
          if (!isNumber(value)) {
            return mom;
          }
        }
      }
      dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
      mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
      return mom;
    }
    function getSetMonth(value) {
      if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
      } else {
        return get$c(this, "Month");
      }
    }
    function getDaysInMonth() {
      return daysInMonth(this.year(), this.month());
    }
    function monthsShortRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, "_monthsRegex")) {
          computeMonthsParse.call(this);
        }
        if (isStrict) {
          return this._monthsShortStrictRegex;
        } else {
          return this._monthsShortRegex;
        }
      } else {
        if (!hasOwnProp(this, "_monthsShortRegex")) {
          this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
      }
    }
    function monthsRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, "_monthsRegex")) {
          computeMonthsParse.call(this);
        }
        if (isStrict) {
          return this._monthsStrictRegex;
        } else {
          return this._monthsRegex;
        }
      } else {
        if (!hasOwnProp(this, "_monthsRegex")) {
          this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
      }
    }
    function computeMonthsParse() {
      function cmpLenRev(a, b2) {
        return b2.length - a.length;
      }
      var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
      for (i = 0; i < 12; i++) {
        mom = createUTC([2e3, i]);
        shortPieces.push(this.monthsShort(mom, ""));
        longPieces.push(this.months(mom, ""));
        mixedPieces.push(this.months(mom, ""));
        mixedPieces.push(this.monthsShort(mom, ""));
      }
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);
      for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
      }
      for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
      }
      this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._monthsShortRegex = this._monthsRegex;
      this._monthsStrictRegex = new RegExp(
        "^(" + longPieces.join("|") + ")",
        "i"
      );
      this._monthsShortStrictRegex = new RegExp(
        "^(" + shortPieces.join("|") + ")",
        "i"
      );
    }
    addFormatToken("Y", 0, 0, function() {
      var y2 = this.year();
      return y2 <= 9999 ? zeroFill(y2, 4) : "+" + y2;
    });
    addFormatToken(0, ["YY", 2], 0, function() {
      return this.year() % 100;
    });
    addFormatToken(0, ["YYYY", 4], 0, "year");
    addFormatToken(0, ["YYYYY", 5], 0, "year");
    addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
    addUnitAlias("year", "y");
    addUnitPriority("year", 1);
    addRegexToken("Y", matchSigned);
    addRegexToken("YY", match1to2, match2);
    addRegexToken("YYYY", match1to4, match4);
    addRegexToken("YYYYY", match1to6, match6);
    addRegexToken("YYYYYY", match1to6, match6);
    addParseToken(["YYYYY", "YYYYYY"], YEAR);
    addParseToken("YYYY", function(input, array) {
      array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken("YY", function(input, array) {
      array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken("Y", function(input, array) {
      array[YEAR] = parseInt(input, 10);
    });
    function daysInYear(year) {
      return isLeapYear(year) ? 366 : 365;
    }
    hooks.parseTwoDigitYear = function(input) {
      return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
    };
    var getSetYear = makeGetSet("FullYear", true);
    function getIsLeapYear() {
      return isLeapYear(this.year());
    }
    function createDate(y2, m2, d2, h2, M2, s, ms) {
      var date;
      if (y2 < 100 && y2 >= 0) {
        date = new Date(y2 + 400, m2, d2, h2, M2, s, ms);
        if (isFinite(date.getFullYear())) {
          date.setFullYear(y2);
        }
      } else {
        date = new Date(y2, m2, d2, h2, M2, s, ms);
      }
      return date;
    }
    function createUTCDate(y2) {
      var date, args;
      if (y2 < 100 && y2 >= 0) {
        args = Array.prototype.slice.call(arguments);
        args[0] = y2 + 400;
        date = new Date(Date.UTC.apply(null, args));
        if (isFinite(date.getUTCFullYear())) {
          date.setUTCFullYear(y2);
        }
      } else {
        date = new Date(Date.UTC.apply(null, arguments));
      }
      return date;
    }
    function firstWeekOffset(year, dow, doy) {
      var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
      return -fwdlw + fwd - 1;
    }
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
      var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
      if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
      } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
      } else {
        resYear = year;
        resDayOfYear = dayOfYear;
      }
      return {
        year: resYear,
        dayOfYear: resDayOfYear
      };
    }
    function weekOfYear(mom, dow, doy) {
      var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
      if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
      } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
      } else {
        resYear = mom.year();
        resWeek = week;
      }
      return {
        week: resWeek,
        year: resYear
      };
    }
    function weeksInYear(year, dow, doy) {
      var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
      return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }
    addFormatToken("w", ["ww", 2], "wo", "week");
    addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
    addUnitAlias("week", "w");
    addUnitAlias("isoWeek", "W");
    addUnitPriority("week", 5);
    addUnitPriority("isoWeek", 5);
    addRegexToken("w", match1to2);
    addRegexToken("ww", match1to2, match2);
    addRegexToken("W", match1to2);
    addRegexToken("WW", match1to2, match2);
    addWeekParseToken(
      ["w", "ww", "W", "WW"],
      function(input, week, config2, token2) {
        week[token2.substr(0, 1)] = toInt(input);
      }
    );
    function localeWeek(mom) {
      return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }
    var defaultLocaleWeek = {
      dow: 0,
      doy: 6
    };
    function localeFirstDayOfWeek() {
      return this._week.dow;
    }
    function localeFirstDayOfYear() {
      return this._week.doy;
    }
    function getSetWeek(input) {
      var week = this.localeData().week(this);
      return input == null ? week : this.add((input - week) * 7, "d");
    }
    function getSetISOWeek(input) {
      var week = weekOfYear(this, 1, 4).week;
      return input == null ? week : this.add((input - week) * 7, "d");
    }
    addFormatToken("d", 0, "do", "day");
    addFormatToken("dd", 0, 0, function(format2) {
      return this.localeData().weekdaysMin(this, format2);
    });
    addFormatToken("ddd", 0, 0, function(format2) {
      return this.localeData().weekdaysShort(this, format2);
    });
    addFormatToken("dddd", 0, 0, function(format2) {
      return this.localeData().weekdays(this, format2);
    });
    addFormatToken("e", 0, 0, "weekday");
    addFormatToken("E", 0, 0, "isoWeekday");
    addUnitAlias("day", "d");
    addUnitAlias("weekday", "e");
    addUnitAlias("isoWeekday", "E");
    addUnitPriority("day", 11);
    addUnitPriority("weekday", 11);
    addUnitPriority("isoWeekday", 11);
    addRegexToken("d", match1to2);
    addRegexToken("e", match1to2);
    addRegexToken("E", match1to2);
    addRegexToken("dd", function(isStrict, locale2) {
      return locale2.weekdaysMinRegex(isStrict);
    });
    addRegexToken("ddd", function(isStrict, locale2) {
      return locale2.weekdaysShortRegex(isStrict);
    });
    addRegexToken("dddd", function(isStrict, locale2) {
      return locale2.weekdaysRegex(isStrict);
    });
    addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config2, token2) {
      var weekday = config2._locale.weekdaysParse(input, token2, config2._strict);
      if (weekday != null) {
        week.d = weekday;
      } else {
        getParsingFlags(config2).invalidWeekday = input;
      }
    });
    addWeekParseToken(["d", "e", "E"], function(input, week, config2, token2) {
      week[token2] = toInt(input);
    });
    function parseWeekday(input, locale2) {
      if (typeof input !== "string") {
        return input;
      }
      if (!isNaN(input)) {
        return parseInt(input, 10);
      }
      input = locale2.weekdaysParse(input);
      if (typeof input === "number") {
        return input;
      }
      return null;
    }
    function parseIsoWeekday(input, locale2) {
      if (typeof input === "string") {
        return locale2.weekdaysParse(input) % 7 || 7;
      }
      return isNaN(input) ? null : input;
    }
    function shiftWeekdays(ws, n2) {
      return ws.slice(n2, 7).concat(ws.slice(0, n2));
    }
    var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
    function localeWeekdays(m2, format2) {
      var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m2 && m2 !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
      return m2 === true ? shiftWeekdays(weekdays, this._week.dow) : m2 ? weekdays[m2.day()] : weekdays;
    }
    function localeWeekdaysShort(m2) {
      return m2 === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m2 ? this._weekdaysShort[m2.day()] : this._weekdaysShort;
    }
    function localeWeekdaysMin(m2) {
      return m2 === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m2 ? this._weekdaysMin[m2.day()] : this._weekdaysMin;
    }
    function handleStrictParse$1(weekdayName, format2, strict) {
      var i, ii2, mom, llc = weekdayName.toLocaleLowerCase();
      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];
        for (i = 0; i < 7; ++i) {
          mom = createUTC([2e3, 1]).day(i);
          this._minWeekdaysParse[i] = this.weekdaysMin(
            mom,
            ""
          ).toLocaleLowerCase();
          this._shortWeekdaysParse[i] = this.weekdaysShort(
            mom,
            ""
          ).toLocaleLowerCase();
          this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
        }
      }
      if (strict) {
        if (format2 === "dddd") {
          ii2 = indexOf.call(this._weekdaysParse, llc);
          return ii2 !== -1 ? ii2 : null;
        } else if (format2 === "ddd") {
          ii2 = indexOf.call(this._shortWeekdaysParse, llc);
          return ii2 !== -1 ? ii2 : null;
        } else {
          ii2 = indexOf.call(this._minWeekdaysParse, llc);
          return ii2 !== -1 ? ii2 : null;
        }
      } else {
        if (format2 === "dddd") {
          ii2 = indexOf.call(this._weekdaysParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._shortWeekdaysParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._minWeekdaysParse, llc);
          return ii2 !== -1 ? ii2 : null;
        } else if (format2 === "ddd") {
          ii2 = indexOf.call(this._shortWeekdaysParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._weekdaysParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._minWeekdaysParse, llc);
          return ii2 !== -1 ? ii2 : null;
        } else {
          ii2 = indexOf.call(this._minWeekdaysParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._weekdaysParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._shortWeekdaysParse, llc);
          return ii2 !== -1 ? ii2 : null;
        }
      }
    }
    function localeWeekdaysParse(weekdayName, format2, strict) {
      var i, mom, regex;
      if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format2, strict);
      }
      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
      }
      for (i = 0; i < 7; i++) {
        mom = createUTC([2e3, 1]).day(i);
        if (strict && !this._fullWeekdaysParse[i]) {
          this._fullWeekdaysParse[i] = new RegExp(
            "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
            "i"
          );
          this._shortWeekdaysParse[i] = new RegExp(
            "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
            "i"
          );
          this._minWeekdaysParse[i] = new RegExp(
            "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
            "i"
          );
        }
        if (!this._weekdaysParse[i]) {
          regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
          this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
        }
        if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
          return i;
        }
      }
    }
    function getSetDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
      if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, "d");
      } else {
        return day;
      }
    }
    function getSetLocaleDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
      return input == null ? weekday : this.add(input - weekday, "d");
    }
    function getSetISODayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
      } else {
        return this.day() || 7;
      }
    }
    function weekdaysRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysStrictRegex;
        } else {
          return this._weekdaysRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
      }
    }
    function weekdaysShortRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysShortStrictRegex;
        } else {
          return this._weekdaysShortRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysShortRegex")) {
          this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
      }
    }
    function weekdaysMinRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysMinStrictRegex;
        } else {
          return this._weekdaysMinRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysMinRegex")) {
          this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
      }
    }
    function computeWeekdaysParse() {
      function cmpLenRev(a, b2) {
        return b2.length - a.length;
      }
      var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
      for (i = 0; i < 7; i++) {
        mom = createUTC([2e3, 1]).day(i);
        minp = regexEscape(this.weekdaysMin(mom, ""));
        shortp = regexEscape(this.weekdaysShort(mom, ""));
        longp = regexEscape(this.weekdays(mom, ""));
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
      }
      minPieces.sort(cmpLenRev);
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);
      this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._weekdaysShortRegex = this._weekdaysRegex;
      this._weekdaysMinRegex = this._weekdaysRegex;
      this._weekdaysStrictRegex = new RegExp(
        "^(" + longPieces.join("|") + ")",
        "i"
      );
      this._weekdaysShortStrictRegex = new RegExp(
        "^(" + shortPieces.join("|") + ")",
        "i"
      );
      this._weekdaysMinStrictRegex = new RegExp(
        "^(" + minPieces.join("|") + ")",
        "i"
      );
    }
    function hFormat() {
      return this.hours() % 12 || 12;
    }
    function kFormat() {
      return this.hours() || 24;
    }
    addFormatToken("H", ["HH", 2], 0, "hour");
    addFormatToken("h", ["hh", 2], 0, hFormat);
    addFormatToken("k", ["kk", 2], 0, kFormat);
    addFormatToken("hmm", 0, 0, function() {
      return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });
    addFormatToken("hmmss", 0, 0, function() {
      return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    addFormatToken("Hmm", 0, 0, function() {
      return "" + this.hours() + zeroFill(this.minutes(), 2);
    });
    addFormatToken("Hmmss", 0, 0, function() {
      return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    function meridiem(token2, lowercase) {
      addFormatToken(token2, 0, 0, function() {
        return this.localeData().meridiem(
          this.hours(),
          this.minutes(),
          lowercase
        );
      });
    }
    meridiem("a", true);
    meridiem("A", false);
    addUnitAlias("hour", "h");
    addUnitPriority("hour", 13);
    function matchMeridiem(isStrict, locale2) {
      return locale2._meridiemParse;
    }
    addRegexToken("a", matchMeridiem);
    addRegexToken("A", matchMeridiem);
    addRegexToken("H", match1to2);
    addRegexToken("h", match1to2);
    addRegexToken("k", match1to2);
    addRegexToken("HH", match1to2, match2);
    addRegexToken("hh", match1to2, match2);
    addRegexToken("kk", match1to2, match2);
    addRegexToken("hmm", match3to4);
    addRegexToken("hmmss", match5to6);
    addRegexToken("Hmm", match3to4);
    addRegexToken("Hmmss", match5to6);
    addParseToken(["H", "HH"], HOUR);
    addParseToken(["k", "kk"], function(input, array, config2) {
      var kInput = toInt(input);
      array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(["a", "A"], function(input, array, config2) {
      config2._isPm = config2._locale.isPM(input);
      config2._meridiem = input;
    });
    addParseToken(["h", "hh"], function(input, array, config2) {
      array[HOUR] = toInt(input);
      getParsingFlags(config2).bigHour = true;
    });
    addParseToken("hmm", function(input, array, config2) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
      getParsingFlags(config2).bigHour = true;
    });
    addParseToken("hmmss", function(input, array, config2) {
      var pos1 = input.length - 4, pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
      getParsingFlags(config2).bigHour = true;
    });
    addParseToken("Hmm", function(input, array, config2) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken("Hmmss", function(input, array, config2) {
      var pos1 = input.length - 4, pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
    });
    function localeIsPM(input) {
      return (input + "").toLowerCase().charAt(0) === "p";
    }
    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
    function localeMeridiem(hours2, minutes2, isLower) {
      if (hours2 > 11) {
        return isLower ? "pm" : "PM";
      } else {
        return isLower ? "am" : "AM";
      }
    }
    var baseConfig = {
      calendar: defaultCalendar,
      longDateFormat: defaultLongDateFormat,
      invalidDate: defaultInvalidDate,
      ordinal: defaultOrdinal,
      dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
      relativeTime: defaultRelativeTime,
      months: defaultLocaleMonths,
      monthsShort: defaultLocaleMonthsShort,
      week: defaultLocaleWeek,
      weekdays: defaultLocaleWeekdays,
      weekdaysMin: defaultLocaleWeekdaysMin,
      weekdaysShort: defaultLocaleWeekdaysShort,
      meridiemParse: defaultLocaleMeridiemParse
    };
    var locales = {}, localeFamilies = {}, globalLocale;
    function commonPrefix(arr1, arr2) {
      var i, minl = Math.min(arr1.length, arr2.length);
      for (i = 0; i < minl; i += 1) {
        if (arr1[i] !== arr2[i]) {
          return i;
        }
      }
      return minl;
    }
    function normalizeLocale(key) {
      return key ? key.toLowerCase().replace("_", "-") : key;
    }
    function chooseLocale(names) {
      var i = 0, j, next2, locale2, split;
      while (i < names.length) {
        split = normalizeLocale(names[i]).split("-");
        j = split.length;
        next2 = normalizeLocale(names[i + 1]);
        next2 = next2 ? next2.split("-") : null;
        while (j > 0) {
          locale2 = loadLocale(split.slice(0, j).join("-"));
          if (locale2) {
            return locale2;
          }
          if (next2 && next2.length >= j && commonPrefix(split, next2) >= j - 1) {
            break;
          }
          j--;
        }
        i++;
      }
      return globalLocale;
    }
    function isLocaleNameSane(name) {
      return name.match("^[^/\\\\]*$") != null;
    }
    function loadLocale(name) {
      var oldLocale = null, aliasedRequire;
      if (locales[name] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name)) {
        try {
          oldLocale = globalLocale._abbr;
          aliasedRequire = require;
          aliasedRequire("./locale/" + name);
          getSetGlobalLocale(oldLocale);
        } catch (e2) {
          locales[name] = null;
        }
      }
      return locales[name];
    }
    function getSetGlobalLocale(key, values2) {
      var data;
      if (key) {
        if (isUndefined(values2)) {
          data = getLocale(key);
        } else {
          data = defineLocale(key, values2);
        }
        if (data) {
          globalLocale = data;
        } else {
          if (typeof console !== "undefined" && console.warn) {
            console.warn(
              "Locale " + key + " not found. Did you forget to load it?"
            );
          }
        }
      }
      return globalLocale._abbr;
    }
    function defineLocale(name, config2) {
      if (config2 !== null) {
        var locale2, parentConfig = baseConfig;
        config2.abbr = name;
        if (locales[name] != null) {
          deprecateSimple(
            "defineLocaleOverride",
            "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
          );
          parentConfig = locales[name]._config;
        } else if (config2.parentLocale != null) {
          if (locales[config2.parentLocale] != null) {
            parentConfig = locales[config2.parentLocale]._config;
          } else {
            locale2 = loadLocale(config2.parentLocale);
            if (locale2 != null) {
              parentConfig = locale2._config;
            } else {
              if (!localeFamilies[config2.parentLocale]) {
                localeFamilies[config2.parentLocale] = [];
              }
              localeFamilies[config2.parentLocale].push({
                name,
                config: config2
              });
              return null;
            }
          }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config2));
        if (localeFamilies[name]) {
          localeFamilies[name].forEach(function(x2) {
            defineLocale(x2.name, x2.config);
          });
        }
        getSetGlobalLocale(name);
        return locales[name];
      } else {
        delete locales[name];
        return null;
      }
    }
    function updateLocale(name, config2) {
      if (config2 != null) {
        var locale2, tmpLocale, parentConfig = baseConfig;
        if (locales[name] != null && locales[name].parentLocale != null) {
          locales[name].set(mergeConfigs(locales[name]._config, config2));
        } else {
          tmpLocale = loadLocale(name);
          if (tmpLocale != null) {
            parentConfig = tmpLocale._config;
          }
          config2 = mergeConfigs(parentConfig, config2);
          if (tmpLocale == null) {
            config2.abbr = name;
          }
          locale2 = new Locale(config2);
          locale2.parentLocale = locales[name];
          locales[name] = locale2;
        }
        getSetGlobalLocale(name);
      } else {
        if (locales[name] != null) {
          if (locales[name].parentLocale != null) {
            locales[name] = locales[name].parentLocale;
            if (name === getSetGlobalLocale()) {
              getSetGlobalLocale(name);
            }
          } else if (locales[name] != null) {
            delete locales[name];
          }
        }
      }
      return locales[name];
    }
    function getLocale(key) {
      var locale2;
      if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
      }
      if (!key) {
        return globalLocale;
      }
      if (!isArray(key)) {
        locale2 = loadLocale(key);
        if (locale2) {
          return locale2;
        }
        key = [key];
      }
      return chooseLocale(key);
    }
    function listLocales() {
      return keys(locales);
    }
    function checkOverflow(m2) {
      var overflow2, a = m2._a;
      if (a && getParsingFlags(m2).overflow === -2) {
        overflow2 = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
        if (getParsingFlags(m2)._overflowDayOfYear && (overflow2 < YEAR || overflow2 > DATE)) {
          overflow2 = DATE;
        }
        if (getParsingFlags(m2)._overflowWeeks && overflow2 === -1) {
          overflow2 = WEEK;
        }
        if (getParsingFlags(m2)._overflowWeekday && overflow2 === -1) {
          overflow2 = WEEKDAY;
        }
        getParsingFlags(m2).overflow = overflow2;
      }
      return m2;
    }
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
      ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
      ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
      ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
      ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
      ["YYYY-DDD", /\d{4}-\d{3}/],
      ["YYYY-MM", /\d{4}-\d\d/, false],
      ["YYYYYYMMDD", /[+-]\d{10}/],
      ["YYYYMMDD", /\d{8}/],
      ["GGGG[W]WWE", /\d{4}W\d{3}/],
      ["GGGG[W]WW", /\d{4}W\d{2}/, false],
      ["YYYYDDD", /\d{7}/],
      ["YYYYMM", /\d{6}/, false],
      ["YYYY", /\d{4}/, false]
    ], isoTimes = [
      ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
      ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
      ["HH:mm:ss", /\d\d:\d\d:\d\d/],
      ["HH:mm", /\d\d:\d\d/],
      ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
      ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
      ["HHmmss", /\d\d\d\d\d\d/],
      ["HHmm", /\d\d\d\d/],
      ["HH", /\d\d/]
    ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
      UT: 0,
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };
    function configFromISO(config2) {
      var i, l2, string = config2._i, match5 = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat2, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
      if (match5) {
        getParsingFlags(config2).iso = true;
        for (i = 0, l2 = isoDatesLen; i < l2; i++) {
          if (isoDates[i][1].exec(match5[1])) {
            dateFormat2 = isoDates[i][0];
            allowTime = isoDates[i][2] !== false;
            break;
          }
        }
        if (dateFormat2 == null) {
          config2._isValid = false;
          return;
        }
        if (match5[3]) {
          for (i = 0, l2 = isoTimesLen; i < l2; i++) {
            if (isoTimes[i][1].exec(match5[3])) {
              timeFormat = (match5[2] || " ") + isoTimes[i][0];
              break;
            }
          }
          if (timeFormat == null) {
            config2._isValid = false;
            return;
          }
        }
        if (!allowTime && timeFormat != null) {
          config2._isValid = false;
          return;
        }
        if (match5[4]) {
          if (tzRegex.exec(match5[4])) {
            tzFormat = "Z";
          } else {
            config2._isValid = false;
            return;
          }
        }
        config2._f = dateFormat2 + (timeFormat || "") + (tzFormat || "");
        configFromStringAndFormat(config2);
      } else {
        config2._isValid = false;
      }
    }
    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      var result = [
        untruncateYear(yearStr),
        defaultLocaleMonthsShort.indexOf(monthStr),
        parseInt(dayStr, 10),
        parseInt(hourStr, 10),
        parseInt(minuteStr, 10)
      ];
      if (secondStr) {
        result.push(parseInt(secondStr, 10));
      }
      return result;
    }
    function untruncateYear(yearStr) {
      var year = parseInt(yearStr, 10);
      if (year <= 49) {
        return 2e3 + year;
      } else if (year <= 999) {
        return 1900 + year;
      }
      return year;
    }
    function preprocessRFC2822(s) {
      return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
    }
    function checkWeekday(weekdayStr, parsedInput, config2) {
      if (weekdayStr) {
        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
          parsedInput[0],
          parsedInput[1],
          parsedInput[2]
        ).getDay();
        if (weekdayProvided !== weekdayActual) {
          getParsingFlags(config2).weekdayMismatch = true;
          config2._isValid = false;
          return false;
        }
      }
      return true;
    }
    function calculateOffset(obsOffset, militaryOffset, numOffset) {
      if (obsOffset) {
        return obsOffsets[obsOffset];
      } else if (militaryOffset) {
        return 0;
      } else {
        var hm = parseInt(numOffset, 10), m2 = hm % 100, h2 = (hm - m2) / 100;
        return h2 * 60 + m2;
      }
    }
    function configFromRFC2822(config2) {
      var match5 = rfc2822.exec(preprocessRFC2822(config2._i)), parsedArray;
      if (match5) {
        parsedArray = extractFromRFC2822Strings(
          match5[4],
          match5[3],
          match5[2],
          match5[5],
          match5[6],
          match5[7]
        );
        if (!checkWeekday(match5[1], parsedArray, config2)) {
          return;
        }
        config2._a = parsedArray;
        config2._tzm = calculateOffset(match5[8], match5[9], match5[10]);
        config2._d = createUTCDate.apply(null, config2._a);
        config2._d.setUTCMinutes(config2._d.getUTCMinutes() - config2._tzm);
        getParsingFlags(config2).rfc2822 = true;
      } else {
        config2._isValid = false;
      }
    }
    function configFromString(config2) {
      var matched = aspNetJsonRegex.exec(config2._i);
      if (matched !== null) {
        config2._d = new Date(+matched[1]);
        return;
      }
      configFromISO(config2);
      if (config2._isValid === false) {
        delete config2._isValid;
      } else {
        return;
      }
      configFromRFC2822(config2);
      if (config2._isValid === false) {
        delete config2._isValid;
      } else {
        return;
      }
      if (config2._strict) {
        config2._isValid = false;
      } else {
        hooks.createFromInputFallback(config2);
      }
    }
    hooks.createFromInputFallback = deprecate(
      "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
      function(config2) {
        config2._d = new Date(config2._i + (config2._useUTC ? " UTC" : ""));
      }
    );
    function defaults(a, b2, c2) {
      if (a != null) {
        return a;
      }
      if (b2 != null) {
        return b2;
      }
      return c2;
    }
    function currentDateArray(config2) {
      var nowValue = new Date(hooks.now());
      if (config2._useUTC) {
        return [
          nowValue.getUTCFullYear(),
          nowValue.getUTCMonth(),
          nowValue.getUTCDate()
        ];
      }
      return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }
    function configFromArray(config2) {
      var i, date, input = [], currentDate, expectedWeekday, yearToUse;
      if (config2._d) {
        return;
      }
      currentDate = currentDateArray(config2);
      if (config2._w && config2._a[DATE] == null && config2._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config2);
      }
      if (config2._dayOfYear != null) {
        yearToUse = defaults(config2._a[YEAR], currentDate[YEAR]);
        if (config2._dayOfYear > daysInYear(yearToUse) || config2._dayOfYear === 0) {
          getParsingFlags(config2)._overflowDayOfYear = true;
        }
        date = createUTCDate(yearToUse, 0, config2._dayOfYear);
        config2._a[MONTH] = date.getUTCMonth();
        config2._a[DATE] = date.getUTCDate();
      }
      for (i = 0; i < 3 && config2._a[i] == null; ++i) {
        config2._a[i] = input[i] = currentDate[i];
      }
      for (; i < 7; i++) {
        config2._a[i] = input[i] = config2._a[i] == null ? i === 2 ? 1 : 0 : config2._a[i];
      }
      if (config2._a[HOUR] === 24 && config2._a[MINUTE] === 0 && config2._a[SECOND] === 0 && config2._a[MILLISECOND] === 0) {
        config2._nextDay = true;
        config2._a[HOUR] = 0;
      }
      config2._d = (config2._useUTC ? createUTCDate : createDate).apply(
        null,
        input
      );
      expectedWeekday = config2._useUTC ? config2._d.getUTCDay() : config2._d.getDay();
      if (config2._tzm != null) {
        config2._d.setUTCMinutes(config2._d.getUTCMinutes() - config2._tzm);
      }
      if (config2._nextDay) {
        config2._a[HOUR] = 24;
      }
      if (config2._w && typeof config2._w.d !== "undefined" && config2._w.d !== expectedWeekday) {
        getParsingFlags(config2).weekdayMismatch = true;
      }
    }
    function dayOfYearFromWeekInfo(config2) {
      var w2, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
      w2 = config2._w;
      if (w2.GG != null || w2.W != null || w2.E != null) {
        dow = 1;
        doy = 4;
        weekYear = defaults(
          w2.GG,
          config2._a[YEAR],
          weekOfYear(createLocal(), 1, 4).year
        );
        week = defaults(w2.W, 1);
        weekday = defaults(w2.E, 1);
        if (weekday < 1 || weekday > 7) {
          weekdayOverflow = true;
        }
      } else {
        dow = config2._locale._week.dow;
        doy = config2._locale._week.doy;
        curWeek = weekOfYear(createLocal(), dow, doy);
        weekYear = defaults(w2.gg, config2._a[YEAR], curWeek.year);
        week = defaults(w2.w, curWeek.week);
        if (w2.d != null) {
          weekday = w2.d;
          if (weekday < 0 || weekday > 6) {
            weekdayOverflow = true;
          }
        } else if (w2.e != null) {
          weekday = w2.e + dow;
          if (w2.e < 0 || w2.e > 6) {
            weekdayOverflow = true;
          }
        } else {
          weekday = dow;
        }
      }
      if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config2)._overflowWeeks = true;
      } else if (weekdayOverflow != null) {
        getParsingFlags(config2)._overflowWeekday = true;
      } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config2._a[YEAR] = temp.year;
        config2._dayOfYear = temp.dayOfYear;
      }
    }
    hooks.ISO_8601 = function() {
    };
    hooks.RFC_2822 = function() {
    };
    function configFromStringAndFormat(config2) {
      if (config2._f === hooks.ISO_8601) {
        configFromISO(config2);
        return;
      }
      if (config2._f === hooks.RFC_2822) {
        configFromRFC2822(config2);
        return;
      }
      config2._a = [];
      getParsingFlags(config2).empty = true;
      var string = "" + config2._i, i, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
      tokens2 = expandFormat(config2._f, config2._locale).match(formattingTokens) || [];
      tokenLen = tokens2.length;
      for (i = 0; i < tokenLen; i++) {
        token2 = tokens2[i];
        parsedInput = (string.match(getParseRegexForToken(token2, config2)) || [])[0];
        if (parsedInput) {
          skipped = string.substr(0, string.indexOf(parsedInput));
          if (skipped.length > 0) {
            getParsingFlags(config2).unusedInput.push(skipped);
          }
          string = string.slice(
            string.indexOf(parsedInput) + parsedInput.length
          );
          totalParsedInputLength += parsedInput.length;
        }
        if (formatTokenFunctions[token2]) {
          if (parsedInput) {
            getParsingFlags(config2).empty = false;
          } else {
            getParsingFlags(config2).unusedTokens.push(token2);
          }
          addTimeToArrayFromToken(token2, parsedInput, config2);
        } else if (config2._strict && !parsedInput) {
          getParsingFlags(config2).unusedTokens.push(token2);
        }
      }
      getParsingFlags(config2).charsLeftOver = stringLength - totalParsedInputLength;
      if (string.length > 0) {
        getParsingFlags(config2).unusedInput.push(string);
      }
      if (config2._a[HOUR] <= 12 && getParsingFlags(config2).bigHour === true && config2._a[HOUR] > 0) {
        getParsingFlags(config2).bigHour = void 0;
      }
      getParsingFlags(config2).parsedDateParts = config2._a.slice(0);
      getParsingFlags(config2).meridiem = config2._meridiem;
      config2._a[HOUR] = meridiemFixWrap(
        config2._locale,
        config2._a[HOUR],
        config2._meridiem
      );
      era = getParsingFlags(config2).era;
      if (era !== null) {
        config2._a[YEAR] = config2._locale.erasConvertYear(era, config2._a[YEAR]);
      }
      configFromArray(config2);
      checkOverflow(config2);
    }
    function meridiemFixWrap(locale2, hour, meridiem2) {
      var isPm;
      if (meridiem2 == null) {
        return hour;
      }
      if (locale2.meridiemHour != null) {
        return locale2.meridiemHour(hour, meridiem2);
      } else if (locale2.isPM != null) {
        isPm = locale2.isPM(meridiem2);
        if (isPm && hour < 12) {
          hour += 12;
        }
        if (!isPm && hour === 12) {
          hour = 0;
        }
        return hour;
      } else {
        return hour;
      }
    }
    function configFromStringAndArray(config2) {
      var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config2._f.length;
      if (configfLen === 0) {
        getParsingFlags(config2).invalidFormat = true;
        config2._d = new Date(NaN);
        return;
      }
      for (i = 0; i < configfLen; i++) {
        currentScore = 0;
        validFormatFound = false;
        tempConfig = copyConfig({}, config2);
        if (config2._useUTC != null) {
          tempConfig._useUTC = config2._useUTC;
        }
        tempConfig._f = config2._f[i];
        configFromStringAndFormat(tempConfig);
        if (isValid(tempConfig)) {
          validFormatFound = true;
        }
        currentScore += getParsingFlags(tempConfig).charsLeftOver;
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
        getParsingFlags(tempConfig).score = currentScore;
        if (!bestFormatIsValid) {
          if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
            if (validFormatFound) {
              bestFormatIsValid = true;
            }
          }
        } else {
          if (currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
          }
        }
      }
      extend(config2, bestMoment || tempConfig);
    }
    function configFromObject(config2) {
      if (config2._d) {
        return;
      }
      var i = normalizeObjectUnits(config2._i), dayOrDate = i.day === void 0 ? i.date : i.day;
      config2._a = map(
        [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
        function(obj) {
          return obj && parseInt(obj, 10);
        }
      );
      configFromArray(config2);
    }
    function createFromConfig(config2) {
      var res = new Moment(checkOverflow(prepareConfig(config2)));
      if (res._nextDay) {
        res.add(1, "d");
        res._nextDay = void 0;
      }
      return res;
    }
    function prepareConfig(config2) {
      var input = config2._i, format2 = config2._f;
      config2._locale = config2._locale || getLocale(config2._l);
      if (input === null || format2 === void 0 && input === "") {
        return createInvalid({ nullInput: true });
      }
      if (typeof input === "string") {
        config2._i = input = config2._locale.preparse(input);
      }
      if (isMoment(input)) {
        return new Moment(checkOverflow(input));
      } else if (isDate(input)) {
        config2._d = input;
      } else if (isArray(format2)) {
        configFromStringAndArray(config2);
      } else if (format2) {
        configFromStringAndFormat(config2);
      } else {
        configFromInput(config2);
      }
      if (!isValid(config2)) {
        config2._d = null;
      }
      return config2;
    }
    function configFromInput(config2) {
      var input = config2._i;
      if (isUndefined(input)) {
        config2._d = new Date(hooks.now());
      } else if (isDate(input)) {
        config2._d = new Date(input.valueOf());
      } else if (typeof input === "string") {
        configFromString(config2);
      } else if (isArray(input)) {
        config2._a = map(input.slice(0), function(obj) {
          return parseInt(obj, 10);
        });
        configFromArray(config2);
      } else if (isObject(input)) {
        configFromObject(config2);
      } else if (isNumber(input)) {
        config2._d = new Date(input);
      } else {
        hooks.createFromInputFallback(config2);
      }
    }
    function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
      var c2 = {};
      if (format2 === true || format2 === false) {
        strict = format2;
        format2 = void 0;
      }
      if (locale2 === true || locale2 === false) {
        strict = locale2;
        locale2 = void 0;
      }
      if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
        input = void 0;
      }
      c2._isAMomentObject = true;
      c2._useUTC = c2._isUTC = isUTC;
      c2._l = locale2;
      c2._i = input;
      c2._f = format2;
      c2._strict = strict;
      return createFromConfig(c2);
    }
    function createLocal(input, format2, locale2, strict) {
      return createLocalOrUTC(input, format2, locale2, strict, false);
    }
    var prototypeMin = deprecate(
      "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
      function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other < this ? this : other;
        } else {
          return createInvalid();
        }
      }
    ), prototypeMax = deprecate(
      "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
      function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other > this ? this : other;
        } else {
          return createInvalid();
        }
      }
    );
    function pickBy(fn, moments) {
      var res, i;
      if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
      }
      if (!moments.length) {
        return createLocal();
      }
      res = moments[0];
      for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
          res = moments[i];
        }
      }
      return res;
    }
    function min() {
      var args = [].slice.call(arguments, 0);
      return pickBy("isBefore", args);
    }
    function max() {
      var args = [].slice.call(arguments, 0);
      return pickBy("isAfter", args);
    }
    var now = function() {
      return Date.now ? Date.now() : +new Date();
    };
    var ordering = [
      "year",
      "quarter",
      "month",
      "week",
      "day",
      "hour",
      "minute",
      "second",
      "millisecond"
    ];
    function isDurationValid(m2) {
      var key, unitHasDecimal = false, i, orderLen = ordering.length;
      for (key in m2) {
        if (hasOwnProp(m2, key) && !(indexOf.call(ordering, key) !== -1 && (m2[key] == null || !isNaN(m2[key])))) {
          return false;
        }
      }
      for (i = 0; i < orderLen; ++i) {
        if (m2[ordering[i]]) {
          if (unitHasDecimal) {
            return false;
          }
          if (parseFloat(m2[ordering[i]]) !== toInt(m2[ordering[i]])) {
            unitHasDecimal = true;
          }
        }
      }
      return true;
    }
    function isValid$1() {
      return this._isValid;
    }
    function createInvalid$1() {
      return createDuration(NaN);
    }
    function Duration(duration2) {
      var normalizedInput = normalizeObjectUnits(duration2), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
      this._isValid = isDurationValid(normalizedInput);
      this._milliseconds = +milliseconds2 + seconds2 * 1e3 + minutes2 * 6e4 + hours2 * 1e3 * 60 * 60;
      this._days = +days2 + weeks2 * 7;
      this._months = +months2 + quarters * 3 + years2 * 12;
      this._data = {};
      this._locale = getLocale();
      this._bubble();
    }
    function isDuration(obj) {
      return obj instanceof Duration;
    }
    function absRound(number) {
      if (number < 0) {
        return Math.round(-1 * number) * -1;
      } else {
        return Math.round(number);
      }
    }
    function compareArrays(array1, array2, dontConvert) {
      var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
      for (i = 0; i < len; i++) {
        if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
          diffs++;
        }
      }
      return diffs + lengthDiff;
    }
    function offset(token2, separator) {
      addFormatToken(token2, 0, 0, function() {
        var offset2 = this.utcOffset(), sign2 = "+";
        if (offset2 < 0) {
          offset2 = -offset2;
          sign2 = "-";
        }
        return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
      });
    }
    offset("Z", ":");
    offset("ZZ", "");
    addRegexToken("Z", matchShortOffset);
    addRegexToken("ZZ", matchShortOffset);
    addParseToken(["Z", "ZZ"], function(input, array, config2) {
      config2._useUTC = true;
      config2._tzm = offsetFromString(matchShortOffset, input);
    });
    var chunkOffset = /([\+\-]|\d\d)/gi;
    function offsetFromString(matcher, string) {
      var matches = (string || "").match(matcher), chunk, parts, minutes2;
      if (matches === null) {
        return null;
      }
      chunk = matches[matches.length - 1] || [];
      parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
      minutes2 = +(parts[1] * 60) + toInt(parts[2]);
      return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
    }
    function cloneWithOffset(input, model) {
      var res, diff2;
      if (model._isUTC) {
        res = model.clone();
        diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        res._d.setTime(res._d.valueOf() + diff2);
        hooks.updateOffset(res, false);
        return res;
      } else {
        return createLocal(input).local();
      }
    }
    function getDateOffset(m2) {
      return -Math.round(m2._d.getTimezoneOffset());
    }
    hooks.updateOffset = function() {
    };
    function getSetOffset(input, keepLocalTime, keepMinutes) {
      var offset2 = this._offset || 0, localAdjust;
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      if (input != null) {
        if (typeof input === "string") {
          input = offsetFromString(matchShortOffset, input);
          if (input === null) {
            return this;
          }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
          input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
          localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
          this.add(localAdjust, "m");
        }
        if (offset2 !== input) {
          if (!keepLocalTime || this._changeInProgress) {
            addSubtract(
              this,
              createDuration(input - offset2, "m"),
              1,
              false
            );
          } else if (!this._changeInProgress) {
            this._changeInProgress = true;
            hooks.updateOffset(this, true);
            this._changeInProgress = null;
          }
        }
        return this;
      } else {
        return this._isUTC ? offset2 : getDateOffset(this);
      }
    }
    function getSetZone(input, keepLocalTime) {
      if (input != null) {
        if (typeof input !== "string") {
          input = -input;
        }
        this.utcOffset(input, keepLocalTime);
        return this;
      } else {
        return -this.utcOffset();
      }
    }
    function setOffsetToUTC(keepLocalTime) {
      return this.utcOffset(0, keepLocalTime);
    }
    function setOffsetToLocal(keepLocalTime) {
      if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;
        if (keepLocalTime) {
          this.subtract(getDateOffset(this), "m");
        }
      }
      return this;
    }
    function setOffsetToParsedOffset() {
      if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
      } else if (typeof this._i === "string") {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
          this.utcOffset(tZone);
        } else {
          this.utcOffset(0, true);
        }
      }
      return this;
    }
    function hasAlignedHourOffset(input) {
      if (!this.isValid()) {
        return false;
      }
      input = input ? createLocal(input).utcOffset() : 0;
      return (this.utcOffset() - input) % 60 === 0;
    }
    function isDaylightSavingTime() {
      return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }
    function isDaylightSavingTimeShifted() {
      if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
      }
      var c2 = {}, other;
      copyConfig(c2, this);
      c2 = prepareConfig(c2);
      if (c2._a) {
        other = c2._isUTC ? createUTC(c2._a) : createLocal(c2._a);
        this._isDSTShifted = this.isValid() && compareArrays(c2._a, other.toArray()) > 0;
      } else {
        this._isDSTShifted = false;
      }
      return this._isDSTShifted;
    }
    function isLocal() {
      return this.isValid() ? !this._isUTC : false;
    }
    function isUtcOffset() {
      return this.isValid() ? this._isUTC : false;
    }
    function isUtc() {
      return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }
    var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
    function createDuration(input, key) {
      var duration2 = input, match5 = null, sign2, ret, diffRes;
      if (isDuration(input)) {
        duration2 = {
          ms: input._milliseconds,
          d: input._days,
          M: input._months
        };
      } else if (isNumber(input) || !isNaN(+input)) {
        duration2 = {};
        if (key) {
          duration2[key] = +input;
        } else {
          duration2.milliseconds = +input;
        }
      } else if (match5 = aspNetRegex.exec(input)) {
        sign2 = match5[1] === "-" ? -1 : 1;
        duration2 = {
          y: 0,
          d: toInt(match5[DATE]) * sign2,
          h: toInt(match5[HOUR]) * sign2,
          m: toInt(match5[MINUTE]) * sign2,
          s: toInt(match5[SECOND]) * sign2,
          ms: toInt(absRound(match5[MILLISECOND] * 1e3)) * sign2
        };
      } else if (match5 = isoRegex.exec(input)) {
        sign2 = match5[1] === "-" ? -1 : 1;
        duration2 = {
          y: parseIso(match5[2], sign2),
          M: parseIso(match5[3], sign2),
          w: parseIso(match5[4], sign2),
          d: parseIso(match5[5], sign2),
          h: parseIso(match5[6], sign2),
          m: parseIso(match5[7], sign2),
          s: parseIso(match5[8], sign2)
        };
      } else if (duration2 == null) {
        duration2 = {};
      } else if (typeof duration2 === "object" && ("from" in duration2 || "to" in duration2)) {
        diffRes = momentsDifference(
          createLocal(duration2.from),
          createLocal(duration2.to)
        );
        duration2 = {};
        duration2.ms = diffRes.milliseconds;
        duration2.M = diffRes.months;
      }
      ret = new Duration(duration2);
      if (isDuration(input) && hasOwnProp(input, "_locale")) {
        ret._locale = input._locale;
      }
      if (isDuration(input) && hasOwnProp(input, "_isValid")) {
        ret._isValid = input._isValid;
      }
      return ret;
    }
    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;
    function parseIso(inp, sign2) {
      var res = inp && parseFloat(inp.replace(",", "."));
      return (isNaN(res) ? 0 : res) * sign2;
    }
    function positiveMomentsDifference(base, other) {
      var res = {};
      res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
      if (base.clone().add(res.months, "M").isAfter(other)) {
        --res.months;
      }
      res.milliseconds = +other - +base.clone().add(res.months, "M");
      return res;
    }
    function momentsDifference(base, other) {
      var res;
      if (!(base.isValid() && other.isValid())) {
        return { milliseconds: 0, months: 0 };
      }
      other = cloneWithOffset(other, base);
      if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
      } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
      }
      return res;
    }
    function createAdder(direction, name) {
      return function(val, period) {
        var dur, tmp;
        if (period !== null && !isNaN(+period)) {
          deprecateSimple(
            name,
            "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
          );
          tmp = val;
          val = period;
          period = tmp;
        }
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
      };
    }
    function addSubtract(mom, duration2, isAdding, updateOffset) {
      var milliseconds2 = duration2._milliseconds, days2 = absRound(duration2._days), months2 = absRound(duration2._months);
      if (!mom.isValid()) {
        return;
      }
      updateOffset = updateOffset == null ? true : updateOffset;
      if (months2) {
        setMonth(mom, get$c(mom, "Month") + months2 * isAdding);
      }
      if (days2) {
        set$1(mom, "Date", get$c(mom, "Date") + days2 * isAdding);
      }
      if (milliseconds2) {
        mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
      }
      if (updateOffset) {
        hooks.updateOffset(mom, days2 || months2);
      }
    }
    var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
    function isString(input) {
      return typeof input === "string" || input instanceof String;
    }
    function isMomentInput(input) {
      return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
    }
    function isMomentInputObject(input) {
      var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties2 = [
        "years",
        "year",
        "y",
        "months",
        "month",
        "M",
        "days",
        "day",
        "d",
        "dates",
        "date",
        "D",
        "hours",
        "hour",
        "h",
        "minutes",
        "minute",
        "m",
        "seconds",
        "second",
        "s",
        "milliseconds",
        "millisecond",
        "ms"
      ], i, property, propertyLen = properties2.length;
      for (i = 0; i < propertyLen; i += 1) {
        property = properties2[i];
        propertyTest = propertyTest || hasOwnProp(input, property);
      }
      return objectTest && propertyTest;
    }
    function isNumberOrStringArray(input) {
      var arrayTest = isArray(input), dataTypeTest = false;
      if (arrayTest) {
        dataTypeTest = input.filter(function(item) {
          return !isNumber(item) && isString(input);
        }).length === 0;
      }
      return arrayTest && dataTypeTest;
    }
    function isCalendarSpec(input) {
      var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties2 = [
        "sameDay",
        "nextDay",
        "lastDay",
        "nextWeek",
        "lastWeek",
        "sameElse"
      ], i, property;
      for (i = 0; i < properties2.length; i += 1) {
        property = properties2[i];
        propertyTest = propertyTest || hasOwnProp(input, property);
      }
      return objectTest && propertyTest;
    }
    function getCalendarFormat(myMoment, now2) {
      var diff2 = myMoment.diff(now2, "days", true);
      return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
    }
    function calendar$1(time, formats) {
      if (arguments.length === 1) {
        if (!arguments[0]) {
          time = void 0;
          formats = void 0;
        } else if (isMomentInput(arguments[0])) {
          time = arguments[0];
          formats = void 0;
        } else if (isCalendarSpec(arguments[0])) {
          formats = arguments[0];
          time = void 0;
        }
      }
      var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
      return this.format(
        output || this.localeData().calendar(format2, this, createLocal(now2))
      );
    }
    function clone() {
      return new Moment(this);
    }
    function isAfter(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(units) || "millisecond";
      if (units === "millisecond") {
        return this.valueOf() > localInput.valueOf();
      } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
      }
    }
    function isBefore(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(units) || "millisecond";
      if (units === "millisecond") {
        return this.valueOf() < localInput.valueOf();
      } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
      }
    }
    function isBetween(from2, to2, units, inclusivity) {
      var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
      if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
        return false;
      }
      inclusivity = inclusivity || "()";
      return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }
    function isSame(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input), inputMs;
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(units) || "millisecond";
      if (units === "millisecond") {
        return this.valueOf() === localInput.valueOf();
      } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
      }
    }
    function isSameOrAfter(input, units) {
      return this.isSame(input, units) || this.isAfter(input, units);
    }
    function isSameOrBefore(input, units) {
      return this.isSame(input, units) || this.isBefore(input, units);
    }
    function diff(input, units, asFloat) {
      var that, zoneDelta, output;
      if (!this.isValid()) {
        return NaN;
      }
      that = cloneWithOffset(input, this);
      if (!that.isValid()) {
        return NaN;
      }
      zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
      units = normalizeUnits(units);
      switch (units) {
        case "year":
          output = monthDiff(this, that) / 12;
          break;
        case "month":
          output = monthDiff(this, that);
          break;
        case "quarter":
          output = monthDiff(this, that) / 3;
          break;
        case "second":
          output = (this - that) / 1e3;
          break;
        case "minute":
          output = (this - that) / 6e4;
          break;
        case "hour":
          output = (this - that) / 36e5;
          break;
        case "day":
          output = (this - that - zoneDelta) / 864e5;
          break;
        case "week":
          output = (this - that - zoneDelta) / 6048e5;
          break;
        default:
          output = this - that;
      }
      return asFloat ? output : absFloor(output);
    }
    function monthDiff(a, b2) {
      if (a.date() < b2.date()) {
        return -monthDiff(b2, a);
      }
      var wholeMonthDiff = (b2.year() - a.year()) * 12 + (b2.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
      if (b2 - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
        adjust = (b2 - anchor) / (anchor - anchor2);
      } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
        adjust = (b2 - anchor) / (anchor2 - anchor);
      }
      return -(wholeMonthDiff + adjust) || 0;
    }
    hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
    hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
    function toString() {
      return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
    }
    function toISOString(keepOffset) {
      if (!this.isValid()) {
        return null;
      }
      var utc = keepOffset !== true, m2 = utc ? this.clone().utc() : this;
      if (m2.year() < 0 || m2.year() > 9999) {
        return formatMoment(
          m2,
          utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
        );
      }
      if (isFunction(Date.prototype.toISOString)) {
        if (utc) {
          return this.toDate().toISOString();
        } else {
          return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m2, "Z"));
        }
      }
      return formatMoment(
        m2,
        utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
      );
    }
    function inspect() {
      if (!this.isValid()) {
        return "moment.invalid(/* " + this._i + " */)";
      }
      var func = "moment", zone = "", prefix2, year, datetime, suffix;
      if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
        zone = "Z";
      }
      prefix2 = "[" + func + '("]';
      year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
      datetime = "-MM-DD[T]HH:mm:ss.SSS";
      suffix = zone + '[")]';
      return this.format(prefix2 + year + datetime + suffix);
    }
    function format(inputString) {
      if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
      }
      var output = formatMoment(this, inputString);
      return this.localeData().postformat(output);
    }
    function from(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }
    function fromNow(withoutSuffix) {
      return this.from(createLocal(), withoutSuffix);
    }
    function to(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }
    function toNow(withoutSuffix) {
      return this.to(createLocal(), withoutSuffix);
    }
    function locale(key) {
      var newLocaleData;
      if (key === void 0) {
        return this._locale._abbr;
      } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
          this._locale = newLocaleData;
        }
        return this;
      }
    }
    var lang = deprecate(
      "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
      function(key) {
        if (key === void 0) {
          return this.localeData();
        } else {
          return this.locale(key);
        }
      }
    );
    function localeData() {
      return this._locale;
    }
    var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
    function mod$1(dividend, divisor) {
      return (dividend % divisor + divisor) % divisor;
    }
    function localStartOfDate(y2, m2, d2) {
      if (y2 < 100 && y2 >= 0) {
        return new Date(y2 + 400, m2, d2) - MS_PER_400_YEARS;
      } else {
        return new Date(y2, m2, d2).valueOf();
      }
    }
    function utcStartOfDate(y2, m2, d2) {
      if (y2 < 100 && y2 >= 0) {
        return Date.UTC(y2 + 400, m2, d2) - MS_PER_400_YEARS;
      } else {
        return Date.UTC(y2, m2, d2);
      }
    }
    function startOf(units) {
      var time, startOfDate;
      units = normalizeUnits(units);
      if (units === void 0 || units === "millisecond" || !this.isValid()) {
        return this;
      }
      startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
      switch (units) {
        case "year":
          time = startOfDate(this.year(), 0, 1);
          break;
        case "quarter":
          time = startOfDate(
            this.year(),
            this.month() - this.month() % 3,
            1
          );
          break;
        case "month":
          time = startOfDate(this.year(), this.month(), 1);
          break;
        case "week":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - this.weekday()
          );
          break;
        case "isoWeek":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - (this.isoWeekday() - 1)
          );
          break;
        case "day":
        case "date":
          time = startOfDate(this.year(), this.month(), this.date());
          break;
        case "hour":
          time = this._d.valueOf();
          time -= mod$1(
            time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
            MS_PER_HOUR
          );
          break;
        case "minute":
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_MINUTE);
          break;
        case "second":
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_SECOND);
          break;
      }
      this._d.setTime(time);
      hooks.updateOffset(this, true);
      return this;
    }
    function endOf(units) {
      var time, startOfDate;
      units = normalizeUnits(units);
      if (units === void 0 || units === "millisecond" || !this.isValid()) {
        return this;
      }
      startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
      switch (units) {
        case "year":
          time = startOfDate(this.year() + 1, 0, 1) - 1;
          break;
        case "quarter":
          time = startOfDate(
            this.year(),
            this.month() - this.month() % 3 + 3,
            1
          ) - 1;
          break;
        case "month":
          time = startOfDate(this.year(), this.month() + 1, 1) - 1;
          break;
        case "week":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - this.weekday() + 7
          ) - 1;
          break;
        case "isoWeek":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - (this.isoWeekday() - 1) + 7
          ) - 1;
          break;
        case "day":
        case "date":
          time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
          break;
        case "hour":
          time = this._d.valueOf();
          time += MS_PER_HOUR - mod$1(
            time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
            MS_PER_HOUR
          ) - 1;
          break;
        case "minute":
          time = this._d.valueOf();
          time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
          break;
        case "second":
          time = this._d.valueOf();
          time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
          break;
      }
      this._d.setTime(time);
      hooks.updateOffset(this, true);
      return this;
    }
    function valueOf() {
      return this._d.valueOf() - (this._offset || 0) * 6e4;
    }
    function unix() {
      return Math.floor(this.valueOf() / 1e3);
    }
    function toDate() {
      return new Date(this.valueOf());
    }
    function toArray() {
      var m2 = this;
      return [
        m2.year(),
        m2.month(),
        m2.date(),
        m2.hour(),
        m2.minute(),
        m2.second(),
        m2.millisecond()
      ];
    }
    function toObject() {
      var m2 = this;
      return {
        years: m2.year(),
        months: m2.month(),
        date: m2.date(),
        hours: m2.hours(),
        minutes: m2.minutes(),
        seconds: m2.seconds(),
        milliseconds: m2.milliseconds()
      };
    }
    function toJSON() {
      return this.isValid() ? this.toISOString() : null;
    }
    function isValid$2() {
      return isValid(this);
    }
    function parsingFlags() {
      return extend({}, getParsingFlags(this));
    }
    function invalidAt() {
      return getParsingFlags(this).overflow;
    }
    function creationData() {
      return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
      };
    }
    addFormatToken("N", 0, 0, "eraAbbr");
    addFormatToken("NN", 0, 0, "eraAbbr");
    addFormatToken("NNN", 0, 0, "eraAbbr");
    addFormatToken("NNNN", 0, 0, "eraName");
    addFormatToken("NNNNN", 0, 0, "eraNarrow");
    addFormatToken("y", ["y", 1], "yo", "eraYear");
    addFormatToken("y", ["yy", 2], 0, "eraYear");
    addFormatToken("y", ["yyy", 3], 0, "eraYear");
    addFormatToken("y", ["yyyy", 4], 0, "eraYear");
    addRegexToken("N", matchEraAbbr);
    addRegexToken("NN", matchEraAbbr);
    addRegexToken("NNN", matchEraAbbr);
    addRegexToken("NNNN", matchEraName);
    addRegexToken("NNNNN", matchEraNarrow);
    addParseToken(
      ["N", "NN", "NNN", "NNNN", "NNNNN"],
      function(input, array, config2, token2) {
        var era = config2._locale.erasParse(input, token2, config2._strict);
        if (era) {
          getParsingFlags(config2).era = era;
        } else {
          getParsingFlags(config2).invalidEra = input;
        }
      }
    );
    addRegexToken("y", matchUnsigned);
    addRegexToken("yy", matchUnsigned);
    addRegexToken("yyy", matchUnsigned);
    addRegexToken("yyyy", matchUnsigned);
    addRegexToken("yo", matchEraYearOrdinal);
    addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
    addParseToken(["yo"], function(input, array, config2, token2) {
      var match5;
      if (config2._locale._eraYearOrdinalRegex) {
        match5 = input.match(config2._locale._eraYearOrdinalRegex);
      }
      if (config2._locale.eraYearOrdinalParse) {
        array[YEAR] = config2._locale.eraYearOrdinalParse(input, match5);
      } else {
        array[YEAR] = parseInt(input, 10);
      }
    });
    function localeEras(m2, format2) {
      var i, l2, date, eras = this._eras || getLocale("en")._eras;
      for (i = 0, l2 = eras.length; i < l2; ++i) {
        switch (typeof eras[i].since) {
          case "string":
            date = hooks(eras[i].since).startOf("day");
            eras[i].since = date.valueOf();
            break;
        }
        switch (typeof eras[i].until) {
          case "undefined":
            eras[i].until = Infinity;
            break;
          case "string":
            date = hooks(eras[i].until).startOf("day").valueOf();
            eras[i].until = date.valueOf();
            break;
        }
      }
      return eras;
    }
    function localeErasParse(eraName, format2, strict) {
      var i, l2, eras = this.eras(), name, abbr, narrow;
      eraName = eraName.toUpperCase();
      for (i = 0, l2 = eras.length; i < l2; ++i) {
        name = eras[i].name.toUpperCase();
        abbr = eras[i].abbr.toUpperCase();
        narrow = eras[i].narrow.toUpperCase();
        if (strict) {
          switch (format2) {
            case "N":
            case "NN":
            case "NNN":
              if (abbr === eraName) {
                return eras[i];
              }
              break;
            case "NNNN":
              if (name === eraName) {
                return eras[i];
              }
              break;
            case "NNNNN":
              if (narrow === eraName) {
                return eras[i];
              }
              break;
          }
        } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
          return eras[i];
        }
      }
    }
    function localeErasConvertYear(era, year) {
      var dir = era.since <= era.until ? 1 : -1;
      if (year === void 0) {
        return hooks(era.since).year();
      } else {
        return hooks(era.since).year() + (year - era.offset) * dir;
      }
    }
    function getEraName() {
      var i, l2, val, eras = this.localeData().eras();
      for (i = 0, l2 = eras.length; i < l2; ++i) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i].since <= val && val <= eras[i].until) {
          return eras[i].name;
        }
        if (eras[i].until <= val && val <= eras[i].since) {
          return eras[i].name;
        }
      }
      return "";
    }
    function getEraNarrow() {
      var i, l2, val, eras = this.localeData().eras();
      for (i = 0, l2 = eras.length; i < l2; ++i) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i].since <= val && val <= eras[i].until) {
          return eras[i].narrow;
        }
        if (eras[i].until <= val && val <= eras[i].since) {
          return eras[i].narrow;
        }
      }
      return "";
    }
    function getEraAbbr() {
      var i, l2, val, eras = this.localeData().eras();
      for (i = 0, l2 = eras.length; i < l2; ++i) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i].since <= val && val <= eras[i].until) {
          return eras[i].abbr;
        }
        if (eras[i].until <= val && val <= eras[i].since) {
          return eras[i].abbr;
        }
      }
      return "";
    }
    function getEraYear() {
      var i, l2, dir, val, eras = this.localeData().eras();
      for (i = 0, l2 = eras.length; i < l2; ++i) {
        dir = eras[i].since <= eras[i].until ? 1 : -1;
        val = this.clone().startOf("day").valueOf();
        if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
          return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
        }
      }
      return this.year();
    }
    function erasNameRegex(isStrict) {
      if (!hasOwnProp(this, "_erasNameRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasNameRegex : this._erasRegex;
    }
    function erasAbbrRegex(isStrict) {
      if (!hasOwnProp(this, "_erasAbbrRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasAbbrRegex : this._erasRegex;
    }
    function erasNarrowRegex(isStrict) {
      if (!hasOwnProp(this, "_erasNarrowRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasNarrowRegex : this._erasRegex;
    }
    function matchEraAbbr(isStrict, locale2) {
      return locale2.erasAbbrRegex(isStrict);
    }
    function matchEraName(isStrict, locale2) {
      return locale2.erasNameRegex(isStrict);
    }
    function matchEraNarrow(isStrict, locale2) {
      return locale2.erasNarrowRegex(isStrict);
    }
    function matchEraYearOrdinal(isStrict, locale2) {
      return locale2._eraYearOrdinalRegex || matchUnsigned;
    }
    function computeErasParse() {
      var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l2, eras = this.eras();
      for (i = 0, l2 = eras.length; i < l2; ++i) {
        namePieces.push(regexEscape(eras[i].name));
        abbrPieces.push(regexEscape(eras[i].abbr));
        narrowPieces.push(regexEscape(eras[i].narrow));
        mixedPieces.push(regexEscape(eras[i].name));
        mixedPieces.push(regexEscape(eras[i].abbr));
        mixedPieces.push(regexEscape(eras[i].narrow));
      }
      this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
      this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
      this._erasNarrowRegex = new RegExp(
        "^(" + narrowPieces.join("|") + ")",
        "i"
      );
    }
    addFormatToken(0, ["gg", 2], 0, function() {
      return this.weekYear() % 100;
    });
    addFormatToken(0, ["GG", 2], 0, function() {
      return this.isoWeekYear() % 100;
    });
    function addWeekYearFormatToken(token2, getter) {
      addFormatToken(0, [token2, token2.length], 0, getter);
    }
    addWeekYearFormatToken("gggg", "weekYear");
    addWeekYearFormatToken("ggggg", "weekYear");
    addWeekYearFormatToken("GGGG", "isoWeekYear");
    addWeekYearFormatToken("GGGGG", "isoWeekYear");
    addUnitAlias("weekYear", "gg");
    addUnitAlias("isoWeekYear", "GG");
    addUnitPriority("weekYear", 1);
    addUnitPriority("isoWeekYear", 1);
    addRegexToken("G", matchSigned);
    addRegexToken("g", matchSigned);
    addRegexToken("GG", match1to2, match2);
    addRegexToken("gg", match1to2, match2);
    addRegexToken("GGGG", match1to4, match4);
    addRegexToken("gggg", match1to4, match4);
    addRegexToken("GGGGG", match1to6, match6);
    addRegexToken("ggggg", match1to6, match6);
    addWeekParseToken(
      ["gggg", "ggggg", "GGGG", "GGGGG"],
      function(input, week, config2, token2) {
        week[token2.substr(0, 2)] = toInt(input);
      }
    );
    addWeekParseToken(["gg", "GG"], function(input, week, config2, token2) {
      week[token2] = hooks.parseTwoDigitYear(input);
    });
    function getSetWeekYear(input) {
      return getSetWeekYearHelper.call(
        this,
        input,
        this.week(),
        this.weekday(),
        this.localeData()._week.dow,
        this.localeData()._week.doy
      );
    }
    function getSetISOWeekYear(input) {
      return getSetWeekYearHelper.call(
        this,
        input,
        this.isoWeek(),
        this.isoWeekday(),
        1,
        4
      );
    }
    function getISOWeeksInYear() {
      return weeksInYear(this.year(), 1, 4);
    }
    function getISOWeeksInISOWeekYear() {
      return weeksInYear(this.isoWeekYear(), 1, 4);
    }
    function getWeeksInYear() {
      var weekInfo = this.localeData()._week;
      return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }
    function getWeeksInWeekYear() {
      var weekInfo = this.localeData()._week;
      return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
    }
    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
      var weeksTarget;
      if (input == null) {
        return weekOfYear(this, dow, doy).year;
      } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
          week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
      }
    }
    function setWeekAll(weekYear, week, weekday, dow, doy) {
      var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
      this.year(date.getUTCFullYear());
      this.month(date.getUTCMonth());
      this.date(date.getUTCDate());
      return this;
    }
    addFormatToken("Q", 0, "Qo", "quarter");
    addUnitAlias("quarter", "Q");
    addUnitPriority("quarter", 7);
    addRegexToken("Q", match1);
    addParseToken("Q", function(input, array) {
      array[MONTH] = (toInt(input) - 1) * 3;
    });
    function getSetQuarter(input) {
      return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }
    addFormatToken("D", ["DD", 2], "Do", "date");
    addUnitAlias("date", "D");
    addUnitPriority("date", 9);
    addRegexToken("D", match1to2);
    addRegexToken("DD", match1to2, match2);
    addRegexToken("Do", function(isStrict, locale2) {
      return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
    });
    addParseToken(["D", "DD"], DATE);
    addParseToken("Do", function(input, array) {
      array[DATE] = toInt(input.match(match1to2)[0]);
    });
    var getSetDayOfMonth = makeGetSet("Date", true);
    addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
    addUnitAlias("dayOfYear", "DDD");
    addUnitPriority("dayOfYear", 4);
    addRegexToken("DDD", match1to3);
    addRegexToken("DDDD", match3);
    addParseToken(["DDD", "DDDD"], function(input, array, config2) {
      config2._dayOfYear = toInt(input);
    });
    function getSetDayOfYear(input) {
      var dayOfYear = Math.round(
        (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
      ) + 1;
      return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
    }
    addFormatToken("m", ["mm", 2], 0, "minute");
    addUnitAlias("minute", "m");
    addUnitPriority("minute", 14);
    addRegexToken("m", match1to2);
    addRegexToken("mm", match1to2, match2);
    addParseToken(["m", "mm"], MINUTE);
    var getSetMinute = makeGetSet("Minutes", false);
    addFormatToken("s", ["ss", 2], 0, "second");
    addUnitAlias("second", "s");
    addUnitPriority("second", 15);
    addRegexToken("s", match1to2);
    addRegexToken("ss", match1to2, match2);
    addParseToken(["s", "ss"], SECOND);
    var getSetSecond = makeGetSet("Seconds", false);
    addFormatToken("S", 0, 0, function() {
      return ~~(this.millisecond() / 100);
    });
    addFormatToken(0, ["SS", 2], 0, function() {
      return ~~(this.millisecond() / 10);
    });
    addFormatToken(0, ["SSS", 3], 0, "millisecond");
    addFormatToken(0, ["SSSS", 4], 0, function() {
      return this.millisecond() * 10;
    });
    addFormatToken(0, ["SSSSS", 5], 0, function() {
      return this.millisecond() * 100;
    });
    addFormatToken(0, ["SSSSSS", 6], 0, function() {
      return this.millisecond() * 1e3;
    });
    addFormatToken(0, ["SSSSSSS", 7], 0, function() {
      return this.millisecond() * 1e4;
    });
    addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
      return this.millisecond() * 1e5;
    });
    addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
      return this.millisecond() * 1e6;
    });
    addUnitAlias("millisecond", "ms");
    addUnitPriority("millisecond", 16);
    addRegexToken("S", match1to3, match1);
    addRegexToken("SS", match1to3, match2);
    addRegexToken("SSS", match1to3, match3);
    var token$1, getSetMillisecond;
    for (token$1 = "SSSS"; token$1.length <= 9; token$1 += "S") {
      addRegexToken(token$1, matchUnsigned);
    }
    function parseMs(input, array) {
      array[MILLISECOND] = toInt(("0." + input) * 1e3);
    }
    for (token$1 = "S"; token$1.length <= 9; token$1 += "S") {
      addParseToken(token$1, parseMs);
    }
    getSetMillisecond = makeGetSet("Milliseconds", false);
    addFormatToken("z", 0, 0, "zoneAbbr");
    addFormatToken("zz", 0, 0, "zoneName");
    function getZoneAbbr() {
      return this._isUTC ? "UTC" : "";
    }
    function getZoneName() {
      return this._isUTC ? "Coordinated Universal Time" : "";
    }
    var proto = Moment.prototype;
    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    if (typeof Symbol !== "undefined" && Symbol.for != null) {
      proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
        return "Moment<" + this.format() + ">";
      };
    }
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.eraName = getEraName;
    proto.eraNarrow = getEraNarrow;
    proto.eraAbbr = getEraAbbr;
    proto.eraYear = getEraYear;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.weeksInWeekYear = getWeeksInWeekYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate(
      "dates accessor is deprecated. Use date instead.",
      getSetDayOfMonth
    );
    proto.months = deprecate(
      "months accessor is deprecated. Use month instead",
      getSetMonth
    );
    proto.years = deprecate(
      "years accessor is deprecated. Use year instead",
      getSetYear
    );
    proto.zone = deprecate(
      "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
      getSetZone
    );
    proto.isDSTShifted = deprecate(
      "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
      isDaylightSavingTimeShifted
    );
    function createUnix(input) {
      return createLocal(input * 1e3);
    }
    function createInZone() {
      return createLocal.apply(null, arguments).parseZone();
    }
    function preParsePostFormat(string) {
      return string;
    }
    var proto$1 = Locale.prototype;
    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set;
    proto$1.eras = localeEras;
    proto$1.erasParse = localeErasParse;
    proto$1.erasConvertYear = localeErasConvertYear;
    proto$1.erasAbbrRegex = erasAbbrRegex;
    proto$1.erasNameRegex = erasNameRegex;
    proto$1.erasNarrowRegex = erasNarrowRegex;
    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;
    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;
    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;
    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;
    function get$1$1(format2, index2, field, setter) {
      var locale2 = getLocale(), utc = createUTC().set(setter, index2);
      return locale2[field](utc, format2);
    }
    function listMonthsImpl(format2, index2, field) {
      if (isNumber(format2)) {
        index2 = format2;
        format2 = void 0;
      }
      format2 = format2 || "";
      if (index2 != null) {
        return get$1$1(format2, index2, field, "month");
      }
      var i, out = [];
      for (i = 0; i < 12; i++) {
        out[i] = get$1$1(format2, i, field, "month");
      }
      return out;
    }
    function listWeekdaysImpl(localeSorted, format2, index2, field) {
      if (typeof localeSorted === "boolean") {
        if (isNumber(format2)) {
          index2 = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
      } else {
        format2 = localeSorted;
        index2 = format2;
        localeSorted = false;
        if (isNumber(format2)) {
          index2 = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
      }
      var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
      if (index2 != null) {
        return get$1$1(format2, (index2 + shift) % 7, field, "day");
      }
      for (i = 0; i < 7; i++) {
        out[i] = get$1$1(format2, (i + shift) % 7, field, "day");
      }
      return out;
    }
    function listMonths(format2, index2) {
      return listMonthsImpl(format2, index2, "months");
    }
    function listMonthsShort(format2, index2) {
      return listMonthsImpl(format2, index2, "monthsShort");
    }
    function listWeekdays(localeSorted, format2, index2) {
      return listWeekdaysImpl(localeSorted, format2, index2, "weekdays");
    }
    function listWeekdaysShort(localeSorted, format2, index2) {
      return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysShort");
    }
    function listWeekdaysMin(localeSorted, format2, index2) {
      return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysMin");
    }
    getSetGlobalLocale("en", {
      eras: [
        {
          since: "0001-01-01",
          until: Infinity,
          offset: 1,
          name: "Anno Domini",
          narrow: "AD",
          abbr: "AD"
        },
        {
          since: "0000-12-31",
          until: -Infinity,
          offset: 1,
          name: "Before Christ",
          narrow: "BC",
          abbr: "BC"
        }
      ],
      dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
      ordinal: function(number) {
        var b2 = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b2 === 1 ? "st" : b2 === 2 ? "nd" : b2 === 3 ? "rd" : "th";
        return number + output;
      }
    });
    hooks.lang = deprecate(
      "moment.lang is deprecated. Use moment.locale instead.",
      getSetGlobalLocale
    );
    hooks.langData = deprecate(
      "moment.langData is deprecated. Use moment.localeData instead.",
      getLocale
    );
    var mathAbs = Math.abs;
    function abs() {
      var data = this._data;
      this._milliseconds = mathAbs(this._milliseconds);
      this._days = mathAbs(this._days);
      this._months = mathAbs(this._months);
      data.milliseconds = mathAbs(data.milliseconds);
      data.seconds = mathAbs(data.seconds);
      data.minutes = mathAbs(data.minutes);
      data.hours = mathAbs(data.hours);
      data.months = mathAbs(data.months);
      data.years = mathAbs(data.years);
      return this;
    }
    function addSubtract$1(duration2, input, value, direction) {
      var other = createDuration(input, value);
      duration2._milliseconds += direction * other._milliseconds;
      duration2._days += direction * other._days;
      duration2._months += direction * other._months;
      return duration2._bubble();
    }
    function add$1(input, value) {
      return addSubtract$1(this, input, value, 1);
    }
    function subtract$1(input, value) {
      return addSubtract$1(this, input, value, -1);
    }
    function absCeil(number) {
      if (number < 0) {
        return Math.floor(number);
      } else {
        return Math.ceil(number);
      }
    }
    function bubble() {
      var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
      if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
        milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
        days2 = 0;
        months2 = 0;
      }
      data.milliseconds = milliseconds2 % 1e3;
      seconds2 = absFloor(milliseconds2 / 1e3);
      data.seconds = seconds2 % 60;
      minutes2 = absFloor(seconds2 / 60);
      data.minutes = minutes2 % 60;
      hours2 = absFloor(minutes2 / 60);
      data.hours = hours2 % 24;
      days2 += absFloor(hours2 / 24);
      monthsFromDays = absFloor(daysToMonths(days2));
      months2 += monthsFromDays;
      days2 -= absCeil(monthsToDays(monthsFromDays));
      years2 = absFloor(months2 / 12);
      months2 %= 12;
      data.days = days2;
      data.months = months2;
      data.years = years2;
      return this;
    }
    function daysToMonths(days2) {
      return days2 * 4800 / 146097;
    }
    function monthsToDays(months2) {
      return months2 * 146097 / 4800;
    }
    function as(units) {
      if (!this.isValid()) {
        return NaN;
      }
      var days2, months2, milliseconds2 = this._milliseconds;
      units = normalizeUnits(units);
      if (units === "month" || units === "quarter" || units === "year") {
        days2 = this._days + milliseconds2 / 864e5;
        months2 = this._months + daysToMonths(days2);
        switch (units) {
          case "month":
            return months2;
          case "quarter":
            return months2 / 3;
          case "year":
            return months2 / 12;
        }
      } else {
        days2 = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
          case "week":
            return days2 / 7 + milliseconds2 / 6048e5;
          case "day":
            return days2 + milliseconds2 / 864e5;
          case "hour":
            return days2 * 24 + milliseconds2 / 36e5;
          case "minute":
            return days2 * 1440 + milliseconds2 / 6e4;
          case "second":
            return days2 * 86400 + milliseconds2 / 1e3;
          case "millisecond":
            return Math.floor(days2 * 864e5) + milliseconds2;
          default:
            throw new Error("Unknown unit " + units);
        }
      }
    }
    function valueOf$1() {
      if (!this.isValid()) {
        return NaN;
      }
      return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
    }
    function makeAs(alias) {
      return function() {
        return this.as(alias);
      };
    }
    var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
    function clone$1() {
      return createDuration(this);
    }
    function get$2$1(units) {
      units = normalizeUnits(units);
      return this.isValid() ? this[units + "s"]() : NaN;
    }
    function makeGetter(name) {
      return function() {
        return this.isValid() ? this._data[name] : NaN;
      };
    }
    var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
    function weeks() {
      return absFloor(this.days() / 7);
    }
    var round = Math.round, thresholds = {
      ss: 44,
      s: 45,
      m: 45,
      h: 22,
      d: 26,
      w: null,
      M: 11
    };
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
      return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }
    function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
      var duration2 = createDuration(posNegDuration).abs(), seconds2 = round(duration2.as("s")), minutes2 = round(duration2.as("m")), hours2 = round(duration2.as("h")), days2 = round(duration2.as("d")), months2 = round(duration2.as("M")), weeks2 = round(duration2.as("w")), years2 = round(duration2.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
      if (thresholds2.w != null) {
        a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
      }
      a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
      a[2] = withoutSuffix;
      a[3] = +posNegDuration > 0;
      a[4] = locale2;
      return substituteTimeAgo.apply(null, a);
    }
    function getSetRelativeTimeRounding(roundingFunction) {
      if (roundingFunction === void 0) {
        return round;
      }
      if (typeof roundingFunction === "function") {
        round = roundingFunction;
        return true;
      }
      return false;
    }
    function getSetRelativeTimeThreshold(threshold, limit) {
      if (thresholds[threshold] === void 0) {
        return false;
      }
      if (limit === void 0) {
        return thresholds[threshold];
      }
      thresholds[threshold] = limit;
      if (threshold === "s") {
        thresholds.ss = limit - 1;
      }
      return true;
    }
    function humanize(argWithSuffix, argThresholds) {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }
      var withSuffix = false, th2 = thresholds, locale2, output;
      if (typeof argWithSuffix === "object") {
        argThresholds = argWithSuffix;
        argWithSuffix = false;
      }
      if (typeof argWithSuffix === "boolean") {
        withSuffix = argWithSuffix;
      }
      if (typeof argThresholds === "object") {
        th2 = Object.assign({}, thresholds, argThresholds);
        if (argThresholds.s != null && argThresholds.ss == null) {
          th2.ss = argThresholds.s - 1;
        }
      }
      locale2 = this.localeData();
      output = relativeTime$1(this, !withSuffix, th2, locale2);
      if (withSuffix) {
        output = locale2.pastFuture(+this, output);
      }
      return locale2.postformat(output);
    }
    var abs$1 = Math.abs;
    function sign(x2) {
      return (x2 > 0) - (x2 < 0) || +x2;
    }
    function toISOString$1() {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }
      var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
      if (!total) {
        return "P0D";
      }
      minutes2 = absFloor(seconds2 / 60);
      hours2 = absFloor(minutes2 / 60);
      seconds2 %= 60;
      minutes2 %= 60;
      years2 = absFloor(months2 / 12);
      months2 %= 12;
      s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
      totalSign = total < 0 ? "-" : "";
      ymSign = sign(this._months) !== sign(total) ? "-" : "";
      daysSign = sign(this._days) !== sign(total) ? "-" : "";
      hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
      return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
    }
    var proto$2 = Duration.prototype;
    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2$1;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;
    proto$2.toIsoString = deprecate(
      "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
      toISOString$1
    );
    proto$2.lang = lang;
    addFormatToken("X", 0, 0, "unix");
    addFormatToken("x", 0, 0, "valueOf");
    addRegexToken("x", matchSigned);
    addRegexToken("X", matchTimestamp);
    addParseToken("X", function(input, array, config2) {
      config2._d = new Date(parseFloat(input) * 1e3);
    });
    addParseToken("x", function(input, array, config2) {
      config2._d = new Date(toInt(input));
    });
    //! moment.js
    hooks.version = "2.29.4";
    setHookCallback(createLocal);
    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto;
    hooks.HTML5_FMT = {
      DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
      DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
      DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
      DATE: "YYYY-MM-DD",
      TIME: "HH:mm",
      TIME_SECONDS: "HH:mm:ss",
      TIME_MS: "HH:mm:ss.SSS",
      WEEK: "GGGG-[W]WW",
      MONTH: "YYYY-MM"
    };
    var defaultFormats = {
      normalDateWithWeekday: "ddd, MMM D",
      normalDate: "D MMMM",
      shortDate: "MMM D",
      monthAndDate: "MMMM D",
      dayOfMonth: "D",
      year: "YYYY",
      month: "MMMM",
      monthShort: "MMM",
      monthAndYear: "MMMM YYYY",
      weekday: "dddd",
      weekdayShort: "ddd",
      minutes: "mm",
      hours12h: "hh",
      hours24h: "HH",
      seconds: "ss",
      fullTime: "LT",
      fullTime12h: "hh:mm A",
      fullTime24h: "HH:mm",
      fullDate: "ll",
      fullDateWithWeekday: "dddd, LL",
      fullDateTime: "lll",
      fullDateTime12h: "ll hh:mm A",
      fullDateTime24h: "ll HH:mm",
      keyboardDate: "L",
      keyboardDateTime: "L LT",
      keyboardDateTime12h: "L hh:mm A",
      keyboardDateTime24h: "L HH:mm"
    };
    var MomentUtils = function() {
      function MomentUtils2(_a2) {
        var _this = this;
        var _b = _a2 === void 0 ? {} : _a2, locale2 = _b.locale, formats = _b.formats, instance = _b.instance;
        this.lib = "moment";
        this.is12HourCycleInCurrentLocale = function() {
          return /A|a/.test(_this.moment().localeData().longDateFormat("LT"));
        };
        this.getFormatHelperText = function(format2) {
          var localFormattingTokens2 = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})|./g;
          return format2.match(localFormattingTokens2).map(function(token2) {
            var firstCharacter = token2[0];
            if (firstCharacter === "L" || firstCharacter === ";") {
              return _this.moment.localeData().longDateFormat(token2);
            }
            return token2;
          }).join("").replace(/a/gi, "(a|p)m").toLocaleLowerCase();
        };
        this.getCurrentLocaleCode = function() {
          return _this.locale || _this.moment.locale();
        };
        this.parseISO = function(isoString) {
          return _this.moment(isoString, true);
        };
        this.toISO = function(value) {
          return value.toISOString();
        };
        this.parse = function(value, format2) {
          if (value === "") {
            return null;
          }
          if (_this.locale) {
            return _this.moment(value, format2, _this.locale, true);
          }
          return _this.moment(value, format2, true);
        };
        this.date = function(value) {
          if (value === null) {
            return null;
          }
          var moment = _this.moment(value);
          moment.locale(_this.locale);
          return moment;
        };
        this.toJsDate = function(value) {
          return value.toDate();
        };
        this.isValid = function(value) {
          return _this.moment(value).isValid();
        };
        this.isNull = function(date) {
          return date === null;
        };
        this.getDiff = function(date, comparing, unit) {
          return date.diff(comparing, unit);
        };
        this.isAfter = function(date, value) {
          return date.isAfter(value);
        };
        this.isBefore = function(date, value) {
          return date.isBefore(value);
        };
        this.isAfterDay = function(date, value) {
          return date.isAfter(value, "day");
        };
        this.isBeforeDay = function(date, value) {
          return date.isBefore(value, "day");
        };
        this.isBeforeYear = function(date, value) {
          return date.isBefore(value, "year");
        };
        this.isAfterYear = function(date, value) {
          return date.isAfter(value, "year");
        };
        this.startOfDay = function(date) {
          return date.clone().startOf("day");
        };
        this.endOfDay = function(date) {
          return date.clone().endOf("day");
        };
        this.format = function(date, formatKey) {
          return _this.formatByString(date, _this.formats[formatKey]);
        };
        this.formatByString = function(date, formatString) {
          var clonedDate = date.clone();
          clonedDate.locale(_this.locale);
          return clonedDate.format(formatString);
        };
        this.formatNumber = function(numberToFormat) {
          return numberToFormat;
        };
        this.getHours = function(date) {
          return date.get("hours");
        };
        this.addSeconds = function(date, count) {
          return count < 0 ? date.clone().subtract(Math.abs(count), "seconds") : date.clone().add(count, "seconds");
        };
        this.addMinutes = function(date, count) {
          return count < 0 ? date.clone().subtract(Math.abs(count), "minutes") : date.clone().add(count, "minutes");
        };
        this.addHours = function(date, count) {
          return count < 0 ? date.clone().subtract(Math.abs(count), "hours") : date.clone().add(count, "hours");
        };
        this.addDays = function(date, count) {
          return count < 0 ? date.clone().subtract(Math.abs(count), "days") : date.clone().add(count, "days");
        };
        this.addWeeks = function(date, count) {
          return count < 0 ? date.clone().subtract(Math.abs(count), "weeks") : date.clone().add(count, "weeks");
        };
        this.addMonths = function(date, count) {
          return count < 0 ? date.clone().subtract(Math.abs(count), "months") : date.clone().add(count, "months");
        };
        this.addYears = function(date, count) {
          return count < 0 ? date.clone().subtract(Math.abs(count), "years") : date.clone().add(count, "years");
        };
        this.setHours = function(date, count) {
          return date.clone().hours(count);
        };
        this.getMinutes = function(date) {
          return date.get("minutes");
        };
        this.setMinutes = function(date, count) {
          return date.clone().minutes(count);
        };
        this.getSeconds = function(date) {
          return date.get("seconds");
        };
        this.setSeconds = function(date, count) {
          return date.clone().seconds(count);
        };
        this.getMonth = function(date) {
          return date.get("month");
        };
        this.getDaysInMonth = function(date) {
          return date.daysInMonth();
        };
        this.isSameDay = function(date, comparing) {
          return date.isSame(comparing, "day");
        };
        this.isSameMonth = function(date, comparing) {
          return date.isSame(comparing, "month");
        };
        this.isSameYear = function(date, comparing) {
          return date.isSame(comparing, "year");
        };
        this.isSameHour = function(date, comparing) {
          return date.isSame(comparing, "hour");
        };
        this.setMonth = function(date, count) {
          return date.clone().month(count);
        };
        this.getMeridiemText = function(ampm) {
          if (_this.is12HourCycleInCurrentLocale()) {
            return _this.moment.localeData().meridiem(ampm === "am" ? 0 : 13, 0, false);
          }
          return ampm === "am" ? "AM" : "PM";
        };
        this.startOfYear = function(date) {
          return date.clone().startOf("year");
        };
        this.endOfYear = function(date) {
          return date.clone().endOf("year");
        };
        this.startOfMonth = function(date) {
          return date.clone().startOf("month");
        };
        this.endOfMonth = function(date) {
          return date.clone().endOf("month");
        };
        this.startOfWeek = function(date) {
          return date.clone().startOf("week");
        };
        this.endOfWeek = function(date) {
          return date.clone().endOf("week");
        };
        this.getNextMonth = function(date) {
          return date.clone().add(1, "month");
        };
        this.getPreviousMonth = function(date) {
          return date.clone().subtract(1, "month");
        };
        this.getMonthArray = function(date) {
          var firstMonth = date.clone().startOf("year");
          var monthArray = [firstMonth];
          while (monthArray.length < 12) {
            var prevMonth = monthArray[monthArray.length - 1];
            monthArray.push(_this.getNextMonth(prevMonth));
          }
          return monthArray;
        };
        this.getYear = function(date) {
          return date.get("year");
        };
        this.setYear = function(date, year) {
          return date.clone().set("year", year);
        };
        this.getDate = function(date) {
          return date.get("date");
        };
        this.setDate = function(date, year) {
          return date.clone().set("date", year);
        };
        this.mergeDateAndTime = function(date, time) {
          return date.hour(time.hour()).minute(time.minute()).second(time.second());
        };
        this.getWeekdays = function() {
          return _this.moment.weekdaysShort(true);
        };
        this.isEqual = function(value, comparing) {
          if (value === null && comparing === null) {
            return true;
          }
          return _this.moment(value).isSame(comparing);
        };
        this.getWeekArray = function(date) {
          var start2 = date.clone().startOf("month").startOf("week");
          var end2 = date.clone().endOf("month").endOf("week");
          var count = 0;
          var current = start2;
          var nestedWeeks = [];
          while (current.isBefore(end2)) {
            var weekNumber = Math.floor(count / 7);
            nestedWeeks[weekNumber] = nestedWeeks[weekNumber] || [];
            nestedWeeks[weekNumber].push(current);
            current = current.clone().add(1, "day");
            count += 1;
          }
          return nestedWeeks;
        };
        this.getYearRange = function(start2, end2) {
          var startDate = _this.moment(start2).startOf("year");
          var endDate = _this.moment(end2).endOf("year");
          var years2 = [];
          var current = startDate;
          while (current.isBefore(endDate)) {
            years2.push(current);
            current = current.clone().add(1, "year");
          }
          return years2;
        };
        this.isWithinRange = function(date, _a3) {
          var start2 = _a3[0], end2 = _a3[1];
          return date.isBetween(start2, end2, null, "[]");
        };
        this.moment = instance || hooks;
        this.locale = locale2;
        this.formats = Object.assign({}, defaultFormats, formats);
      }
      return MomentUtils2;
    }();
    const InputFecha = (props2) => {
      return /* @__PURE__ */ jsx(LocalizationProvider, {
        dateAdapter: MomentUtils,
        children: /* @__PURE__ */ jsx(MobileDatePicker, {
          fontSize: 10,
          inputFormat: "DD/MM/yyyy",
          label: props2.label,
          mask: "__/__/____",
          value: props2.fecha,
          sx: {
            fontSize: 10
          },
          onChange: (newValue) => {
            props2.asignarFecha(newValue);
          },
          renderInput: (params) => /* @__PURE__ */ jsx(TextField$1, {
            size: "small",
            ...params
          })
        })
      });
    };
    var token = /d{1,4}|D{3,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|W{1,2}|[LlopSZN]|"[^"]*"|'[^']*'/g;
    var timezone = /\b(?:[A-Z]{1,3}[A-Z][TC])(?:[-+]\d{4})?|((?:Australian )?(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time)\b/g;
    var timezoneClip = /[^-+\dA-Z]/g;
    function dateFormat(date, mask, utc, gmt) {
      if (arguments.length === 1 && typeof date === "string" && !/\d/.test(date)) {
        mask = date;
        date = void 0;
      }
      date = date || date === 0 ? date : new Date();
      if (!(date instanceof Date)) {
        date = new Date(date);
      }
      if (isNaN(date)) {
        throw TypeError("Invalid date");
      }
      mask = String(masks[mask] || mask || masks["default"]);
      var maskSlice = mask.slice(0, 4);
      if (maskSlice === "UTC:" || maskSlice === "GMT:") {
        mask = mask.slice(4);
        utc = true;
        if (maskSlice === "GMT:") {
          gmt = true;
        }
      }
      var _2 = function _3() {
        return utc ? "getUTC" : "get";
      };
      var _d = function d2() {
        return date[_2() + "Date"]();
      };
      var D2 = function D3() {
        return date[_2() + "Day"]();
      };
      var _m = function m2() {
        return date[_2() + "Month"]();
      };
      var y2 = function y3() {
        return date[_2() + "FullYear"]();
      };
      var _H = function H2() {
        return date[_2() + "Hours"]();
      };
      var _M = function M2() {
        return date[_2() + "Minutes"]();
      };
      var _s = function s() {
        return date[_2() + "Seconds"]();
      };
      var _L = function L2() {
        return date[_2() + "Milliseconds"]();
      };
      var _o = function o() {
        return utc ? 0 : date.getTimezoneOffset();
      };
      var _W = function W2() {
        return getWeek(date);
      };
      var _N = function N2() {
        return getDayOfWeek(date);
      };
      var flags = { d: function d2() {
        return _d();
      }, dd: function dd2() {
        return pad(_d());
      }, ddd: function ddd() {
        return i18n.dayNames[D2()];
      }, DDD: function DDD() {
        return getDayName({ y: y2(), m: _m(), d: _d(), _: _2(), dayName: i18n.dayNames[D2()], short: true });
      }, dddd: function dddd() {
        return i18n.dayNames[D2() + 7];
      }, DDDD: function DDDD() {
        return getDayName({ y: y2(), m: _m(), d: _d(), _: _2(), dayName: i18n.dayNames[D2() + 7] });
      }, m: function m2() {
        return _m() + 1;
      }, mm: function mm() {
        return pad(_m() + 1);
      }, mmm: function mmm() {
        return i18n.monthNames[_m()];
      }, mmmm: function mmmm() {
        return i18n.monthNames[_m() + 12];
      }, yy: function yy() {
        return String(y2()).slice(2);
      }, yyyy: function yyyy() {
        return pad(y2(), 4);
      }, h: function h2() {
        return _H() % 12 || 12;
      }, hh: function hh2() {
        return pad(_H() % 12 || 12);
      }, H: function H2() {
        return _H();
      }, HH: function HH() {
        return pad(_H());
      }, M: function M2() {
        return _M();
      }, MM: function MM() {
        return pad(_M());
      }, s: function s() {
        return _s();
      }, ss: function ss() {
        return pad(_s());
      }, l: function l2() {
        return pad(_L(), 3);
      }, L: function L2() {
        return pad(Math.floor(_L() / 10));
      }, t: function t2() {
        return _H() < 12 ? i18n.timeNames[0] : i18n.timeNames[1];
      }, tt: function tt() {
        return _H() < 12 ? i18n.timeNames[2] : i18n.timeNames[3];
      }, T: function T2() {
        return _H() < 12 ? i18n.timeNames[4] : i18n.timeNames[5];
      }, TT: function TT() {
        return _H() < 12 ? i18n.timeNames[6] : i18n.timeNames[7];
      }, Z: function Z2() {
        return gmt ? "GMT" : utc ? "UTC" : formatTimezone(date);
      }, o: function o() {
        return (_o() > 0 ? "-" : "+") + pad(Math.floor(Math.abs(_o()) / 60) * 100 + Math.abs(_o()) % 60, 4);
      }, p: function p2() {
        return (_o() > 0 ? "-" : "+") + pad(Math.floor(Math.abs(_o()) / 60), 2) + ":" + pad(Math.floor(Math.abs(_o()) % 60), 2);
      }, S: function S2() {
        return ["th", "st", "nd", "rd"][_d() % 10 > 3 ? 0 : (_d() % 100 - _d() % 10 != 10) * _d() % 10];
      }, W: function W2() {
        return _W();
      }, WW: function WW() {
        return pad(_W());
      }, N: function N2() {
        return _N();
      } };
      return mask.replace(token, function(match5) {
        if (match5 in flags) {
          return flags[match5]();
        }
        return match5.slice(1, match5.length - 1);
      });
    }
    var masks = { default: "ddd mmm dd yyyy HH:MM:ss", shortDate: "m/d/yy", paddedShortDate: "mm/dd/yyyy", mediumDate: "mmm d, yyyy", longDate: "mmmm d, yyyy", fullDate: "dddd, mmmm d, yyyy", shortTime: "h:MM TT", mediumTime: "h:MM:ss TT", longTime: "h:MM:ss TT Z", isoDate: "yyyy-mm-dd", isoTime: "HH:MM:ss", isoDateTime: "yyyy-mm-dd'T'HH:MM:sso", isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'", expiresHeaderFormat: "ddd, dd mmm yyyy HH:MM:ss Z" };
    var i18n = { dayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], monthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], timeNames: ["a", "p", "am", "pm", "A", "P", "AM", "PM"] };
    var pad = function pad2(val) {
      var len = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
      return String(val).padStart(len, "0");
    };
    var getDayName = function getDayName2(_ref) {
      var y2 = _ref.y, m2 = _ref.m, d2 = _ref.d, _2 = _ref._, dayName = _ref.dayName, _ref$short = _ref["short"], _short = _ref$short === void 0 ? false : _ref$short;
      var today = new Date();
      var yesterday = new Date();
      yesterday.setDate(yesterday[_2 + "Date"]() - 1);
      var tomorrow = new Date();
      tomorrow.setDate(tomorrow[_2 + "Date"]() + 1);
      var today_d = function today_d2() {
        return today[_2 + "Date"]();
      };
      var today_m = function today_m2() {
        return today[_2 + "Month"]();
      };
      var today_y = function today_y2() {
        return today[_2 + "FullYear"]();
      };
      var yesterday_d = function yesterday_d2() {
        return yesterday[_2 + "Date"]();
      };
      var yesterday_m = function yesterday_m2() {
        return yesterday[_2 + "Month"]();
      };
      var yesterday_y = function yesterday_y2() {
        return yesterday[_2 + "FullYear"]();
      };
      var tomorrow_d = function tomorrow_d2() {
        return tomorrow[_2 + "Date"]();
      };
      var tomorrow_m = function tomorrow_m2() {
        return tomorrow[_2 + "Month"]();
      };
      var tomorrow_y = function tomorrow_y2() {
        return tomorrow[_2 + "FullYear"]();
      };
      if (today_y() === y2 && today_m() === m2 && today_d() === d2) {
        return _short ? "Tdy" : "Today";
      } else if (yesterday_y() === y2 && yesterday_m() === m2 && yesterday_d() === d2) {
        return _short ? "Ysd" : "Yesterday";
      } else if (tomorrow_y() === y2 && tomorrow_m() === m2 && tomorrow_d() === d2) {
        return _short ? "Tmw" : "Tomorrow";
      }
      return dayName;
    };
    var getWeek = function getWeek2(date) {
      var targetThursday = new Date(date.getFullYear(), date.getMonth(), date.getDate());
      targetThursday.setDate(targetThursday.getDate() - (targetThursday.getDay() + 6) % 7 + 3);
      var firstThursday = new Date(targetThursday.getFullYear(), 0, 4);
      firstThursday.setDate(firstThursday.getDate() - (firstThursday.getDay() + 6) % 7 + 3);
      var ds = targetThursday.getTimezoneOffset() - firstThursday.getTimezoneOffset();
      targetThursday.setHours(targetThursday.getHours() - ds);
      var weekDiff = (targetThursday - firstThursday) / (864e5 * 7);
      return 1 + Math.floor(weekDiff);
    };
    var getDayOfWeek = function getDayOfWeek2(date) {
      var dow = date.getDay();
      if (dow === 0) {
        dow = 7;
      }
      return dow;
    };
    var formatTimezone = function formatTimezone2(date) {
      return (String(date).match(timezone) || [""]).pop().replace(timezoneClip, "").replace(/GMT\+0000/g, "UTC");
    };
    const get$b = async () => {
      const empresa = localStorage.getItem("empresa");
      const data = await localDataBase.Maquinarias.where("idempresa").equals(empresa).toArray();
      return data;
    };
    function useMaquinaria() {
      const [maquinarias, setMaquinarias] = react.exports.useState([]);
      const getMaquinarias = () => {
        get$b().then((response) => {
          setMaquinarias(response);
        }).catch(Dexie$1.DexieError, (e2) => {
          console.error(e2);
        });
      };
      return {
        maquinarias,
        getMaquinarias
      };
    }
    const registerMaquinaria = async (cabecera, detalle, user, combustible) => {
      const empresa = localStorage.getItem("empresa");
      console.log(combustible);
      const cod_partemaq = await localDataBase.AC_PARTEMAQUINARIA.add(
        {
          PROVEEDOR: cabecera.PROVEEDOR,
          IDCLIEPROV: cabecera.IDCLIEPROV,
          IDDOCUMENTO: cabecera.IDDOCUMENTO,
          IDCONSUMIDORMAQUINARIA: cabecera.IDCONSUMIDORMAQUINARIA,
          MAQUINA: cabecera.MAQUINA,
          OPERARIO: cabecera.OPERARIO,
          IDOPERARIO: cabecera.IDOPERARIO,
          HORAS_TRAB: cabecera.HORAS_TRAB,
          HORAS_TRAB1: cabecera.HORAS_TRAB1,
          TURNO: cabecera.TURNO,
          IDTURNOTRABAJO: cabecera.IDTURNOTRABAJO,
          TOTAL_COSTO: cabecera.TOTAL_COSTO,
          FORMAPAGO: cabecera.FORMAPAGO,
          AREA: cabecera.AREA,
          IDAREA: cabecera.IDAREA,
          COSTO_HORA: cabecera.COSTO_HORA,
          IDUSUARIO: user,
          ESTADO: "P",
          FECHA: cabecera.FECHA,
          HORAINICIO: cabecera.HORAINICIO,
          HORAFINAL: cabecera.HORAFINAL,
          HOROMETROINICIAL: cabecera.HOROMETROINICIAL,
          HOROMETROFINAL: cabecera.HOROMETROFINAL,
          TOTALAREA_TRAB: cabecera.TOTALAREA_TRAB,
          GLOSA: cabecera.GLOSA,
          IDCONSUMIDORIMPLEMENTO: cabecera.IDIMPLEMENTO,
          DESCIMPLEMENTO: cabecera.DESCIMPLEMENTO,
          DESCCONSUMIDOR: cabecera.DESCCONSUMIDOR,
          idempresa: empresa
        }
      );
      detalle.map((item, index2) => {
        localDataBase.AC_DPARTEMAQUINARIA.add(
          {
            IDPARTEMAQ: cod_partemaq,
            ITEM: index2,
            IDCONSUMIDOR: item.IDCONSUMIDOR,
            DESCRIPCION: item.DESCRIPCION,
            AREA_TRAB: item.AREA_TRAB,
            HORAINICIO: item.HORAINICIO,
            HORAFINAL: item.HORAFINAL,
            HOROMETROINICIAL: item.HOROMETROINICIAL,
            HOROMETROFINAL: item.HOROMETROFINAL,
            HORAS_TRAB: item.HORAS_TRAB,
            HORAS_TRAB1: item.HORAS_TRAB1,
            COSTO_HORA: item.COSTO_HORA,
            IDACTIVIDAD: item.IDACTIVIDAD,
            IDLABOR: item.IDLABOR,
            HOROMETRO_DIFERENCIA: item.HOROMETRO_DIFERENCIA,
            DSC_LABOR: item.DSC_LABOR,
            COSTO_TOTAL: item.COSTO_TOTAL,
            IDCUARTEL: item.IDCUARTEL,
            IDJIRON: item.IDJIRON,
            DESCJIRON: item.DESCJIRON,
            DESCCUARTEL: item.DESCCUARTEL
          }
        );
      });
      combustible.map((item, index2) => {
        localDataBase.AC_COMBUSTIBLE.add({ IDPARTEMAQ: cod_partemaq, ITEM: index2, IDCOMBUSTIBLE: item.IDCOMBUSTIBLE, DESCRIPCION: item.DESCRIPCION, CANTIDAD: item.CANTIDAD, IDMEDIDA: item.IDMEDIDA });
      });
      return cod_partemaq;
    };
    const getParteMaquinariaAll = async (fecha, idmaquina) => {
      const empresa = localStorage.getItem("empresa");
      if (idmaquina != "") {
        const res = await localDataBase.AC_PARTEMAQUINARIA.where(["FECHA", "IDCONSUMIDORMAQUINARIA", "ESTADO", "idempresa"]).equals([fecha, idmaquina, "P", empresa]).toArray();
        return res;
      } else {
        const res = await localDataBase.AC_PARTEMAQUINARIA.where({ FECHA: fecha, ESTADO: "P", idempresa: empresa }).toArray();
        return res;
      }
    };
    const getPartesEnviados = async (fecha, idmaquina) => {
      const empresa = localStorage.getItem("empresa");
      if (idmaquina != "") {
        const res = await localDataBase.AC_PARTEMAQUINARIA.where(["FECHA", "IDCONSUMIDORMAQUINARIA", "ESTADO", "idempresa"]).equals([fecha, idmaquina, "A", empresa]).toArray();
        return res;
      } else {
        const res = await localDataBase.AC_PARTEMAQUINARIA.where({ FECHA: fecha, ESTADO: "A", idempresa: empresa }).toArray();
        return res;
      }
    };
    const getDetalle = async (id2) => {
      const res = await localDataBase.AC_DPARTEMAQUINARIA.where("IDPARTEMAQ").equals(parseInt(id2)).toArray();
      return res;
    };
    const getCombustible = async (id2) => {
      const res = await localDataBase.AC_COMBUSTIBLE.where("IDPARTEMAQ").equals(parseInt(id2)).toArray();
      return res;
    };
    const deleteById = async (id2) => {
      await localDataBase.AC_PARTEMAQUINARIA.where("cod").equals(parseInt(id2)).delete();
      await localDataBase.AC_DPARTEMAQUINARIA.where("IDPARTEMAQ").equals(parseInt(id2)).delete();
      await localDataBase.AC_COMBUSTIBLE.where("IDPARTEMAQ").equals(parseInt(id2)).delete();
      return "elemento eliminado: " + id2;
    };
    const updateParteMaq = async (id2) => {
      await localDataBase.AC_PARTEMAQUINARIA.update(id2, { ESTADO: "A" });
      return "elemento actualizado: " + id2;
    };
    function useParteMaquinaria() {
      useNavigate();
      const [parteMaquinaria, setPartesMaq] = react.exports.useState([]);
      const [detalle, setDetalle] = react.exports.useState([]);
      const [combustible, setCombustible] = react.exports.useState([]);
      const registrarParte = ({ cabecera, detalle: detalle2, user, combustible: combustible2, onSuccess }) => {
        registerMaquinaria(cabecera, detalle2, user, combustible2).then((response) => {
          onSuccess(response);
        }).catch((e2) => {
          console.error(e2);
        });
      };
      const getParteMaquinariaAll$1 = (fecha, idmaquina) => {
        getParteMaquinariaAll(fecha, idmaquina).then((response) => {
          setPartesMaq(response);
        }).catch((e2) => {
          console.error(e2);
        });
      };
      const getDetalleMaq = (idpartemaq) => {
        getDetalle(idpartemaq).then((response) => {
          setDetalle(response);
        }).catch((e2) => {
          console.error(e2);
        });
      };
      const getCombustible$1 = (idpartemaq) => {
        getCombustible(idpartemaq).then((response) => {
          setCombustible(response);
        }).catch((e2) => {
          console.error(e2);
        });
      };
      const deleteParteMaq = (idpartemaq) => {
        deleteById(idpartemaq).then((response) => {
          console.log(response);
        }).catch((e2) => {
          console.error(e2);
        });
      };
      const updateParteMaq$1 = (idpartemaq) => {
        updateParteMaq(idpartemaq).then((response) => {
          console.log(response);
        }).catch((e2) => {
          console.error(e2);
        });
      };
      const getParteMaquinariaEnviados = (fecha, idmaquina) => {
        getPartesEnviados(fecha, idmaquina).then((response) => {
          console.log(response);
          setPartesMaq(response);
        }).catch((e2) => {
          console.error(e2);
        });
      };
      return {
        parteMaquinaria,
        detalle,
        combustible,
        getCombustible: getCombustible$1,
        updateParteMaq: updateParteMaq$1,
        deleteParteMaq,
        getDetalleMaq,
        registrarParte,
        getParteMaquinariaAll: getParteMaquinariaAll$1,
        getParteMaquinariaEnviados
      };
    }
    const HomeMaquinariaPropia = () => {
      var usuario = JSON.parse(localStorage.getItem("usuario"));
      usuario.usuario;
      const navigate = useNavigate();
      const {
        maquinarias,
        getMaquinarias
      } = useMaquinaria();
      const {
        parteMaquinaria,
        getParteMaquinariaAll: getParteMaquinariaAll2,
        deleteParteMaq
      } = useParteMaquinaria();
      const {
        user,
        empresa,
        logOut
      } = useAuth();
      const [openBorrar, setOpenBorrar] = react.exports.useState(false);
      const [idMquina, setIdMaquina] = react.exports.useState("");
      const [idparte, setIdParte] = react.exports.useState("");
      const [fechaBusqueda, setFechaBusqueda] = react.exports.useState(dateFormat(new Date(), "yyyy-mm-dd"));
      const onChangeAutocompleteHome = (newValue) => {
        console.log(newValue);
        if (newValue != null) {
          setIdMaquina(newValue.ID);
        } else {
          setIdMaquina("");
        }
      };
      const salir = () => {
        logOut();
        navigate("/", {
          replace: true
        });
      };
      function listarParteMaquinaria() {
        getParteMaquinariaAll2(fechaBusqueda, idMquina);
      }
      function elimnarParte() {
        console.log(idparte);
        deleteParteMaq(idparte);
        listarParteMaquinaria();
        setOpenBorrar(false);
      }
      const asignarFechaBusqueda = (newValue) => {
        setFechaBusqueda(dateFormat(newValue, "yyyy-mm-dd"));
      };
      const cerrarDialogBorrar = () => {
        setOpenBorrar(false);
      };
      const abrirDialogBorrar = (id2) => {
        setOpenBorrar(true);
        setIdParte(id2);
      };
      react.exports.useEffect(() => {
        getMaquinarias();
        listarParteMaquinaria();
      }, []);
      return /* @__PURE__ */ jsx("div", {
        children: /* @__PURE__ */ jsxs(Box$1, {
          children: [/* @__PURE__ */ jsx(Appbar, {
            nombre: "Inicio",
            salir,
            mostrarEnviar: "none",
            mostrarGuardar: "none"
          }), /* @__PURE__ */ jsx(Dialogs, {
            open: openBorrar,
            cerrar: cerrarDialogBorrar,
            aceptar: elimnarParte,
            mensaje: "\xBFEst\xE1 seguro de borrar parte de maquinaria?"
          }), /* @__PURE__ */ jsx("h3", {
            children: "Buscar Parte de Maquinaria"
          }), /* @__PURE__ */ jsx(Card$1, {
            children: /* @__PURE__ */ jsx(CardContent$1, {
              children: /* @__PURE__ */ jsxs(Grid$1, {
                container: true,
                spacing: 1,
                children: [/* @__PURE__ */ jsx(Grid$1, {
                  item: true,
                  xs: 4,
                  children: /* @__PURE__ */ jsx(InputFecha, {
                    fecha: fechaBusqueda,
                    label: "Fecha",
                    asignarFecha: (val) => asignarFechaBusqueda(val)
                  })
                }), /* @__PURE__ */ jsx(Grid$1, {
                  item: true,
                  xs: 8,
                  children: /* @__PURE__ */ jsx(Autocompletar, {
                    label: "Buscar Maquina",
                    options: maquinarias,
                    cambiar: (event, newValue) => onChangeAutocompleteHome(newValue)
                  })
                }), /* @__PURE__ */ jsx(Grid$1, {
                  item: true,
                  xs: 12,
                  sx: {
                    position: "center"
                  },
                  children: /* @__PURE__ */ jsx(Button$1, {
                    variant: "contained",
                    fullWidth: true,
                    color: "success",
                    onClick: () => listarParteMaquinaria(),
                    children: "Buscar"
                  })
                })]
              })
            })
          }), /* @__PURE__ */ jsx(List$1, {
            sx: {
              width: "100%",
              maxWidth: "100%",
              position: "relative",
              overflow: "auto",
              maxHeight: 500
            },
            subheader: /* @__PURE__ */ jsx("li", {}),
            children: /* @__PURE__ */ jsx(ListaParteMaq, {
              datos: parteMaquinaria,
              delete: elimnarParte,
              openBorrar,
              abrirDialogBorrar,
              cerrarDialogBorrar
            })
          }), /* @__PURE__ */ jsx(Fab$1, {
            sx: {
              position: "absolute",
              bottom: 20,
              right: 20
            },
            "aria-label": "Add",
            color: "warning",
            size: "large",
            onClick: () => navigate("/nuevoParte"),
            children: /* @__PURE__ */ jsx(default_1$6, {})
          }), /* @__PURE__ */ jsx(Loading, {
            open: false,
            label: "Buscando datos"
          })]
        })
      });
    };
    var Article = {};
    var _interopRequireDefault$3 = interopRequireDefault.exports;
    Object.defineProperty(Article, "__esModule", {
      value: true
    });
    var default_1$3 = Article.default = void 0;
    var _createSvgIcon$3 = _interopRequireDefault$3(requireCreateSvgIcon());
    var _jsxRuntime$3 = require$$2;
    var _default$3 = (0, _createSvgIcon$3.default)(/* @__PURE__ */ (0, _jsxRuntime$3.jsx)("path", {
      d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"
    }), "Article");
    default_1$3 = Article.default = _default$3;
    const Detalle = (props2) => {
      return props2.detalle.map((item, i) => /* @__PURE__ */ jsxs(Box$1, {
        children: [/* @__PURE__ */ jsxs(ListItem$1, {
          onClick: () => props2.itemSeleccionado(props2.detalle[i], i),
          sx: {
            marginLeft: 0
          },
          children: [/* @__PURE__ */ jsx(ListItemAvatar$1, {
            children: /* @__PURE__ */ jsx(default_1$3, {})
          }), /* @__PURE__ */ jsx(Grid$1, {
            container: true,
            spacing: 0,
            children: /* @__PURE__ */ jsxs(Grid$1, {
              item: true,
              xs: 12,
              children: [/* @__PURE__ */ jsx(Typography$1, {
                sx: {
                  fontSize: 11,
                  fontWeight: "bold"
                },
                children: item.IDCONSUMIDOR + " - " + item.DESCRIPCION
              }), /* @__PURE__ */ jsxs(Typography$1, {
                style: {
                  fontSize: 10
                },
                children: ["Labor: ", item.IDLABOR + " - " + item.DSC_LABOR]
              }), /* @__PURE__ */ jsxs(Typography$1, {
                sx: {
                  fontSize: 10
                },
                children: [item.DESCJIRON, " - ", item.DESCCUARTEL, "- Area(Has): ", parseFloat(item.AREA_TRAB).toFixed(2), "  "]
              })]
            })
          })]
        }, i), /* @__PURE__ */ jsx(Divider$1, {
          color: "success"
        })]
      }, i));
    };
    const CabeceraParteMaquinaria = (props2) => {
      return /* @__PURE__ */ jsxs(Grid$1, {
        container: true,
        spacing: "5px",
        children: [/* @__PURE__ */ jsx(Grid$1, {
          item: true,
          xs: 3,
          children: /* @__PURE__ */ jsx(TextField$1, {
            id: "txtarea",
            select: true,
            label: "\xC1rea",
            size: "small",
            value: props2.idArea,
            sx: {
              width: "100%"
            },
            onChange: (event, newValue) => props2.cambiarArea(event, newValue),
            children: props2.areas.map((option) => /* @__PURE__ */ jsx(MenuItem$1, {
              value: option.ID,
              name: option.DESCRIPCION,
              children: /* @__PURE__ */ jsx(Typography$1, {
                fontSize: 12,
                children: option.DESCRIPCION
              })
            }, option.ID))
          })
        }), /* @__PURE__ */ jsx(Grid$1, {
          item: true,
          xs: 3,
          children: /* @__PURE__ */ jsx(TextField$1, {
            id: "txtturno",
            select: true,
            label: "Turno",
            size: "small",
            value: props2.idTurno,
            sx: {
              width: "100%"
            },
            onChange: (event, newvalue) => props2.cambiarTurno(event, newvalue),
            children: props2.turnos.map((option) => /* @__PURE__ */ jsx(MenuItem$1, {
              value: option.idturno,
              name: option.descripcion,
              children: /* @__PURE__ */ jsx(Typography$1, {
                fontSize: 12,
                name: option.descripcion,
                children: option.descripcion
              })
            }, option.idturno))
          })
        }), /* @__PURE__ */ jsx(Grid$1, {
          item: true,
          xs: 3,
          children: /* @__PURE__ */ jsx(TextField$1, {
            id: "txtformaPago",
            select: true,
            label: "Forma de Pago",
            size: "small",
            value: props2.idFormaPago,
            sx: {
              width: "100%"
            },
            onChange: props2.cambiarFormaPago,
            children: props2.formaPago.map((option) => /* @__PURE__ */ jsx(MenuItem$1, {
              value: option.ID,
              children: /* @__PURE__ */ jsx(Typography$1, {
                fontSize: 12,
                children: option.DESCRIPCION
              })
            }, option.ID))
          })
        }), /* @__PURE__ */ jsx(Grid$1, {
          item: true,
          xs: 3,
          children: /* @__PURE__ */ jsx(InputFecha, {
            fecha: props2.fecha,
            label: "Fecha",
            asignarFecha: (value) => props2.asignarFecha(value)
          })
        }), /* @__PURE__ */ jsx(Grid$1, {
          item: true,
          xs: 12,
          children: /* @__PURE__ */ jsx(Autocompletar, {
            label: "Maquina",
            options: props2.maquinarias,
            cambiar: (event, newValue) => props2.cambiarMaquina(newValue),
            disabled: props2.disabled
          })
        }), /* @__PURE__ */ jsx(Grid$1, {
          item: true,
          xs: 12,
          children: /* @__PURE__ */ jsx(Autocompletar, {
            label: "Implemento",
            options: props2.implementos,
            cambiar: (event, newValue) => props2.cambiarImplemento(newValue)
          })
        }), /* @__PURE__ */ jsx(Grid$1, {
          item: true,
          xs: 6,
          children: /* @__PURE__ */ jsx(Autocompletar, {
            label: "proveedor",
            options: props2.proveedor,
            cambiar: (event, newValue) => props2.cambiarProveedor(newValue),
            disabled: props2.tipoParte == "PMQ" ? true : false
          })
        }), /* @__PURE__ */ jsx(Grid$1, {
          item: true,
          xs: 6,
          children: /* @__PURE__ */ jsx(Autocompletar, {
            label: "Operario",
            options: props2.operarios,
            cambiar: (event, newValue) => props2.cambiarOperario(newValue)
          })
        }), /* @__PURE__ */ jsx(Grid$1, {
          item: true,
          xs: 6,
          children: /* @__PURE__ */ jsx(Autocompletar, {
            label: "Actividad",
            options: props2.actividades,
            cambiar: (event, newValue) => props2.cambiarActividad(newValue)
          })
        }), /* @__PURE__ */ jsx(Grid$1, {
          item: true,
          xs: 6,
          children: /* @__PURE__ */ jsx(Autocompletar, {
            label: "Labor",
            options: props2.labores,
            cambiar: (event, newValue) => props2.cambiarLabor(newValue),
            input: props2.descLabor,
            value: props2.valueLabor
          })
        }), /* @__PURE__ */ jsx(Grid$1, {
          item: true,
          xs: 4,
          children: /* @__PURE__ */ jsx(TextField$1, {
            label: "Hora Inicio",
            sx: {
              width: "100%"
            },
            type: "time",
            InputLabelProps: {
              shrink: true
            },
            onChange: (event) => props2.cambiarHoraInicio(event),
            value: props2.horaInicio,
            size: "small"
          })
        }), /* @__PURE__ */ jsx(Grid$1, {
          item: true,
          xs: 4,
          children: /* @__PURE__ */ jsx(TextField$1, {
            label: "Hora Fin",
            sx: {
              width: "100%"
            },
            type: "time",
            InputLabelProps: {
              shrink: true
            },
            onChange: (event) => props2.cambiarHoraFin(event),
            value: props2.horaFin,
            size: "small"
          })
        }), /* @__PURE__ */ jsx(Grid$1, {
          item: true,
          xs: 4,
          children: /* @__PURE__ */ jsx(TextField$1, {
            id: "txtCantidadCabecera",
            label: "Cantidad HR/HA",
            sx: {
              width: "100%"
            },
            size: "small",
            color: "success",
            focused: true,
            value: props2.horas_trab1_cabecera,
            InputLabelProps: {
              shrink: true
            }
          })
        }), /* @__PURE__ */ jsx(Grid$1, {
          item: true,
          xs: 4,
          children: /* @__PURE__ */ jsx(TextField$1, {
            label: "Horometro Inicial",
            sx: {
              width: "100%"
            },
            type: "number",
            onChange: (event) => props2.cambiarHorometroInicio(event),
            size: "small"
          })
        }), /* @__PURE__ */ jsx(Grid$1, {
          item: true,
          xs: 4,
          children: /* @__PURE__ */ jsx(TextField$1, {
            label: "Horometro Final",
            sx: {
              width: "100%"
            },
            type: "number",
            onChange: (event) => props2.cambiarHorometroFin(event),
            size: "small"
          })
        }), /* @__PURE__ */ jsx(Grid$1, {
          item: true,
          xs: 4,
          children: /* @__PURE__ */ jsx(TextField$1, {
            label: "Dif. Horometro",
            sx: {
              width: "100%"
            },
            color: "success",
            focused: true,
            InputLabelProps: {
              shrink: true
            },
            value: props2.difHorometro,
            size: "small"
          })
        }), /* @__PURE__ */ jsx(Grid$1, {
          item: true,
          xs: 12,
          children: /* @__PURE__ */ jsx(TextField$1, {
            label: "Observaciones",
            sx: {
              width: "100%"
            },
            color: "success",
            focused: true,
            InputLabelProps: {
              shrink: true
            },
            onChange: (event) => {
              props2.inputGlosa(event);
            },
            size: "small"
          })
        })]
      });
    };
    var Close = {};
    var _interopRequireDefault$2 = interopRequireDefault.exports;
    Object.defineProperty(Close, "__esModule", {
      value: true
    });
    var default_1$2 = Close.default = void 0;
    var _createSvgIcon$2 = _interopRequireDefault$2(requireCreateSvgIcon());
    var _jsxRuntime$2 = require$$2;
    var _default$2 = (0, _createSvgIcon$2.default)(/* @__PURE__ */ (0, _jsxRuntime$2.jsx)("path", {
      d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
    }), "Close");
    default_1$2 = Close.default = _default$2;
    const get$a = async () => {
      const empresa = localStorage.getItem("empresa");
      const data = await localDataBase.consumidoresMaquinaria.where("idempresa").equals(empresa).toArray();
      return data;
    };
    function useConsumidores() {
      const [consumidores, setConsumidores] = react.exports.useState([]);
      const getConsumidores = () => {
        get$a().then((response) => {
          setConsumidores(response);
        }).catch(Dexie$1.DexieError, (e2) => {
          console.error(e2);
        });
      };
      return {
        consumidores,
        getConsumidores
      };
    }
    const get$9 = async () => {
      const data = await localDataBase.Jirones.toArray();
      return data;
    };
    function useJirones() {
      const [jirones, setJirones] = react.exports.useState([]);
      const getJirones = () => {
        get$9().then((response) => {
          setJirones(response);
        }).catch(Dexie$1.DexieError, (e2) => {
          console.error(e2);
        });
      };
      return {
        jirones,
        getJirones
      };
    }
    const get$8 = async () => {
      const data = await localDataBase.Cuarteles.toArray();
      return data;
    };
    function useCuartel() {
      const [cuarteles, setCuarteles] = react.exports.useState([]);
      const getCuarteles = () => {
        get$8().then((response) => {
          setCuarteles(response);
        }).catch(Dexie$1.DexieError, (e2) => {
          console.error(e2);
        });
      };
      return {
        cuarteles,
        getCuarteles
      };
    }
    const BootstrapDialog$3 = styled$1(Dialog$1)(({
      theme
    }) => ({
      "& .MuiDialogContent-root": {
        padding: theme.spacing(2)
      },
      "& .MuiDialogActions-root": {
        padding: theme.spacing(1)
      }
    }));
    const BootstrapDialogTitle$3 = (props2) => {
      const {
        children,
        onClose,
        ...other
      } = props2;
      return /* @__PURE__ */ jsxs(DialogTitle$1, {
        sx: {
          background: "#2e7d32",
          color: "white"
        },
        ...other,
        children: [children, /* @__PURE__ */ jsx(IconButton$1, {
          "aria-label": "close",
          onClick: onClose,
          sx: {
            position: "absolute",
            color: "white",
            right: 8,
            top: 8
          },
          children: /* @__PURE__ */ jsx(default_1$2, {})
        })]
      });
    };
    const FormularioModal = (props2) => {
      const {
        consumidores,
        getConsumidores
      } = useConsumidores();
      const {
        jirones,
        getJirones
      } = useJirones();
      const {
        cuarteles,
        getCuarteles
      } = useCuartel();
      react.exports.useEffect(() => {
        getConsumidores();
        getJirones();
        getCuarteles();
      }, []);
      return /* @__PURE__ */ jsx(Box$1, {
        children: /* @__PURE__ */ jsxs(BootstrapDialog$3, {
          open: props2.open,
          "aria-labelledby": "customized-dialog-title",
          children: [/* @__PURE__ */ jsx(BootstrapDialogTitle$3, {
            onClose: props2.handleCloseModal,
            children: "Nuevo Item"
          }), /* @__PURE__ */ jsx(DialogContent$1, {
            dividers: true,
            children: /* @__PURE__ */ jsxs(Grid$1, {
              container: true,
              spacing: 2,
              children: [/* @__PURE__ */ jsx(Grid$1, {
                item: true,
                xs: 12,
                children: /* @__PURE__ */ jsx(Autocompletar, {
                  label: "Consumidor",
                  options: consumidores,
                  cambiar: (event, newValue) => props2.cambiarConsumidor(newValue)
                })
              }), /* @__PURE__ */ jsx(Grid$1, {
                item: true,
                xs: 6,
                children: /* @__PURE__ */ jsx(Autocompletar, {
                  label: "Lote",
                  options: jirones,
                  cambiar: (event, newValue) => props2.cambiarJiron(newValue)
                })
              }), /* @__PURE__ */ jsx(Grid$1, {
                item: true,
                xs: 6,
                children: /* @__PURE__ */ jsx(Autocompletar, {
                  label: "V\xE1lvula",
                  options: cuarteles,
                  cambiar: (event, newValue) => props2.cambiarCuartel(newValue)
                })
              }), /* @__PURE__ */ jsx(Grid$1, {
                item: true,
                xs: 6,
                children: /* @__PURE__ */ jsx(TextField$1, {
                  label: "Area",
                  sx: {
                    width: "100%"
                  },
                  type: "number",
                  onChange: (event) => props2.cambiarAreaTrabajada(event),
                  size: "small",
                  InputLabelProps: {
                    shrink: true
                  }
                })
              })]
            })
          }), /* @__PURE__ */ jsxs(DialogActions$1, {
            children: [/* @__PURE__ */ jsx(Button$1, {
              autoFocus: true,
              onClick: props2.handleCloseModal,
              variant: "contained",
              color: "error",
              children: "Cancelar"
            }), /* @__PURE__ */ jsx(Button$1, {
              onClick: () => props2.guardar(),
              variant: "contained",
              color: "success",
              children: "Agregar"
            })]
          })]
        })
      });
    };
    const BootstrapDialog$2 = styled$1(Dialog$1)(({
      theme
    }) => ({
      "& .MuiDialogContent-root": {
        padding: theme.spacing(2)
      },
      "& .MuiDialogActions-root": {
        padding: theme.spacing(1)
      }
    }));
    const BootstrapDialogTitle$2 = (props2) => {
      const {
        children,
        onClose,
        ...other
      } = props2;
      return /* @__PURE__ */ jsxs(DialogTitle$1, {
        sx: {
          background: "#2e7d32",
          color: "white"
        },
        ...other,
        children: [children, /* @__PURE__ */ jsx(IconButton$1, {
          "aria-label": "close",
          onClick: onClose,
          sx: {
            position: "absolute",
            color: "white",
            right: 8,
            top: 8
          },
          children: /* @__PURE__ */ jsx(default_1$2, {})
        })]
      });
    };
    const FormularioModalEditar = (props2) => {
      return /* @__PURE__ */ jsx("div", {
        children: /* @__PURE__ */ jsxs(BootstrapDialog$2, {
          "aria-labelledby": "customized-dialog-title",
          open: props2.open,
          children: [/* @__PURE__ */ jsx(BootstrapDialogTitle$2, {
            id: "customized-dialog-title",
            onClose: props2.handleCloseModal,
            children: "Editar Item"
          }), /* @__PURE__ */ jsx(DialogContent$1, {
            dividers: true,
            children: /* @__PURE__ */ jsxs(Grid$1, {
              container: true,
              spacing: 2,
              children: [/* @__PURE__ */ jsx(Grid$1, {
                item: true,
                xs: 12,
                children: /* @__PURE__ */ jsx(TextField$1, {
                  id: "txtOperario",
                  label: "Consumidor",
                  size: "small",
                  value: props2.idConsumidor,
                  sx: {
                    width: "100%"
                  },
                  InputLabelProps: {
                    shrink: true
                  }
                })
              }), /* @__PURE__ */ jsx(Grid$1, {
                item: true,
                xs: 6,
                children: /* @__PURE__ */ jsx(TextField$1, {
                  label: "Lote",
                  size: "small",
                  value: props2.jiron,
                  sx: {
                    width: "100%"
                  },
                  InputLabelProps: {
                    shrink: true
                  }
                })
              }), /* @__PURE__ */ jsx(Grid$1, {
                item: true,
                xs: 6,
                children: /* @__PURE__ */ jsx(TextField$1, {
                  id: "txtOperario",
                  label: "V\xE1lvula",
                  size: "small",
                  value: props2.cuartel,
                  sx: {
                    width: "100%"
                  },
                  InputLabelProps: {
                    shrink: true
                  }
                })
              }), /* @__PURE__ */ jsx(Grid$1, {
                item: true,
                xs: 6,
                children: /* @__PURE__ */ jsx(TextField$1, {
                  label: "Area",
                  sx: {
                    width: "100%"
                  },
                  type: "number",
                  defaultValue: props2.areaTrabajada,
                  onChange: (event) => props2.cambiarAreaTrabajada(event),
                  size: "small",
                  InputLabelProps: {
                    shrink: true
                  }
                })
              })]
            })
          }), /* @__PURE__ */ jsxs(DialogActions$1, {
            children: [/* @__PURE__ */ jsx(Button$1, {
              autoFocus: true,
              onClick: props2.dialogBorrar,
              variant: "contained",
              color: "error",
              children: "Borrar"
            }), /* @__PURE__ */ jsx(Button$1, {
              onClick: () => props2.guardar(),
              variant: "contained",
              color: "success",
              disabled: props2.buttonModal,
              children: "Editar"
            })]
          })]
        })
      });
    };
    const Interruptor = (props2) => {
      const SwitchC = styled$1(Switch$1)(({
        theme
      }) => ({
        padding: 8,
        "& .MuiSwitch-track": {
          borderRadius: 22 / 2,
          background: "#FF2D00",
          "&:before, &:after": {
            content: '""',
            position: "absolute",
            top: "50%",
            transform: "translateY(-50%)",
            width: 16,
            height: 16
          },
          "&:before": {
            backgroundImage: `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" height="16" width="16" viewBox="0 0 24 24"><path fill="${encodeURIComponent(theme.palette.getContrastText(theme.palette.primary.main))}" /></svg>')`,
            left: 12
          },
          "&:after": {
            backgroundImage: `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" height="16" width="16" viewBox="0 0 24 24"><path fill="${encodeURIComponent(theme.palette.getContrastText(theme.palette.primary.main))}" /></svg>')`,
            right: 12
          }
        },
        "& .MuiSwitch-thumb": {
          width: 16,
          height: 16,
          margin: 2
        }
      }));
      return /* @__PURE__ */ jsxs(Stack$1, {
        direction: "row",
        spacing: 2,
        alignItems: "center",
        justifyContent: "center",
        display: "flex",
        children: [/* @__PURE__ */ jsx(Typography$1, {
          variant: "h6",
          sx: {
            fontWeight: "bold"
          },
          children: "Propia"
        }), /* @__PURE__ */ jsx(SwitchC, {
          color: "success",
          size: "medium",
          checked: props2.switchChecked,
          onClick: props2.cambiarSwitch
        }), /* @__PURE__ */ jsx(Typography$1, {
          variant: "h6",
          sx: {
            fontWeight: "bold"
          },
          children: "Alquilada"
        })]
      });
    };
    const get$7 = async () => {
      const data = await localDataBase.Areas.toArray();
      return data;
    };
    function useAreas() {
      const [areas, setAreas] = react.exports.useState([]);
      const getAreas = () => {
        get$7().then((response) => {
          setAreas(response);
        }).catch(Dexie$1.DexieError, (e2) => {
          console.error(e2);
        });
      };
      return {
        areas,
        getAreas
      };
    }
    const get$6 = async () => {
      const data = await localDataBase.Proveedores.toArray();
      return data;
    };
    function useProveedores() {
      const [proveedores, setProveedores] = react.exports.useState([]);
      const getProveedores = () => {
        get$6().then((response) => {
          setProveedores(response);
        }).catch(Dexie$1.DexieError, (e2) => {
          console.error(e2);
        });
      };
      return {
        proveedores,
        getProveedores
      };
    }
    const get$5 = async () => {
      const data = await localDataBase.Operarios.toArray();
      return data;
    };
    function useOperario() {
      const [operarios, setOperarios] = react.exports.useState([]);
      const getOperarios = () => {
        get$5().then((response) => {
          setOperarios(response);
        }).catch(Dexie$1.DexieError, (e2) => {
          console.error(e2);
        });
      };
      return {
        operarios,
        getOperarios
      };
    }
    const get$4 = async () => {
      const data = await localDataBase.Actividades.toArray();
      return data;
    };
    function useActividad() {
      const [actividades, setActividades] = react.exports.useState([]);
      const getActividades = () => {
        get$4().then((response) => {
          setActividades(response);
        }).catch(Dexie$1.DexieError, (e2) => {
          console.error(e2);
        });
      };
      return {
        actividades,
        getActividades
      };
    }
    const get$3 = async ({ id_actividad }) => {
      console.log(id_actividad);
      const data = await localDataBase.Labores.where("IDACTIVIDAD").equals(id_actividad).toArray();
      return data;
    };
    function useLabores() {
      const [labores, setLabores] = react.exports.useState([]);
      const getLabores = (id_actividad) => {
        get$3({ id_actividad }).then((response) => {
          setLabores(response);
        }).catch(Dexie$1.DexieError, (e2) => {
          console.error(e2);
        });
      };
      return {
        labores,
        getLabores
      };
    }
    const get$2 = async () => {
      const data = await localDataBase.Turno.toArray();
      return data;
    };
    function useTurnoTrabajo() {
      const [turnostrabajo, setTurnostrabajo] = react.exports.useState([]);
      const getTurnosTrabajo = () => {
        get$2().then((response) => {
          setTurnostrabajo(response);
        }).catch(Dexie$1.DexieError, (e2) => {
          console.error(e2);
        });
      };
      return {
        turnostrabajo,
        getTurnosTrabajo
      };
    }
    const get$1 = async () => {
      const data = await localDataBase.Implementos.toArray();
      return data;
    };
    function useImplemento() {
      const [implementos, setImplementos] = react.exports.useState([]);
      const getImplementos = () => {
        get$1().then((response) => {
          setImplementos(response);
        }).catch(Dexie$1.DexieError, (e2) => {
          console.error(e2);
        });
      };
      return {
        implementos,
        getImplementos
      };
    }
    const Context = /* @__PURE__ */ react.exports.createContext(null);
    function useUniquePrefix() {
      const [id2, setId] = react.exports.useState(null);
      react.exports.useEffect(() => {
        setId(`mui-p-${Math.round(Math.random() * 1e5)}`);
      }, []);
      return id2;
    }
    function TabContext(props2) {
      const {
        children,
        value
      } = props2;
      const idPrefix = useUniquePrefix();
      const context = react.exports.useMemo(() => {
        return {
          idPrefix,
          value
        };
      }, [idPrefix, value]);
      return /* @__PURE__ */ jsx(Context.Provider, {
        value: context,
        children
      });
    }
    function useTabContext() {
      return react.exports.useContext(Context);
    }
    function getPanelId(context, value) {
      const {
        idPrefix
      } = context;
      if (idPrefix === null) {
        return null;
      }
      return `${context.idPrefix}-P-${value}`;
    }
    function getTabId(context, value) {
      const {
        idPrefix
      } = context;
      if (idPrefix === null) {
        return null;
      }
      return `${context.idPrefix}-T-${value}`;
    }
    const _excluded$1 = ["children"];
    const TabList = /* @__PURE__ */ react.exports.forwardRef(function TabList2(props2, ref) {
      const {
        children: childrenProp
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded$1);
      const context = useTabContext();
      if (context === null) {
        throw new TypeError("No TabContext provided");
      }
      const children = react.exports.Children.map(childrenProp, (child) => {
        if (!/* @__PURE__ */ react.exports.isValidElement(child)) {
          return null;
        }
        return /* @__PURE__ */ react.exports.cloneElement(child, {
          "aria-controls": getPanelId(context, child.props.value),
          id: getTabId(context, child.props.value)
        });
      });
      return /* @__PURE__ */ jsx(Tabs$1, _extends({}, other, {
        ref,
        value: context.value,
        children
      }));
    });
    const TabList$1 = TabList;
    function getTabPanelUtilityClass(slot) {
      return generateUtilityClass("MuiTabPanel", slot);
    }
    generateUtilityClasses("MuiTabPanel", ["root"]);
    const _excluded = ["children", "className", "value"];
    const useUtilityClasses = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"]
      };
      return composeClasses(slots, getTabPanelUtilityClass, classes);
    };
    const TabPanelRoot = styled$1("div", {
      name: "MuiTabPanel",
      slot: "Root",
      overridesResolver: (props2, styles2) => styles2.root
    })(({
      theme
    }) => ({
      padding: theme.spacing(3)
    }));
    const TabPanel = /* @__PURE__ */ react.exports.forwardRef(function TabPanel2(inProps, ref) {
      const props2 = useThemeProps({
        props: inProps,
        name: "MuiTabPanel"
      });
      const {
        children,
        className,
        value
      } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded);
      const ownerState = _extends({}, props2);
      const classes = useUtilityClasses(ownerState);
      const context = useTabContext();
      if (context === null) {
        throw new TypeError("No TabContext provided");
      }
      const id2 = getPanelId(context, value);
      const tabId = getTabId(context, value);
      return /* @__PURE__ */ jsx(TabPanelRoot, _extends({
        "aria-labelledby": tabId,
        className: clsx(classes.root, className),
        hidden: value !== context.value,
        id: id2,
        ref,
        role: "tabpanel",
        ownerState
      }, other, {
        children: value === context.value && children
      }));
    });
    const TabPanel$1 = TabPanel;
    var Signpost = {};
    var _interopRequireDefault$1 = interopRequireDefault.exports;
    Object.defineProperty(Signpost, "__esModule", {
      value: true
    });
    var default_1$1 = Signpost.default = void 0;
    var _createSvgIcon$1 = _interopRequireDefault$1(requireCreateSvgIcon());
    var _jsxRuntime$1 = require$$2;
    var _default$1 = (0, _createSvgIcon$1.default)(/* @__PURE__ */ (0, _jsxRuntime$1.jsx)("path", {
      d: "M13 10h5l3-3-3-3h-5V2h-2v2H4v6h7v2H6l-3 3 3 3h5v4h2v-4h7v-6h-7z"
    }), "Signpost");
    default_1$1 = Signpost.default = _default$1;
    var LocalGasStation = {};
    var _interopRequireDefault = interopRequireDefault.exports;
    Object.defineProperty(LocalGasStation, "__esModule", {
      value: true
    });
    var default_1 = LocalGasStation.default = void 0;
    var _createSvgIcon = _interopRequireDefault(requireCreateSvgIcon());
    var _jsxRuntime = require$$2;
    var _default = (0, _createSvgIcon.default)(/* @__PURE__ */ (0, _jsxRuntime.jsx)("path", {
      d: "m19.77 7.23.01-.01-3.72-3.72L15 4.56l2.11 2.11c-.94.36-1.61 1.26-1.61 2.33 0 1.38 1.12 2.5 2.5 2.5.36 0 .69-.08 1-.21v7.21c0 .55-.45 1-1 1s-1-.45-1-1V14c0-1.1-.9-2-2-2h-1V5c0-1.1-.9-2-2-2H6c-1.1 0-2 .9-2 2v16h10v-7.5h1.5v5c0 1.38 1.12 2.5 2.5 2.5s2.5-1.12 2.5-2.5V9c0-.69-.28-1.32-.73-1.77zM12 10H6V5h6v5zm6 0c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1z"
    }), "LocalGasStation");
    default_1 = LocalGasStation.default = _default;
    const get = async () => {
      const empresa = localStorage.getItem("empresa");
      const data = await localDataBase.Combustibles.where("idempresa").equals(empresa).toArray();
      return data;
    };
    function useCombustibles() {
      const [combustibles, setCombustibles] = react.exports.useState([]);
      const getCombustibles = () => {
        get().then((response) => {
          setCombustibles(response);
        }).catch(Dexie$1.DexieError, (e2) => {
          console.error(e2);
        });
      };
      return {
        combustibles,
        getCombustibles
      };
    }
    const BootstrapDialog$1 = styled$1(Dialog$1)(({
      theme
    }) => ({
      "& .MuiDialogContent-root": {
        padding: theme.spacing(2)
      },
      "& .MuiDialogActions-root": {
        padding: theme.spacing(1)
      }
    }));
    const BootstrapDialogTitle$1 = (props2) => {
      const {
        children,
        onClose,
        ...other
      } = props2;
      return /* @__PURE__ */ jsxs(DialogTitle$1, {
        sx: {
          background: "#2e7d32",
          color: "white"
        },
        ...other,
        children: [children, /* @__PURE__ */ jsx(IconButton$1, {
          "aria-label": "close",
          onClick: onClose,
          sx: {
            position: "absolute",
            color: "white",
            right: 8,
            top: 8
          },
          children: /* @__PURE__ */ jsx(default_1$2, {})
        })]
      });
    };
    const ModalCombustible = (props2) => {
      const {
        combustibles,
        getCombustibles
      } = useCombustibles();
      react.exports.useEffect(() => {
        getCombustibles();
        console.log(combustibles);
      }, []);
      return /* @__PURE__ */ jsx(Box$1, {
        children: /* @__PURE__ */ jsxs(BootstrapDialog$1, {
          open: props2.open,
          "aria-labelledby": "customized-dialog-title",
          children: [/* @__PURE__ */ jsx(BootstrapDialogTitle$1, {
            onClose: props2.CloseModal,
            children: "Nuevo item de combustible"
          }), /* @__PURE__ */ jsx(DialogContent$1, {
            dividers: true,
            children: /* @__PURE__ */ jsxs(Grid$1, {
              container: true,
              spacing: 2,
              children: [/* @__PURE__ */ jsx(Grid$1, {
                item: true,
                xs: 12,
                children: /* @__PURE__ */ jsx(Autocompletar, {
                  label: "Seleccione combustible",
                  options: combustibles,
                  cambiar: (event, newValue) => props2.cambiarCombustible(newValue)
                })
              }), /* @__PURE__ */ jsx(Grid$1, {
                item: true,
                xs: 12,
                children: /* @__PURE__ */ jsx(TextField$1, {
                  label: "Cantidad GL",
                  sx: {
                    width: "100%"
                  },
                  type: "number",
                  onChange: (event) => props2.cambiarCantidad(event),
                  size: "small",
                  InputLabelProps: {
                    shrink: true
                  }
                })
              })]
            })
          }), /* @__PURE__ */ jsxs(DialogActions$1, {
            children: [/* @__PURE__ */ jsx(Button$1, {
              autoFocus: true,
              onClick: props2.CloseModal,
              variant: "contained",
              color: "error",
              children: "Cancelar"
            }), /* @__PURE__ */ jsx(Button$1, {
              onClick: () => props2.guardar(),
              variant: "contained",
              color: "success",
              children: "Agregar"
            })]
          })]
        })
      });
    };
    const DetalleCombustible = (props2) => {
      return props2.combustible.map((item, i) => /* @__PURE__ */ jsxs(Box$1, {
        children: [/* @__PURE__ */ jsxs(ListItem$1, {
          onClick: () => props2.itemSeleccionado(props2.combustible[i], i),
          sx: {
            marginLeft: 0
          },
          children: [/* @__PURE__ */ jsx(ListItemAvatar$1, {
            children: /* @__PURE__ */ jsx(default_1, {})
          }), /* @__PURE__ */ jsx(Grid$1, {
            container: true,
            spacing: 0,
            children: /* @__PURE__ */ jsxs(Grid$1, {
              item: true,
              xs: 12,
              children: [/* @__PURE__ */ jsx(Typography$1, {
                sx: {
                  fontSize: 12,
                  fontWeight: "bold"
                },
                children: item.IDCOMBUSTIBLE + "-" + item.DESCRIPCION
              }), /* @__PURE__ */ jsxs(Typography$1, {
                sx: {
                  fontSize: 12
                },
                children: ["Cantidad: ", item.CANTIDAD, " - ", item.IDMEDIDA, "   "]
              })]
            })
          })]
        }, i), /* @__PURE__ */ jsx(Divider$1, {
          color: "success"
        })]
      }, i));
    };
    const BootstrapDialog = styled$1(Dialog$1)(({
      theme
    }) => ({
      "& .MuiDialogContent-root": {
        padding: theme.spacing(2)
      },
      "& .MuiDialogActions-root": {
        padding: theme.spacing(1)
      }
    }));
    const BootstrapDialogTitle = (props2) => {
      const {
        children,
        onClose,
        ...other
      } = props2;
      return /* @__PURE__ */ jsxs(DialogTitle$1, {
        sx: {
          background: "#2e7d32",
          color: "white"
        },
        ...other,
        children: [children, /* @__PURE__ */ jsx(IconButton$1, {
          "aria-label": "close",
          onClick: onClose,
          sx: {
            position: "absolute",
            color: "white",
            right: 8,
            top: 8
          },
          children: /* @__PURE__ */ jsx(default_1$2, {})
        })]
      });
    };
    const ModalCombustibleEditar = (props2) => {
      return /* @__PURE__ */ jsx(Box$1, {
        children: /* @__PURE__ */ jsxs(BootstrapDialog, {
          open: props2.open,
          "aria-labelledby": "customized-dialog-title",
          children: [/* @__PURE__ */ jsx(BootstrapDialogTitle, {
            onClose: props2.CloseModal,
            children: "Editar item de combustible"
          }), /* @__PURE__ */ jsx(DialogContent$1, {
            dividers: true,
            children: /* @__PURE__ */ jsxs(Grid$1, {
              container: true,
              spacing: 2,
              children: [/* @__PURE__ */ jsx(Grid$1, {
                item: true,
                xs: 12,
                children: /* @__PURE__ */ jsx(TextField$1, {
                  id: "txtOperario",
                  label: "Combustible",
                  size: "small",
                  value: props2.idCombustible + "-" + props2.descripcion,
                  sx: {
                    width: "100%"
                  },
                  InputLabelProps: {
                    shrink: true
                  }
                })
              }), /* @__PURE__ */ jsx(Grid$1, {
                item: true,
                xs: 6,
                children: /* @__PURE__ */ jsx(TextField$1, {
                  label: "Cantidad GL",
                  sx: {
                    width: "100%"
                  },
                  type: "number",
                  defaultValue: props2.cantCombustible,
                  onChange: (event) => props2.cambiarCantidad(event),
                  size: "small",
                  InputLabelProps: {
                    shrink: true
                  }
                })
              })]
            })
          }), /* @__PURE__ */ jsxs(DialogActions$1, {
            children: [/* @__PURE__ */ jsx(Button$1, {
              autoFocus: true,
              onClick: props2.CloseModal,
              variant: "contained",
              color: "error",
              children: "Eliminar"
            }), /* @__PURE__ */ jsx(Button$1, {
              onClick: () => props2.editar(),
              variant: "contained",
              color: "success",
              children: "Editar"
            })]
          })]
        })
      });
    };
    const NuevoParteMaquinaria = () => {
      const [horas_min, setHoras_min] = react.exports.useState(0);
      var usuario = JSON.parse(localStorage.getItem("usuario"));
      var idUsuario = usuario.IDUSUARIO;
      var user = usuario.usuario;
      const navigate = useNavigate();
      const formaPago = [{
        ID: "HR",
        DESCRIPCION: "POR HORA"
      }, {
        ID: "HA",
        DESCRIPCION: "POR HECTAREA"
      }];
      const {
        registrarParte
      } = useParteMaquinaria();
      const {
        turnostrabajo,
        getTurnosTrabajo
      } = useTurnoTrabajo();
      const {
        areas,
        getAreas
      } = useAreas();
      const {
        maquinarias,
        getMaquinarias
      } = useMaquinaria();
      const {
        proveedores,
        getProveedores
      } = useProveedores();
      const {
        operarios,
        getOperarios
      } = useOperario();
      const {
        actividades,
        getActividades
      } = useActividad();
      const {
        labores,
        getLabores
      } = useLabores();
      const {
        implementos,
        getImplementos
      } = useImplemento();
      const [openModal, setOpenModal] = react.exports.useState(false);
      const [openModalCombustible, setOpenModalCombustible] = react.exports.useState(false);
      const [openModalEditar, setOpenModalEditar] = react.exports.useState(false);
      const [openModalEditarCombustible, setOpenModalEditarCombustible] = react.exports.useState(false);
      const [openDialog, setOpenDilog] = react.exports.useState(false);
      const [cabecera, setCabecera] = react.exports.useState("");
      const [detalle, setDetalle] = react.exports.useState([]);
      const [combustible, setCombustible] = react.exports.useState([]);
      const [turno, setTurno] = react.exports.useState("DIURNO");
      const [idTurno, setIdTurno] = react.exports.useState("01");
      const [area, setArea] = react.exports.useState("AREA DE CAMPO");
      const [idArea, setIdArea] = react.exports.useState("005");
      const [idFormaPago, setIdFormaPago] = react.exports.useState("HR");
      const [maquina, setMaquina] = react.exports.useState("");
      const [idMquina, setIdMaquina] = react.exports.useState("");
      const [proveedor, setProveedor] = react.exports.useState("");
      const [idProveedor, setIdProveedor] = react.exports.useState("");
      const [operario, setOperario] = react.exports.useState("");
      const [idOperario, setIdOperario] = react.exports.useState("");
      const [idConsumidor, setIdConsumidor] = react.exports.useState("");
      const [descConsumidor, setDescConsumidor] = react.exports.useState("");
      const [idActividad, setIdActividad] = react.exports.useState("");
      react.exports.useState("");
      const [idLabor, setIdLabor] = react.exports.useState("");
      const [descLabor, setDescLabor] = react.exports.useState("");
      const [idJiron, setIdJiron] = react.exports.useState("");
      const [idCuartel, setIdCuartel] = react.exports.useState("");
      const [costoHora, setCostoHora] = react.exports.useState("");
      const [HoraInicio, setHoraInicio] = react.exports.useState("");
      const [HoraFin, setHoraFin] = react.exports.useState("");
      const [horas_trab, setHoras_trab] = react.exports.useState("");
      const [horas_trab1, setHoras_trab1] = react.exports.useState("0");
      const [switchChecked, setSwitch] = react.exports.useState(true);
      const [tipoParte, setTipoParte] = react.exports.useState("PMA");
      const [costoTotal, setCostoTotal] = react.exports.useState(0);
      const [areaTrabajada, setAreaTrabajada] = react.exports.useState("");
      const [totalAreaTrabajada, setTotalAreaTrabajada] = react.exports.useState(0);
      const [horometroInicio, setHorometroInicio] = react.exports.useState("");
      const [horometroFin, setHorometroFin] = react.exports.useState("");
      const [difHorometro, setDifHorometro] = react.exports.useState(0);
      const [disabledFab, setDisabledFab] = react.exports.useState(true);
      const [disabledGuardar, setDisabledGuardar] = react.exports.useState(true);
      const [mensajeDialog, setMensajeDialog] = react.exports.useState("");
      const [horas_trabCabecera, setHoras_trabCabecera] = react.exports.useState(0);
      const [horas_trab1_cabecera, setHoras_trab1_cabecera] = react.exports.useState(0);
      const [totalCostoCabecera, setTotalCostoCabecera] = react.exports.useState(0);
      const [openGuardar, setOpenGuardar] = react.exports.useState(false);
      const [openBorrar, setOpenBorrar] = react.exports.useState(false);
      const [descJiron, setDescJiron] = react.exports.useState("");
      const [descCuartel, setDescCuartel] = react.exports.useState("");
      const [index2, setIndex] = react.exports.useState("");
      const [bloquearGuardar, setBloquearGuardar] = react.exports.useState(false);
      const [fecha, setFecha] = react.exports.useState(dateFormat(new Date(), "yyyy-mm-dd"));
      const [valueLabor, setValueLabor] = react.exports.useState("");
      const [idImplemento, setIdImplemento] = react.exports.useState("");
      const [descImplemento, setDescImplemento] = react.exports.useState("");
      const [glosa, setGlosa] = react.exports.useState("");
      const [value, setValue] = react.exports.useState("1");
      const [idCombustible, setIdCombustible] = react.exports.useState("");
      const [descCombustible, setDescCombustible] = react.exports.useState("");
      const [idMedidaCom, setIdMedidaCom] = react.exports.useState("");
      const [cantCombustible, setCantCombustible] = react.exports.useState("");
      const [indexCombustible, setIndexCombustible] = react.exports.useState("");
      const cambiarTab = (event, newValue) => {
        setValue(newValue);
      };
      const cerrarDialog = () => {
        setOpenDilog(false);
      };
      const cambiarSwitch = (event) => {
        if (event.target.checked === true) {
          setSwitch(true);
          setTipoParte("PMA");
        } else {
          setTipoParte("PMQ");
          setSwitch(false);
        }
      };
      const cambiarHorometroFin = (event) => {
        if (horometroInicio != "") {
          if (parseFloat(horometroInicio) < parseFloat(event.target.value)) {
            setHorometroFin(event.target.value);
            var dif_horo = parseFloat(event.target.value) - parseFloat(horometroInicio);
            setDifHorometro(dif_horo.toFixed(2));
            setHoras_trabCabecera(dif_horo.toFixed(2));
          } else {
            setDifHorometro(0);
            console.log("Horometro final menor que horoemtro de inicio");
          }
        } else {
          setDifHorometro(0);
          alert("ingrese horometro de Inicio");
        }
      };
      const cambiarHorometroInicio = (event) => {
        console.log(event.target.value);
        if (event.target.value != "") {
          setHorometroInicio(event.target.value);
        } else {
          setHorometroInicio("");
        }
      };
      const cambiarAreaTrabajada = (event) => {
        if (event.target.value != null) {
          console.log(event.target.value);
          setAreaTrabajada(event.target.value);
          if (idFormaPago === "HA") {
            var total_costo = event.target.value * costoHora;
            setCostoTotal(total_costo.toFixed(2));
            console.log(event.target.value * costoHora);
          }
        }
      };
      const cambiarCantidad = (event) => {
        if (event.target.value != null) {
          console.log(event.target.value);
          setCantCombustible(event.target.value);
        }
      };
      const cambiarHoraInicio = (event) => {
        if (event.target.value != "") {
          if (HoraFin < event.target.value && HoraFin != "") {
            setHoraInicio("");
            alert("Hora Inicio no puede ser mayor a hora fin");
          } else {
            if (HoraFin != "" && idLabor != "" && idActividad != "") {
              setDisabledFab(false);
              setDisabledGuardar(false);
            }
            setHoraInicio(event.target.value);
          }
        } else {
          setDisabledFab(true);
          setDisabledGuardar(true);
          setHoraInicio("");
        }
      };
      const cambiarHoraFin = (event) => {
        if (HoraInicio != "") {
          if (HoraInicio < event.target.value) {
            setHoraFin(event.target.value);
            if (idFormaPago === "HR") {
              var hora2 = HoraInicio.split(":");
              var hora1 = event.target.value.split(":");
              var t1 = new Date();
              var t2 = new Date();
              t1.setHours(hora1[0], hora1[1]);
              t2.setHours(hora2[0], hora2[1]);
              t1.setHours(t1.getHours() - t2.getHours(), t1.getMinutes() - t2.getMinutes(), t1.getSeconds() - t2.getSeconds());
              setHoras_trab1_cabecera((t1.getHours() ? t1.getHours() : "0") + (t1.getMinutes() ? "." + (t1.getMinutes() < 10 ? "0" : "") + t1.getMinutes() : ".00"));
              setHoras_min((t1.getHours() ? t1.getHours() * 60 : "0") + (t1.getMinutes() ? +(t1.getMinutes() < 10 ? "0" : "") + t1.getMinutes() : ""));
              console.log((t1.getHours() ? t1.getHours() : "0") + (t1.getMinutes() ? "." + (t1.getMinutes() < 10 ? "0" : "") + t1.getMinutes() : ".00"));
              if (idActividad != "" && idLabor != "") {
                setDisabledFab(false);
                setDisabledGuardar(false);
              }
            }
          } else {
            setDisabledFab(true);
            setDisabledGuardar(true);
            setHoraFin("");
            alert("Hora fin no puede ser menor a hora de inicio");
          }
        } else {
          setDisabledFab(true);
          setDisabledGuardar(true);
          setHoraFin("");
          alert("Seleccione hora inicio primero");
        }
      };
      const cambiarCuartel = (newValue) => {
        if (newValue != null) {
          console.log(newValue.ID);
          setIdCuartel(newValue.ID);
          setDescCuartel(newValue.DESCRIPCION);
        } else {
          setIdCuartel("");
        }
      };
      const cambiarJiron = (newValue) => {
        console.log(newValue);
        if (newValue != null) {
          console.log(newValue.ID);
          setIdJiron(newValue.ID);
          setDescJiron(newValue.DESCRIPCION);
        } else {
          setIdJiron("");
        }
      };
      const cambiarActividad = (newValue) => {
        console.log(newValue);
        if (newValue != null) {
          console.log(newValue.ID);
          setIdActividad(newValue.ID);
          getLabores(newValue.ID);
          setValueLabor("");
          setIdLabor("");
          setDescLabor("");
        } else {
          setIdActividad("");
        }
      };
      const cambiarLabor = (newValue) => {
        console.log(newValue);
        if (newValue != null) {
          setValueLabor(newValue);
          console.log(newValue.ID);
          setIdLabor(newValue.ID);
          setDescLabor(newValue.DESCRIPCION);
        } else {
          setIdLabor("");
        }
      };
      const cambiarConsumidor = (newValue) => {
        if (newValue != null) {
          setIdConsumidor(newValue.ID);
          setDescConsumidor(newValue.DESCRIPCION);
          console.log(idConsumidor);
        } else {
          setIdConsumidor("");
        }
      };
      const cambiarOperario = (newValue) => {
        if (newValue != null) {
          console.log(newValue);
          setIdOperario(newValue.ID);
          setOperario(newValue.DESCRIPCION);
          if (idMquina != "" && idLabor != "") {
            setDisabledFab(false);
            setDisabledGuardar(false);
          }
        } else {
          setDisabledFab(true);
          setDisabledGuardar(true);
          setIdOperario("");
        }
      };
      const cambiarProveedor = (event, newValue) => {
        if (event != null) {
          console.log(event);
          setIdProveedor(event.ID);
          setProveedor(event.DESCRIPCION);
        } else {
          setIdProveedor("");
        }
      };
      const inputGlosa = (event) => {
        console.log(event.target.value);
        if (event.target.value != null) {
          setGlosa(event.target.value);
        }
      };
      const cambiarImplemento = (newValue) => {
        if (newValue != null) {
          console.log(newValue);
          setIdImplemento(newValue.ID);
          setDescImplemento(newValue.DESCRIPCION);
          if (idMquina != "" && idProveedor != "") {
            setDisabledFab(false);
            setDisabledGuardar(false);
          }
        } else {
          setIdImplemento("");
        }
      };
      const cambiarMaquina = (newValue) => {
        if (newValue != null) {
          console.log(newValue);
          setIdMaquina(newValue.ID);
          setMaquina(newValue.DESCRIPCION);
          setCostoHora(newValue.COSTO_MOF);
          if (idOperario != "" && idActividad != "" && idLabor != "" && HoraInicio != "" && HoraFin != "") {
            setDisabledFab(false);
            setDisabledGuardar(false);
          }
        } else {
          setDisabledFab(true);
          setDisabledGuardar(true);
          setIdMaquina("");
        }
      };
      const cambiarArea = (event, newValue) => {
        setIdArea(event.target.value);
        setArea(newValue.props.name);
      };
      const cambiarTurno = (event, newValue) => {
        setIdTurno(event.target.value);
        setTurno(newValue.props.name);
      };
      const cambiarFormaPago = (event) => {
        console.log(totalAreaTrabajada);
        setIdFormaPago(event.target.value);
        if (event.target.value === "HR") {
          var hora2 = HoraInicio.split(":");
          var hora1 = HoraFin.split(":");
          var t1 = new Date();
          var t2 = new Date();
          t1.setHours(hora1[0], hora1[1]);
          t2.setHours(hora2[0], hora2[1]);
          t1.setHours(t1.getHours() - t2.getHours(), t1.getMinutes() - t2.getMinutes(), t1.getSeconds() - t2.getSeconds());
          setHoras_trab1_cabecera((t1.getHours() ? t1.getHours() : "0") + (t1.getMinutes() ? "." + (t1.getMinutes() < 10 ? "0" : "") + t1.getMinutes() : ".00"));
          setHoras_min((t1.getHours() ? t1.getHours() * 60 : "0") + (t1.getMinutes() ? +(t1.getMinutes() < 10 ? "0" : "") + t1.getMinutes() : ""));
          console.log((t1.getHours() ? t1.getHours() * 60 : "0") + (t1.getMinutes() ? +(t1.getMinutes() < 10 ? "0" : "") + t1.getMinutes() : ""));
        } else {
          var hora2 = HoraInicio.split(":");
          var hora1 = HoraFin.split(":");
          var t1 = new Date();
          var t2 = new Date();
          t1.setHours(hora1[0], hora1[1]);
          t2.setHours(hora2[0], hora2[1]);
          t1.setHours(t1.getHours() - t2.getHours(), t1.getMinutes() - t2.getMinutes(), t1.getSeconds() - t2.getSeconds());
          setHoras_trab1_cabecera(totalAreaTrabajada);
          setHoras_min((t1.getHours() ? t1.getHours() * 60 : "0") + (t1.getMinutes() ? +(t1.getMinutes() < 10 ? "0" : "") + t1.getMinutes() : ""));
          console.log((t1.getHours() ? t1.getHours() * 60 : "0") + (t1.getMinutes() ? +(t1.getMinutes() < 10 ? "0" : "") + t1.getMinutes() : ""));
        }
      };
      const OpenModal = () => {
        setIdConsumidor("");
        setIdJiron("");
        setIdCuartel("");
        setAreaTrabajada("");
        setOpenModal(true);
      };
      const CloseModal = () => {
        setOpenModal(false);
      };
      const OpenModalCombustible = () => {
        setIdCombustible("");
        setCantCombustible("");
        setOpenModalCombustible(true);
      };
      const CloseModalCombustible = () => {
        setOpenModalCombustible(false);
      };
      const OpenModalEditar = () => {
        setOpenModalEditar(true);
      };
      const CloseModalEditar = () => {
        setOpenModalEditar(false);
      };
      const OpenModalEditarCombustible = () => {
        setOpenModalEditarCombustible(true);
      };
      const CloseModalEditarCombustible = () => {
        setOpenModalEditarCombustible(false);
      };
      const guardarItem = () => {
        if (idConsumidor == "") {
          setMensajeDialog("Ingrese un consumidor para continuar");
          setOpenDilog(true);
          return;
        }
        if (idJiron == "" && tipoParte == "PMA") {
          setMensajeDialog("Ingrese un lote para continuar");
          setOpenDilog(true);
          return;
        }
        if (idCuartel == "" && tipoParte == "PMA") {
          setMensajeDialog("Ingrese un valvula para continuar");
          setOpenDilog(true);
          return;
        }
        if (areaTrabajada == "" && tipoParte == "PMA") {
          setMensajeDialog("Ingrese el area para continuar");
          setOpenDilog(true);
          return;
        }
        if (idLabor == "") {
          setMensajeDialog("Ingrese una labor para continuar");
          setOpenDilog(true);
          return;
        }
        var item = new Object({
          IDCONSUMIDOR: idConsumidor,
          IDCONSUMIDORIMPLEMENTO: idImplemento,
          DESCRIPCION: descConsumidor,
          AREA_TRAB: areaTrabajada != "" ? areaTrabajada : 0,
          HORAINICIO: HoraInicio,
          HORAFINAL: HoraFin,
          HOROMETROINICIAL: horometroInicio,
          HOROMETROFINAL: horometroFin,
          HORAS_TRAB: horas_trab,
          HORAS_TRAB1: horas_trab1,
          COSTO_HORA: costoHora,
          IDACTIVIDAD: idActividad,
          IDLABOR: idLabor,
          DSC_LABOR: descLabor,
          HOROMETRO_DIFERENCIA: difHorometro,
          COSTO_TOTAL: costoTotal,
          IDJIRON: idJiron,
          DESCJIRON: descJiron,
          IDCUARTEL: idCuartel,
          DESCCUARTEL: descCuartel
        });
        console.log(item);
        detalle.push(item);
        if (idFormaPago == "HR") {
          var total_area = areaTrabajada != "" ? parseFloat(totalAreaTrabajada) + parseFloat(areaTrabajada) : 0;
          var total_costo = parseFloat(costoHora) * parseFloat(horas_trab1_cabecera);
          setTotalCostoCabecera(total_costo.toFixed(2));
          setTotalAreaTrabajada(total_area.toFixed(2));
          console.log(total_costo);
          console.log(total_area);
        } else {
          var total_area = areaTrabajada != "" ? parseFloat(totalAreaTrabajada) + parseFloat(areaTrabajada) : 0;
          var suma = parseFloat(horas_trab1_cabecera) + parseFloat(areaTrabajada);
          var suma_totalCosto = parseFloat(horas_trab1_cabecera) * parseFloat(costoHora);
          setTotalAreaTrabajada(total_area.toFixed(2));
          setHoras_trab1_cabecera(suma.toFixed(2));
          setTotalCostoCabecera(suma_totalCosto.toFixed(2));
          setHoras_trabCabecera(suma.toFixed(2));
          console.log(suma);
          console.log(total_area);
        }
        CloseModal();
      };
      const EditarItem = () => {
        detalle.map((item, i) => {
          detalle[index2].AREA_TRAB = areaTrabajada;
          if (formaPago === "HA") {
            detalle[index2].COSTO_TOTAL = (areaTrabajada * detalle[index2].COSTO_HORA).toFixed(2);
          }
        });
        let suma = detalle.reduce((acumulador, actual) => parseFloat(acumulador) + parseFloat(actual.AREA_TRAB), 0);
        if (idFormaPago == "HA") {
          setHoras_trab1_cabecera(suma.toFixed(2));
        }
        setTotalAreaTrabajada(suma.toFixed(2));
        console.log(suma.toFixed(2));
        CloseModalEditar();
      };
      const editarCombustible = () => {
        combustible[indexCombustible].CANTIDAD = cantCombustible;
        console.log(combustible);
        CloseModalEditarCombustible();
      };
      const guardarBorrador = () => {
        if (idMquina == "") {
          setMensajeDialog("Seleccione una maquina para continuar");
          setOpenDilog(true);
          setOpenGuardar(false);
          return;
        }
        if (idOperario == "") {
          setMensajeDialog("Seleccione un operario para continuar");
          setOpenDilog(true);
          setOpenGuardar(false);
          return;
        }
        if (idActividad == "") {
          setMensajeDialog("Seleccione una actividad para continuar");
          setOpenDilog(true);
          setOpenGuardar(false);
          return;
        }
        if (idLabor == "") {
          setMensajeDialog("Seleccione una labor para continuar");
          setOpenDilog(true);
          setOpenGuardar(false);
          return;
        }
        if (HoraInicio == "") {
          setMensajeDialog("Ingrese la hora de Inicio para continuar");
          setOpenDilog(true);
          setOpenGuardar(false);
          return;
        }
        if (HoraFin == "") {
          setMensajeDialog("Ingrese la hora de Fin para continuar");
          setOpenDilog(true);
          setOpenGuardar(false);
          return;
        }
        if (idProveedor == "" && tipoParte == "PMA") {
          console.log(idProveedor);
          console.log(tipoParte);
          setMensajeDialog("Ingrese un proveedor para continuar");
          setOpenDilog(true);
          setOpenGuardar(false);
          return;
        }
        if (horometroInicio == "") {
          setMensajeDialog("Ingrese horometro inicio para continuar");
          setOpenDilog(true);
          setOpenGuardar(false);
          return;
        }
        if (horometroFin == "") {
          setMensajeDialog("Ingrese horometro final para continuar");
          setOpenDilog(true);
          setOpenGuardar(false);
          return;
        }
        var cabecera2 = new Object({
          IDDOCUMENTO: tipoParte,
          IDCONSUMIDORMAQUINARIA: idMquina,
          MAQUINA: maquina,
          OPERARIO: operario,
          AREA: area,
          PROVEEDOR: proveedor,
          TURNO: turno,
          IDIMPLEMENTO: idImplemento,
          DESCIMPLEMENTO: descImplemento,
          DESCCONSUMIDOR: descConsumidor,
          GLOSA: glosa,
          IDOPERARIO: idOperario,
          HORAINICIO: HoraInicio,
          HORAFINAL: HoraFin,
          HOROMETROINICIAL: horometroInicio,
          HOROMETROFINAL: horometroFin,
          HORAS_TRAB: horas_trabCabecera,
          HORAS_TRAB1: horas_trab1_cabecera,
          IDTURNOTRABAJO: idTurno,
          TOTAL_COSTO: totalCostoCabecera,
          TOTALAREA_TRAB: totalAreaTrabajada,
          FORMAPAGO: idFormaPago,
          IDAREA: idArea,
          COSTO_HORA: costoHora,
          IDCLIEPROV: idProveedor,
          IDUSUARIO: idUsuario,
          FECHA: fecha
        });
        if (detalle.length > 1) {
          var rango = [];
          var rango_horometro = [];
          var horas = [];
          var min2 = [];
          var minFn = [];
          const hora_ini = parseFloat(HoraInicio.replace(":", "."));
          rango.push(hora_ini);
          rango_horometro.push(horometroInicio);
          horas.push(hora_ini);
          var fin = 0;
          var fin_horometro = 0;
          detalle.map((item, i) => {
            var area_percent = item.AREA_TRAB * 100 / totalAreaTrabajada;
            var minutos = horas_min * area_percent / 100;
            var minutos_item = (minutos / 60).toFixed(2);
            fin = rango[i] + parseFloat(minutos_item);
            rango.push(fin);
            detalle[i].HORAS_TRAB = minutos_item;
            detalle[i].HORAINICIO = parseFloat(rango[i]).toFixed(2);
            detalle[i].HORAFINAL = parseFloat(rango[i] + parseFloat(minutos_item)).toFixed(2);
            var dif_horo = difHorometro * area_percent / 100;
            fin_horometro = parseFloat(rango_horometro[i]) + dif_horo;
            rango_horometro.push(fin_horometro);
            detalle[i].HOROMETROINICIAL = parseFloat(rango_horometro[i]).toFixed(2);
            detalle[i].HOROMETROFINAL = parseFloat(parseFloat(rango_horometro[i]) + dif_horo).toFixed(2);
            detalle[i].HOROMETRO_DIFERENCIA = dif_horo.toFixed(2);
          });
          detalle.map((item, i) => {
            var minInicio = detalle[i].HORAINICIO.slice(-3);
            var horaInicio = detalle[i].HORAINICIO.slice(0, -3);
            min2.push(minInicio);
            var minIni = i === 0 ? parseFloat(min2[i]) * 100 : Math.round(parseFloat(min2[i]) * 60);
            var minFin = detalle[i].HORAFINAL.slice(-3);
            var horaFin = detalle[i].HORAFINAL.slice(0, -3);
            minFn.push(minFin);
            var minF = Math.round(parseFloat(minFn[i]) * 60);
            detalle[i].HORAINICIO = parseFloat(horaInicio + "." + parseFloat(minIni)).toFixed(2);
            detalle[i].HORAFINAL = parseFloat(horaFin + "." + minF).toFixed(2);
            var hora1 = detalle[i].HORAINICIO.split(".");
            var hora2 = detalle[i].HORAFINAL.split(".");
            var t1 = new Date();
            var t2 = new Date();
            t2.setHours(hora1[0], hora1[1]);
            t1.setHours(hora2[0], hora2[1]);
            t1.setHours(t1.getHours() - t2.getHours(), t1.getMinutes() - t2.getMinutes(), t1.getSeconds() - t2.getSeconds());
            var horas_t1 = (t1.getHours() ? t1.getHours() : "0") + (t1.getMinutes() ? "." + (t1.getMinutes() < 10 ? "0" : "") + t1.getMinutes() : ".00");
            detalle[i].HORAS_TRAB1 = horas_t1;
            detalle[i].COSTO_TOTAL = (parseFloat(detalle[i].HORAS_TRAB) * parseFloat(detalle[i].COSTO_HORA)).toFixed(2);
          });
        } else {
          detalle[0].HORAINICIO = HoraInicio.replace(":", ".");
          detalle[0].HORAFINAL = HoraFin.replace(":", ".");
          detalle[0].HORAS_TRAB = horas_trab1_cabecera;
          detalle[0].HORAS_TRAB1 = horas_trabCabecera;
          detalle[0].HOROMETROINICIAL = horometroInicio;
          detalle[0].HOROMETROFINAL = horometroFin;
          detalle[0].HOROMETRO_DIFERENCIA = difHorometro;
          detalle[0].COSTO_TOTAL = (parseFloat(detalle[0].HORAS_TRAB) * parseFloat(detalle[0].COSTO_HORA)).toFixed(2);
        }
        setBloquearGuardar(true);
        console.log(cabecera2);
        console.log(combustible);
        registrarParte({
          cabecera: cabecera2,
          detalle,
          user,
          combustible,
          onSuccess: (response) => {
            console.log(response);
            navigate("/home", {
              replace: true
            });
          }
        });
      };
      const abrirDialogGuardar = () => {
        setOpenGuardar(true);
      };
      const cerrarDialogGuardar = () => {
        setOpenGuardar(false);
      };
      const itemSeleccionado = (item, i) => {
        console.log(item);
        setIndex(i);
        setIdConsumidor(item.DESCRIPCION);
        setIdJiron(item.DESCJIRON);
        setIdCuartel(item.DESCCUARTEL);
        setAreaTrabajada(item.AREA_TRAB);
        OpenModalEditar();
      };
      const itemSelectCombustible = (item, i) => {
        console.log(item);
        setIndexCombustible(i);
        setIdCombustible(item.IDCOMBUSTIBLE);
        setDescCombustible(item.DESCRIPCION);
        setCantCombustible(item.CANTIDAD);
        OpenModalEditarCombustible();
      };
      const asignarFecha = (newValue) => {
        console.log(dateFormat(newValue, "yyyy-mm-dd"));
        setFecha(dateFormat(newValue, "yyyy-mm-dd"));
      };
      const cerrarDialogBorrar = () => {
        setOpenBorrar(false);
      };
      const abrirDialogBorrar = () => {
        setOpenBorrar(true);
      };
      const borrarItem = () => {
        console.log(index2);
        var filter = detalle.filter((item, i) => {
          return detalle[i] !== detalle[index2];
        });
        setDetalle(filter);
        let suma = filter.reduce((acumulador, actual) => parseFloat(acumulador) + parseFloat(actual.AREA_TRAB), 0);
        if (idFormaPago == "HA") {
          setHoras_trab1_cabecera(suma.toFixed(2));
        }
        setTotalAreaTrabajada(suma.toFixed(2));
        console.log(suma.toFixed(2));
        console.log(horas_trab1_cabecera);
        setOpenBorrar(false);
        CloseModalEditar();
      };
      const cambiarCombustible = (newValue) => {
        console.log(newValue);
        if (newValue != null) {
          console.log(newValue.ID);
          setIdCombustible(newValue.ID);
          setDescCombustible(newValue.DESCRIPCION);
          setIdMedidaCom(newValue.IDMEDIDA);
        } else {
          setIdCombustible("");
          setDescCombustible("");
          setIdMedidaCom("");
        }
      };
      const guardarCombustible = () => {
        if (idCombustible == "") {
          setMensajeDialog("Falta seleccionar Combustible");
          setOpenDilog(true);
          return;
        }
        if (cantCombustible == "") {
          setMensajeDialog("Ingrese la cantidad de combustible");
          setOpenDilog(true);
          return;
        }
        var data = new Object({
          IDCOMBUSTIBLE: idCombustible.trim(),
          DESCRIPCION: descCombustible,
          IDMEDIDA: idMedidaCom.trim(),
          CANTIDAD: cantCombustible
        });
        console.log(data);
        combustible.push(data);
        CloseModalCombustible();
        console.log(combustible);
      };
      react.exports.useEffect(() => {
        getTurnosTrabajo();
        getAreas();
        getMaquinarias();
        getOperarios();
        getActividades();
        getProveedores();
        getImplementos();
      }, []);
      return /* @__PURE__ */ jsx("div", {
        children: /* @__PURE__ */ jsxs("div", {
          children: [/* @__PURE__ */ jsx(Appbar, {
            nombre: "Nuevo Parte de Maquinaria",
            mostrarSalir: "none",
            mostrarEnviar: "none",
            deshabilitar: detalle.length > 0 ? disabledGuardar : true,
            guardar: abrirDialogGuardar
          }), /* @__PURE__ */ jsx(Dialogs, {
            open: openGuardar,
            cerrar: cerrarDialogGuardar,
            aceptar: guardarBorrador,
            mensaje: "\xBFEst\xE1 seguro de guardar los datos?",
            esconder: "none",
            disabled: false
          }), /* @__PURE__ */ jsx(Dialogs, {
            open: openDialog,
            cerrar: cerrarDialog,
            aceptar: cerrarDialog,
            mensaje: mensajeDialog,
            esconder: "none"
          }), /* @__PURE__ */ jsx(Dialogs, {
            open: openBorrar,
            cerrar: cerrarDialogBorrar,
            aceptar: borrarItem,
            mensaje: "\xBFEst\xE1 seguro de borrar item?",
            esconder: "none"
          }), /* @__PURE__ */ jsx(Interruptor, {
            cambiarSwitch,
            switchChecked
          }), /* @__PURE__ */ jsx(Box$3, {
            children: /* @__PURE__ */ jsx(CabeceraParteMaquinaria, {
              cabecera,
              areas,
              idArea,
              cambiarArea,
              turnos: turnostrabajo,
              turno,
              idTurno,
              cambiarTurno,
              maquinarias,
              cambiarMaquina,
              proveedor: proveedores,
              cambiarProveedor,
              actividades,
              cambiarActividad,
              labores,
              descLabor,
              cambiarLabor,
              formaPago,
              idFormaPago,
              cambiarFormaPago,
              operarios,
              cambiarOperario,
              horas_trabCabecera,
              horas_trab1_cabecera,
              tipoParte,
              cambiarHoraInicio,
              cambiarHoraFin,
              horaFin: HoraFin,
              horaInicio: HoraInicio,
              cambiarHorometroInicio,
              cambiarHorometroFin,
              difHorometro,
              disabled: detalle.length >= 1 ? true : false,
              asignarFecha,
              fecha,
              cambiarConsumidor,
              cambiarImplemento,
              implementos,
              inputGlosa,
              valueLabor
            })
          }), /* @__PURE__ */ jsx("p", {}), /* @__PURE__ */ jsxs(Box$3, {
            children: [/* @__PURE__ */ jsxs(TabContext, {
              value,
              children: [/* @__PURE__ */ jsx(Box$3, {
                sx: {
                  borderBottom: 1,
                  borderColor: "divider",
                  marginTop: 2
                },
                children: /* @__PURE__ */ jsxs(TabList$1, {
                  onChange: cambiarTab,
                  "aria-label": "lab API tabs example",
                  variant: "fullWidth",
                  textColor: "inherit",
                  sx: {
                    background: "#ed6c02",
                    color: "white"
                  },
                  TabIndicatorProps: {
                    style: {
                      backgroundColor: "#ffff"
                    }
                  },
                  children: [/* @__PURE__ */ jsx(Tab$1, {
                    label: "Detalle",
                    value: "1"
                  }), /* @__PURE__ */ jsx(Tab$1, {
                    label: "Combustible",
                    value: "2"
                  })]
                })
              }), /* @__PURE__ */ jsxs(TabPanel$1, {
                value: "1",
                children: [/* @__PURE__ */ jsx(List$1, {
                  sx: {
                    width: "100%",
                    maxWidth: "100%",
                    position: "relative",
                    overflow: "auto",
                    maxHeight: 200
                  },
                  subheader: /* @__PURE__ */ jsx("li", {}),
                  children: /* @__PURE__ */ jsx(Detalle, {
                    detalle,
                    itemSeleccionado
                  })
                }), /* @__PURE__ */ jsx(Fab$1, {
                  sx: {
                    position: "absolute",
                    bottom: 20,
                    right: 20
                  },
                  "aria-label": "Add_detalle",
                  color: "success",
                  size: "large",
                  onClick: OpenModal,
                  children: /* @__PURE__ */ jsx(default_1$1, {})
                })]
              }), /* @__PURE__ */ jsxs(TabPanel$1, {
                value: "2",
                children: [/* @__PURE__ */ jsx(List$1, {
                  sx: {
                    width: "100%",
                    maxWidth: "100%",
                    position: "relative",
                    overflow: "auto",
                    maxHeight: 200
                  },
                  subheader: /* @__PURE__ */ jsx("li", {}),
                  children: /* @__PURE__ */ jsx(DetalleCombustible, {
                    combustible,
                    itemSeleccionado: itemSelectCombustible
                  })
                }), /* @__PURE__ */ jsx(Fab$1, {
                  sx: {
                    position: "absolute",
                    bottom: 20,
                    right: 20
                  },
                  color: "success",
                  onClick: OpenModalCombustible,
                  children: /* @__PURE__ */ jsx(default_1, {})
                })]
              })]
            }), /* @__PURE__ */ jsx(FormularioModal, {
              open: openModal,
              valueLabor,
              handleCloseModal: CloseModal,
              cambiarConsumidor,
              cambiarJiron,
              cambiarCuartel,
              cambiarAreaTrabajada,
              guardar: guardarItem
            }), /* @__PURE__ */ jsx(FormularioModalEditar, {
              open: openModalEditar,
              handleCloseModal: CloseModalEditar,
              idConsumidor,
              jiron: idJiron,
              cuartel: idCuartel,
              areaTrabajada,
              cambiarAreaTrabajada,
              guardar: EditarItem,
              dialogBorrar: abrirDialogBorrar
            }), /* @__PURE__ */ jsx(ModalCombustible, {
              open: openModalCombustible,
              CloseModal: CloseModalCombustible,
              cambiarCombustible,
              cambiarCantidad,
              guardar: guardarCombustible
            }), /* @__PURE__ */ jsx(ModalCombustibleEditar, {
              open: openModalEditarCombustible,
              CloseModal: CloseModalEditarCombustible,
              idCombustible,
              descripcion: descCombustible,
              cantCombustible,
              cambiarCantidad,
              editar: editarCombustible
            })]
          })]
        })
      });
    };
    const CabeceraEditarParteMaquinaria = ({
      cabecera
    }) => {
      return /* @__PURE__ */ jsx(Box$1, {
        children: /* @__PURE__ */ jsxs(Grid$1, {
          container: true,
          spacing: 0.5,
          sx: {
            marginTop: 1
          },
          children: [/* @__PURE__ */ jsx(Grid$1, {
            item: true,
            xs: 4.7,
            children: /* @__PURE__ */ jsxs(Typography$1, {
              fontSize: 12,
              textAlign: "left",
              fontWeight: "bold",
              component: "h5",
              children: ["Area: ", /* @__PURE__ */ jsx(Chip$1, {
                sx: {
                  marginLeft: 3.7
                },
                label: cabecera.AREA,
                variant: "outlined",
                size: "small",
                color: "success"
              })]
            })
          }), /* @__PURE__ */ jsx(Grid$1, {
            item: true,
            xs: 3.8,
            children: /* @__PURE__ */ jsxs(Typography$1, {
              fontSize: 12,
              textAlign: "left",
              fontWeight: "bold",
              component: "h5",
              marginRight: 5,
              children: ["Turno: ", /* @__PURE__ */ jsx(Chip$1, {
                label: cabecera.TURNO,
                variant: "outlined",
                size: "small",
                color: "success"
              })]
            })
          }), /* @__PURE__ */ jsx(Grid$1, {
            item: true,
            xs: 3.5,
            children: /* @__PURE__ */ jsxs(Typography$1, {
              fontSize: 12,
              textAlign: "left",
              fontWeight: "bold",
              component: "h5",
              children: ["Fecha: ", /* @__PURE__ */ jsx(Chip$1, {
                label: cabecera.FECHA,
                variant: "outlined",
                size: "small",
                color: "success"
              })]
            })
          }), /* @__PURE__ */ jsx(Grid$1, {
            item: true,
            xs: 12,
            children: /* @__PURE__ */ jsxs(Typography$1, {
              fontSize: 12,
              textAlign: "left",
              fontWeight: "bold",
              component: "h5",
              children: ["Maquina: ", /* @__PURE__ */ jsx(Chip$1, {
                sx: {
                  marginLeft: 1
                },
                label: cabecera.MAQUINA,
                variant: "outlined",
                size: "small",
                color: "success"
              })]
            })
          }), /* @__PURE__ */ jsx(Grid$1, {
            item: true,
            xs: 12,
            children: cabecera.DESCIMPLEMENTO && /* @__PURE__ */ jsxs(Typography$1, {
              fontSize: 12,
              textAlign: "left",
              fontWeight: "bold",
              component: "h5",
              children: ["Implemen: ", /* @__PURE__ */ jsx(Chip$1, {
                label: cabecera.DESCIMPLEMENTO,
                variant: "outlined",
                size: "small",
                color: "success"
              })]
            })
          }), cabecera.IDDOCUMENTO == "PMA" && /* @__PURE__ */ jsx(Grid$1, {
            item: true,
            xs: 12,
            children: /* @__PURE__ */ jsxs(Typography$1, {
              fontSize: 12,
              textAlign: "left",
              fontWeight: "bold",
              component: "h5",
              children: ["Proveedor: ", /* @__PURE__ */ jsx(Chip$1, {
                label: cabecera.PROVEEDOR,
                variant: "outlined",
                size: "small",
                color: "success"
              })]
            })
          }), /* @__PURE__ */ jsx(Grid$1, {
            item: true,
            xs: 8,
            children: /* @__PURE__ */ jsxs(Typography$1, {
              fontSize: 12,
              textAlign: "left",
              fontWeight: "bold",
              component: "h5",
              children: ["Operario: ", /* @__PURE__ */ jsx(Chip$1, {
                sx: {
                  marginLeft: 1
                },
                label: cabecera.OPERARIO,
                variant: "outlined",
                size: "small",
                color: "success"
              })]
            })
          }), /* @__PURE__ */ jsx(Grid$1, {
            item: true,
            xs: 4,
            children: /* @__PURE__ */ jsxs(Typography$1, {
              fontSize: 12,
              textAlign: "left",
              fontWeight: "bold",
              component: "h5",
              children: ["Pago: ", /* @__PURE__ */ jsx(Chip$1, {
                label: cabecera.FORMAPAGO == "HR" ? "POR HORA" : "POR HECTAREA",
                variant: "outlined",
                size: "small",
                color: "success"
              })]
            })
          }), /* @__PURE__ */ jsx(Grid$1, {
            item: true,
            xs: 4,
            children: /* @__PURE__ */ jsxs(Typography$1, {
              fontSize: 12,
              textAlign: "left",
              fontWeight: "bold",
              component: "h5",
              children: ["Hora Inicial: ", /* @__PURE__ */ jsx(Chip$1, {
                label: cabecera.HORAINICIO,
                variant: "outlined",
                size: "small",
                color: "success"
              })]
            })
          }), /* @__PURE__ */ jsx(Grid$1, {
            item: true,
            xs: 4,
            children: /* @__PURE__ */ jsxs(Typography$1, {
              fontSize: 12,
              textAlign: "left",
              fontWeight: "bold",
              component: "h5",
              children: ["Hora Final: ", /* @__PURE__ */ jsx(Chip$1, {
                label: cabecera.HORAFINAL,
                variant: "outlined",
                size: "small",
                color: "success"
              })]
            })
          }), /* @__PURE__ */ jsx(Grid$1, {
            item: true,
            xs: 4,
            children: /* @__PURE__ */ jsxs(Typography$1, {
              fontSize: 12,
              textAlign: "left",
              fontWeight: "bold",
              component: "h5",
              children: ["Cantidad HR/HA: ", /* @__PURE__ */ jsx(Chip$1, {
                label: parseFloat(cabecera.HORAS_TRAB1).toFixed(2),
                variant: "outlined",
                size: "small",
                color: "success"
              })]
            })
          }), /* @__PURE__ */ jsx(Grid$1, {
            item: true,
            xs: 4,
            children: /* @__PURE__ */ jsxs(Typography$1, {
              fontSize: 12,
              textAlign: "left",
              fontWeight: "bold",
              component: "h5",
              children: ["Htro. Inicial: ", /* @__PURE__ */ jsx(Chip$1, {
                label: cabecera.HOROMETROINICIAL,
                variant: "outlined",
                size: "small",
                color: "success"
              })]
            })
          }), /* @__PURE__ */ jsx(Grid$1, {
            item: true,
            xs: 4,
            children: /* @__PURE__ */ jsxs(Typography$1, {
              fontSize: 12,
              textAlign: "left",
              fontWeight: "bold",
              component: "h5",
              children: ["Htro. Final: ", /* @__PURE__ */ jsx(Chip$1, {
                label: cabecera.HOROMETROFINAL,
                variant: "outlined",
                size: "small",
                color: "success"
              })]
            })
          }), /* @__PURE__ */ jsx(Grid$1, {
            item: true,
            xs: 4,
            children: /* @__PURE__ */ jsxs(Typography$1, {
              fontSize: 12,
              textAlign: "left",
              fontWeight: "bold",
              component: "h5",
              children: ["Tot. Horas Netas: ", /* @__PURE__ */ jsx(Chip$1, {
                label: cabecera.HORAS_TRAB,
                variant: "outlined",
                size: "small",
                color: "success"
              })]
            })
          }), /* @__PURE__ */ jsx(Grid$1, {
            item: true,
            xs: 12,
            children: /* @__PURE__ */ jsxs(Typography$1, {
              fontSize: 12,
              textAlign: "left",
              fontWeight: "bold",
              component: "h5",
              children: ["Observaciones: ", cabecera.GLOSA != "" ? /* @__PURE__ */ jsx(Chip$1, {
                label: cabecera.GLOSA,
                variant: "outlined",
                size: "small",
                color: "success"
              }) : ""]
            })
          })]
        })
      });
    };
    const EditarParteMaquinaria = () => {
      const url_api2 = "https://69.64.95.68:6061/cayaltiservernisira/controlador/index.php";
      var {
        state: data
      } = useLocation();
      let {
        id: id2
      } = useParams();
      const navigate = useNavigate();
      const empresa = localStorage.getItem("empresa").toString();
      const {
        updateParteMaq: updateParteMaq2
      } = useParteMaquinaria();
      const {
        detalle,
        getDetalleMaq,
        combustible,
        getCombustible: getCombustible2
      } = useParteMaquinaria();
      const [openEnviar, setOpenEnviar] = react.exports.useState(false);
      const [disabled, setDisabled] = react.exports.useState(true);
      const [value, setValue] = react.exports.useState("1");
      const [responsbles, setResponsables] = react.exports.useState([]);
      const [implemento, setIdImplemento] = react.exports.useState("");
      const [idResponsable, setIdResponsable] = react.exports.useState();
      const handleChange = (event, newValue) => {
        setValue(newValue);
      };
      const getDParteMap = () => {
        getDetalleMaq(id2);
        getCombustible2(id2);
      };
      const abrirDialogEnviar = () => {
        setOpenEnviar(true);
      };
      const cerrarDialogEnviar = () => {
        setOpenEnviar(false);
      };
      const enviarDatos = () => {
        if (implemento == "") {
          alert("seleccione opcion de implemento de terceros");
          return;
        }
        console.log("enviando datos");
        console.log(data.cabecera);
        console.log(detalle);
        console.log(combustible);
        const formData = new FormData();
        formData.append("empresa", empresa);
        formData.append("modelo", "Maquinaria");
        formData.append("metodo", "cerrarParteMaquinaria");
        formData.append("data_out[0]", JSON.stringify(data.cabecera));
        formData.append("data_out[1]", JSON.stringify(detalle));
        formData.append("data_out[2]", JSON.stringify(combustible));
        formData.append("data_out[3]", JSON.stringify(idResponsable));
        formData.append("data_out[4]", JSON.stringify(implemento));
        setDisabled(true);
        fetch(url_api2, {
          body: formData,
          method: "POST"
        }).then((res) => res.json()).then((res) => {
          if (res.flag == true) {
            setDisabled(false);
            updateParteMaq2(data.cabecera.cod);
            navigate(-1);
          }
        }).catch((e2) => {
          setDisabled(false);
          console.log(e2);
        });
      };
      const listarResponsables = () => {
        const formData = new FormData();
        formData.append("empresa", "002");
        formData.append("modelo", "Maquinaria");
        formData.append("metodo", "listarResponsable");
        fetch(url_api2, {
          body: formData,
          method: "POST"
        }).then((res) => res.json()).then((res) => {
          console.log(res);
          setResponsables(res);
        }).catch((e2) => {
          console.log(e2);
        });
      };
      const cambiarResponsable = (event, newValue) => {
        if (event != null) {
          console.log(event.ID);
          setIdResponsable(event.ID);
          setDisabled(false);
        } else {
          setDisabled(true);
        }
      };
      const cambiarImplemento = (event) => {
        console.log(event.target.value);
        if (event != null) {
          setIdImplemento(event.target.value);
        }
      };
      react.exports.useEffect(() => {
        getDParteMap();
        listarResponsables();
      }, []);
      return /* @__PURE__ */ jsx(Box$3, {
        children: /* @__PURE__ */ jsxs(Box$3, {
          children: [/* @__PURE__ */ jsx(Appbar, {
            nombre: data.cabecera.IDDOCUMENTO === "PMA" ? " Cerrar Parte de Maquinaria Alquilada" : "Cerrar Parte de Maquinaria Propia",
            mostrarSalir: "none",
            mostrarGuardar: "none",
            enviar: abrirDialogEnviar
          }), /* @__PURE__ */ jsx(Dialogs, {
            open: openEnviar,
            cerrar: cerrarDialogEnviar,
            aceptar: enviarDatos,
            mensaje: "Seleccione responsable para guardar",
            disabled,
            responsbles,
            cambiarResponsable,
            cambiarImplemento,
            implemento
          }), /* @__PURE__ */ jsx(CabeceraEditarParteMaquinaria, {
            cabecera: data.cabecera
          }), /* @__PURE__ */ jsxs(TabContext, {
            value,
            children: [/* @__PURE__ */ jsx(Box$3, {
              sx: {
                borderBottom: 1,
                borderColor: "divider",
                marginTop: 2
              },
              children: /* @__PURE__ */ jsxs(TabList$1, {
                onChange: handleChange,
                "aria-label": "lab API tabs example",
                variant: "fullWidth",
                textColor: "inherit",
                sx: {
                  background: "#ed6c02",
                  color: "white"
                },
                TabIndicatorProps: {
                  style: {
                    backgroundColor: "#ffff"
                  }
                },
                children: [/* @__PURE__ */ jsx(Tab$1, {
                  label: "Detalle",
                  value: "1"
                }), /* @__PURE__ */ jsx(Tab$1, {
                  label: "Combustible",
                  value: "2"
                })]
              })
            }), /* @__PURE__ */ jsx(TabPanel$1, {
              value: "1",
              children: /* @__PURE__ */ jsx(List$1, {
                sx: {
                  width: "100%",
                  maxWidth: "100%",
                  position: "relative",
                  overflow: "auto",
                  maxHeight: 400
                },
                subheader: /* @__PURE__ */ jsx("li", {}),
                children: /* @__PURE__ */ jsx(Detalle, {
                  detalle
                })
              })
            }), /* @__PURE__ */ jsx(TabPanel$1, {
              value: "2",
              children: /* @__PURE__ */ jsx(List$1, {
                sx: {
                  width: "100%",
                  maxWidth: "100%",
                  position: "relative",
                  overflow: "auto",
                  maxHeight: 400
                },
                subheader: /* @__PURE__ */ jsx("li", {}),
                children: /* @__PURE__ */ jsx(DetalleCombustible, {
                  combustible
                })
              })
            })]
          })]
        })
      });
    };
    const ListaEnviados = (props2) => {
      const navigate = useNavigate();
      var disabled = true;
      function itemSeleccionado(cod, cabecera) {
        navigate("/editarParte/" + cod, {
          state: {
            cabecera,
            deshabilitar: disabled
          }
        });
      }
      return props2.datos != null ? props2.datos.map((item, i) => /* @__PURE__ */ jsxs(Box$1, {
        children: [/* @__PURE__ */ jsxs(ListItem$1, {
          children: [/* @__PURE__ */ jsx(ListItemAvatar$1, {
            onClick: () => {
              itemSeleccionado(item.cod, item), console.log(item);
            },
            children: /* @__PURE__ */ jsx(default_1$4, {
              color: "warning"
            })
          }, `avatar-${i}`), /* @__PURE__ */ jsx(ListItemText$1, {
            primary: /* @__PURE__ */ jsx(Typography$1, {
              variant: "h1",
              color: "green",
              fontSize: 14,
              children: item.IDDOCUMENTO == "PMA" ? "PARTE DE MAQUINARIA ALQUILADA" : "PARTE DE MAQUINARIA PROPIA"
            }),
            secondary: /* @__PURE__ */ jsxs(React.Fragment, {
              children: [/* @__PURE__ */ jsx(Typography$1, {
                component: "span",
                variant: "body2",
                fontWeight: "bold",
                fontSize: 12,
                children: item.MAQUINA
              }), /* @__PURE__ */ jsx("br", {}), /* @__PURE__ */ jsxs(Typography$1, {
                component: "span",
                variant: "body2",
                fontWeight: "bold",
                fontSize: 12,
                children: ["OPERARIO: ", item.OPERARIO, " || FECHA: ", " " + item.FECHA]
              }), /* @__PURE__ */ jsx("br", {}), /* @__PURE__ */ jsx(Typography$1, {
                component: "span",
                variant: "body2",
                fontWeight: "bold"
              })]
            })
          }, `txt-${i}`)]
        }, `item-${i}`), /* @__PURE__ */ jsx(Divider$1, {
          color: "green"
        })]
      }, i)) : "sin registros";
    };
    const ListarPartesEnviados = () => {
      var usuario = JSON.parse(localStorage.getItem("usuario"));
      usuario.usuario;
      useNavigate();
      const {
        maquinarias,
        getMaquinarias
      } = useMaquinaria();
      const {
        parteMaquinaria,
        getParteMaquinariaEnviados,
        deleteParteMaq
      } = useParteMaquinaria();
      useAuth();
      const [openBorrar, setOpenBorrar] = react.exports.useState(false);
      const [idMquina, setIdMaquina] = react.exports.useState("");
      const [idparte, setIdParte] = react.exports.useState("");
      const [fechaBusqueda, setFechaBusqueda] = react.exports.useState(dateFormat(new Date(), "yyyy-mm-dd"));
      const onChangeAutocompleteHome = (newValue) => {
        console.log(newValue);
        if (newValue != null) {
          setIdMaquina(newValue.ID);
        } else {
          setIdMaquina("");
        }
      };
      function listarParteMaquinaria() {
        getParteMaquinariaEnviados(fechaBusqueda, idMquina);
      }
      function elimnarParte() {
        console.log(idparte);
        deleteParteMaq(idparte);
        listarParteMaquinaria();
        setOpenBorrar(false);
      }
      const asignarFechaBusqueda = (newValue) => {
        setFechaBusqueda(dateFormat(newValue, "yyyy-mm-dd"));
      };
      const cerrarDialogBorrar = () => {
        setOpenBorrar(false);
      };
      const abrirDialogBorrar = (id2) => {
        setOpenBorrar(true);
        setIdParte(id2);
      };
      react.exports.useEffect(() => {
        getMaquinarias();
        listarParteMaquinaria();
      }, []);
      return /* @__PURE__ */ jsx("div", {
        children: /* @__PURE__ */ jsxs(Box$1, {
          children: [/* @__PURE__ */ jsx(Appbar, {
            nombre: "PARTES ENVIADOS A NISIRA",
            mostrarEnviar: "none",
            mostrarGuardar: "none"
          }), /* @__PURE__ */ jsx(Dialogs, {
            open: openBorrar,
            cerrar: cerrarDialogBorrar,
            aceptar: elimnarParte,
            mensaje: "\xBFEst\xE1 seguro de borrar parte de maquinaria?"
          }), /* @__PURE__ */ jsx("h3", {
            children: "Buscar Partes enviados"
          }), /* @__PURE__ */ jsx(Card$1, {
            children: /* @__PURE__ */ jsx(CardContent$1, {
              children: /* @__PURE__ */ jsxs(Grid$1, {
                container: true,
                spacing: 1,
                children: [/* @__PURE__ */ jsx(Grid$1, {
                  item: true,
                  xs: 4,
                  children: /* @__PURE__ */ jsx(InputFecha, {
                    fecha: fechaBusqueda,
                    label: "Fecha",
                    asignarFecha: (val) => asignarFechaBusqueda(val)
                  })
                }), /* @__PURE__ */ jsx(Grid$1, {
                  item: true,
                  xs: 8,
                  children: /* @__PURE__ */ jsx(Autocompletar, {
                    label: "Buscar Maquina",
                    options: maquinarias,
                    cambiar: (event, newValue) => onChangeAutocompleteHome(newValue)
                  })
                }), /* @__PURE__ */ jsx(Grid$1, {
                  item: true,
                  xs: 12,
                  sx: {
                    position: "center"
                  },
                  children: /* @__PURE__ */ jsx(Button$1, {
                    variant: "contained",
                    fullWidth: true,
                    color: "success",
                    onClick: () => listarParteMaquinaria(),
                    children: "Buscar"
                  })
                })]
              })
            })
          }), /* @__PURE__ */ jsx(List$1, {
            sx: {
              width: "100%",
              maxWidth: "100%",
              position: "relative",
              overflow: "auto",
              maxHeight: 500
            },
            subheader: /* @__PURE__ */ jsx("li", {}),
            children: /* @__PURE__ */ jsx(ListaEnviados, {
              datos: parteMaquinaria,
              delete: elimnarParte,
              openBorrar,
              abrirDialogBorrar,
              cerrarDialogBorrar
            })
          }), /* @__PURE__ */ jsx(Loading, {
            open: false,
            label: "Buscando datos"
          })]
        })
      });
    };
    const nameApp = "AppMaquinaria";
    function useAppUtility() {
      const isMovil = Boolean(window.cordova);
      const alertar = ({ txtMessage, callback }) => {
        const callbackExists = typeof callback === "function";
        if (isMovil) {
          window.navigator.notification.alert(txtMessage, callbackExists ? callback : null, nameApp, "LISTO");
          return;
        }
        alert(txtMessage);
        if (callbackExists) {
          callback();
        }
      };
      const confirmar = ({ txtMessage, onConfirm, onReject }) => {
        const fnOK = function(index2) {
          if (typeof onConfirm === "function") {
            if (index2 === 1) {
              onConfirm();
              return;
            }
            if (typeof onReject === "function") {
              onReject();
            }
            return;
          }
          console.error("Funci\xF3n de confirmaci\xF3n inv\xE1lida.");
        };
        if (isMovil) {
          window.navigator.notification.confirm(txtMessage, fnOK, nameApp, ["ACEPTAR", "CANCELAR"]);
          return;
        }
        const answer = confirm(txtMessage) === true ? 1 : 0;
        fnOK(answer);
      };
      const getDevice = () => {
        if (isMovil) {
          return window.device.uuid;
        }
        return navigator.userAgent.substr(0, 30);
      };
      const isActivatedGPS = ({ onSuccess, onError }) => {
        if (isMovil) {
          window.CheckGPS.check(onSuccess, onError);
          return;
        }
        onSuccess();
      };
      const checkPermissions = ({ requiredPermissions, onGranted, onDenied }) => {
        const cadenaInformativaDePermisos = () => {
          return `Esta aplicaci\xF3n necesita permisos de: ${requiredPermissions.join()} para funcionar correctamente.`;
        };
        if (!isMovil) {
          console.error(cadenaInformativaDePermisos());
          return;
        }
        const permissions = window.cordova.plugins.permissions;
        const permissionList = requiredPermissions.map(function(permission) {
          return permissions[permission];
        });
        const error = () => {
          alertar({ txtMessage: cadenaInformativaDePermisos() });
        };
        const success = (status) => {
          if (!status.hasPermission) {
            permissions.requestPermissions(
              permissionList,
              (status2) => {
                if (!status2.hasPermission) {
                  if (onDenied != null && typeof onDenied === "function") {
                    onDenied();
                  } else {
                    error();
                  }
                } else {
                  if (onGranted != null && typeof onGranted === "function") {
                    onGranted();
                  }
                }
              },
              error
            );
          } else {
            if (onGranted != null && typeof onGranted === "function") {
              onGranted();
            }
          }
        };
        permissions.hasPermission(permissionList, success, null);
      };
      const geoposition = ({ onSuccess, onError }) => {
        const fnSuccess = (posicion) => {
          if (typeof onSuccess === "function") {
            onSuccess(posicion);
            return;
          }
          console.error("Funci\xF3n de \xE9xito inv\xE1lida.");
        };
        const showError = (error) => {
          switch (error.code) {
            case error.PERMISSION_DENIED:
              alert("Permisos rechazados.");
              break;
            case error.POSITION_UNAVAILABLE:
              alert("Informaci\xF3n del lugar inaccesible.");
              break;
            case error.TIMEOUT:
              alert("No encontr\xE9 posici\xF3n GPS.");
              break;
            case error.UNKNOWN_ERROR:
              alert("Error desconocido.");
              break;
          }
        };
        const fnError = (error) => {
          showError(error);
          if (typeof onError == "function") {
            onError();
            return;
          }
          console.error("Funci\xF3n de error inv\xE1lida.");
        };
        if (window.navigator.geolocation) {
          window.navigator.geolocation.getCurrentPosition(fnSuccess, fnError, { enableHighAccuracy: true, maximumAge: 5e3, timeout: 15e3 });
          return;
        }
        alert("No tengo la funci\xF3n de geolocaci\xF3n disponible en este dispositivo.");
      };
      const barcodeScan = ({ onSuccess, onError }) => {
        if (isMovil) {
          alert("No tengo la funci\xF3n de LECTOR DE C\xD3DIGO DE BARRAS disponible en esta versi\xF3n del aplicativo.");
          return;
        }
        const fnSuccess = (result) => {
          if (typeof onSuccess === "function") {
            onSuccess(result);
            return;
          }
          console.error("Funci\xF3n de \xE9xito inv\xE1lida.");
        };
        const fnError = (error) => {
          showError(error);
          if (typeof onError == "function") {
            onError();
            return;
          }
          console.error("Funci\xF3n de error inv\xE1lida.");
        };
        const showError = (error) => {
          alert("Scanning failed: " + error);
        };
        const barcodeScannerInstance = window.cordova.plugins.barcodeScanner;
        if (!barcodeScannerInstance) {
          alert("No tengo la funci\xF3n de LECTOR DE C\xD3DIGO DE BARRAS disponible en este dispositivo.");
          return;
        }
        barcodeScannerInstance.scan(
          fnSuccess,
          fnError,
          {
            preferFrontCamera: false,
            showFlipCameraButton: true,
            showTorchButton: true,
            torchOn: true,
            saveHistory: false,
            prompt: "Coloque un c\xF3digo de barras sobre el \xE1rea de escaneo.",
            resultDisplayDuration: 500,
            formats: "QR_CODE,CODE_39,PDF_417,CODE_128",
            orientation: "portrait",
            disableSuccessBeep: false
          }
        );
      };
      const checkConexion = () => {
        if (!isMovil) {
          return { online: window.navigator.onLine, estados: null };
        }
        const networkState = window.navigator.connection.type;
        let states = {};
        states[window.Connection.UNKNOWN] = "Conexi\xF3n Desconocida";
        states[window.Connection.ETHERNET] = "Conexi\xF3n Ethernet";
        states[window.Connection.WIFI] = "Conexi\xF3n WiFi";
        states[window.Connection.CELL_2G] = "Conexi\xF3n 2G";
        states[window.Connection.CELL_3G] = "Conexi\xF3n 3G";
        states[window.Connection.CELL_4G] = "Conexi\xF3n 4G";
        states[window.Connection.CELL] = "Conexi\xF3n generica";
        states[window.Connection.NONE] = "Sin conexi\xF3n red";
        return { online: networkState != window.Connection.NONE, state: states[networkState] };
      };
      const checkUpdate = () => {
        if (!isMovil) {
          return false;
        }
        const updaterURL = `${"https://apps.cayalti.com.pe/apk/maquinaria/version.xml"}`;
        window.AppUpdate.checkAppUpdate(
          (e2) => {
            console.log(e2);
          },
          (e2) => {
            console.error(e2);
          },
          updaterURL
        );
        console.log("actualizando");
      };
      return {
        alertar,
        confirmar,
        getDevice,
        checkPermissions,
        geoposition,
        isActivatedGPS,
        barcodeScan,
        checkConexion,
        checkUpdate
      };
    }
    function App() {
      const navigate = useNavigate();
      const {
        checkUpdate
      } = useAppUtility();
      react.exports.useEffect(() => {
        checkUpdate();
        const fnBackButton = (e2) => {
          const hash2 = window.location.hash;
          console.log(hash2);
          if (hash2 === "#/" || hash2 === "#" || hash2 === "") {
            window.navigator.app.exitApp();
            return false;
          } else if (hash2 === "#/home") {
            window.plugins.appMinimize.minimize();
          }
          navigate(-1);
        };
        document.addEventListener("backbutton", fnBackButton, false);
        return () => {
          document.removeEventListener("backbutton", fnBackButton, false);
        };
      }, []);
      return /* @__PURE__ */ jsx("div", {
        children: /* @__PURE__ */ jsxs(Routes, {
          children: [/* @__PURE__ */ jsx(Route, {
            path: "/",
            element: /* @__PURE__ */ jsx(Login, {})
          }), /* @__PURE__ */ jsx(Route, {
            path: "/home",
            element: /* @__PURE__ */ jsx(HomeMaquinariaPropia, {})
          }), /* @__PURE__ */ jsx(Route, {
            path: "/nuevoParte",
            element: /* @__PURE__ */ jsx(NuevoParteMaquinaria, {})
          }), /* @__PURE__ */ jsx(Route, {
            path: "/editarParte/:id",
            element: /* @__PURE__ */ jsx(EditarParteMaquinaria, {})
          }), /* @__PURE__ */ jsx(Route, {
            path: "/listarEnviados",
            element: /* @__PURE__ */ jsx(ListarPartesEnviados, {})
          })]
        })
      });
    }
    const index = "";
    const renderReactDom = () => {
      client.createRoot(document.getElementById("root")).render(/* @__PURE__ */ jsx(React.StrictMode, {
        children: /* @__PURE__ */ jsx(HashRouter, {
          children: /* @__PURE__ */ jsx(AuthContextProvider, {
            children: /* @__PURE__ */ jsx(App, {})
          })
        })
      }));
    };
    if (window.cordova) {
      document.addEventListener("deviceready", () => {
        renderReactDom();
      }, false);
    } else {
      renderReactDom();
    }
  }
});
export default require_index_81daafcd();
